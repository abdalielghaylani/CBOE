<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  "http://www.w3.org/TR/html4/loose.dtd">

<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<meta name="keywords" content="Toad Data Modeler, html, report">
		<title>Toad Data Modeler - HTML Report</title>

		<link rel="stylesheet" type="text/css" media="screen" href="aqua_blue.css" title="report">
		<link rel="stylesheet" type="text/css" media="print" href="aqua_blue_print.css" title="report">
	</head>

<body class="rightPage">
<a name = "TextObjName_1"></a>
<div class="caption1">FUNCTIONS</div>
<a name = "TextObject_1"></a>
<div class="caption2">COEDB.CHANGEPWD</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE FUNCTION &quot;COEDB&quot;.&quot;CHANGEPWD&quot;  (<br>     pUserName      IN   people.user_id%TYPE,<br>     pPassword      IN   VARCHAR2 := NULL,<br>     pNewPassword   IN   VARCHAR2 := NULL)<br>     RETURN VARCHAR2<br>  AS<br>     invalid_user_or_pass   EXCEPTION;<br>     --source_cursor integer;<br>     --rows_processed integer;<br>     pw                     VARCHAR2 (30);<br>     cannot_reuse_pwd       EXCEPTION;<br>     PRAGMA EXCEPTION_INIT (cannot_reuse_pwd, -28007);<br>  BEGIN<br>     SELECT PASSWORD INTO pw<br>       FROM dba_users<br>      WHERE UPPER (userName) = UPPER (pUserName);<br>  <br>     IF pPassword &lt;&gt; pw THEN<br>        RAISE invalid_user_or_pass;<br>     END IF;<br>  <br>     --source_cursor := dbms_sql.open_cursor;<br>     IF (pNewPassword IS NOT NULL) THEN<br>        --dbms_sql.parse (source_cursor, 'ALTER USER ' || pUserName || ' IDENTIFIED BY ' || pNewPassword, dbms_sql.NATIVE);<br>        --rows_processed := dbms_sql.execute (source_cursor);<br>        EXECUTE IMMEDIATE 'ALTER USER ' || pUserName || ' IDENTIFIED BY ' || pNewPassword;<br>     END IF;<br>  <br>     RETURN '1';<br>  EXCEPTION<br>     WHEN invalid_user_or_pass THEN<br>        RETURN 'Invalid User Name or Password';<br>     WHEN cannot_reuse_pwd THEN<br>        RETURN 'Cannot reuse previously used password.';<br>  END changePwd;<br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_2"></a>
<div class="caption2">COEDB.CREATEROLE</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE FUNCTION &quot;COEDB&quot;.&quot;CREATEROLE&quot;  (<br>     pRoleName            IN   security_roles.role_name%TYPE,<br>     pPrivTableName       IN   privilege_tables.privilege_table_name%TYPE,<br>     pIsAlreadyInOracle   IN   INTEGER,<br>     pPrivValueList       IN   VARCHAR2)<br>     RETURN VARCHAR2<br>  AS<br>     privTableId   INTEGER;<br>     roleId        INTEGER;<br>  BEGIN<br>  <br>     IF pIsAlreadyInOracle = 0 THEN<br>        EXECUTE IMMEDIATE 'CREATE ROLE ' || pRoleName || ' NOT IDENTIFIED';<br>        EXECUTE IMMEDIATE 'GRANT CSS_USER TO ' || pRoleName;<br>        EXECUTE IMMEDIATE 'REVOKE ' || pRoleName || ' FROM COEDB';<br>  <br>        SELECT privilege_table_id<br>          INTO privTableId<br>          FROM privilege_tables<br>         WHERE UPPER (privilege_table_name) = UPPER (pPrivTableName);<br>  <br>        INSERT INTO security_roles (privilege_table_int_id, role_name)<br>             VALUES (privTableId, UPPER (pRoleName))<br>          RETURNING role_id<br>               INTO roleId;<br>  <br>        EXECUTE IMMEDIATE 'INSERT INTO ' || pPrivTableName || ' VALUES ( ' || roleId || ', ' || pPrivValueList || ')';<br>     ELSE<br>        INSERT INTO security_roles (privilege_table_int_id, role_name)<br>             VALUES (NULL, UPPER (pRoleName))<br>          RETURNING role_id<br>               INTO roleId;<br>     END IF;<br>  <br>     RETURN '1';<br>  END createRole;<br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_3"></a>
<div class="caption2">COEDB.CREATEUSER</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE FUNCTION &quot;COEDB&quot;.&quot;CREATEUSER&quot;  (<br>     pUserName            IN   people.user_id%TYPE,<br>     pIsAlreadyInOracle   IN   INTEGER := 0,<br>     pPassword            IN   VARCHAR2,<br>     pRolesGranted        IN   VARCHAR2,<br>     pFirstName           IN   people.first_name%TYPE := NULL,<br>     pMiddleName          IN   people.middle_name%TYPE := NULL,<br>     pLastName            IN   people.last_name%TYPE := NULL,<br>     pTelephone           IN   people.telephone%TYPE := NULL,<br>     pEmail               IN   people.email%TYPE := NULL,<br>     pAddress             IN   people.int_address%TYPE := NULL,<br>     pUserCode            IN   people.user_code%TYPE := NULL,<br>     pSupervisorId        IN   people.supervisor_internal_id%TYPE := NULL,<br>     pSiteId              IN   people.site_id%TYPE := NULL,<br>     pIsActive            IN   people.active%TYPE := 1)<br>     RETURN VARCHAR2<br>  AS<br>     source_cursor                INTEGER;<br>     rows_processed               INTEGER;<br>     userCode                     people.user_code%TYPE;<br>     user_or_role_name_conflict   EXCEPTION;<br>     unique_constraint_violated   EXCEPTION;<br>     role_not_found               EXCEPTION;<br>     PRAGMA EXCEPTION_INIT (unique_constraint_violated, -1);<br>     PRAGMA EXCEPTION_INIT (user_or_role_name_conflict, -1920);<br>     PRAGMA EXCEPTION_INIT (role_not_found, -1919);<br>  BEGIN<br>     source_cursor := DBMS_SQL.open_cursor;<br>  <br>     IF pIsAlreadyInOracle = 0 THEN<br>        DBMS_SQL.parse (source_cursor, 'CREATE USER ' || pUserName || ' IDENTIFIED BY ' || pPassword || ' DEFAULT TABLESPACE T_COEDB TEMPORARY TABLESPACE T_COEDB_TEMP', DBMS_SQL.native);<br>        rows_processed := DBMS_SQL.EXECUTE (source_cursor);<br>     END IF;<br>  <br>     DBMS_SQL.parse (source_cursor, 'GRANT CONNECT TO ' || pUserName, DBMS_SQL.native);<br>     rows_processed := DBMS_SQL.EXECUTE (source_cursor);<br>     DBMS_SQL.parse (source_cursor, 'GRANT ' || pRolesGranted || ' TO ' || pUserName, DBMS_SQL.native);<br>     rows_processed := DBMS_SQL.EXECUTE (source_cursor);<br>     DBMS_SQL.parse (source_cursor, 'ALTER USER ' || pUserName || ' DEFAULT ROLE ALL', DBMS_SQL.native);<br>     rows_processed := DBMS_SQL.EXECUTE (source_cursor);<br>     DBMS_SQL.parse (source_cursor, 'ALTER USER ' || pUserName || ' PROFILE csuserprofile', DBMS_SQL.native);<br>     rows_processed := DBMS_SQL.EXECUTE (source_cursor);<br>  <br>     IF pUserCode IS NULL THEN<br>        userCode := pUserName;<br>     ELSE<br>        userCode := pUserCode;<br>     END IF;<br>  <br>     INSERT INTO people (user_id, first_name, middle_name, last_name, email, telephone, int_address, user_code, supervisor_internal_id, site_id, active)<br>          VALUES (pUserName, pFirstName, pMiddleName, pLastName, pEmail, pTelephone, pAddress, userCode, pSupervisorId, pSiteId, pIsActive);<br>  <br>     RETURN '1';<br>  EXCEPTION<br>     WHEN user_or_role_name_conflict THEN<br>        RETURN 'user name ' || pUserName || ' conflicts with another user or role name ';<br>     WHEN unique_constraint_violated THEN<br>        DBMS_SQL.parse (source_cursor, 'DROP USER ' || pUserName, DBMS_SQL.native);<br>        rows_processed := DBMS_SQL.EXECUTE (source_cursor);<br>        RETURN 'User Code ' || usercode || ' is or has been already taken by another user';<br>     WHEN role_not_found THEN<br>        DBMS_SQL.parse (source_cursor, 'DROP USER ' || pUserName, DBMS_SQL.native);<br>        rows_processed := DBMS_SQL.EXECUTE (source_cursor);<br>        RETURN 'Failed to find one or more of the roles to be granted';<br>  END createUser;<br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_4"></a>
<div class="caption2">COEDB.DELETEROLE</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE FUNCTION &quot;COEDB&quot;.&quot;DELETEROLE&quot;  (<br>     pRoleName        IN   security_roles.role_name%TYPE,<br>     pPrivTableName   IN   privilege_tables.privilege_table_name%TYPE)<br>     RETURN VARCHAR2<br>  AS<br>     roleId        INTEGER;<br>     numGrantees   INTEGER;<br>  BEGIN<br>     SELECT COUNT (*) INTO numGrantees<br>       FROM dba_role_privs<br>      WHERE UPPER (granted_role) = UPPER (pRoleName);<br>  <br>     IF numGrantees &gt; 0 THEN<br>        raise_application_error (-20000, 'Cannot delete ' || pRoleName || ' because it is assigned to existing users.');<br>     END IF;<br>  <br>     SELECT role_id INTO roleId<br>       FROM security_roles<br>      WHERE UPPER (role_name) = UPPER (pRoleName);<br>  <br>     EXECUTE IMMEDIATE 'DELETE FROM ' || pPrivTableName || ' WHERE ROLE_INTERNAL_ID= ' || roleId;<br>     EXECUTE IMMEDIATE 'DELETE FROM COEDB_PRIVILEGES WHERE ROLE_INTERNAL_ID= ' || roleId;<br>     EXECUTE IMMEDIATE 'DELETE FROM Security_Roles WHERE ROLE_ID = ' || roleId;<br>     EXECUTE IMMEDIATE 'DROP ROLE ' || pRoleName;<br>  <br>     RETURN '1';<br>  END deleteRole;<br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_5"></a>
<div class="caption2">COEDB.DELETEUSER</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE FUNCTION &quot;COEDB&quot;.&quot;DELETEUSER&quot;  (pUserName IN people.user_id%TYPE) RETURN VARCHAR2 AS<br>     cannot_drop_connected_user   EXCEPTION;<br>     PRAGMA EXCEPTION_INIT (cannot_drop_connected_user, -1940);<br>  BEGIN<br>     EXECUTE IMMEDIATE 'DROP USER ' || pUserName || ' CASCADE';<br>  <br>     UPDATE people<br>        SET active = 0<br>      WHERE user_id = pUserName;<br>  <br>     RETURN '1';<br>  EXCEPTION<br>     WHEN cannot_drop_connected_user THEN<br>        RETURN 'Cannot drop user ' || pUserName || ' because it is currently connected to Oracle';<br>  END deleteUser;<br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_6"></a>
<div class="caption2">COEDB.NORMALIZE</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE FUNCTION &quot;COEDB&quot;.&quot;NORMALIZE&quot; (AChemName varchar2) RETURN VARCHAR2 deterministic IS<br>      TYPE TReplacements IS Varray(600) OF Varchar2(300);<br>      chemName     Varchar2(2000);<br>      replacements TReplacements;<br>      newname Varchar2(2000):='';<br>      offset Integer:= 1;<br>      i Integer:= 1;<br>      numReplacements Integer;<br>      didReplace boolean:= false;<br>      repl integer;<br>      CharChemName Varchar2(1);<br>      BeforeCharChemName Varchar2(1);<br>      AfterCharChemName Varchar2(1);<br>  <br>      thisOrig Varchar2(2000);<br>      thisReplacement Varchar2(2000);<br>  	deltaOffset Integer;<br>      ChemNameLength Integer;<br>  <br>      FUNCTION CleanNormalized(AChemName VARCHAR2) RETURN VARCHAR2 IS<br>          TYPE TReplacements IS Varray(100) OF Varchar2(50);<br>          replacements TReplacements;<br>          ChemName     Varchar2(2000);<br>          newname Varchar2(2000);<br>          offset Integer;<br>          CharChemName Varchar2(1);<br>          numReplacements Integer;<br>          didReplace boolean;<br>          repl Integer;<br>      BEGIN<br>          ChemName:='('||Lower(AChemName);<br>  <br>          replacements:=TReplacements(<br>                          '11dimethylethyl',                        'tbutyl',<br>                          '1methylpropyl',                        'sbutyl',<br>                          '1methylethyl',                            'isopropyl',<br>                          '135triazine',                            'striazin',<br>                          'arachid',                                'eicosan',<br>                          'butyr',                                'butan',<br>                          'capro',                                'hexan',<br>                          'd+',                                    'd',<br>                          'd-',                                    'd',<br>                          'ethylenedinitrilotetraaceticacid',        'edta',<br>                          'ethylenediaminetetraaceticacid',        'edta',<br>                          'ethylenediaminetetraacetate',            'edta',<br>                          'edetate',                                'edta',<br>                          'enath',                               'heptan',<br>                          'laur',                                    'dodecan',<br>                          'l+',                                    'l',<br>                          'l-',                                    'l',<br>                          'myrist',                                'tetradecan',<br>                          'naphthalenyl',                            'naphthyl',<br>                          'pelargon',                                'nonan',<br>                          'propion',                                'propan',<br>                          'palmit',                                'hexadecan',<br>                          'silveri',                                'silver',<br>                          'stear',                                'octadecan',<br>                          'valer',                                'pentan');<br>          newname := '';<br>          offset := 1;<br>          LOOP<br>              EXIT WHEN  (offset&gt;=Length(chemname)); --while (offset &lt; chemname.Length)<br>              CharChemName :=  SUBSTR(chemName,offset+1,1);<br>              IF (ASCII(CharChemName) &lt; 32) THEN<br>                  offset := offset + 1;    -- skip this character<br>              ELSE<br>                  --now do some cleanup of the genrated name<br>  <br>                  numReplacements := replacements.count;<br>  <br>                  didReplace := false;<br>                  repl := 1;<br>                  LOOP<br>                      EXIT WHEN  (repl&gt;numReplacements);<br>                      -- Make sure the first character is a match; if not, no point in checking anything else<br>                      IF ((CharChemName = SUBSTR(replacements(repl),1,1)) AND  (Length(chemname) - offset &gt;= Length(replacements(repl))) AND (SUBSTR(chemname,offset+1, Length(replacements(repl))) = replacements(repl))) THEN<br>                          newname := newname || replacements(repl + 1);<br>                          offset := offset + Length(replacements(repl));<br>                          didReplace := true;<br>                          EXIT;<br>                      END IF;<br>                      repl := repl + 2;<br>                  END LOOP;<br>                  IF  NOT(didReplace) THEN<br>                      newname := newname || CharChemName;  --added this<br>                      offset := offset + 1;<br>                  END IF;<br>              END IF;<br>          END LOOP;<br>          RETURN newname;<br>      END;<br>  <br>      FUNCTION FixIcAte(AChemName VARCHAR2) RETURN VARCHAR2 IS<br>          TYPE TReplacements IS Varray(100) OF Varchar2(50);<br>          LChemName       Varchar2(2000);<br>          clen            Integer;<br>          numReplacements Integer;<br>          repl            Integer;<br>          replacements    TReplacements;<br>      BEGIN<br>          LChemName:=AChemName;<br>          clen := Length(AChemName);<br>  <br>          replacements:=TReplacements(<br>                              'pelargon',        'nonano',<br>                              'propion',        'propano',<br>                              'arachid',        'eicosano',<br>                              'methano',        'form',<br>                              'myrist',        'tetradecano',<br>                              'ethano',        'acet',<br>                              'palmit',        'hexadecano',<br>                              'stear',        'octadecano',<br>                              'valer',        'pentano',<br>                              'butyr',        'butano',<br>                              'capro',        'hexano',<br>                              'enath',        'heptano',<br>                              'laur',            'dodecano',<br>                              'capr',            'decano'<br>                           );<br>  <br>          numReplacements := replacements.count;<br>          repl := 1;<br>          LOOP<br>              EXIT WHEN  (repl&gt;numReplacements);<br>              -- Make sure the first character is a match; if not, no point in checking anything else<br>              IF (Length(LChemName) &gt;= Length(replacements(repl)) AND<br>                  SUBSTR(LChemName,(Length(LChemName) - Length(replacements(repl)))+1) = replacements(repl)) THEN<br>  <br>                  LChemName := Replace(LChemName,replacements(repl), replacements(repl + 1));<br>                  Exit;<br>              END IF;<br>              repl:=repl+2;<br>          END LOOP;<br>  <br>          RETURN LChemName;<br>      END;<br>  <br>  <br>      FUNCTION IsLetter(AChar Varchar2) RETURN boolean IS<br>          LLetters Varchar2(50):='abcdefghijklmnopqrstuvwxyz';<br>      BEGIN<br>          IF INSTR(LLetters,AChar)&gt;0 THEN<br>              RETURN TRUE;<br>          ELSE<br>              RETURN FALSE;<br>          END IF;<br>      END;<br>  BEGIN<br>      chemName:='('||Lower(AChemName);<br>  <br>      replacements:=TReplacements(<br>                           ' potassium',              'potassium',<br>                           ' sodium',                 'sobium',<br>                           ' and ',                   '+',<br>                           ' na+',                    'sobium',<br>                           ' k+',                     'potassium',<br>                           ' ',                       '',                    --this might be wrong<br>                           '`',                       '''',                --this might be wrong or might be able to moved up<br>                           '&amp;',                       '+',                --this might be wrong or might be able to moved up<br>                           ',0''',                    ',O''',<br>                           ',',                       '',<br>                           '-0-',                     '-O-',<br>                           '-',                       '',<br>                           '; ',                      '',                    --what is this<br>                           '0,0',                     '22',<br>                           '1+',                      'i',<br>                           '2hcl',                    'bihydrochlorid',<br>                           '2+',                      'ii',<br>                           '3+',                      'iii',<br>                           '4+',                      'iv',<br>                           '5+',                      'v',<br>                           '6+',                      'vi',<br>                           '(-)',                     '-',<br>                           '('    ,                   '',                    --this might be wrong<br>                           '#',                       'no',<br>                           '+/-',                     '+-',<br>                           '+,-',                     '+-',<br>                           '+-',                      '+-',<br>                           'antimony tri',            'antimonyiii',<br>                           'antimonious',             'antimonyiii',<br>                           'antimonous',              'antimonyiii',<br>                           'antimonius',              'antimonyiii',<br>                           'aluminium',               'aluminum',<br>                           'anhydrous',               '',<br>                           'argentous',               'silveri',<br>                           'arsenious',               'arseniciii',<br>                           'anisidine',               'methoxybenzenamin',<br>                           'arsenous',                'arseniciii',<br>                           'aniline',                 'benzenamin',<br>                           'ammine',                  'amin',<br>                           'alpha',                   'a',<br>                           'benzeneamine',            'benzenamin',<br>                           'bismuth tri',             'bismuthiii',<br>                           'bromo',                   'brom',<br>                           'beta',                    'b',<br>                           'bis',                     'bi',<br>                           'carbamodithioato-S,S',    'bithiocarbamato',<br>                           'columbium',               'niobium',<br>                           'cobaltous',               'cobaltii',<br>                           'carbamoyl',               'carbamyl',<br>                           'complex',                 '',<br>                           'chromic',                 'chromiumiii',<br>                           'caesium',                 'cesium',<br>                           'cuprous',                 'copperi',<br>                           'capryl ',                 'octyl',<br>                           'chloro',                  'chlor',<br>                           'capryl',                  'octano',<br>                           'cresol',                  'methylphenol',<br>                           'cupric',                  'copperii',<br>                           'cerous',                  'ceriumiii',<br>                           'choro',                   'chlor',<br>                           'ceric',                   'ceriumiv',<br>                           'dodecahydrate',           '12h2o',<br>                           'decahydrate' ,            '10h2o',<br>                           'derivative' ,             '',<br>                           'dihydrate' ,              '2h2o',<br>                           'dextro' ,                 'd',<br>                           'delta',                   'd',<br>                           'des',                     'de',<br>                           'di',                      'bi',<br>                           'enneahydrate',            '9h2o',<br>                           'enathyl',                 'heptyl',<br>                           'eico',                    'ico',<br>                           'ehty',                    'ethy',<br>                           'ferrous',                 'ironii',<br>                           'ferric',                  'ironiii',<br>                           'fluoro',                  'fluor',<br>                           'flouro',                  'fluor',<br>                           'flour',                   'fluor',<br>                           'gamma',                   'y',<br>                           'hemipentahydrate',        '2.5h2o',<br>                           'heptahydrate',            '7h2o',<br>                           'hemihydrate',             '1/2h2o',<br>                           'hexahydrate',             '6h2o',<br>                           'hexadecyl',               'cetyl',<br>                           'hydrate',                 'h2o',<br>                           'hyro',                    'hydro',<br>                           'hcl',                     'hydrochlorid',<br>                           'hbr',                     'hydrobromid',<br>                           'icacid',                  'at',<br>                           'i'    ,                   'i',<br>                           'levo',                    'l',<br>                           'mercaptan',               'thiol',<br>                           'manganous',               'manganesii',<br>                           'mercurous',               'mercuryi',<br>                           'mercuric',                'mercuryii',<br>                           'yl alcohol',              'anol',<br>                           'ylalcohol',               'anol',<br>                           'methyl',                  'methyl',<br>                           'methy',                   'methy',            --these are out of order on purpose<br>                           'methyoxy',                'methoxy',<br>                           'meta',                    '3',                --missing some other weritd thing<br>                           'nonahydrate',             '9h2o',<br>                           'nickelous',               'nickelii',<br>                           'napth',                   'naphth',<br>                           'octadecahydrate',         '18h2o',<br>                           'octahydrate',             '8h2o',                --some ous acid stuff missing after this<br>                           'ortho' ,                  '2',<br>                           'omega',                   'w',<br>                           'phosphorothioate',        'thiophosphat',<br>                           'pentahydrate' ,           '5h2o',<br>                           'phosphorous',             'phosphorus',<br>                           'plumbous',                'leadi',<br>                           'pyrine' ,                 'pyren',<br>                           'para',                    '4',<br>                           'phth',                    'phth',<br>                           'pht',                     'phth',<br>                           'p',                       'p',<br>                           'sesquihydrate',           '3/2h2o',<br>                           'salicycl',                'salicyl',<br>                           'stannane',                'tin',<br>                           'stannous',                'tinii',<br>                           'stannic',                 'tiniv',<br>                           'sulph',                   'sulf',<br>                           'salts',                   '',<br>                           'sec-',                    's',<br>                           'salt',                    '',<br>                           'tetrahydrate',            '4h2o',<br>                           'trihydrate',              '3h2o',<br>                           'toluidine',               'methylbenzenamin',<br>                           'thallous',                'thalliumi',<br>                           'terthiop',                'terthiop',<br>                           'thallic',                 'thalliumiii',<br>                           'tert',                    't',<br>                           'tris',                    'tri',<br>                           't',                       't',<br>                           'water',                   'h2o',<br>                           'yl mercaptan',            'anethiol',<br>                           'ylmercaptan',             'anethiol');<br>  <br>      newname := '';<br>      offset := 1;<br>      ChemNameLength:=LENGTH(chemName);<br>      LOOP<br>          EXIT WHEN offset &gt;=ChemNameLength;<br>          CharChemName :=  SUBSTR(chemName,offset+1,1);<br>          BeforeCharChemName :=  SUBSTR(chemName,offset,1);<br>          AfterCharChemName :=  SUBSTR(chemName,offset+2,1);<br>  <br>          IF (ASCII(CharChemName) &lt; 32) THEN<br>              offset:=offset+1;    -- skip this character<br>          ELSIF (CharChemName = '.'<br>              OR CharChemName = ')' OR CharChemName = ']' OR CharChemName = '}'<br>              OR CharChemName = '(' OR CharChemName = '[' OR CharChemName = '{'<br>              OR CharChemName = '/' OR CharChemName = '_' OR CharChemName = ':'<br>              OR CharChemName = '\\') THEN<br>  <br>              --we are supposed to be maintaining (-) as - and (+) as +<br>              IF ((offset + 3 &lt;= ChemNameLength) AND ((SUBSTR(chemname,offset+1,3) = '(-)') OR (SUBSTR(chemname,offset+1,3) = '(+)'))) THEN<br>                  newname := newname || AfterCharChemName;<br>                  offset:=offset + 3;<br>              ELSE<br>                  offset:=offset + 1;    --    skip this character<br>              END IF;<br>          ELSIF (offset + 3 &lt;= ChemNameLength AND CharChemName = 'a' AND SUBSTR(chemname,offset+1,3) = 'ate') THEN<br>              newname := FixIcAte(newname) || 'a';<br>              offset := offset + 1;<br>          ELSIF (offset + 4 &lt;= ChemNameLength AND CharChemName = 'a' AND SUBSTR(chemname,offset+1, 4) = 'amyl') THEN<br>              newname := newname || 'pent';<br>              offset := offset + 2;<br>          ELSIF (offset &gt; 0 AND BeforeCharChemName = 'y' AND CharChemName = 'c' AND ChemNameLength - offset &gt; 5 AND SUBSTR(chemname, offset+1, 5) = 'ceric') THEN<br>              newname := newname || 'cer';<br>              offset := offset + 3;<br>              -- ceric --&gt; cer<br>          ELSIF (ChemNameLength&gt;5 AND offset = ChemNameLength - 1 AND offset &gt; 0 AND CharChemName = 'e' AND IsLetter(BeforeCharChemName)) THEN<br>              -- drop an 'e' at the very end of the name<br>              offset := offset + 1;    --    skip this character<br>          ELSIF (ChemNameLength&gt;5 AND offset &gt; 0 AND offset + 1 &lt; ChemNameLength AND CharChemName = 'e' AND IsLetter(BeforeCharChemName) AND NOT(IsLetter(AfterCharChemName))) THEN<br>              -- drop an 'e' after a letter and before a non-letter<br>              offset := offset + 1;    --    skip this character<br>          ELSIF (offset + 7 &lt;= ChemNameLength AND CharChemName = 'i' AND SUBSTR(chemname, offset+1, 7) = 'ic acid') THEN<br>              IF INSTR(newname,'yl')&lt;&gt;0 THEN<br>                  newname := newname || 'icacid';<br>              ELSE<br>                  newname := FixIcAte(newname) || 'at';<br>              END IF;<br>              offset := offset + 7;<br>          ELSIF (offset + 6 &lt;= ChemNameLength AND CharChemName = 'i' AND SUBSTR(chemname, offset+1, 6) = 'icacid') THEN<br>              newname := FixIcAte(newname) || 'at';<br>              offset := offset + 6;<br>          ELSIF (offset + 8 &lt;= ChemNameLength AND CharChemName = 'o' AND SUBSTR(chemname, offset+1, 8) = 'ous acid') THEN<br>              IF INSTR(newname,'yl')&lt;&gt;0 THEN<br>                  newname := newname || 'ousacid';<br>              ELSE<br>                  newname := newname || 'it';<br>              END IF;<br>              offset := offset + 8;<br>          ELSIF (offset + 6 &lt;= ChemNameLength AND CharChemName = 'i' AND SUBSTR(chemname, offset+1, 6) = 'icacid') THEN<br>              newname := FixIcAte(newname) || 'at';<br>              offset := offset + 6;<br>          ELSIF (offset &gt; 0 AND offset + 1 &lt; ChemNameLength AND CharChemName = 'm'<br>              AND INSTR('-' ||' ' ||',' || '''',AfterCharChemName)&gt;0<br>              AND INSTR('-' || ' ' || ',' || '''' || '(' || '[' || '{',BeforeCharChemName)&gt;0) THEN<br>              newname := newname || '3';<br>              offset := offset + 1;    --    skip this character<br>          ELSIF (offset + 3 &lt;= ChemNameLength AND CharChemName = 'o' AND SUBSTR(chemname, offset+1, 3) = 'oyl') THEN<br>              newname := FixIcAte(newname) || 'o';<br>              --                    newname = FixIcAte(newsyns);<br>              --                    if (newname.LENGTH() &gt; 0 AND newname[newname.LENGTH - 1] != 'o')<br>              --                        newname ||= 'o';<br>              offset := offset + 1;<br>          ELSIF (offset &gt; 0 AND offset + 1 &lt; ChemNameLength AND CharChemName = 'o'<br>                AND INSTR('-'||' '||','|| '''',AfterCharChemName)&gt;0<br>                AND INSTR('-'|| ' '|| ','|| ''''|| '('|| '['|| '{',BeforeCharChemName)&gt;0 )  THEN<br>              newname := newname || '2';<br>              offset := offset + 1;    --    skip this character<br>          ELSIF (offset &gt; 0 AND offset + 1 &lt; ChemNameLength AND CharChemName = 'p'<br>                AND INSTR('-'||' '||','|| '''',AfterCharChemName)&gt;0<br>                AND INSTR('-'|| ' '|| ','|| ''''|| '('|| '['|| '{',BeforeCharChemName)&gt;0 )  THEN<br>              newname := newname || '4';<br>              offset := offset + 1;    --    skip this character<br>              --don't replace des at end of string<br>         ELSIF (offset + 3 = ChemNameLength AND CharChemName = 'd' AND SUBSTR(chemname, offset+1, 3) = 'des') THEN<br>  			newname := newname || 'des';<br>  			offset :=  offset + 3;<br>  <br>          ELSE<br>  <br>              numReplacements := replacements.count;<br>              didReplace := false;<br>              repl := 1;<br>              LOOP<br>                  EXIT WHEN  (repl&gt;numReplacements);<br>                  -- Make sure the first character is a match; if not, no point in checking anything else<br>  <br>                  IF ((CharChemName = SUBSTR(replacements(repl),1,1)) AND<br>                       (ChemNameLength - offset &gt;= LENGTH(replacements(repl))) AND<br>                      (SUBSTR(chemname, offset+1, LENGTH(replacements(repl))) = replacements(repl))) THEN<br>                          thisOrig := replacements(repl);<br>              			thisReplacement := replacements(repl + 1);<br>              			deltaOffset :=Length(thisOrig);<br>              			IF (NOT(replacements(repl) = ' potassium') AND NOT(replacements(repl) = ' sodium')<br>                             AND NOT(replacements(repl) = ' na+') AND NOT(replacements(repl) = ' k+')) THEN<br>              				-- If both the original and the replacement end in 'yl',<br>              				-- then don't replace that part.  We only checked it to confirm the match,<br>              				-- but we might still want to replace it further.<br>              				-- enanthyl alcohol --&gt; heptyl alcohol --&gt; heptanol<br>              				IF (deltaOffset &gt; 2<br>              					AND SUBSTR(thisOrig,deltaOffset - 1,1) = 'y'<br>                                  AND SUBSTR(thisOrig,deltaOffset,1) = 'l'<br>              					AND SUBSTR(thisReplacement,LENGTH(thisReplacement) - 1,1) = 'y'<br>                                  AND SUBSTR(thisReplacement,LENGTH(thisReplacement),1) = 'l') THEN<br>              					thisReplacement := SUBSTR(thisReplacement,1, LENGTH(thisReplacement) - 2);<br>              					deltaOffset := deltaOffset - 2;<br>                              END IF;<br>              				newname := newname || thisReplacement;<br>                          ELSE<br>              				newname := thisReplacement || newname;<br>                          END IF;<br>              			offset := offset + deltaOffset;<br>                          didReplace := TRUE;<br>                          EXIT;<br>                  END IF;<br>                  repl := repl + 2;<br>              END LOOP;<br>              IF NOT (didReplace)<br>              THEN<br>                  newname := newname || CharChemName;  --added this<br>                  offset := offset + 1;<br>              END IF;<br>          END IF;<br>      END LOOP;<br>      newname := CleanNormalized(newname);<br>  <br>      RETURN newname;<br>  END;<br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_7"></a>
<div class="caption2">COEDB.UPDATEROLE</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE FUNCTION &quot;COEDB&quot;.&quot;UPDATEROLE&quot;  (<br>     pRoleName        IN   security_roles.role_name%TYPE,<br>     pPrivTableName   IN   privilege_tables.privilege_table_name%TYPE,<br>     pPrivValueList   IN   VARCHAR2)<br>     RETURN VARCHAR2<br>  AS<br>     roleId   INTEGER;<br>  BEGIN<br>     SELECT role_id INTO roleId<br>       FROM security_roles<br>      WHERE UPPER (role_name) = UPPER (pRoleName);<br>  <br>     EXECUTE IMMEDIATE 'DELETE FROM ' || pPrivTableName || ' WHERE ROLE_INTERNAL_ID= ' || roleId;<br>     EXECUTE IMMEDIATE 'INSERT INTO ' || pPrivTableName || ' VALUES ( ' || roleId || ', ' || pPrivValueList || ')';<br>  <br>     RETURN '1';<br>  END updaterole;<br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_8"></a>
<div class="caption2">COEDB.UPDATEUSER</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE FUNCTION &quot;COEDB&quot;.&quot;UPDATEUSER&quot;  (<br>     pUserName       IN   people.user_id%TYPE,<br>     pPassword       IN   VARCHAR2 := NULL,<br>     pRolesGranted   IN   VARCHAR2 := NULL,<br>     pRolesRevoked   IN   VARCHAR2 := NULL,<br>     pFirstName      IN   people.first_name%TYPE := NULL,<br>     pMiddleName     IN   people.middle_name%TYPE := NULL,<br>     pLastName       IN   people.last_name%TYPE := NULL,<br>     pTelephone      IN   people.telephone%TYPE := NULL,<br>     pEmail          IN   people.email%TYPE := NULL,<br>     pAddress        IN   people.int_address%TYPE := NULL,<br>     pUserCode       IN   people.user_code%TYPE := NULL,<br>     pSupervisorId   IN   people.supervisor_internal_id%TYPE := NULL,<br>     pSiteId         IN   people.site_id%TYPE := NULL,<br>     pIsActive       IN   people.active%TYPE := 1<br>  )<br>     RETURN VARCHAR2<br>  AS<br>     source_cursor    INTEGER;<br>     rows_processed   INTEGER;<br>  BEGIN<br>     UPDATE people<br>        SET first_name = pFirstName,<br>            middle_name = pMiddleName,<br>            last_name = pLastName,<br>            email = pEmail,<br>            telephone = pTelephone,<br>            int_address = pAddress,<br>            user_code = pUserCode,<br>            supervisor_internal_id = pSupervisorId,<br>            site_id = pSiteId,<br>            active = pIsActive<br>      WHERE UPPER (people.user_id) = UPPER (pUserName);<br>  <br>     IF (pPassword IS NOT NULL) OR (pRolesGranted IS NOT NULL) OR (pRolesRevoked IS NOT NULL) THEN<br>        source_cursor := DBMS_SQL.open_cursor;<br>  <br>        IF (pPassword IS NOT NULL) THEN<br>           DBMS_SQL.parse (source_cursor, 'ALTER USER ' || pUserName || ' IDENTIFIED BY ' || pPassword, DBMS_SQL.native);<br>           rows_processed := DBMS_SQL.EXECUTE (source_cursor);<br>        END IF;<br>  <br>        IF (pRolesRevoked IS NOT NULL) THEN<br>           DBMS_SQL.parse (source_cursor, 'REVOKE ' || pRolesRevoked || ' FROM ' || pUserName, DBMS_SQL.native);<br>           rows_processed := DBMS_SQL.EXECUTE (source_cursor);<br>        END IF;<br>  <br>        IF (pRolesGranted IS NOT NULL) THEN<br>           DBMS_SQL.parse (source_cursor, 'GRANT ' || pRolesGranted || ' TO ' || pUserName, DBMS_SQL.native);<br>           rows_processed := DBMS_SQL.EXECUTE (source_cursor);<br>        END IF;<br>     END IF;<br>  <br>     RETURN '1';<br>  END updateUser;<br> /
</code></pre>   </td>  </tr>
</table>

 <br><br> 
<a name = "TextObjName_9"></a>
<div class="caption1">PACKAGES</div>
<a name = "TextObject_9"></a>
<div class="caption2">COEDB.AUDIT_TRAIL</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE PACKAGE &quot;COEDB&quot;.&quot;AUDIT_TRAIL&quot;  IS<br>     PROCEDURE Record_Transaction (<br>        raId      IN   NUMBER,<br>        tabName   IN   VARCHAR2,<br>        erId      IN   NUMBER,<br>        act       IN   VARCHAR2<br>     );<br>  <br>     PROCEDURE Column_Update (<br>        raId      IN   NUMBER,<br>        colName   IN   VARCHAR2,<br>        oldVal    IN   VARCHAR2,<br>        newVal    IN   VARCHAR2<br>     );<br>  END Audit_Trail; <br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_10"></a>
<div class="caption2">COEDB.COEDBLIBRARY</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE PACKAGE &quot;COEDB&quot;.&quot;COEDBLIBRARY&quot; <br>  AS<br>      TYPE T_TableFloat IS TABLE OF FLOAT<br>         INDEX BY BINARY_INTEGER;<br>  <br>      TYPE T_TableNumber IS TABLE OF NUMBER(9)<br>         INDEX BY BINARY_INTEGER;<br>  <br>      TYPE T_TableInteger IS TABLE OF INTEGER<br>         INDEX BY BINARY_INTEGER;<br>  <br>      PROCEDURE UpdateArray (AHitListID IN NUMBER, AIDArray  IN T_TableNumber, ASortArray IN T_TableFloat);<br>  <br>      PROCEDURE InsertHitList(refcursor IN sys_refcursor, commitSize IN INTEGER, recordCount OUT INTEGER);<br>  <br>      Function ClobToTable(c IN CLOB) return myTableType;<br>  <br>  END CoeDBLibrary; <br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_11"></a>
<div class="caption2">COEDB.CONFIGURATIONCOMPOUNDREGISTRY</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE PACKAGE &quot;COEDB&quot;.&quot;CONFIGURATIONCOMPOUNDREGISTRY&quot;  AS<br>  /******************************************************************************<br>     NAME:       PropertyList<br>     PURPOSE:<br>  <br>     REVISIONS:<br>     Ver        Date        Author           Description<br>     ---------  ----------  ---------------  ------------------------------------<br>     1.0        28/8/2008   Fari              1. Created this package body.<br>  ******************************************************************************/<br>  <br>    PROCEDURE ProcessFieldsfromXml(ACoeObjectConfigXML IN CLOB);<br>    PROCEDURE ProcessFieldsfromDB;<br>  <br>     eGenericException Constant Number:=-20000;<br>     <br>  END ConfigurationCompoundRegistry;  <br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_12"></a>
<div class="caption2">COEDB.CONFIGURATIONMANAGER</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE PACKAGE &quot;COEDB&quot;.&quot;CONFIGURATIONMANAGER&quot; <br>  AS<br>      PROCEDURE RetrieveConfiguration(ADescription IN VARCHAR2, AClassName OUT VARCHAR2, AConfiguration OUT CLOB);<br>      FUNCTION RetrieveParameter(ADescription IN VARCHAR2, AParameter IN VARCHAR2) RETURN CLOB;<br>      PROCEDURE UpdateParameter(ADescription IN VARCHAR2, AParameter IN VARCHAR2, AValue VARCHAR2);<br>      PROCEDURE InsertConfiguration(ADescription IN VARCHAR2, AClassName IN VARCHAR2, AConfiguration IN CLOB);<br>      PROCEDURE UpdateConfiguration(ADescription IN VARCHAR2, AClassName IN VARCHAR2, AConfiguration IN CLOB);<br>      PROCEDURE DeleteConfiguration(ADescription IN VARCHAR2);<br>  <br>      Debuging Constant boolean:=True;<br>  <br>      eGenericException Constant Number:=-20000;<br>      eNoRowsReturned Constant Number:=-20020;<br>      eParameterNonexistent Constant Number:=-20021;<br>  <br>      eRetrieveConfiguration Constant Number:=-20001;<br>      eInsertConfiguration Constant Number:=-20002;<br>      eUpdateConfiguration Constant Number:=-20003;<br>      eDeleteConfiguration Constant Number:=-20004;<br>  <br>      eRetrieveParameter Constant Number:=-20005;<br>      eUpdateParameter Constant Number:=-20006;<br>  <br>  <br>  <br>  END ConfigurationManager; <br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_13"></a>
<div class="caption2">COEDB.LOGIN</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE PACKAGE &quot;COEDB&quot;.&quot;LOGIN&quot;  AS<br>     TYPE cursor_type IS REF CURSOR;<br>  <br>     --This package is used during the COWS login process and should be made available to every user<br>  <br>     --Gets role ids granted to a given user within a given privilege table<br>     --Set pPrivTableName to NULL to get all roles for a given user in all of CS_SECURITY<br>     PROCEDURE getUserRoleIds (<br>        pUserName        IN       people.user_id%TYPE,<br>        pPrivTableName   IN       privilege_tables.privilege_table_name%TYPE,<br>        o_rs             OUT      cursor_type);<br>  <br>     --Returns a single record with the boolean values of the privileges<br>     PROCEDURE getPrivs (<br>        pPrivTableName   IN       privilege_tables.privilege_table_name%TYPE,<br>        o_rs             OUT      cursor_type);<br>  <br>     --Returns a recordset with all privilege values for the given role ids<br>     PROCEDURE getPrivsByRoleId (<br>        pRoleIdList      IN       VARCHAR2,<br>        pPrivTableName   IN       privilege_tables.privilege_table_name%TYPE,<br>        o_rs             OUT      cursor_type);<br>  <br>     --Returns a person_id for a given user name<br>     FUNCTION getPersonId (pUserName IN people.user_id%TYPE)<br>        RETURN people.person_id%TYPE;<br>  END Login; <br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_14"></a>
<div class="caption2">COEDB.MANAGE_ROLES</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE PACKAGE &quot;COEDB&quot;.&quot;MANAGE_ROLES&quot;  AS<br>     TYPE cursor_type IS REF CURSOR;<br>  <br>     ---Gets all Oracle roles<br>     PROCEDURE getAllRoles (o_rs OUT cursor_type);<br>  <br>     ---Gets all roles for a given privilege table<br>     ---Set pPrivTableName to NULL to get all roles in CS_SECURITY<br>     PROCEDURE getRoles (<br>        pPrivTableName   IN       privilege_tables.privilege_table_name%TYPE,<br>        o_rs             OUT      cursor_type);<br>  <br>     ---Gets all roles NOT already granted to a given user within a given privilege table<br>     ---Set pPrivTableName to NULL to get all roles NOT already granted to a given user in all of CS_SECURITY<br>     PROCEDURE getAvailableRoles (<br>        pUserName        IN       people.user_id%TYPE,<br>        pPrivTableName   IN       privilege_tables.privilege_table_name%TYPE := NULL,<br>        o_rs             OUT      cursor_type);<br>  <br>     ---Gets all roles granted to a given user within a given privilege table<br>     ---Set pPrivTableName to NULL to get all roles for a given user in all of CS_SECURITY<br>     PROCEDURE getUserRoles (<br>        pUserName        IN       people.user_id%TYPE,<br>        pPrivTableName   IN       privilege_tables.privilege_table_name%TYPE := NULL,<br>        o_rs             OUT      cursor_type);<br>  <br>     ---Gets all roles granted to a given role<br>     PROCEDURE getRoleRoles (<br>        pRoleName   IN       security_roles.role_name%TYPE,<br>        o_rs        OUT      cursor_type);<br>  <br>     ---Gets all roles in a privTable available to a given role<br>     PROCEDURE getRoleAvailableRoles (<br>        pPrivTableName   IN       privilege_tables.privilege_table_name%TYPE,<br>        pRoleName        IN       security_roles.role_name%TYPE,<br>        o_rs             OUT      cursor_type);<br>  <br>     ---Returns a single record whose fields contain the privilege names for that role<br>     PROCEDURE getRolePrivs (<br>        pRoleName   IN       security_roles.role_name%TYPE,<br>        o_rs        OUT      cursor_type);<br>  <br>     ---Updates roles granted to a given role<br>     FUNCTION updateRolesGrantedToRole (<br>        pRoleName       IN   security_roles.role_name%TYPE,<br>        pRolesGranted   IN   VARCHAR2 := NULL,<br>        pRolesRevoked   IN   VARCHAR2 := NULL)<br>        RETURN VARCHAR2;<br>  <br>     ---Updates users granted a given role<br>     FUNCTION updateUsersGrantedARole (<br>        pRoleName       IN   security_roles.role_name%TYPE,<br>        pUsersGranted   IN   VARCHAR2 := NULL,<br>        pUsersRevoked   IN   VARCHAR2 := NULL)<br>        RETURN VARCHAR2;<br>  END manage_roles; <br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_15"></a>
<div class="caption2">COEDB.MANAGE_USERS</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE PACKAGE &quot;COEDB&quot;.&quot;MANAGE_USERS&quot;  AS<br>     TYPE cursor_type IS REF CURSOR;<br>  <br>     --Returns all Oracle users<br>     PROCEDURE getAllUsers (o_rs OUT cursor_type);<br>  <br>     --Returns all CSS users for a given PrivTable.<br>     --Use PrivTableName = Null to get all CSS users<br>     PROCEDURE getUsers (<br>        pprivtablename   IN       privilege_tables.privilege_table_name%TYPE,<br>        o_rs             OUT      cursor_type);<br>  <br>     --Returns all attributes of a single user<br>     PROCEDURE getUser (pusername IN people.user_id%TYPE, o_rs OUT cursor_type);<br>  <br>     --Gets grantees of a given role<br>     PROCEDURE getRoleGrantees (<br>        prolename   IN       security_roles.role_name%TYPE,<br>        o_rs        OUT      cursor_type);<br>  <br>     --Gets users that are not yet grantees to a role<br>     PROCEDURE getRoleAvailableUsers (<br>        pprivtablename   IN       privilege_tables.privilege_table_name%TYPE,<br>        prolename        IN       security_roles.role_name%TYPE,<br>        o_rs             OUT      cursor_type);<br>  END Manage_Users; <br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_16"></a>
<div class="caption2">COEDB.PARTITIONMANAGMENT</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE PACKAGE &quot;COEDB&quot;.&quot;PARTITIONMANAGMENT&quot;  AS<br>      /******************************************************************************<br>         NAME:       PartitionManagment<br>         PURPOSE:<br>  <br>         REVISIONS:<br>         Ver        Date        Author           Description<br>         ---------  ----------  ---------------  ------------------------------------<br>         1.0        4/015/2008   Fari               Created this package.<br>      ******************************************************************************/<br>  <br>      PROCEDURE CreatePartitions        (ATableName IN VARCHAR2, ACurrentDate IN DATE, ASchemaName VARCHAR2);<br>      PROCEDURE DeletePartitions        (ATableName IN VARCHAR2, ACurrentDate IN DATE, ASchemaName VARCHAR2);<br>      PROCEDURE UpdatePartitions        (ATableName IN VARCHAR2, ACurrentDate IN DATE, ASchemaName VARCHAR2);<br>      PROCEDURE UpdatePartitionJob      (ATableName IN VARCHAR2, ACurrentDate IN DATE, ASchemaName VARCHAR2);<br>      PROCEDURE ValidatePartitionSupport;<br>  <br>      Debuging Constant boolean:=True;<br>  <br>      eGenericException Constant Number:=-20000;<br>  <br>      eCreatePartitions    Constant Number:=-20001;<br>      eDeletePartitions    Constant Number:=-20002;<br>      eUpdatePartitions    Constant Number:=-20003;<br>      eUpdatePartitionJob  Constant Number:=-20004;<br>  <br>      eOraclePartitionsnotsupported Constant Number:=-20010;<br>      ePartitionParamManagmentError Constant Number:=-20011;<br>      eValidatePartitionSupport     Constant Number:=-20012;<br>  <br>  END PartitionManagment; <br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_17"></a>
<div class="caption2">COEDB.PROPERTYLIST</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE PACKAGE &quot;COEDB&quot;.&quot;PROPERTYLIST&quot;  AS<br>  /******************************************************************************<br>     NAME:       PropertyList<br>     PURPOSE:<br>  <br>     REVISIONS:<br>     Ver        Date        Author           Description<br>     ---------  ----------  ---------------  ------------------------------------<br>     1.0        10/4/2007             1. Created this package.<br>  ******************************************************************************/<br>  <br>    PROCEDURE ProcessFieldsfromXml(ACoeObjectConfigXML in CLOB);<br>    PROCEDURE ProcessFieldsfromDB;<br>  <br>     eGenericException Constant Number:=-20000;<br>     <br>  END PropertyList;  <br> /
</code></pre>   </td>  </tr>
</table>

 <br><br> 
<a name = "TextObjName_18"></a>
<div class="caption1">PACKAGE BODIES</div>
<a name = "TextObject_18"></a>
<div class="caption2">COEDB.AUDIT_TRAIL</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE PACKAGE BODY &quot;COEDB&quot;.&quot;AUDIT_TRAIL&quot;  IS<br>     PROCEDURE Record_Transaction (<br>        raId      IN   NUMBER,<br>        tabName   IN   VARCHAR2,<br>        erId      IN   NUMBER,<br>        act       IN   VARCHAR2<br>     ) IS<br>     BEGIN<br>        -- Write a record of the transaction to the master audit trail<br>        -- table.  Timestamp and User_Name are not included here -<br>        -- they are filled in by column defaults defined at the table<br>        -- level (should be faster).<br>        INSERT INTO audit_row (raId, table_name, rId, action, TIMESTAMP, user_name)<br>             VALUES (raId, tabName, erId, act, SYSDATE, USER);<br>  <br>        -- Return a scary message if for some reason the statement failed.<br>        IF SQL%NOTFOUND THEN<br>           Raise_Application_Error (-20000, 'Error creating Row Audit record.');<br>        END IF;<br>     END;<br>  <br>     PROCEDURE column_update (<br>        raId      IN   NUMBER,<br>        colName   IN   VARCHAR2,<br>        oldVal    IN   VARCHAR2,<br>        newVal    IN   VARCHAR2<br>     ) IS<br>     BEGIN<br>        -- Record the column names and old/new data values of individual<br>        -- columns altered in the transaction to the AUDIT_COLUMN table.<br>        INSERT INTO audit_column (raId, caId, column_name, old_value, new_value)<br>             VALUES (raId, seq_audit.NEXTVAL, colName, oldVal, newVal);<br>  <br>        -- Return a scary message if for some reason the statement fails.<br>        IF SQL%NOTFOUND THEN<br>           Raise_Application_Error (-20000, 'Error creating Column Audit record.');<br>        END IF;<br>     END;<br>  END audit_trail; <br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_19"></a>
<div class="caption2">COEDB.COEDBLIBRARY</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE PACKAGE BODY &quot;COEDB&quot;.&quot;COEDBLIBRARY&quot; <br>  IS<br>      PROCEDURE UpdateArray (AHitListID IN NUMBER, AIDArray IN T_TableNumber, ASortArray IN T_TableFloat) IS<br>         LIndex   NUMBER(9);<br>      BEGIN<br>         FORALL LIndex IN AIDArray.FIRST .. AIDArray.LAST<br>            UPDATE CoeDB.CoeTempHitList<br>               SET SortOrder = ASortArray (LIndex)<br>             WHERE HitListid = AHitListID AND ID = AIDArray (LIndex);<br>      END;<br>  <br>      PROCEDURE InsertHitList(refcursor IN sys_refcursor, commitSize IN INTEGER, recordCount OUT INTEGER) AS<br>          TYPE hitListID_type IS TABLE OF coedb.coetemphitlist.hitlistid%TYPE;<br>          TYPE id_type IS TABLE OF coedb.coetemphitlist.id%type;<br>          TYPE sortOrder_type IS TABLE OF coedb.coetemphitlist.sortorder%TYPE;<br>  <br>          hitListID_t hitListID_type := hitListID_type();<br>          id_t id_type := id_type();<br>          sortOrder_t sortOrder_type := sortOrder_type();<br>          counter INTEGER := 1;<br>      BEGIN<br>          IF commitSize &gt; 0 THEN<br>              FOR i IN 1..commitSize<br>              LOOP<br>                  IF refcursor%NOTFOUND THEN<br>                      CLOSE refcursor;<br>                      EXIT;<br>                  ELSE<br>                      hitlistID_t.EXTEND(1);<br>                      id_t.EXTEND(1);<br>                      sortOrder_t.EXTEND(1);<br>  <br>                      FETCH refcursor INTO hitListID_t(i), id_t(i);<br>  <br>                      sortOrder_t(i) := refcursor%rowcount;<br>                      recordCount := refcursor%rowcount;<br>                  END IF;<br>              END LOOP;<br>          ELSE<br>              LOOP<br>                  /* Retrieve each row of the result of the above query<br>                  into PL/SQL variables: */<br>                  IF refcursor%NOTFOUND THEN<br>                      CLOSE refcursor;<br>                      EXIT;<br>                  ELSE<br>                         hitlistID_t.EXTEND(1);<br>                      id_t.EXTEND(1);<br>                      sortOrder_t.EXTEND(1);<br>  <br>                      FETCH refcursor INTO hitListID_t(counter), id_t(counter);<br>  <br>                      sortOrder_t(counter) := refcursor%rowcount;<br>                      counter := counter + 1;<br>                  END IF;<br>              END LOOP;<br>  <br>              recordCount := refcursor%rowcount;<br>          END IF;<br>  <br>          IF (id_t(id_t.LAST) IS NULL OR hitlistID_t(hitlistID_t.LAST) IS NULL) THEN<br>              id_t.TRIM();<br>              hitlistID_t.TRIM();<br>              sortOrder_t.TRIM();<br>          END IF;<br>          /* TODO: if there is no commitSize, the insertion should be chunked */<br>          FORALL j IN 1..id_t.count<br>              INSERT INTO COEDB.COETEMPHITLIST(hitlistid, id, datestamp, sortorder) VALUES(hitListID_t(j), id_t(j), SYSDATE, sortOrder_t(j));<br>  <br>      /*EXCEPTION<br>          WHEN OTHERS THEN<br>              RAISE_APPLICATION_ERROR(-20000, to_char(hitListID_t(recordCount) || ' ' || id_t(recordCount) || ' ' || id_t.count));*/<br>  <br>      END;<br>  <br>      FUNCTION ClobToTable(c IN CLOB) return myTableType IS<br>          i INTEGER;<br>          commaPos INTEGER;<br>  <br>          previousCommaPos INTEGER;<br>          val VARCHAR(30);<br>          length INTEGER;<br>          tab myTableType := myTableType();<br>      BEGIN<br>          i := 1;<br>  <br>          previousCommaPos := 0;<br>          length := DBMS_LOB.GETLENGTH(c);<br>  <br>          LOOP<br>              commaPos := DBMS_LOB.INSTR(c, ',', 1, i);<br>              IF commaPos != 0 THEN<br>                  val := DBMS_LOB.SUBSTR(c, commaPos - previousCommaPos - 1, previousCommaPos + 1);<br>  <br>                  previousCommaPos := commaPos;<br>  <br>                  tab.extend;<br>                  tab(tab.count) := val;<br>              ELSE<br>                  val := DBMS_LOB.SUBSTR(c, length - previousCommaPos, previousCommaPos + 1);<br>  <br>                 tab.extend;<br>                 tab(tab.count) := val;<br>  <br>                 EXIT;<br>              END IF;<br>  <br>              i := i + 1;<br>          END LOOP;<br>  <br>          RETURN tab;<br>      END;<br>  END; <br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_20"></a>
<div class="caption2">COEDB.CONFIGURATIONCOMPOUNDREGISTRY</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE PACKAGE BODY &quot;COEDB&quot;.&quot;CONFIGURATIONCOMPOUNDREGISTRY&quot;  AS<br>  /******************************************************************************<br>     NAME:       PropertyList<br>     PURPOSE:<br>  <br>     REVISIONS:<br>     Ver        Date        Author           Description<br>     ---------  ----------  ---------------  ------------------------------------<br>     1.0        28/8/2008   Fari              1. Created this package body.<br>  ******************************************************************************/<br>     PROCEDURE InsertLog(ALogProcedure CLOB,ALogComment CLOB) IS<br>         PRAGMA AUTONOMOUS_TRANSACTION;<br>     BEGIN<br>         INSERT INTO LOG(LogProcedure,LogComment) VALUES($$plsql_unit||'.'||ALogProcedure,ALogComment);<br>         COMMIT;<br>     EXCEPTION<br>         WHEN OTHERS THEN NULL; --If logs don't work then don't stop<br>     END;<br>     <br>     PROCEDURE SetSessionParameter IS<br>         PRAGMA AUTONOMOUS_TRANSACTION;<br>     BEGIN<br>         DBMS_SESSION.set_nls('NLS_DATE_FORMAT','''YYYY-MM-DD HH:Mi:SS''');<br>         DBMS_SESSION.set_nls('NLS_NUMERIC_CHARACTERS', '''.,''');<br>         COMMIT; --It is necesary to finished the Autonomou-Transaction<br>     EXCEPTION<br>         WHEN OTHERS THEN<br>         BEGIN<br>             InsertLog('SetSessionParameter'||' Line:'||$$plsql_line,DBMS_UTILITY.FORMAT_ERROR_STACK);<br>             RAISE_APPLICATION_ERROR(eGenericException, 'SetSessionParameter'||CHR(10)||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>         END;<br>  END;<br>      <br>     PROCEDURE SetField(AField IN VARCHAR2, AViewField OUT VARCHAR2, ATableField OUT VARCHAR2, ASection IN VARCHAR2, AType in VARCHAR2) IS<br>     BEGIN  <br>          AViewField:=UPPER(AField);<br>          ATableField:=UPPER(AField);<br>          CASE UPPER(ASection)<br>              WHEN 'BATCH' THEN<br>                  BEGIN<br>                      CASE UPPER(AType)<br>                          WHEN 'DEFINITIVE' THEN<br>                              BEGIN<br>                                  IF ATableField='OPTICALROTATION' THEN<br>                                      ATableField:='OPTICAL_ROTATION';<br>                                  END IF;<br>                                  IF ATableField='REFRACTIONINDEX' THEN<br>                                      ATableField:='REFRACTIVE_INDEX';<br>                                  END IF;<br>                              END;<br>                          WHEN 'TEMPORARY' THEN<br>                              BEGIN<br>                                  NULL;<br>                              END;<br>                      END CASE; <br>                  END;<br>              WHEN 'COMPOUND' THEN<br>                  BEGIN<br>                      NULL;<br>                  END;<br>              WHEN 'BATCHCOMPONENT' THEN<br>                  BEGIN<br>                      CASE UPPER(AType)<br>                          WHEN 'DEFINITIVE' THEN<br>                              BEGIN<br>                                  NULL;<br>                              END;<br>                          WHEN 'TEMPORARY' THEN<br>                              BEGIN<br>                                  IF ATableField='COMMENTS' THEN<br>                                      ATableField:='BATCHCOMPONENT_COMMENTS';<br>                                  END IF;<br>                                  IF AViewField='COMMENTS' THEN<br>                                      AViewField:='BATCHCOMPONENTCOMMENTS';<br>                                  END IF;<br>                              END;<br>                      END CASE;<br>                  END;            <br>          END CASE;<br>      END;<br>  <br>      PROCEDURE AddField(AField IN VARCHAR2, ASection IN VARCHAR2, AFieldType IN VARCHAR2) IS<br>          LStatement   Varchar2(4000);<br>          LViewField   Varchar2(100);<br>          LTableField  Varchar2(100);<br>  <br>          FUNCTION AddFieldToView(AViewName VARCHAR2,APrimaryTable in VARCHAR2:='') RETURN VARCHAR2 IS<br>              LViewSelect VARCHAR2(10000);<br>              LViewFields VARCHAR2(10000);<br>              CURSOR LCViewFields(ViewName VARCHAR2) IS <br>                  SELECT Column_Name<br>                    FROM User_Tab_Columns c<br>                   WHERE Table_Name = ViewName;<br>          BEGIN<br>              LViewFields:='';<br>              FOR  RViewFields IN LCViewFields(AViewName) LOOP<br>                  LViewFields:=LViewFields||RViewFields.Column_Name||',';<br>              END LOOP;<br>              LViewFields:=SUBSTR(LViewFields,1,LENGTH(LViewFields)-1);<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LViewFields='||LViewFields);<br>              SELECT Text <br>                INTO LViewSelect <br>                FROM USER_VIEWS <br>               WHERE VIEW_NAME=AViewName;<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LViewSelect=1'||LViewSelect);    <br>              LViewSelect:=SUBSTR(LViewSelect,1,INSTR(LViewSelect,'FROM '||APrimaryTable)-2)||','||LTableField||' '||SUBSTR(LViewSelect,INSTR(LViewSelect,'FROM '||APrimaryTable),LENGTH(LViewSelect));<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LViewSelect=2'||LViewSelect);<br>              LStatement:='CREATE OR REPLACE VIEW '||AViewName||'('||LViewFields||','||LViewField||') AS '||LViewSelect;<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LStatement='||LStatement);<br>              RETURN LStatement;<br>          END;<br>      BEGIN<br>          InsertLog('AddField'||' Line:'||$$plsql_line,'AField='||AField||' ASection='||ASection);<br>  <br>          CASE UPPER(ASection)<br>              WHEN 'COMPOUND' THEN<br>                  BEGIN<br>                      IF (INSTR(UPPER(AFieldType),'NUMBER')&lt;&gt;0) OR (INSTR(UPPER(AFieldType),'VARCHAR2')&lt;&gt;0) OR (INSTR(UPPER(AFieldType),'DATE')&lt;&gt;0) THEN<br>                          SetField(AField,LViewField,LTableField,ASection,'DEFINITIVE');<br>                          LStatement:='ALTER TABLE COMPOUND_MOLECULE ADD '||UPPER(LTableField)||' '||AFieldType;<br>                          BEGIN<br>                              EXECUTE IMMEDIATE LStatement;<br>                              <br>                              LStatement:=AddFieldToView('VW_COMPOUND');<br>                              EXECUTE IMMEDIATE LStatement;<br>                          EXCEPTION<br>                              WHEN OTHERS THEN <br>                              BEGIN<br>                                  InsertLog('AddField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                                  IF SQLCODE=-1430 THEN NULL;<br>                                  END IF;<br>                              END;<br>                          END;<br>                          <br>                          LStatement:='ALTER TABLE TEMPORARY_COMPOUND ADD '||UPPER(LTableField)||' '||AFieldType;<br>                          BEGIN<br>                              EXECUTE IMMEDIATE LStatement;<br>                              <br>                              LStatement:=AddFieldToView('VW_TEMPORARYCOMPOUND');<br>                              EXECUTE IMMEDIATE LStatement;<br>                          EXCEPTION<br>                              WHEN OTHERS THEN <br>                              BEGIN<br>                                  InsertLog('AddField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                                  IF SQLCODE=-1430 THEN NULL;<br>                                  END IF;<br>                              END;<br>                          END;<br>                      ELSE<br>                          RAISE_APPLICATION_ERROR(eGenericException, 'Field Type isn''t recognized');    <br>                      END IF;    <br>                  END;<br>              WHEN 'BATCH' THEN<br>                  BEGIN<br>                      IF (INSTR(UPPER(AFieldType),'NUMBER')&lt;&gt;0) OR (INSTR(UPPER(AFieldType),'VARCHAR2')&lt;&gt;0) OR (INSTR(UPPER(AFieldType),'DATE')&lt;&gt;0) THEN<br>                          SetField(AField,LViewField,LTableField,ASection,'DEFINITIVE');<br>                          LStatement:='ALTER TABLE BATCHES ADD '||UPPER(LTableField)||' '||AFieldType;<br>                          InsertLog('AddField'||' Line:'||$$plsql_line,'BATCH LStatement='||LStatement);<br>                          BEGIN<br>                              EXECUTE IMMEDIATE LStatement;<br>                              <br>                              LStatement:=AddFieldToView('VW_BATCH');<br>                              EXECUTE IMMEDIATE LStatement;<br>                              <br>                          EXCEPTION<br>                              WHEN OTHERS THEN <br>                              BEGIN<br>                                  InsertLog('AddField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                                  IF SQLCODE=-1430 THEN NULL;<br>                                  END IF;<br>                              END;<br>                          END;<br>                          <br>                          SetField(AField,LViewField,LTableField,ASection,'TEMPORARY');<br>                          LStatement:='ALTER TABLE TEMPORARY_BATCH ADD '||UPPER(LTableField)||' '||AFieldType;<br>                          BEGIN<br>                              EXECUTE IMMEDIATE LStatement;<br>                              <br>                              LStatement:=AddFieldToView('VW_TEMPORARYBATCH','TEMPORARY_BATCH');<br>                              EXECUTE IMMEDIATE LStatement;<br>                          EXCEPTION<br>                              WHEN OTHERS THEN <br>                              BEGIN<br>                                  InsertLog('AddField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                                  IF SQLCODE=-1430 THEN NULL;<br>                                  END IF;<br>                              END;<br>                          END;<br>                      ELSE<br>                           InsertLog('AddField'||' Line:'||$$plsql_line,'AddField - '||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>                          RAISE_APPLICATION_ERROR(eGenericException, 'Field Type isn''t recognized');    <br>                      END IF;    <br>                  END;<br>              WHEN 'BATCHCOMPONENT' THEN<br>                  BEGIN<br>                      IF (INSTR(UPPER(AFieldType),'NUMBER')&lt;&gt;0) OR (INSTR(UPPER(AFieldType),'VARCHAR2')&lt;&gt;0) OR (INSTR(UPPER(AFieldType),'DATE')&lt;&gt;0) THEN<br>                          SetField(AField,LViewField,LTableField,ASection,'DEFINITIVE');<br>                          LStatement:='ALTER TABLE BATCHCOMPONENT ADD '||UPPER(LTableField)||' '||AFieldType;<br>                          InsertLog('AddField'||' Line:'||$$plsql_line,'BATCHCOMPONENT LStatement='||LStatement);<br>                          BEGIN<br>                              EXECUTE IMMEDIATE LStatement;<br>                              <br>                              LStatement:=AddFieldToView('VW_BATCHCOMPONENT');<br>                              EXECUTE IMMEDIATE LStatement;<br>                              <br>                          EXCEPTION<br>                              WHEN OTHERS THEN <br>                              BEGIN<br>                                  InsertLog('AddField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                                  IF SQLCODE=-1430 THEN NULL;<br>                                  END IF;<br>                              END;<br>                          END;<br>                          <br>                          SetField(AField,LViewField,LTableField,ASection,'TEMPORARY');<br>                          LStatement:='ALTER TABLE TEMPORARY_COMPOUND ADD '||UPPER(LTableField)||' '||AFieldType;<br>                          BEGIN<br>                              EXECUTE IMMEDIATE LStatement;<br>                              <br>                              LStatement:=AddFieldToView('VW_TEMPORARYCOMPOUND','TEMPORARY_COMPOUND');<br>                              EXECUTE IMMEDIATE LStatement;<br>                          EXCEPTION<br>                              WHEN OTHERS THEN <br>                              BEGIN<br>                                  InsertLog('AddField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                                  IF SQLCODE=-1430 THEN NULL;<br>                                  END IF;<br>                              END;<br>                          END;<br>                      ELSE<br>                          InsertLog('AddField'||' Line:'||$$plsql_line,'AddField - '||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>                          RAISE_APPLICATION_ERROR(eGenericException, 'Field Type isn''t recognized');    <br>                      END IF;    <br>                  END;      <br>          END CASE;<br>      EXCEPTION<br>          WHEN OTHERS THEN<br>          BEGIN<br>               InsertLog('AddField'||' Line:'||$$plsql_line,'AddField - '||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>              RAISE_APPLICATION_ERROR(eGenericException, 'DropField - Error adding the field.'||chr(10)||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>          END;<br>      END;<br>  <br>      PROCEDURE DropField(AField IN VARCHAR2, ASection IN VARCHAR2) IS<br>          LStatement   Varchar2(4000);<br>          LViewField   Varchar2(100);<br>          LTableField  Varchar2(100);<br>          FUNCTION AddFieldToView(AViewName VARCHAR2) RETURN VARCHAR2 IS<br>              LViewSelect VARCHAR2(10000);<br>              LViewFields VARCHAR2(10000);<br>              LTable      VARCHAR2(100);<br>              CURSOR LCViewFields(ViewName VARCHAR2) IS <br>                  SELECT Column_Name<br>                    FROM User_Tab_Columns c<br>                   WHERE Table_Name = ViewName;<br>          BEGIN<br>              LViewFields:='';<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'Begin AViewName'||AViewName);<br>              FOR  RViewFields IN LCViewFields(AViewName) LOOP<br>                  IF UPPER(RViewFields.Column_Name)&lt;&gt;LViewField THEN<br>                      LViewFields:=LViewFields||RViewFields.Column_Name||',';<br>                       --InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'ViewFields.Column_Name='||RViewFields.Column_Name);<br>                  END IF;<br>              END LOOP;<br>              LViewFields:=SUBSTR(LViewFields,1,LENGTH(LViewFields)-1);<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LViewFields='||LViewFields);<br>              SELECT Text <br>                INTO LViewSelect <br>                FROM USER_VIEWS <br>               WHERE VIEW_NAME=AViewName;<br>              <br>              LViewSelect:=REPLACE(' '||SUBSTR(UPPER(LViewSelect),8,LENGTH(LViewSelect)),CHR(10),'');<br>              LTable:=SUBSTR(LViewSelect,INSTR(LViewSelect,'FROM ',-1),LENGTH(LViewSelect));<br>              LViewSelect:=REPLACE(LViewSelect,LTable,' ');<br>              <br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LTableField 1='||LTableField);<br>              <br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LViewSelect 1='||LViewSelect);<br>              LViewSelect:=REPLACE(LViewSelect,','||LTableField||',',',');<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LViewSelect 2='||LViewSelect);<br>              LViewSelect:=REPLACE(LViewSelect,','||LTableField||' ',' ');<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LViewSelect 3='||LViewSelect);<br>              LViewSelect:=REPLACE(LViewSelect,' '||LTableField||',',' ');<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LViewSelect 4='||LViewSelect);<br>              <br>              LViewSelect:='SELECT'||LViewSelect||LTable;<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LViewSelect 5='||LViewSelect);<br>              <br>              LStatement:='CREATE OR REPLACE VIEW '||AViewName||'('||LViewFields||') AS '||LViewSelect;<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LStatement='||LStatement);<br>              RETURN LStatement;<br>          END; <br>      BEGIN<br>          InsertLog('DropField'||' Line:'||$$plsql_line,'LViewField='||LViewField||' LTableField='||LTableField);<br>          CASE UPPER(ASection)<br>              WHEN 'COMPOUND' THEN<br>                  BEGIN<br>                      SetField(AField,LViewField,LTableField,ASection,'DEFINITIVE');<br>                      LStatement:='ALTER TABLE COMPOUND_MOLECULE DROP COLUMN '||LTableField;<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'LStatement1='||LStatement);<br>                      BEGIN<br>                          EXECUTE IMMEDIATE LStatement;<br>                         <br>                      EXCEPTION<br>                          WHEN OTHERS THEN <br>                          BEGIN<br>                              InsertLog('DropField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                              IF SQLCODE=-904 THEN NULL;<br>                              END IF;<br>                          END;<br>                      END;<br>                      <br>                      LStatement:=AddFieldToView('VW_COMPOUND');<br>                      EXECUTE IMMEDIATE LStatement;<br>  <br>                      LStatement:='ALTER TABLE TEMPORARY_COMPOUND DROP COLUMN '||LTableField;<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'LStatement2='||LStatement);<br>                      BEGIN<br>                          EXECUTE IMMEDIATE LStatement;<br>                      EXCEPTION<br>                          WHEN OTHERS THEN <br>                          BEGIN<br>                              InsertLog('DropField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                              IF SQLCODE=-904 THEN NULL;<br>                              END IF;<br>                          END;<br>                      END;<br>                      <br>                      LStatement:=AddFieldToView('VW_TEMPORARYCOMPOUND');<br>                      EXECUTE IMMEDIATE LStatement;<br>                  END;<br>              WHEN 'BATCH' THEN<br>                  BEGIN<br>                      SetField(AField,LViewField,LTableField,ASection,'DEFINITIVE');<br>                      LStatement:='ALTER TABLE BATCHES DROP COLUMN '||LTableField;<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'LStatement1='||LStatement);<br>                      BEGIN<br>                          EXECUTE IMMEDIATE LStatement;<br>                      EXCEPTION<br>                          WHEN OTHERS THEN <br>                          BEGIN<br>                              InsertLog('DropField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                              IF SQLCODE=-904 THEN NULL;<br>                              END IF;<br>                          END;<br>                      END;<br>                      <br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'before AddFieldToView VW_BATCH');<br>                      LStatement:=AddFieldToView('VW_BATCH');<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'after AddFieldToView VW_BATCH');<br>                      EXECUTE IMMEDIATE LStatement;<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'after EXECUTE AddFieldToView VW_BATCH');<br>                      <br>                      SetField(AField,LViewField,LTableField,ASection,'TEMPORARY');<br>                      LStatement:='ALTER TABLE TEMPORARY_BATCH DROP COLUMN '||LTableField;<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'LStatement2='||LStatement);<br>                      BEGIN<br>                          EXECUTE IMMEDIATE LStatement;<br>                      EXCEPTION<br>                          WHEN OTHERS THEN <br>                          BEGIN<br>                              InsertLog('DropField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                              IF SQLCODE=-904 THEN NULL;<br>                              END IF;<br>                          END;<br>                      END;<br>                          <br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'before AddFieldToView VW_TEMPORARYBATCH');<br>                      LStatement:=AddFieldToView('VW_TEMPORARYBATCH');<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'after AddFieldToView VW_TEMPORARYBATCH');<br>                      EXECUTE IMMEDIATE LStatement;<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'after EXECUTE AddFieldToView VW_TEMPORARYBATCH');<br>                  END;<br>              WHEN 'BATCHCOMPONENT' THEN<br>                  BEGIN<br>                      SetField(AField,LViewField,LTableField,ASection,'DEFINITIVE');<br>                      LStatement:='ALTER TABLE BATCHCOMPONENT DROP COLUMN '||LTableField;<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'LStatement1='||LStatement);<br>                      BEGIN<br>                          EXECUTE IMMEDIATE LStatement;<br>                      EXCEPTION<br>                          WHEN OTHERS THEN <br>                          BEGIN<br>                              InsertLog('DropField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                              IF SQLCODE=-904 THEN NULL;<br>                              END IF;<br>                          END;<br>                      END;<br>                      <br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'before AddFieldToView VW_BATCHCOMPONENT');<br>                      LStatement:=AddFieldToView('VW_BATCHCOMPONENT');<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'after AddFieldToView VW_BATCHCOMPONENT');<br>                      EXECUTE IMMEDIATE LStatement;<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'after EXECUTE AddFieldToView VW_BATCH');<br>                      <br>                      SetField(AField,LViewField,LTableField,ASection,'TEMPORARY');<br>                      LStatement:='ALTER TABLE TEMPORARY_COMPOUND DROP COLUMN '||LTableField;<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'LStatement2='||LStatement);<br>                      BEGIN<br>                          EXECUTE IMMEDIATE LStatement;<br>                      EXCEPTION<br>                          WHEN OTHERS THEN <br>                          BEGIN<br>                              InsertLog('DropField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                              IF SQLCODE=-904 THEN NULL;<br>                              END IF;<br>                          END;<br>                      END;<br>                          <br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'before AddFieldToView VW_TEMPORARYCOMPOUND');<br>                      LStatement:=AddFieldToView('VW_TEMPORARYCOMPOUND');<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'after AddFieldToView VW_TEMPORARYCOMPOUND');<br>                      EXECUTE IMMEDIATE LStatement;<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'after EXECUTE AddFieldToView VW_TEMPORARYCOMPOUND');<br>                  END;<br>          END CASE;        <br>      EXCEPTION<br>          WHEN OTHERS THEN<br>          BEGIN<br>              InsertLog('DropField'||' Line:'||$$plsql_line,'DropField - '||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>              RAISE_APPLICATION_ERROR(eGenericException, 'DropField - Error dropping a field'||chr(10)||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>          END;<br>      END;<br>  <br>      PROCEDURE ProcessFieldsfromXml(ACoeObjectConfigXML IN  CLOB) IS<br>          LCoeObjectConfigField     XmlType;<br>          LFiled               Varchar2(100);<br>          LFiledType           Varchar2(200);<br>          LFieldType           Varchar2(100);<br>  <br>          LDOMDocument         DBMS_XMLDom.DOMDocument;<br>          LDocumentNode        DBMS_XMLDom.DOMNode;<br>          LNodeList            DBMS_XMLDom.DOMNodelist;<br>          LNode                DBMS_XMLDom.DOMNode;<br>          LNodesCount          Number;<br>          LAttrs               DBMS_XMLDom.DOMNamedNodeMap;<br>          LAttr                DBMS_XMLDom.DOMNode;<br>          LIndexAttr           Number;<br>          LAttrName            Varchar2(300);<br>  <br>          ValidationRuleNode  DBMS_XMLDom.DOMNode;<br>          LValidationRuleList DBMS_XMLDom.DOMNodelist;<br>          LAttributeName      Varchar2(300);<br>          LLong               Varchar2(50);<br>  <br>          PROCEDURE ProcessDelete(ANodeList DBMS_XMLDom.DOMNodelist,ASection in VARCHAR2) IS<br>          BEGIN<br>              LNodesCount:=DBMS_XMLDom.GetLength(ANodeList);<br>              FOR LIndex IN 0..LNodesCount-1 LOOP<br>                  LNode := DBMS_XMLDom.Item(ANodeList, LIndex);<br>                  LAttrs := dbms_xmldom.Getattributes(LNode);<br>                  LAttr := dbms_xmldom.GetNamedItem(LAttrs,'name');<br>                  LFiled :=dbms_xmldom.GetNodeValue(LAttr);<br>  <br>                  DropField(LFiled,ASection);<br>              END LOOP;<br>          END;<br>          PROCEDURE ProcessInsert(ANodeList DBMS_XMLDom.DOMNodelist,ASection in VARCHAR2) IS<br>          BEGIN<br>              LNodesCount:=DBMS_XMLDom.GetLength(ANodeList);<br>              FOR LIndex IN 0..LNodesCount-1 LOOP<br>                  LNode := DBMS_XMLDom.Item(ANodeList, LIndex);<br>                  LAttrs := dbms_xmldom.Getattributes(LNode);<br>                  LAttr := dbms_xmldom.GetNamedItem(LAttrs,'name');<br>                  LFiled := dbms_xmldom.GetNodeValue(LAttr);<br>                  <br>                  LValidationRuleList:=dbms_xslprocessor.selectNodes(LNode,'DBField');<br>                  LNode := DBMS_XMLDom.Item(LValidationRuleList, 0);<br>                  <br>                  LAttrs := dbms_xmldom.Getattributes(LNode);<br>                  LAttr := dbms_xmldom.GetNamedItem(LAttrs,'type');<br>                  LAttributeName :=UPPER(dbms_xmldom.GetNodeValue(LAttr));<br>                  <br>                  InsertLog('ProcessSection'||' Line:'||$$plsql_line,'LFiled-&gt;'||LFiled||' LAttributeName-&gt;'||LAttributeName);<br>  <br>                  IF LAttributeName IN ('TEXT','NUMBER') THEN<br>                      LAttr := dbms_xmldom.GetNamedItem(LAttrs,'precision');<br>                      LLong := dbms_xmldom.GetNodeValue(LAttr);<br>                      <br>                      IF LAttributeName='TEXT' THEN<br>                          InsertLog('ProcessesSection'||' Line:'||$$plsql_line,'Text LFiled-&gt;'||LFiled||' LLong-&gt;'||LLong||' LAttributeName-&gt;'||LAttributeName);<br>                          LFiledType:='VARCHAR2('||LLong||')';<br>                      ELSIF LAttributeName='NUMBER' THEN<br>                          InsertLog('ProcessesSection'||' Line:'||$$plsql_line,'Number LFiled-&gt;'||LFiled||' LLong-&gt;'||LLong||' LAttributeName-&gt;'||LAttributeName);                    <br>                          IF NVL(LLong,0)&lt;&gt;0 THEN<br>                              LFiledType:='NUMBER('||Replace(LLong,'.',',')||')';<br>                          ELSE<br>                              LFiledType:='NUMBER';<br>                          END IF;    <br>                      END IF;<br>                  ELSIF LAttributeName='DATE' THEN<br>                      LFiledType:='DATE';<br>                  ELSE  <br>                      LFiledType:='VARCHAR2(1000)';<br>                  END IF;<br>  <br>                  AddField(LFiled,ASection,LFiledType);<br>                  <br>              END LOOP;<br>          END;<br>  <br>          PROCEDURE ProcessSection(ANodeList DBMS_XMLDom.DOMNodelist,ASection in VARCHAR2) IS<br>              LNodeList DBMS_XMLDom.DOMNodelist;<br>              LValidationRuleList DBMS_XMLDom.DOMNodelist;<br>          BEGIN<br>              InsertLog('ProcessSection'||' Line:'||$$plsql_line,'DBMS_XMLDom.GetLength(ANodeList)-&gt;'||DBMS_XMLDom.GetLength(ANodeList));<br>              LNodeList:=dbms_xslprocessor.selectNodes(DBMS_XMLDOM.ITEM(ANodeList,0),'Property[@delete=&quot;yes&quot;]');<br>              InsertLog('ProcessSection'||' Line:'||$$plsql_line,'Property[@delete=&quot;yes&quot;] LNodeList-&gt;'||DBMS_XMLDom.GetLength(LNodeList));<br>              ProcessDelete(LNodeList,ASection);<br>              LNodeList:=dbms_xslprocessor.selectNodes(DBMS_XMLDOM.ITEM(ANodeList,0),'Property[@insert=&quot;yes&quot;]');<br>              InsertLog('ProcessSection'||' Line:'||$$plsql_line,'Property[@insert=&quot;yes&quot;] LNodeList-&gt;'||DBMS_XMLDom.GetLength(LNodeList));<br>              ProcessInsert(LNodeList,ASection);<br>          END;<br>  <br>          PROCEDURE ProcessAndSaveInDB(ACoeObjectConfigXML IN CLOB) IS<br>              LCoeObjectConfigXMLType   XMLType;<br>          BEGIN<br>              LCoeObjectConfigXMLType := XMLType.CreateXML(Replace(ACoeObjectConfigXML, 'insert=&quot;yes&quot;', ''));<br>              <br>              SELECT DeleteXML(LCoeObjectConfigXMLType,'/MultiCompoundRegistryRecord//PropertyList/Property/DBField')<br>                INTO LCoeObjectConfigXMLType<br>                FROM DUAL;<br>  <br>              SELECT DeleteXML(LCoeObjectConfigXMLType,'/MultiCompoundRegistryRecord//PropertyList/Property[@delete=&quot;yes&quot;]')<br>                INTO LCoeObjectConfigXMLType<br>                FROM DUAL;<br>  <br>              UPDATE COEOBJECTCONFIG<br>                 SET XML = LCoeObjectConfigXMLType.GetClobVal()<br>               WHERE ID = 2;<br>               <br>              COMMIT;<br>          END;<br>  <br>      BEGIN<br>          SetSessionParameter;<br>          <br>          LDOMDocument := DBMS_XMLDom.NewDOMDocument(ACoeObjectConfigXML);<br>          LDocumentNode := DBMS_XMLDom.MakeNode(LDOMDocument);<br>  <br>          LNodeList:=dbms_xslprocessor.selectNodes(LDocumentNode,'/MultiCompoundRegistryRecord/ComponentList/Component/Compound/PropertyList');<br>          InsertLog('ProcessFieldsfromDB'||' Line:'||$$plsql_line,'ProcessSection COMPOUND');<br>          ProcessSection(LNodeList,'COMPOUND');<br>  <br>          LNodeList:=dbms_xslprocessor.selectNodes(LDocumentNode,'/MultiCompoundRegistryRecord/BatchList/Batch/PropertyList');<br>          InsertLog('ProcessFieldsfromDB'||' Line:'||$$plsql_line,'ProcessSection BATCH');<br>          ProcessSection(LNodeList,'BATCH');<br>  <br>          LNodeList:=dbms_xslprocessor.selectNodes(LDocumentNode,'/MultiCompoundRegistryRecord/BatchList/Batch/BatchComponentList/BatchComponent/PropertyList');<br>          InsertLog('ProcessFieldsfromDB'||' Line:'||$$plsql_line,'ProcessSection BATCH COMPONENT');<br>          ProcessSection(LNodeList,'BATCHCOMPONENT');<br>  <br>          ProcessAndSaveInDB(ACoeObjectConfigXML);  <br>      EXCEPTION<br>          WHEN OTHERS THEN<br>          BEGIN<br>              InsertLog('ProcessFieldsfromDB'||' Line:'||$$plsql_line,DBMS_UTILITY.FORMAT_ERROR_STACK);<br>              RAISE_APPLICATION_ERROR(eGenericException, 'ProcessFieldsfromDB'||chr(10)||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>          END;<br>      END;<br>  <br>      PROCEDURE ProcessFieldsfromDB IS<br>          LCoeObjectConfigField     XmlType;<br>      BEGIN<br>          SELECT XmlType.CreateXml(XML)<br>            INTO LCoeObjectConfigField<br>            FROM COEOBJECTCONFIG<br>           WHERE ID=2;<br>          InsertLog('ProcessFieldsfromDB'||' Line:'||$$plsql_line,LCoeObjectConfigField.GetClobval());<br>          ProcessFieldsfromXml(LCoeObjectConfigField.GetClobval());<br>      EXCEPTION<br>          WHEN OTHERS THEN<br>          BEGIN<br>              InsertLog('ProcessFieldsfromDB'||' Line:'||$$plsql_line,DBMS_UTILITY.FORMAT_ERROR_STACK);<br>              RAISE_APPLICATION_ERROR(eGenericException, 'ProcessFieldsfromDB'||chr(10)||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>          END;<br>      END;<br>  <br>  END ConfigurationCompoundRegistry;  <br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_21"></a>
<div class="caption2">COEDB.CONFIGURATIONMANAGER</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE PACKAGE BODY &quot;COEDB&quot;.&quot;CONFIGURATIONMANAGER&quot; <br>  IS<br>      PROCEDURE InsertLog(ALogProcedure CLOB,ALogComment CLOB) IS<br>      PRAGMA AUTONOMOUS_TRANSACTION;<br>      BEGIN<br>          INSERT INTO LOG(LogProcedure,LogComment) VALUES($$plsql_unit||'.'||ALogProcedure,ALogComment);<br>          COMMIT;<br>      EXCEPTION<br>          WHEN OTHERS THEN NULL; --If logs don't work then don't stop<br>      END;<br>  <br>      PROCEDURE RetrieveConfiguration(ADescription IN VARCHAR2, AClassName OUT VARCHAR2, AConfiguration OUT CLOB) IS<br>      BEGIN<br>          SELECT CC.ClassName, CC.ConfigurationXML.getClobVal()<br>              INTO AClassName,AConfiguration<br>              FROM CoeConfiguration  CC<br>              WHERE UPPER(CC.Description)=UPPER(ADescription);<br>  <br>      EXCEPTION<br>          WHEN OTHERS THEN<br>          BEGIN<br>              $if ConfigurationManager.Debuging $then InsertLog('RetrieveConfiguration','Error eetrieving a configuration. '||chr(10)||DBMS_UTILITY.FORMAT_ERROR_STACK); $end null;<br>              RAISE_APPLICATION_ERROR(eRetrieveConfiguration, 'Error retrieving a configuration.'||chr(10)||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>          END;<br>      END;<br>  <br>      FUNCTION RetrieveParameter(ADescription IN VARCHAR2, AParameter IN VARCHAR2) RETURN CLOB IS<br>          LValue CLOB;<br>      BEGIN<br>          SELECT ExtractValue(CC.ConfigurationXML,'node()/node()/'||AParameter||'[1]')<br>              INTO LValue<br>              FROM CoeConfiguration CC<br>              WHERE UPPER(CC.Description)=UPPER(ADescription);<br>  <br>          IF LValue IS NULL THEN<br>              RAISE_APPLICATION_ERROR(eParameterNonexistent, 'Parameter non-existent.');<br>          END IF;<br>  <br>          RETURN LValue;<br>  <br>      EXCEPTION<br>          WHEN OTHERS THEN<br>          BEGIN<br>              $if ConfigurationManager.Debuging $then InsertLog('RetrieveParameter','Error retrieving a configuration parameter.'||chr(10)||DBMS_UTILITY.FORMAT_ERROR_STACK); $end null;<br>              RAISE_APPLICATION_ERROR(eRetrieveParameter, 'Error retrieving a configuration parameter.'||chr(10)||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>          END;<br>      END;<br>  <br>      PROCEDURE UpdateParameter(ADescription IN VARCHAR2, AParameter IN VARCHAR2, AValue VARCHAR2) IS<br>      BEGIN<br>          UPDATE COECONFIGURATION<br>              SET CONFIGURATIONXML=UpdateXML(CONFIGURATIONXML,'/Registration/ParameterList/'||AParameter||'/text()',AValue)<br>              WHERE DESCRIPTION='Registration';<br>      EXCEPTION<br>          WHEN OTHERS THEN<br>          BEGIN<br>              $if ConfigurationManager.Debuging $then InsertLog('UpdateParameter','Error updating a configuration parameter.'||chr(10)||DBMS_UTILITY.FORMAT_ERROR_STACK); $end null;<br>              RAISE_APPLICATION_ERROR(eUpdateParameter, 'Error updating a configuration parameter.'||chr(10)||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>          END;<br>      END;<br>  <br>      PROCEDURE InsertConfiguration(ADescription IN VARCHAR2, AClassName IN VARCHAR2, AConfiguration IN CLOB) IS<br>      BEGIN<br>          INSERT INTO CoeConfiguration(Description,ClassName,ConfigurationXML) VALUES(ADescription,AClassName,XmlType(AConfiguration));<br>      EXCEPTION<br>          WHEN OTHERS THEN<br>          BEGIN<br>              $if ConfigurationManager.Debuging $then InsertLog('InsertConfiguration','Error inserting a configuration.'||chr(10)||DBMS_UTILITY.FORMAT_ERROR_STACK); $end null;<br>              RAISE_APPLICATION_ERROR(eRetrieveParameter, 'Error inserting a configuration.'||chr(10)||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>          END;<br>      END;<br>  <br>      PROCEDURE UpdateConfiguration(ADescription IN VARCHAR2, AClassName IN VARCHAR2, AConfiguration IN CLOB) IS<br>      BEGIN<br>          IF AClassName IS NOT NULL THEN<br>              UPDATE CoeConfiguration SET ClassName=AClassName WHERE UPPER(Description)=UPPER(ADescription);<br>          END IF;<br>          IF AConfiguration IS NOT NULL THEN<br>              UPDATE CoeConfiguration SET ConfigurationXML=XmlType(AConfiguration) WHERE UPPER(Description)=UPPER(ADescription);<br>          END IF;<br>      EXCEPTION<br>          WHEN OTHERS THEN<br>          BEGIN<br>              $if ConfigurationManager.Debuging $then InsertLog('UpdateConfiguration','Error updating a configuration.'||chr(10)||DBMS_UTILITY.FORMAT_ERROR_STACK); $end null;<br>              RAISE_APPLICATION_ERROR(eUpdateConfiguration, 'Error updating a configuration.'||chr(10)||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>          END;<br>      END;<br>  <br>      PROCEDURE DeleteConfiguration(ADescription IN VARCHAR2) IS<br>      BEGIN<br>          DELETE CoeConfiguration WHERE UPPER(Description)=UPPER(ADescription);<br>      EXCEPTION<br>          WHEN OTHERS THEN<br>          BEGIN<br>              $if ConfigurationManager.Debuging $then InsertLog('DeleteConfiguration','Error brief description.'||chr(10)||DBMS_UTILITY.FORMAT_ERROR_STACK); $end null;<br>              RAISE_APPLICATION_ERROR(eDeleteConfiguration, 'Error deleting a configuration.'||chr(10)||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>          END;<br>      END;<br>  <br>  END; <br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_22"></a>
<div class="caption2">COEDB.LOGIN</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE PACKAGE BODY &quot;COEDB&quot;.&quot;LOGIN&quot;  IS<br>     PROCEDURE getPrivsByRoleId (<br>        pRoleIdList      IN       VARCHAR2,<br>        pPrivTableName   IN       privilege_tables.privilege_table_name%TYPE,<br>        o_rs             OUT      cursor_type)<br>     AS<br>        my_sql   VARCHAR2 (2000);<br>     BEGIN<br>        my_sql := 'SELECT * FROM ' || pPrivTableName || ' WHERE ROLE_INTERNAL_ID IN ( ' || pRoleIdList || ')';<br>  <br>        OPEN o_rs FOR my_sql;<br>     END getPrivsByRoleId;<br>  <br>     PROCEDURE getPrivs (<br>        pPrivTableName   IN       privilege_tables.privilege_table_name%TYPE,<br>        o_rs             OUT      cursor_type)<br>     AS<br>        my_sql   VARCHAR2 (2000);<br>     BEGIN<br>        my_sql := 'SELECT * FROM ' || pPrivTableName || ' WHERE ROLE_INTERNAL_ID IS NULL';<br>        OPEN o_rs FOR my_sql;<br>     END getPrivs;<br>  <br>     PROCEDURE getUserRoleIds (<br>        pUserName        IN       people.user_id%TYPE,<br>        pPrivTableName   IN       privilege_tables.privilege_table_name%TYPE,<br>        o_rs             OUT      cursor_type)<br>     AS<br>     BEGIN<br>        OPEN o_rs FOR<br>           SELECT DISTINCT s.role_id<br>                      FROM security_roles s,<br>                           privilege_tables p,<br>                           dba_role_privs rp<br>                     WHERE s.privilege_table_int_id = p.privilege_table_id<br>                       AND s.role_name = rp.granted_role<br>                       AND UPPER (p.privilege_table_name) = pPrivTableName<br>                       AND rp.granted_role IN (<br>                              SELECT granted_role<br>                                FROM dba_role_privs<br>                               WHERE grantee = pUserName<br>                              UNION<br>                              SELECT granted_role<br>                                FROM dba_role_privs<br>                               WHERE grantee IN (SELECT granted_role<br>                                                   FROM dba_role_privs<br>                                                  WHERE grantee = pUserName));<br>     END getUserRoleIds;<br>  <br>     FUNCTION getpersonid (pusername IN people.user_id%TYPE)  RETURN people.person_id%TYPE AS<br>        personId   people.person_id%TYPE;<br>     BEGIN<br>        SELECT person_id<br>          INTO personId<br>          FROM people<br>         WHERE UPPER (user_id) = UPPER (pUserName) AND active &lt;&gt; -1;<br>  <br>        RETURN personId;<br>     EXCEPTION<br>        WHEN NO_DATA_FOUND THEN<br>           RETURN 0;<br>     END getPersonId;<br>  END Login; <br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_23"></a>
<div class="caption2">COEDB.MANAGE_ROLES</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE PACKAGE BODY &quot;COEDB&quot;.&quot;MANAGE_ROLES&quot;  AS<br>     FUNCTION excludeFGRolesSql RETURN VARCHAR2 AS<br>        n   NUMBER;<br>     BEGIN<br>        SELECT COUNT (*)<br>          INTO n<br>          FROM dba_tables<br>         WHERE table_name = UPPER ('BIOSAR_BROWSER_PRIVILEGES');<br>  <br>        IF n = 1 THEN<br>           RETURN 'role_id NOT IN (select role_internal_id from biosar_browser_privileges where is_formgroup_role = 1)';<br>        ELSE<br>           RETURN '1=1';<br>        END IF;<br>     END excludeFGRolesSql;<br>  <br>     PROCEDURE getAllRoles (o_rs OUT cursor_type) AS<br>     BEGIN<br>        OPEN o_rs FOR<br>           SELECT role AS role_name FROM dba_roles<br>           MINUS<br>           SELECT role_name FROM security_roles<br>           ORDER BY 1 ASC;<br>     END getAllRoles;<br>  <br>     PROCEDURE getRoles (<br>        pPrivTableName   IN       privilege_tables.privilege_table_name%TYPE,<br>        o_rs             OUT      cursor_type)<br>     AS<br>        mySql   VARCHAR (2000);<br>     BEGIN<br>        IF pPrivTableName IS NOT NULL THEN<br>           mySql := 'SELECT Distinct ROLE_NAME<br>  					 FROM security_roles s, privilege_tables p<br>  					WHERE p.privilege_table_id = s.privilege_table_int_id<br>  					  AND Upper(p.privilege_table_name) = Upper(''' || pPrivTableName || ''')<br>  					  AND ' || excludeFGRolesSql<br>                 || ' ORDER BY ROLE_NAME ASC';<br>        ELSE<br>           mySql := 'SELECT Distinct ROLE_NAME FROM security_roles<br>  		            WHERE ' || excludeFGRolesSql<br>                 || ' ORDER BY ROLE_NAME';<br>        END IF;<br>  <br>        OPEN o_rs FOR mySql;<br>     END getRoles;<br>  <br>     PROCEDURE getAvailableRoles (<br>        pUserName        IN       people.user_id%TYPE,<br>        pPrivTableName   IN       privilege_tables.privilege_table_name%TYPE := NULL,<br>        o_rs             OUT      cursor_type)<br>     AS<br>        mySql   VARCHAR (2000);<br>     BEGIN<br>        mySql := 'SELECT DISTINCT ROLE_NAME<br>  				  FROM   security_roles s<br>  				  WHERE ' || excludeFGRolesSql || '<br>  				 MINUS<br>  				  SELECT ROLE_NAME<br>  				  FROM   security_roles s<br>  				  WHERE  s.role_name IN (SELECT granted_role<br>  										 FROM   dba_role_privs<br>  										 WHERE	Upper(grantee) = Upper(''' || pusername || ''')<br>  										   AND  Upper(dba_role_privs.granted_role) IN ( SELECT DISTINCT ROLE_NAME<br>  																						FROM   security_roles s, privilege_tables p<br>  																						WHERE  s.privilege_table_int_id = p.privilege_table_id<br>  																						  AND  p.privilege_table_name LIKE NVL(''' || pprivtablename || ''', ''%'')))<br>  				  ORDER BY 1 ASC';<br>  <br>        OPEN o_rs FOR mySql;<br>     END getAvailableRoles;<br>  <br>     PROCEDURE getUserRoles (<br>        pUserName        IN       people.user_id%TYPE,<br>        pPrivTableName   IN       privilege_tables.privilege_table_name%TYPE := NULL,<br>        o_rs             OUT      cursor_type)<br>     AS<br>     BEGIN<br>        OPEN o_rs FOR<br>           SELECT   granted_role AS role_name<br>               FROM dba_role_privs<br>              WHERE UPPER (grantee) = UPPER (pUserName)<br>                AND UPPER (dba_role_privs.granted_role) IN (<br>                       SELECT DISTINCT role_name<br>                                  FROM security_roles s, privilege_tables p<br>                                 WHERE s.privilege_table_int_id = p.privilege_table_id<br>                                   AND p.privilege_table_name LIKE NVL (pprivtablename, '%'))<br>           ORDER BY role_name ASC;<br>     END getUserRoles;<br>  <br>     PROCEDURE getRoleRoles (<br>        pRoleName   IN       security_roles.role_name%TYPE,<br>        o_rs        OUT      cursor_type)<br>     AS<br>     BEGIN<br>        OPEN o_rs FOR<br>           SELECT   granted_role AS role_name<br>               FROM dba_role_privs<br>              WHERE UPPER (grantee) = UPPER (pRoleName)<br>           ORDER BY role_name ASC;<br>     END getRoleRoles;<br>  <br>     PROCEDURE getRoleAvailableRoles (<br>        pPrivTableName   IN       privilege_tables.privilege_table_name%TYPE,<br>        pRoleName        IN       security_roles.role_name%TYPE,<br>        o_rs             OUT      cursor_type<br>     )<br>     AS<br>        mySql   VARCHAR (2000);<br>     BEGIN<br>        mySql := 'Select Distinct ROLE_NAME<br>  					FROM security_roles s, privilege_tables p<br>  					WHERE  s.privilege_table_int_id = p.privilege_table_id<br>  					AND Upper(p.privilege_table_name) LIKE NVL(Upper(''' || pPrivTableName || '''), ''%'')<br>  					AND role_name &lt;&gt; ''' || pRoleName || '''<br>  					AND role_name NOT IN (Select granted_role AS ROLE_NAME from dba_role_privs<br>  										  WHERE Upper(grantee) = Upper(''' || pRoleName || ''')<br>  										  )<br>  					AND ' || excludeFGRolesSql<br>              || ' ORDER BY ROLE_NAME ASC';<br>  <br>        OPEN o_rs FOR mySql;<br>     END getRoleAvailableRoles;<br>  <br>     PROCEDURE getRolePrivs (<br>        pRoleName   IN       security_roles.role_name%TYPE,<br>        o_rs        OUT      cursor_type)<br>     AS<br>        roleId          INTEGER;<br>        privTableName   VARCHAR2 (30);<br>        my_sql          VARCHAR2 (2000);<br>     BEGIN<br>        SELECT s.role_id, p.privilege_table_name<br>          INTO roleId, privTableName<br>          FROM security_roles s, privilege_tables p<br>         WHERE s.privilege_table_int_id = p.privilege_table_id<br>           AND UPPER (s.role_name) = UPPER (prolename);<br>  <br>        my_sql := 'SELECT * FROM ' || privTableName || ' WHERE ROLE_INTERNAL_ID = ' || TO_CHAR (roleId);<br>  <br>        OPEN o_rs FOR my_sql;<br>     END getRolePrivs;<br>  <br>     FUNCTION updateRolesGrantedToRole (<br>        pRoleName       IN   security_roles.role_name%TYPE,<br>        pRolesGranted   IN   VARCHAR2 := NULL,<br>        pRolesRevoked   IN   VARCHAR2 := NULL)<br>        RETURN VARCHAR2<br>     AS<br>        source_cursor    INTEGER;<br>        rows_processed   INTEGER;<br>     BEGIN<br>        source_cursor := DBMS_SQL.open_cursor;<br>  <br>        IF (prolesrevoked IS NOT NULL) THEN<br>           DBMS_SQL.parse (source_cursor, 'REVOKE ' || prolesrevoked || ' FROM ' || prolename, DBMS_SQL.native);<br>           rows_processed := DBMS_SQL.EXECUTE (source_cursor);<br>        END IF;<br>  <br>        IF (prolesgranted IS NOT NULL) THEN<br>           DBMS_SQL.parse (source_cursor, 'GRANT ' || prolesgranted || ' TO ' || prolename, DBMS_SQL.native);<br>           rows_processed := DBMS_SQL.EXECUTE (source_cursor);<br>        END IF;<br>  <br>        RETURN '1';<br>     END updateRolesGrantedToRole;<br>  <br>     FUNCTION updateUsersGrantedARole (<br>        pRoleName       IN   security_roles.role_name%TYPE,<br>        pUsersGranted   IN   VARCHAR2 := NULL,<br>        pUsersRevoked   IN   VARCHAR2 := NULL)<br>        RETURN VARCHAR2<br>     AS<br>        source_cursor    INTEGER;<br>        rows_processed   INTEGER;<br>     BEGIN<br>        source_cursor := DBMS_SQL.open_cursor;<br>  <br>        IF (pUsersRevoked IS NOT NULL) THEN<br>           DBMS_SQL.parse (source_cursor, 'REVOKE ' || pRoleName || ' FROM ' || pUsersRevoked, DBMS_SQL.native);<br>           rows_processed := DBMS_SQL.EXECUTE (source_cursor);<br>        END IF;<br>  <br>        IF (pUsersGranted IS NOT NULL) THEN<br>           DBMS_SQL.parse (source_cursor, 'GRANT ' || pRoleName || ' TO ' || pUsersGranted, DBMS_SQL.native);<br>           rows_processed := DBMS_SQL.EXECUTE (source_cursor);<br>        END IF;<br>  <br>        RETURN '1';<br>     END updateUsersGrantedARole;<br>  END Manage_Roles; <br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_24"></a>
<div class="caption2">COEDB.MANAGE_USERS</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE PACKAGE BODY &quot;COEDB&quot;.&quot;MANAGE_USERS&quot; <br>  AS<br>     PROCEDURE getUsers (<br>        pPrivTableName   IN       privilege_tables.privilege_table_name%TYPE,<br>        o_rs             OUT      cursor_type<br>     )<br>     AS<br>     BEGIN<br>        OPEN o_rs FOR<br>           SELECT DISTINCT grantee AS username, first_name AS firstname, last_name AS lastname<br>                      FROM dba_role_privs, people<br>                     WHERE UPPER (dba_role_privs.grantee) = UPPER (people.user_id)<br>                       AND UPPER (dba_role_privs.granted_role) IN (<br>                              SELECT UPPER (role_name)<br>                                FROM security_roles s, privilege_tables p<br>                               WHERE s.privilege_table_int_id = p.privilege_table_id<br>                                 AND p.privilege_table_name LIKE NVL (pprivtablename, '%'));<br>     END getUsers;<br>  <br>     PROCEDURE getAllUsers (o_rs OUT cursor_type)<br>     AS<br>     BEGIN<br>        OPEN o_rs FOR<br>           SELECT   UPPER (username) AS userName<br>               FROM dba_users<br>              WHERE username NOT IN ('SYSTEM', 'SYS', 'SYSMAN')<br>           MINUS<br>           SELECT   UPPER (user_id) AS userName<br>               FROM people<br>           ORDER BY 1 ASC;<br>     END getAllUsers;<br>  <br>     PROCEDURE getUser (pUserName IN people.user_id%TYPE, o_rs OUT cursor_type)<br>     AS<br>        my_sql   VARCHAR2 (2000);<br>        pw       VARCHAR2 (30);<br>     BEGIN<br>        SELECT PASSWORD<br>          INTO pw<br>          FROM dba_users<br>         WHERE UPPER (userName) = UPPER (pUserName);<br>  <br>        my_sql := 'SELECT ' || 'Person_ID AS PersonID, '<br>                            || 'User_ID AS UserName, '<br>                            || '''' || pw || ''' AS Password, '<br>                            || 'First_Name AS FirstName, '<br>                            || 'Middle_Name AS MiddleName, '<br>                            || 'Last_Name AS LastName, '<br>                            || 'Email AS Email, '<br>                            || 'Telephone AS Telephone, '<br>                            || 'Int_Address AS Address, '<br>                            || 'User_Code AS UserCode, '<br>                            || 'Supervisor_internal_id AS SuperVisorID, '<br>                            || 'Site_id AS SiteID, '<br>                            || 'Active AS isActive '<br>               || 'FROM People '<br>               || 'WHERE upper(User_ID) = ''' || UPPER (pUserName) || '''';<br>  <br>        OPEN o_rs FOR my_sql;<br>     END getUser;<br>  <br>     PROCEDURE getRoleGrantees (<br>        pRoleName   IN       security_roles.role_name%TYPE,<br>        o_rs        OUT      cursor_type<br>     )<br>     AS<br>     BEGIN<br>        OPEN o_rs FOR<br>           SELECT DISTINCT grantee<br>                      FROM dba_role_privs<br>                     WHERE UPPER (granted_role) = UPPER (pRoleName);<br>     END getrolegrantees;<br>  <br>     PROCEDURE getRoleAvailableUsers (<br>        pPrivTableName   IN       privilege_tables.privilege_table_name%TYPE,<br>        pRoleName        IN       security_roles.role_name%TYPE,<br>        o_rs             OUT      cursor_type<br>     )<br>     AS<br>     BEGIN<br>        OPEN o_rs FOR<br>           SELECT DISTINCT grantee AS userName<br>                      FROM dba_role_privs, people<br>                     WHERE UPPER (dba_role_privs.grantee) = UPPER (people.user_id)<br>                       AND UPPER (dba_role_privs.granted_role) IN (<br>                              SELECT UPPER (role_name)<br>                                FROM security_roles s, privilege_tables p<br>                               WHERE s.privilege_table_int_id = p.privilege_table_id<br>                                 AND p.privilege_table_name LIKE NVL (pprivtablename, '%'))<br>                       AND grantee NOT IN (<br>                                   SELECT DISTINCT grantee<br>                                              FROM dba_role_privs<br>                                             WHERE UPPER (granted_role) = UPPER (prolename));<br>     END getRoleAvailableUsers;<br>  END Manage_Users; <br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_25"></a>
<div class="caption2">COEDB.PARTITIONMANAGMENT</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE PACKAGE BODY &quot;COEDB&quot;.&quot;PARTITIONMANAGMENT&quot;  IS<br>  <br>  PROCEDURE InsertLog(ALogProcedure CLOB,ALogComment CLOB) IS<br>      PRAGMA AUTONOMOUS_TRANSACTION;<br>  BEGIN<br>      INSERT INTO LOG(LogProcedure,LogComment) VALUES($$plsql_unit||'.'||ALogProcedure,ALogComment);<br>      COMMIT;<br>  EXCEPTION<br>      WHEN OTHERS THEN NULL; --If logs don't work then don't stop<br>  END;<br>  <br>  PROCEDURE ValidatePartitionSupport IS<br>      LExist Integer;<br>  BEGIN<br>  <br>      SELECT Count(1) INTO LExist<br>          FROM PRODUCT_COMPONENT_VERSION<br>          WHERE Product like('%Enterprise%');<br>      IF LExist=0 THEN<br>          Raise_Application_Error(eOraclePartitionsnotsupported, 'Error: Oracle Database Partitions isn''t supported '||'-'||DBMS_UTILITY.Format_Error_Stack);<br>      END IF;<br>  EXCEPTION<br>      WHEN OTHERS THEN<br>      BEGIN<br>        $if PartitionManagment.Debuging $then InsertLog('ValidatePartitionSupport',DBMS_UTILITY.FORMAT_ERROR_STACK); $end null;<br>        RAISE_APPLICATION_ERROR(eValidatePartitionSupport, DBMS_UTILITY.FORMAT_ERROR_STACK);<br>      END;<br>  END;<br>  <br>  PROCEDURE CreatePartitions(ATableName IN VARCHAR2,ACurrentDate IN DATE, ASchemaName VARCHAR2) IS<br>  <br>    LNextPartitionDate       DATE;<br>    LNextMonthPartitionName VARCHAR2(30);<br>    LNextPartitionDateStr   VARCHAR2(30);<br>  <br>    LSQLDDL VARCHAR2(1000);<br>    LExist  INTEGER;<br>    LCount  INTEGER;<br>    LIndex  INTEGER;<br>  <br>    LDaysBetweenCreation    NUMBER:=0;<br>    LWeeksBetweenCreation   NUMBER:=0;<br>    LMonthsBetweenCreation  NUMBER:=0;<br>    LPeriodCount    NUMBER;<br>    LPartitionStr   VARCHAR2(100);<br>    LPartitionDate  DATE;<br>  <br>    LHighValueMax  DBA_Tab_Partitions.high_value%TYPE;<br>    CURSOR C_User_Tab_Partitions(LTableName VARCHAR2)  IS<br>        SELECT High_Value, Partition_Name FROM DBA_TAB_PARTITIONS WHERE Table_Name=ATableName AND Table_Owner=ASchemaName;<br>  <br>  BEGIN<br>  <br>       ValidatePartitionSupport;<br>  <br>      --Get Partition Managment Parameter<br>      BEGIN<br>          SELECT DaysBetweenCreation,WeeksBetweenCreation,MonthsBetweenCreation,PeriodCount<br>              INTO LDaysBetweenCreation,LWeeksBetweenCreation,LMonthsBetweenCreation,LPeriodCount<br>              FROM COEPARTITIONMANAGMENT<br>              WHERE TableName=ATableName AND Owner=ASchemaName;<br>      EXCEPTION<br>      WHEN OTHERS THEN<br>          Raise_Application_Error (ePartitionParamManagmentError, 'Error in the Partition Parameter Managment '||'-'||DBMS_UTILITY.Format_Error_Stack);<br>      END;<br>  <br>      --Create partitions<br>      FOR LIndex IN 0..LPeriodCount-1 LOOP<br>          LNextPartitionDate:=ACurrentDate;<br>          IF LDaysBetweenCreation&gt;0 THEN<br>              LNextPartitionDate:=LNextPartitionDate + (LIndex*LDaysBetweenCreation);<br>          END IF;<br>  <br>          IF LWeeksBetweenCreation&gt;0 THEN<br>              LNextPartitionDate:=LNextPartitionDate + (LIndex*LWeeksBetweenCreation*7);<br>          END IF;<br>  <br>          IF LMonthsBetweenCreation&gt;0 THEN<br>              LNextPartitionDate:=ADD_MONTHS(LNextPartitionDate,LMonthsBetweenCreation*LIndex);<br>          END IF;<br>  <br>          LNextMonthPartitionName:=ATableName||TO_CHAR(LNextPartitionDate,'YYYYMMDD');<br>          LNextPartitionDateStr:=TO_CHAR(TRUNC(LNextPartitionDate+1),'DDMMYYYY');<br>  <br>  <br>          SELECT COUNT(1) INTO LExist FROM DBA_TAB_PARTITIONS WHERE Partition_Name=LNextMonthPartitionName AND Table_Owner=ASchemaName;<br>          IF LExist=0 THEN<br>  <br>              SELECT COUNT(1) INTO LExist FROM DBA_TAB_PARTITIONS WHERE Partition_Name=ATableName||'MAXVALUE' AND Table_Owner=ASchemaName;<br>  <br>              IF LExist=0 THEN<br>                  SELECT HIGH_VALUE<br>                      INTO  LHighValueMax<br>                      FROM DBA_TAB_PARTITIONS<br>                      WHERE UPPER(Table_Name)=UPPER(ATableName) AND Table_Owner=ASchemaName AND Partition_Position=<br>                          (SELECT MAX(partition_position)<br>                              FROM DBA_TAB_PARTITIONS<br>                              WHERE UPPER(Table_Name)=UPPER(ATableName) AND Table_Owner=ASchemaName);<br>  <br>                  EXECUTE IMMEDIATE 'SELECT '||LHighValueMax||' FROM DUAL ' INTO LPartitionStr;<br>                  LPartitionDate:=TO_DATE(LPartitionStr);<br>  <br>                  IF LPartitionDate&lt;LNextPartitionDate THEN<br>                      LSQLDDL:= 'ALTER TABLE '||ASchemaName||'.'||ATableName||' ADD PARTITION '||LNextMonthPartitionName||' VALUES LESS THAN (TO_DATE('''||LNextPartitionDateStr||''',''DDMMYYYY''))';<br>                      EXECUTE IMMEDIATE LSQLDDL;<br>                  END IF;<br>              ELSE<br>                  SELECT COUNT(1) INTO LCount FROM DBA_TAB_PARTITIONS WHERE UPPER(Table_Name)=UPPER(ATableName) AND Table_Owner=ASchemaName;<br>                  IF LCount&gt;1 THEN<br>                      SELECT HIGH_VALUE<br>                          INTO  LHighValueMax<br>                          FROM DBA_TAB_PARTITIONS<br>                          WHERE UPPER(Table_Name)=UPPER(ATableName) AND Table_Owner=ASchemaName AND Partition_Position=<br>                              (SELECT MAX(partition_position)-1<br>                                  FROM DBA_TAB_PARTITIONS<br>                                  WHERE UPPER(Table_Name)=UPPER(ATableName) AND Table_Owner=ASchemaName);<br>  <br>                      EXECUTE IMMEDIATE 'SELECT '||LHighValueMax||' FROM DUAL ' INTO LPartitionStr;<br>                      LPartitionDate:=TO_DATE(LPartitionStr);<br>  <br>                      IF LPartitionDate&lt;LNextPartitionDate THEN<br>                          LSQLDDL:= 'ALTER TABLE '||ASchemaName||'.'||ATableName||' SPLIT PARTITION '||ATableName||'MAXVALUE AT (TO_DATE('''||LNextPartitionDateStr||''',''DDMMYYYY'')) INTO (PARTITION '||LNextMonthPartitionName||',PARTITION  '||ATableName||'MAXVALUE'||') ';<br>                         EXECUTE IMMEDIATE LSQLDDL;<br>                      END IF;<br>                  ELSE<br>                      LSQLDDL:= 'ALTER TABLE '||ASchemaName||'.'||ATableName||' SPLIT PARTITION '||ATableName||'MAXVALUE AT (TO_DATE('''||LNextPartitionDateStr||''',''DDMMYYYY'')) INTO (PARTITION '||LNextMonthPartitionName||',PARTITION  '||ATableName||'MAXVALUE'||') ';<br>                     EXECUTE IMMEDIATE LSQLDDL;<br>                  END IF;<br>              END IF;<br>          END IF;<br>  <br>      END LOOP;<br>  EXCEPTION<br>      WHEN OTHERS THEN<br>      BEGIN<br>        $if PartitionManagment.Debuging $then InsertLog('CreatePartitions',DBMS_UTILITY.FORMAT_ERROR_STACK); $end null;<br>        RAISE_APPLICATION_ERROR(eCreatePartitions, DBMS_UTILITY.FORMAT_ERROR_STACK);<br>      END;<br>  END;<br>  <br>  PROCEDURE DeletePartitions(ATableName IN VARCHAR2,ACurrentDate IN DATE,ASchemaName VARCHAR2) IS<br>  <br>    LSQLDDL VARCHAR2(1000);<br>    LCount  INTEGER;<br>  <br>    LLiveDays    NUMBER;<br>    LLiveWeeks   NUMBER;<br>    LLiveMonths  NUMBER;<br>  <br>    LPartitionStr   VARCHAR2(100);<br>    LPartitionDate  DATE;<br>    LDeleteDate  DATE;<br>  <br>    CURSOR C_User_Tab_Partitions(LTableName VARCHAR2)  IS<br>        SELECT High_Value, Partition_Name<br>          FROM DBA_TAB_PARTITIONS<br>          WHERE Table_Name=ATableName AND Table_Owner=ASchemaName;<br>  <br>  BEGIN<br>  <br>      ValidatePartitionSupport;<br>  <br>      --Get Partition Managment Parameter<br>      BEGIN<br>          SELECT LiveDays,LiveWeeks,LiveMonths<br>              INTO LLiveDays,LLiveWeeks,LLiveMonths<br>              FROM COEPARTITIONMANAGMENT<br>              WHERE TableName=ATableName AND Owner=ASchemaName;<br>      EXCEPTION<br>      WHEN OTHERS THEN<br>          Raise_Application_Error (ePartitionParamManagmentError, 'Error getting Partition Managment Parameter'||'-'||DBMS_UTILITY.Format_Error_Stack);<br>      END;<br>  <br>      LDeleteDate:=ACurrentDate-(LLiveDays+(LLiveWeekS*7)+(ADD_MONTHS(ACurrentDate,LLiveMonths)-ACurrentDate));<br>  <br>      --Delete partitions<br>      FOR  R_User_Tab_Partitions IN C_User_Tab_Partitions(ATableName) LOOP<br>          IF R_User_Tab_Partitions.HIGH_VALUE&lt;&gt;'MAXVALUE' THEN<br>              EXECUTE IMMEDIATE 'SELECT '||R_User_Tab_Partitions.HIGH_VALUE||' FROM DUAL ' INTO LPartitionStr;<br>              LPartitionDate:=TO_DATE(LPartitionStr);<br>  <br>              IF LPartitionDate &lt; LDeleteDate THEN<br>                  SELECT COUNT(1) INTO LCount FROM DBA_TAB_PARTITIONS WHERE UPPER(Table_Name)=UPPER(ATableName) AND Table_Owner=ASchemaName;<br>                  IF LCount&gt;1 THEN<br>                      LSQLDDL:='ALTER TABLE '||ASchemaName||'.'||ATableName||' DROP PARTITION '||R_User_Tab_Partitions.Partition_Name;<br>                      EXECUTE IMMEDIATE LSQLDDL;<br>                  END IF;<br>              END IF;<br>          END IF;<br>      END LOOP;<br>  <br>  EXCEPTION<br>      WHEN OTHERS THEN<br>      BEGIN<br>        $if PartitionManagment.Debuging $then InsertLog('DeletePartitions',DBMS_UTILITY.FORMAT_ERROR_STACK); $end null;<br>        RAISE_APPLICATION_ERROR(eDeletePartitions, DBMS_UTILITY.FORMAT_ERROR_STACK);<br>      END;<br>  END;<br>  <br>  PROCEDURE UpdatePartitions(ATableName IN VARCHAR2,ACurrentDate IN DATE,ASchemaName VARCHAR2) IS<br>  BEGIN<br>      DeletePartitions(ATableName,ACurrentDate,ASchemaName);<br>      CreatePartitions(ATableName,ACurrentDate,ASchemaName);<br>  EXCEPTION<br>      WHEN OTHERS THEN<br>      BEGIN<br>        $if PartitionManagment.Debuging $then InsertLog('UpdatePartitions',DBMS_UTILITY.FORMAT_ERROR_STACK); $end null;<br>        RAISE_APPLICATION_ERROR(eUpdatePartitions, DBMS_UTILITY.FORMAT_ERROR_STACK);<br>      END;<br>  END;<br>  <br>  PROCEDURE UpdatePartitionJob(ATableName IN VARCHAR2,ACurrentDate IN DATE,ASchemaName VARCHAR2) IS<br>      LDaysBetweenCreation    NUMBER:=0;<br>      LWeeksBetweenCreation   NUMBER:=0;<br>      LMonthsBetweenCreation  NUMBER:=0;<br>  <br>      LJobWhat  VARCHAR2(2000);<br>      LJob      Number;<br>      LInterval DATE;<br>  <br>      CURSOR C_Jobs(AWhat VARCHAR2)  IS<br>        SELECT Job<br>          FROM USER_JOBS<br>          WHERE UPPER(What)=UPPER(AWhat);<br>  BEGIN<br>      ValidatePartitionSupport;<br>  <br>      --Get Partition Managment Parameter<br>      BEGIN<br>           SELECT DaysBetweenCreation,WeeksBetweenCreation,MonthsBetweenCreation<br>              INTO LDaysBetweenCreation,LWeeksBetweenCreation,LMonthsBetweenCreation<br>              FROM COEPARTITIONMANAGMENT<br>              WHERE TableName=ATableName AND Owner=ASchemaName;<br>      EXCEPTION<br>      WHEN OTHERS THEN<br>          Raise_Application_Error (ePartitionParamManagmentError, 'Error getting Partition Managment Parameter '||'-'||DBMS_UTILITY.Format_Error_Stack);<br>      END;<br>  <br>  <br>      --Calculate interval<br>      LInterval:=ACurrentDate;<br>      IF LDaysBetweenCreation&gt;0 THEN<br>          LInterval:=LInterval + (LDaysBetweenCreation);<br>      END IF;<br>  <br>      IF LWeeksBetweenCreation&gt;0 THEN<br>          LInterval:=LInterval + (LWeeksBetweenCreation*7);<br>      END IF;<br>  <br>      IF LMonthsBetweenCreation&gt;0 THEN<br>          LInterval:=ADD_MONTHS(LInterval,LMonthsBetweenCreation);<br>      END IF;<br>  <br>  <br>      --Create job<br>      LJobWhat:='PartitionManagment.UpdatePartitions('''||ATableName||''',SYSDATE,'''||ASchemaName||''');';<br>      FOR  R_Jobs IN C_Jobs(LJobWhat) LOOP<br>          DBMS_JOB.REMOVE(R_Jobs.Job);<br>      END LOOP;<br>  <br>  <br>      DBMS_JOB.SUBMIT<br>         (<br>           job        =&gt; LJob<br>          ,what       =&gt; LJobWhat<br>          ,next_date  =&gt; SYSDATE<br>          ,interval   =&gt; 'TRUNC(SYSDATE) + '||(LInterval-ACurrentDate)<br>          ,no_parse   =&gt; FALSE<br>         );<br>  <br>      COMMIT;<br>  EXCEPTION<br>      WHEN OTHERS THEN<br>      BEGIN<br>        $if PartitionManagment.Debuging $then InsertLog('UpdatePartitionJob',DBMS_UTILITY.FORMAT_ERROR_STACK); $end null;<br>        RAISE_APPLICATION_ERROR(eUpdatePartitionJob, DBMS_UTILITY.FORMAT_ERROR_STACK);<br>      END;<br>  END;<br>  <br>  END; <br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_26"></a>
<div class="caption2">COEDB.PROPERTYLIST</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE PACKAGE BODY &quot;COEDB&quot;.&quot;PROPERTYLIST&quot;  AS<br>  /******************************************************************************<br>     NAME:       PropertyList<br>     PURPOSE:<br>  <br>     REVISIONS:<br>     Ver        Date        Author           Description<br>     ---------  ----------  ---------------  ------------------------------------<br>     1.0        10/4/2007   Fari              1. Created this package body.<br>  ******************************************************************************/<br>     PROCEDURE InsertLog(ALogProcedure CLOB,ALogComment CLOB) IS<br>         PRAGMA AUTONOMOUS_TRANSACTION;<br>     BEGIN<br>         INSERT INTO LOG(LogProcedure,LogComment) VALUES($$plsql_unit||'.'||ALogProcedure,ALogComment);<br>         COMMIT;<br>     EXCEPTION<br>         WHEN OTHERS THEN NULL; --If logs don't work then don't stop<br>     END;<br>     <br>     PROCEDURE SetSessionParameter IS<br>         PRAGMA AUTONOMOUS_TRANSACTION;<br>     BEGIN<br>         DBMS_SESSION.set_nls('NLS_DATE_FORMAT','''YYYY-MM-DD HH:Mi:SS''');<br>         DBMS_SESSION.set_nls('NLS_NUMERIC_CHARACTERS', '''.,''');<br>         COMMIT; --It is necesary to finished the Autonomou-Transaction<br>     EXCEPTION<br>         WHEN OTHERS THEN<br>         BEGIN<br>             InsertLog('SetSessionParameter'||' Line:'||$$plsql_line,DBMS_UTILITY.FORMAT_ERROR_STACK);<br>             RAISE_APPLICATION_ERROR(eGenericException, 'SetSessionParameter'||CHR(10)||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>         END;<br>  END;<br>      <br>     PROCEDURE SetField(AField IN VARCHAR2, AViewField OUT VARCHAR2, ATableField OUT VARCHAR2, ASection IN VARCHAR2, AType in VARCHAR2) IS<br>     BEGIN  <br>          AViewField:=UPPER(AField);<br>          ATableField:=UPPER(AField);<br>          CASE UPPER(ASection)<br>              WHEN 'BATCH' THEN<br>                  BEGIN<br>                      CASE UPPER(AType)<br>                          WHEN 'DEFINITIVE' THEN<br>                              BEGIN<br>                                  IF ATableField='OPTICALROTATION' THEN<br>                                      ATableField:='OPTICAL_ROTATION';<br>                                  END IF;<br>                                  IF ATableField='REFRACTIONINDEX' THEN<br>                                      ATableField:='REFRACTIVE_INDEX';<br>                                  END IF;<br>                              END;<br>                          WHEN 'TEMPORARY' THEN<br>                              BEGIN<br>                                  NULL;<br>                              END;<br>                      END CASE; <br>                  END;<br>              WHEN 'COMPOUND' THEN<br>                  BEGIN<br>                      NULL;<br>                  END;<br>              WHEN 'BATCHCOMPONENT' THEN<br>                  BEGIN<br>                      CASE UPPER(AType)<br>                          WHEN 'DEFINITIVE' THEN<br>                              BEGIN<br>                                  NULL;<br>                              END;<br>                          WHEN 'TEMPORARY' THEN<br>                              BEGIN<br>                                  IF ATableField='COMMENTS' THEN<br>                                      ATableField:='BATCHCOMPONENT_COMMENTS';<br>                                  END IF;<br>                                  IF AViewField='COMMENTS' THEN<br>                                      AViewField:='BATCHCOMPONENTCOMMENTS';<br>                                  END IF;<br>                              END;<br>                      END CASE;<br>                  END;            <br>          END CASE;<br>      END;<br>  <br>      PROCEDURE AddField(AField IN VARCHAR2, ASection IN VARCHAR2, AFieldType IN VARCHAR2) IS<br>          LStatement   Varchar2(4000);<br>          LViewField   Varchar2(100);<br>          LTableField  Varchar2(100);<br>  <br>          FUNCTION AddFieldToView(AViewName VARCHAR2,APrimaryTable in VARCHAR2:='') RETURN VARCHAR2 IS<br>              LViewSelect VARCHAR2(10000);<br>              LViewFields VARCHAR2(10000);<br>              CURSOR LCViewFields(ViewName VARCHAR2) IS <br>                  SELECT Column_Name<br>                    FROM User_Tab_Columns c<br>                   WHERE Table_Name = ViewName;<br>          BEGIN<br>              LViewFields:='';<br>              FOR  RViewFields IN LCViewFields(AViewName) LOOP<br>                  LViewFields:=LViewFields||RViewFields.Column_Name||',';<br>              END LOOP;<br>              LViewFields:=SUBSTR(LViewFields,1,LENGTH(LViewFields)-1);<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LViewFields='||LViewFields);<br>              SELECT Text <br>                INTO LViewSelect <br>                FROM USER_VIEWS <br>               WHERE VIEW_NAME=AViewName;<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LViewSelect=1'||LViewSelect);    <br>              LViewSelect:=SUBSTR(LViewSelect,1,INSTR(LViewSelect,'FROM '||APrimaryTable)-2)||','||LTableField||' '||SUBSTR(LViewSelect,INSTR(LViewSelect,'FROM '||APrimaryTable),LENGTH(LViewSelect));<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LViewSelect=2'||LViewSelect);<br>              LStatement:='CREATE OR REPLACE VIEW '||AViewName||'('||LViewFields||','||LViewField||') AS '||LViewSelect;<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LStatement='||LStatement);<br>              RETURN LStatement;<br>          END;<br>      BEGIN<br>          InsertLog('AddField'||' Line:'||$$plsql_line,'AField='||AField||' ASection='||ASection);<br>  <br>          CASE UPPER(ASection)<br>              WHEN 'COMPOUND' THEN<br>                  BEGIN<br>                      IF (INSTR(UPPER(AFieldType),'NUMBER')&lt;&gt;0) OR (INSTR(UPPER(AFieldType),'VARCHAR2')&lt;&gt;0) OR (INSTR(UPPER(AFieldType),'DATE')&lt;&gt;0) THEN<br>                          SetField(AField,LViewField,LTableField,ASection,'DEFINITIVE');<br>                          LStatement:='ALTER TABLE COMPOUND_MOLECULE ADD '||UPPER(LTableField)||' '||AFieldType;<br>                          BEGIN<br>                              EXECUTE IMMEDIATE LStatement;<br>                              <br>                              LStatement:=AddFieldToView('VW_COMPOUND');<br>                              EXECUTE IMMEDIATE LStatement;<br>                          EXCEPTION<br>                              WHEN OTHERS THEN <br>                              BEGIN<br>                                  InsertLog('AddField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                                  IF SQLCODE=-1430 THEN NULL;<br>                                  END IF;<br>                              END;<br>                          END;<br>                          <br>                          LStatement:='ALTER TABLE TEMPORARY_COMPOUND ADD '||UPPER(LTableField)||' '||AFieldType;<br>                          BEGIN<br>                              EXECUTE IMMEDIATE LStatement;<br>                              <br>                              LStatement:=AddFieldToView('VW_TEMPORARYCOMPOUND');<br>                              EXECUTE IMMEDIATE LStatement;<br>                          EXCEPTION<br>                              WHEN OTHERS THEN <br>                              BEGIN<br>                                  InsertLog('AddField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                                  IF SQLCODE=-1430 THEN NULL;<br>                                  END IF;<br>                              END;<br>                          END;<br>                      ELSE<br>                          RAISE_APPLICATION_ERROR(eGenericException, 'Field Type isn''t recognized');    <br>                      END IF;    <br>                  END;<br>              WHEN 'BATCH' THEN<br>                  BEGIN<br>                      IF (INSTR(UPPER(AFieldType),'NUMBER')&lt;&gt;0) OR (INSTR(UPPER(AFieldType),'VARCHAR2')&lt;&gt;0) OR (INSTR(UPPER(AFieldType),'DATE')&lt;&gt;0) THEN<br>                          SetField(AField,LViewField,LTableField,ASection,'DEFINITIVE');<br>                          LStatement:='ALTER TABLE BATCHES ADD '||UPPER(LTableField)||' '||AFieldType;<br>                          InsertLog('AddField'||' Line:'||$$plsql_line,'BATCH LStatement='||LStatement);<br>                          BEGIN<br>                              EXECUTE IMMEDIATE LStatement;<br>                              <br>                              LStatement:=AddFieldToView('VW_BATCH');<br>                              EXECUTE IMMEDIATE LStatement;<br>                              <br>                          EXCEPTION<br>                              WHEN OTHERS THEN <br>                              BEGIN<br>                                  InsertLog('AddField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                                  IF SQLCODE=-1430 THEN NULL;<br>                                  END IF;<br>                              END;<br>                          END;<br>                          <br>                          SetField(AField,LViewField,LTableField,ASection,'TEMPORARY');<br>                          LStatement:='ALTER TABLE TEMPORARY_BATCH ADD '||UPPER(LTableField)||' '||AFieldType;<br>                          BEGIN<br>                              EXECUTE IMMEDIATE LStatement;<br>                              <br>                              LStatement:=AddFieldToView('VW_TEMPORARYBATCH','TEMPORARY_BATCH');<br>                              EXECUTE IMMEDIATE LStatement;<br>                          EXCEPTION<br>                              WHEN OTHERS THEN <br>                              BEGIN<br>                                  InsertLog('AddField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                                  IF SQLCODE=-1430 THEN NULL;<br>                                  END IF;<br>                              END;<br>                          END;<br>                      ELSE<br>                           InsertLog('AddField'||' Line:'||$$plsql_line,'AddField - '||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>                          RAISE_APPLICATION_ERROR(eGenericException, 'Field Type isn''t recognized');    <br>                      END IF;    <br>                  END;<br>              WHEN 'BATCHCOMPONENT' THEN<br>                  BEGIN<br>                      IF (INSTR(UPPER(AFieldType),'NUMBER')&lt;&gt;0) OR (INSTR(UPPER(AFieldType),'VARCHAR2')&lt;&gt;0) OR (INSTR(UPPER(AFieldType),'DATE')&lt;&gt;0) THEN<br>                          SetField(AField,LViewField,LTableField,ASection,'DEFINITIVE');<br>                          LStatement:='ALTER TABLE BATCHCOMPONENT ADD '||UPPER(LTableField)||' '||AFieldType;<br>                          InsertLog('AddField'||' Line:'||$$plsql_line,'BATCHCOMPONENT LStatement='||LStatement);<br>                          BEGIN<br>                              EXECUTE IMMEDIATE LStatement;<br>                              <br>                              LStatement:=AddFieldToView('VW_BATCHCOMPONENT');<br>                              EXECUTE IMMEDIATE LStatement;<br>                              <br>                          EXCEPTION<br>                              WHEN OTHERS THEN <br>                              BEGIN<br>                                  InsertLog('AddField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                                  IF SQLCODE=-1430 THEN NULL;<br>                                  END IF;<br>                              END;<br>                          END;<br>                          <br>                          SetField(AField,LViewField,LTableField,ASection,'TEMPORARY');<br>                          LStatement:='ALTER TABLE TEMPORARY_COMPOUND ADD '||UPPER(LTableField)||' '||AFieldType;<br>                          BEGIN<br>                              EXECUTE IMMEDIATE LStatement;<br>                              <br>                              LStatement:=AddFieldToView('VW_TEMPORARYCOMPOUND','TEMPORARY_COMPOUND');<br>                              EXECUTE IMMEDIATE LStatement;<br>                          EXCEPTION<br>                              WHEN OTHERS THEN <br>                              BEGIN<br>                                  InsertLog('AddField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                                  IF SQLCODE=-1430 THEN NULL;<br>                                  END IF;<br>                              END;<br>                          END;<br>                      ELSE<br>                          InsertLog('AddField'||' Line:'||$$plsql_line,'AddField - '||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>                          RAISE_APPLICATION_ERROR(eGenericException, 'Field Type isn''t recognized');    <br>                      END IF;    <br>                  END;      <br>          END CASE;<br>      EXCEPTION<br>          WHEN OTHERS THEN<br>          BEGIN<br>               InsertLog('AddField'||' Line:'||$$plsql_line,'AddField - '||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>              RAISE_APPLICATION_ERROR(eGenericException, 'DropField - Error adding the field.'||chr(10)||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>          END;<br>      END;<br>  <br>      PROCEDURE DropField(AField IN VARCHAR2, ASection IN VARCHAR2) IS<br>          LStatement   Varchar2(4000);<br>          LViewField   Varchar2(100);<br>          LTableField  Varchar2(100);<br>          FUNCTION AddFieldToView(AViewName VARCHAR2) RETURN VARCHAR2 IS<br>              LViewSelect VARCHAR2(10000);<br>              LViewFields VARCHAR2(10000);<br>              LTable      VARCHAR2(100);<br>              CURSOR LCViewFields(ViewName VARCHAR2) IS <br>                  SELECT Column_Name<br>                    FROM User_Tab_Columns c<br>                   WHERE Table_Name = ViewName;<br>          BEGIN<br>              LViewFields:='';<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'Begin AViewName'||AViewName);<br>              FOR  RViewFields IN LCViewFields(AViewName) LOOP<br>                  IF UPPER(RViewFields.Column_Name)&lt;&gt;LViewField THEN<br>                      LViewFields:=LViewFields||RViewFields.Column_Name||',';<br>                       --InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'ViewFields.Column_Name='||RViewFields.Column_Name);<br>                  END IF;<br>              END LOOP;<br>              LViewFields:=SUBSTR(LViewFields,1,LENGTH(LViewFields)-1);<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LViewFields='||LViewFields);<br>              SELECT Text <br>                INTO LViewSelect <br>                FROM USER_VIEWS <br>               WHERE VIEW_NAME=AViewName;<br>              <br>              LViewSelect:=REPLACE(' '||SUBSTR(UPPER(LViewSelect),8,LENGTH(LViewSelect)),CHR(10),'');<br>              LTable:=SUBSTR(LViewSelect,INSTR(LViewSelect,'FROM ',-1),LENGTH(LViewSelect));<br>              LViewSelect:=REPLACE(LViewSelect,LTable,' ');<br>              <br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LTableField 1='||LTableField);<br>              <br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LViewSelect 1='||LViewSelect);<br>              LViewSelect:=REPLACE(LViewSelect,','||LTableField||',',',');<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LViewSelect 2='||LViewSelect);<br>              LViewSelect:=REPLACE(LViewSelect,','||LTableField||' ',' ');<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LViewSelect 3='||LViewSelect);<br>              LViewSelect:=REPLACE(LViewSelect,' '||LTableField||',',' ');<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LViewSelect 4='||LViewSelect);<br>              <br>              LViewSelect:='SELECT'||LViewSelect||LTable;<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LViewSelect 5='||LViewSelect);<br>              <br>              LStatement:='CREATE OR REPLACE VIEW '||AViewName||'('||LViewFields||') AS '||LViewSelect;<br>              InsertLog('AddFieldToView'||' Line:'||$$plsql_line,'LStatement='||LStatement);<br>              RETURN LStatement;<br>          END; <br>      BEGIN<br>          InsertLog('DropField'||' Line:'||$$plsql_line,'LViewField='||LViewField||' LTableField='||LTableField);<br>          CASE UPPER(ASection)<br>              WHEN 'COMPOUND' THEN<br>                  BEGIN<br>                      SetField(AField,LViewField,LTableField,ASection,'DEFINITIVE');<br>                      LStatement:='ALTER TABLE COMPOUND_MOLECULE DROP COLUMN '||LTableField;<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'LStatement1='||LStatement);<br>                      BEGIN<br>                          EXECUTE IMMEDIATE LStatement;<br>                         <br>                      EXCEPTION<br>                          WHEN OTHERS THEN <br>                          BEGIN<br>                              InsertLog('DropField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                              IF SQLCODE=-904 THEN NULL;<br>                              END IF;<br>                          END;<br>                      END;<br>                      <br>                      LStatement:=AddFieldToView('VW_COMPOUND');<br>                      EXECUTE IMMEDIATE LStatement;<br>  <br>                      LStatement:='ALTER TABLE TEMPORARY_COMPOUND DROP COLUMN '||LTableField;<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'LStatement2='||LStatement);<br>                      BEGIN<br>                          EXECUTE IMMEDIATE LStatement;<br>                      EXCEPTION<br>                          WHEN OTHERS THEN <br>                          BEGIN<br>                              InsertLog('DropField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                              IF SQLCODE=-904 THEN NULL;<br>                              END IF;<br>                          END;<br>                      END;<br>                      <br>                      LStatement:=AddFieldToView('VW_TEMPORARYCOMPOUND');<br>                      EXECUTE IMMEDIATE LStatement;<br>                  END;<br>              WHEN 'BATCH' THEN<br>                  BEGIN<br>                      SetField(AField,LViewField,LTableField,ASection,'DEFINITIVE');<br>                      LStatement:='ALTER TABLE BATCHES DROP COLUMN '||LTableField;<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'LStatement1='||LStatement);<br>                      BEGIN<br>                          EXECUTE IMMEDIATE LStatement;<br>                      EXCEPTION<br>                          WHEN OTHERS THEN <br>                          BEGIN<br>                              InsertLog('DropField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                              IF SQLCODE=-904 THEN NULL;<br>                              END IF;<br>                          END;<br>                      END;<br>                      <br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'before AddFieldToView VW_BATCH');<br>                      LStatement:=AddFieldToView('VW_BATCH');<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'after AddFieldToView VW_BATCH');<br>                      EXECUTE IMMEDIATE LStatement;<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'after EXECUTE AddFieldToView VW_BATCH');<br>                      <br>                      SetField(AField,LViewField,LTableField,ASection,'TEMPORARY');<br>                      LStatement:='ALTER TABLE TEMPORARY_BATCH DROP COLUMN '||LTableField;<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'LStatement2='||LStatement);<br>                      BEGIN<br>                          EXECUTE IMMEDIATE LStatement;<br>                      EXCEPTION<br>                          WHEN OTHERS THEN <br>                          BEGIN<br>                              InsertLog('DropField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                              IF SQLCODE=-904 THEN NULL;<br>                              END IF;<br>                          END;<br>                      END;<br>                          <br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'before AddFieldToView VW_TEMPORARYBATCH');<br>                      LStatement:=AddFieldToView('VW_TEMPORARYBATCH');<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'after AddFieldToView VW_TEMPORARYBATCH');<br>                      EXECUTE IMMEDIATE LStatement;<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'after EXECUTE AddFieldToView VW_TEMPORARYBATCH');<br>                  END;<br>              WHEN 'BATCHCOMPONENT' THEN<br>                  BEGIN<br>                      SetField(AField,LViewField,LTableField,ASection,'DEFINITIVE');<br>                      LStatement:='ALTER TABLE BATCHCOMPONENT DROP COLUMN '||LTableField;<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'LStatement1='||LStatement);<br>                      BEGIN<br>                          EXECUTE IMMEDIATE LStatement;<br>                      EXCEPTION<br>                          WHEN OTHERS THEN <br>                          BEGIN<br>                              InsertLog('DropField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                              IF SQLCODE=-904 THEN NULL;<br>                              END IF;<br>                          END;<br>                      END;<br>                      <br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'before AddFieldToView VW_BATCHCOMPONENT');<br>                      LStatement:=AddFieldToView('VW_BATCHCOMPONENT');<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'after AddFieldToView VW_BATCHCOMPONENT');<br>                      EXECUTE IMMEDIATE LStatement;<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'after EXECUTE AddFieldToView VW_BATCH');<br>                      <br>                      SetField(AField,LViewField,LTableField,ASection,'TEMPORARY');<br>                      LStatement:='ALTER TABLE TEMPORARY_COMPOUND DROP COLUMN '||LTableField;<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'LStatement2='||LStatement);<br>                      BEGIN<br>                          EXECUTE IMMEDIATE LStatement;<br>                      EXCEPTION<br>                          WHEN OTHERS THEN <br>                          BEGIN<br>                              InsertLog('DropField'||' Line:'||$$plsql_line,'SQLCODE='||SQLCODE);<br>                              IF SQLCODE=-904 THEN NULL;<br>                              END IF;<br>                          END;<br>                      END;<br>                          <br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'before AddFieldToView VW_TEMPORARYCOMPOUND');<br>                      LStatement:=AddFieldToView('VW_TEMPORARYCOMPOUND');<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'after AddFieldToView VW_TEMPORARYCOMPOUND');<br>                      EXECUTE IMMEDIATE LStatement;<br>                      InsertLog('DropField'||' Line:'||$$plsql_line,'after EXECUTE AddFieldToView VW_TEMPORARYCOMPOUND');<br>                  END;<br>          END CASE;        <br>      EXCEPTION<br>          WHEN OTHERS THEN<br>          BEGIN<br>              InsertLog('DropField'||' Line:'||$$plsql_line,'DropField - '||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>              RAISE_APPLICATION_ERROR(eGenericException, 'DropField - Error dropping a field'||chr(10)||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>          END;<br>      END;<br>  <br>      PROCEDURE ProcessFieldsfromXml(ACoeObjectConfigXML IN  CLOB) IS<br>          LCoeObjectConfigField     XmlType;<br>          LFiled               Varchar2(100);<br>          LFiledType           Varchar2(200);<br>          LFieldType           Varchar2(100);<br>  <br>          LDOMDocument         DBMS_XMLDom.DOMDocument;<br>          LDocumentNode        DBMS_XMLDom.DOMNode;<br>          LNodeList            DBMS_XMLDom.DOMNodelist;<br>          LNode                DBMS_XMLDom.DOMNode;<br>          LNodesCount          Number;<br>          LAttrs               DBMS_XMLDom.DOMNamedNodeMap;<br>          LAttr                DBMS_XMLDom.DOMNode;<br>          LIndexAttr           Number;<br>          LAttrName            Varchar2(300);<br>  <br>          ValidationRuleNode  DBMS_XMLDom.DOMNode;<br>          LValidationRuleList DBMS_XMLDom.DOMNodelist;<br>          LAttributeName      Varchar2(300);<br>          LLong               Varchar2(50);<br>  <br>          PROCEDURE ProcessDelete(ANodeList DBMS_XMLDom.DOMNodelist,ASection in VARCHAR2) IS<br>          BEGIN<br>              LNodesCount:=DBMS_XMLDom.GetLength(ANodeList);<br>              FOR LIndex IN 0..LNodesCount-1 LOOP<br>                  LNode := DBMS_XMLDom.Item(ANodeList, LIndex);<br>                  LAttrs := dbms_xmldom.Getattributes(LNode);<br>                  LAttr := dbms_xmldom.GetNamedItem(LAttrs,'name');<br>                  LFiled :=dbms_xmldom.GetNodeValue(LAttr);<br>  <br>                  DropField(LFiled,ASection);<br>              END LOOP;<br>          END;<br>          PROCEDURE ProcessInsert(ANodeList DBMS_XMLDom.DOMNodelist,ASection in VARCHAR2) IS<br>          BEGIN<br>              LNodesCount:=DBMS_XMLDom.GetLength(ANodeList);<br>              FOR LIndex IN 0..LNodesCount-1 LOOP<br>                  LNode := DBMS_XMLDom.Item(ANodeList, LIndex);<br>                  LAttrs := dbms_xmldom.Getattributes(LNode);<br>                  LAttr := dbms_xmldom.GetNamedItem(LAttrs,'name');<br>                  LFiled := dbms_xmldom.GetNodeValue(LAttr);<br>                  <br>                  LValidationRuleList:=dbms_xslprocessor.selectNodes(LNode,'DBField');<br>                  LNode := DBMS_XMLDom.Item(LValidationRuleList, 0);<br>                  <br>                  LAttrs := dbms_xmldom.Getattributes(LNode);<br>                  LAttr := dbms_xmldom.GetNamedItem(LAttrs,'type');<br>                  LAttributeName :=UPPER(dbms_xmldom.GetNodeValue(LAttr));<br>                  <br>                  InsertLog('ProcessSection'||' Line:'||$$plsql_line,'LFiled-&gt;'||LFiled||' LAttributeName-&gt;'||LAttributeName);<br>  <br>                  IF LAttributeName IN ('TEXT','NUMBER') THEN<br>                      LAttr := dbms_xmldom.GetNamedItem(LAttrs,'precision');<br>                      LLong := dbms_xmldom.GetNodeValue(LAttr);<br>                      <br>                      IF LAttributeName='TEXT' THEN<br>                          InsertLog('ProcessesSection'||' Line:'||$$plsql_line,'Text LFiled-&gt;'||LFiled||' LLong-&gt;'||LLong||' LAttributeName-&gt;'||LAttributeName);<br>                          LFiledType:='VARCHAR2('||LLong||')';<br>                      ELSIF LAttributeName='NUMBER' THEN<br>                          InsertLog('ProcessesSection'||' Line:'||$$plsql_line,'Number LFiled-&gt;'||LFiled||' LLong-&gt;'||LLong||' LAttributeName-&gt;'||LAttributeName);                    <br>                          IF NVL(LLong,0)&lt;&gt;0 THEN<br>                              LFiledType:='NUMBER('||Replace(LLong,'.',',')||')';<br>                          ELSE<br>                              LFiledType:='NUMBER';<br>                          END IF;    <br>                      END IF;<br>                  ELSIF LAttributeName='DATE' THEN<br>                      LFiledType:='DATE';<br>                  ELSE  <br>                      LFiledType:='VARCHAR2(1000)';<br>                  END IF;<br>  <br>                  AddField(LFiled,ASection,LFiledType);<br>                  <br>              END LOOP;<br>          END;<br>  <br>          PROCEDURE ProcessSection(ANodeList DBMS_XMLDom.DOMNodelist,ASection in VARCHAR2) IS<br>              LNodeList DBMS_XMLDom.DOMNodelist;<br>              LValidationRuleList DBMS_XMLDom.DOMNodelist;<br>          BEGIN<br>              InsertLog('ProcessSection'||' Line:'||$$plsql_line,'DBMS_XMLDom.GetLength(ANodeList)-&gt;'||DBMS_XMLDom.GetLength(ANodeList));<br>              LNodeList:=dbms_xslprocessor.selectNodes(DBMS_XMLDOM.ITEM(ANodeList,0),'Property[@delete=&quot;yes&quot;]');<br>              InsertLog('ProcessSection'||' Line:'||$$plsql_line,'Property[@delete=&quot;yes&quot;] LNodeList-&gt;'||DBMS_XMLDom.GetLength(LNodeList));<br>              ProcessDelete(LNodeList,ASection);<br>              LNodeList:=dbms_xslprocessor.selectNodes(DBMS_XMLDOM.ITEM(ANodeList,0),'Property[@insert=&quot;yes&quot;]');<br>              InsertLog('ProcessSection'||' Line:'||$$plsql_line,'Property[@insert=&quot;yes&quot;] LNodeList-&gt;'||DBMS_XMLDom.GetLength(LNodeList));<br>              ProcessInsert(LNodeList,ASection);<br>          END;<br>  <br>          PROCEDURE ProcessAndSaveInDB(ACoeObjectConfigXML IN CLOB) IS<br>              LCoeObjectConfigXMLType   XMLType;<br>          BEGIN<br>              LCoeObjectConfigXMLType := XMLType.CreateXML(Replace(ACoeObjectConfigXML, 'insert=&quot;yes&quot;', ''));<br>              <br>              SELECT DeleteXML(LCoeObjectConfigXMLType,'/MultiCompoundRegistryRecord//PropertyList/Property/DBField')<br>                INTO LCoeObjectConfigXMLType<br>                FROM DUAL;<br>  <br>              SELECT DeleteXML(LCoeObjectConfigXMLType,'/MultiCompoundRegistryRecord//PropertyList/Property[@delete=&quot;yes&quot;]')<br>                INTO LCoeObjectConfigXMLType<br>                FROM DUAL;<br>  <br>              UPDATE COEOBJECTCONFIG<br>                 SET XML = LCoeObjectConfigXMLType.GetClobVal()<br>               WHERE ID = 2;<br>               <br>              COMMIT;<br>          END;<br>  <br>      BEGIN<br>          SetSessionParameter;<br>          <br>          LDOMDocument := DBMS_XMLDom.NewDOMDocument(ACoeObjectConfigXML);<br>          LDocumentNode := DBMS_XMLDom.MakeNode(LDOMDocument);<br>  <br>          LNodeList:=dbms_xslprocessor.selectNodes(LDocumentNode,'/MultiCompoundRegistryRecord/ComponentList/Component/Compound/PropertyList');<br>          InsertLog('ProcessFieldsfromDB'||' Line:'||$$plsql_line,'ProcessSection COMPOUND');<br>          ProcessSection(LNodeList,'COMPOUND');<br>  <br>          LNodeList:=dbms_xslprocessor.selectNodes(LDocumentNode,'/MultiCompoundRegistryRecord/BatchList/Batch/PropertyList');<br>          InsertLog('ProcessFieldsfromDB'||' Line:'||$$plsql_line,'ProcessSection BATCH');<br>          ProcessSection(LNodeList,'BATCH');<br>  <br>          LNodeList:=dbms_xslprocessor.selectNodes(LDocumentNode,'/MultiCompoundRegistryRecord/BatchList/Batch/BatchComponentList/BatchComponent/PropertyList');<br>          InsertLog('ProcessFieldsfromDB'||' Line:'||$$plsql_line,'ProcessSection BATCH COMPONENT');<br>          ProcessSection(LNodeList,'BATCHCOMPONENT');<br>  <br>          ProcessAndSaveInDB(ACoeObjectConfigXML);  <br>      EXCEPTION<br>          WHEN OTHERS THEN<br>          BEGIN<br>              InsertLog('ProcessFieldsfromDB'||' Line:'||$$plsql_line,DBMS_UTILITY.FORMAT_ERROR_STACK);<br>              RAISE_APPLICATION_ERROR(eGenericException, 'ProcessFieldsfromDB'||chr(10)||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>          END;<br>      END;<br>  <br>      PROCEDURE ProcessFieldsfromDB IS<br>          LCoeObjectConfigField     XmlType;<br>      BEGIN<br>          SELECT XmlType.CreateXml(XML)<br>            INTO LCoeObjectConfigField<br>            FROM COEOBJECTCONFIG<br>           WHERE ID=2;<br>          InsertLog('ProcessFieldsfromDB'||' Line:'||$$plsql_line,LCoeObjectConfigField.GetClobval());<br>          ProcessFieldsfromXml(LCoeObjectConfigField.GetClobval());<br>      EXCEPTION<br>          WHEN OTHERS THEN<br>          BEGIN<br>              InsertLog('ProcessFieldsfromDB'||' Line:'||$$plsql_line,DBMS_UTILITY.FORMAT_ERROR_STACK);<br>              RAISE_APPLICATION_ERROR(eGenericException, 'ProcessFieldsfromDB'||chr(10)||DBMS_UTILITY.FORMAT_ERROR_STACK);<br>          END;<br>      END;<br>  <br>  END PropertyList;  <br> /
</code></pre>   </td>  </tr>
</table>

 <br><br> 
<a name = "TextObjName_38"></a>
<div class="caption1">SEQUENCES</div>
<a name = "TextObject_38"></a>
<div class="caption2">COEDB.COEDATABASE_SEQ</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE SEQUENCE &quot;COEDB&quot;.&quot;COEDATABASE_SEQ&quot; INCREMENT BY 1 START WITH 1 MAXVALUE 1e+27 MINVALUE 1 NOCYCLE CACHE 20 NOORDER<br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_31"></a>
<div class="caption2">COEDB.COEDATAVIEW_SEQ</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE SEQUENCE &quot;COEDB&quot;.&quot;COEDATAVIEW_SEQ&quot; INCREMENT BY 100000 START WITH 1 MAXVALUE 1e+27 MINVALUE 1 NOCYCLE CACHE 20 NOORDER<br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_32"></a>
<div class="caption2">COEDB.COEFORM_SEQ</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE SEQUENCE &quot;COEDB&quot;.&quot;COEFORM_SEQ&quot; INCREMENT BY 1 START WITH 1 MAXVALUE 1e+27 MINVALUE 1 NOCYCLE CACHE 20 NOORDER<br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_36"></a>
<div class="caption2">COEDB.COEGENERICOBJECT_SEQ</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE SEQUENCE &quot;COEDB&quot;.&quot;COEGENERICOBJECT_SEQ&quot; INCREMENT BY 1 START WITH 1 MAXVALUE 1e+27 MINVALUE 1 NOCYCLE CACHE 20 NOORDER<br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_33"></a>
<div class="caption2">COEDB.COEGLOBALS_SEQ</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE SEQUENCE &quot;COEDB&quot;.&quot;COEGLOBALS_SEQ&quot; INCREMENT BY 1 START WITH 1 MAXVALUE 1e+27 MINVALUE 1 NOCYCLE CACHE 20 NOORDER<br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_34"></a>
<div class="caption2">COEDB.COEHITLISTID_SEQ</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE SEQUENCE &quot;COEDB&quot;.&quot;COEHITLISTID_SEQ&quot; INCREMENT BY 1 START WITH 1 MAXVALUE 1e+27 MINVALUE 1 NOCYCLE CACHE 20 NOORDER<br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_35"></a>
<div class="caption2">COEDB.COESEARCHCRITERIA_SEQ</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE SEQUENCE &quot;COEDB&quot;.&quot;COESEARCHCRITERIA_SEQ&quot; INCREMENT BY 1 START WITH 1 MAXVALUE 1e+27 MINVALUE 1 NOCYCLE CACHE 20 NOORDER<br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_37"></a>
<div class="caption2">COEDB.COESESSION_SEQ</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE SEQUENCE &quot;COEDB&quot;.&quot;COESESSION_SEQ&quot; INCREMENT BY 1 START WITH 1 MAXVALUE 1e+27 MINVALUE 1 NOCYCLE CACHE 20 NOORDER<br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_30"></a>
<div class="caption2">COEDB.LOGSEQ</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE SEQUENCE &quot;COEDB&quot;.&quot;LOGSEQ&quot; INCREMENT BY 1 START WITH 39 MAXVALUE 9.999999999999999e+26 MINVALUE 1 NOCYCLE CACHE 2 NOORDER<br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_40"></a>
<div class="caption2">COEDB.PEOPLE_SEQ</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE SEQUENCE &quot;COEDB&quot;.&quot;PEOPLE_SEQ&quot; INCREMENT BY 1 START WITH 141 MAXVALUE 9.999999999999999e+26 MINVALUE 1 NOCYCLE CACHE 20 NOORDER<br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_27"></a>
<div class="caption2">COEDB.PRIVILEGE_TABLES_SEQ</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE SEQUENCE &quot;COEDB&quot;.&quot;PRIVILEGE_TABLES_SEQ&quot; INCREMENT BY 1 START WITH 41 MAXVALUE 9.999999999999999e+26 MINVALUE 1 NOCYCLE CACHE 20 NOORDER<br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_41"></a>
<div class="caption2">COEDB.SECURITY_ROLES_SEQ</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE SEQUENCE &quot;COEDB&quot;.&quot;SECURITY_ROLES_SEQ&quot; INCREMENT BY 1 START WITH 141 MAXVALUE 9.999999999999999e+26 MINVALUE 1 NOCYCLE CACHE 20 NOORDER<br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_29"></a>
<div class="caption2">COEDB.SEQ_AUDIT</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE SEQUENCE &quot;COEDB&quot;.&quot;SEQ_AUDIT&quot; INCREMENT BY 1 START WITH 1300 MAXVALUE 9.999999999999999e+26 MINVALUE 1 NOCYCLE CACHE 100 ORDER<br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_28"></a>
<div class="caption2">COEDB.SEQ_RID</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE SEQUENCE &quot;COEDB&quot;.&quot;SEQ_RID&quot; INCREMENT BY 1 START WITH 1300 MAXVALUE 9.999999999999999e+26 MINVALUE 1 NOCYCLE CACHE 100 ORDER<br> /
</code></pre>   </td>  </tr>
</table>

<a name = "TextObject_39"></a>
<div class="caption2">COEDB.SITES_SEQ</div>
<table class="tabformat" border="0" cellpadding="2" cellspacing="1" width="100%">
 
  <tr>
    <td class="tabdata" > <pre><code>CREATE SEQUENCE &quot;COEDB&quot;.&quot;SITES_SEQ&quot; INCREMENT BY 1 START WITH 21 MAXVALUE 9.999999999999999e+26 MINVALUE 1 NOCYCLE CACHE 20 NOORDER<br> /
</code></pre>   </td>  </tr>
</table>

</body></html>
