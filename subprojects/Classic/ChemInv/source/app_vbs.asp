
<%'Copyright 1999-2003 CambridgeSoft Corporation. All rights reserved
'DO NOT EDIT THIS FILE%>
<%
'stop
' Improves the performance of batch loading into the temporary table by skiping the deletion of rows.  If you enable it
' you will have to either truncate the temp table or at least delete the succesfully registered rows at the end of the load.
' you can identify succesfully registered rows by select * from temporary_structures where duplicate="REGISTERED_DELETEABLE"
' Note that incorrect tempid counts may appear until the affected rows are removed.
bDeleteFromTemp = true

Dim RegConn

'SYAN added on 5/27/2005 to fix CSBR-50860
Dim regDelimiter
'End of SYAN modification
'DGB Defaultcode is used in UpdateBatchFormula, GetSolvatecodeFromName and GetSaltCodeFromName
' In most sstems the "no_salt" and "no_solvate" codes have and id of 1, but in some systems this
' may need to be changed to 0
Dim DefaultCode
DefaultCode = 1 

''SYAN added on 12/14/2004 to fix CSBR-49812
''Use http://<servername>/<appname>/SetCfwTraceLevel.asp?level=20&scope=session to set values for the current session.  Overriden by either of the above.

'Dim sessionTraceLevel

'if Session("CfwTraceLevel") <> "" then 
'	sessionTraceLevel = Session("CfwTraceLevel")
'else
'	sessionTraceLevel = 0
'end if
''End of SYAN modification

'******************************************************************
'the following code is a layer on top of cows that provides registration functionality to the application
'Application("appkey").
'******************************************************************
'********
'**************************DEVELOPER DOC SECTION **************************
'Duplicate Checking Functions AND Subs are'
'checkForDuplicates
'doCompoundDupsSearch
'getPrimaryStrWhere
'getSecondaryStrWhere
'doPrimaryDupsSearch
'doSecondaryDupsSearch
'getDuplicateAction

'A summary of how Duplicate Checking works is as follows"
'	Initial User action: user clicks the register
'	button which calls dataaction= register in formaction_asp. This in turn calls
'   DoCommit the main function for performing commits. 
'	The flag duplicates_check=true is looked for AND if not found this indicates
'	that a duplicate check needs to be performed.  If it where false, then
'	this step was performed, AND the code is returned from getting user choice
'	for duplicate action.
'	In the first case when no check is performed, the series of events is:
'	1.DoCommit calls checkForDuplicates which is the Main function. checkForDuplicates calls doCompoundDupsSearch
'	2.doCompoundDupsSearch calls CFW AND performs an exact search. If found, molid string to calling function.
'	3. if mol_ids are returned, then checkForDuplicates calls getPrimaryStrWhere
'	followed by doPrimaryDupsSearch. This functions do teh following:
'	4. getPrimaryStrWhere creates a strwhere clause with structure ids AND prefix data (this is where you would customize AND add something elase
'		like "compound_type" as a duplicate check criteria
'	5. next, doPrimaryDupsSearch is called which performs relational search with te strWhere AND returns
'		cpd_database_counter if a dup is found.
'	6. if no dup is found then a checkForDuplicates is done AND no duplicates are found. We end up back
'	in DoCommit with duplicates_found = "" so a full_commit is performed.
'	7. if a compound_prefix dup is found that checkForDuplicates calls the getSecondaryStrWhere
'	AND getSecondaryStrWhere to build another strWhere that includes that criteria that
'	determines if a new salt or a new batch are the duplicate options for the user.
'	'NOTE:this is where you would customize. If you where not using salt at this level,
'		you would bypass this second level altogether AND then change how
'		the reg_number is build in buildReg_Num
'	8. doSecondaryDupsSearch is performed using the strWhere AND returns cpd_database_counter if found
'	9. If a value is returned this signals that checkForDuplicates return a duplicate with the prefix "Add_Batch" for 
'	later user input.  If no dup is found, the primary duplicate is return with
'	a prefix "Add_Salt for later user input
'	10. Once returned to the original calling function, if duplicates are found,
'	then getDuplicateAction is called.  This redirects to the reg_dups.asp page where the user
'	choose what to do.  The prefix Add_Batch AND Add_Salt are used in this .asp page to determine
'	what buttons to display as choices.
'********************************************************************************************************
'compound_type id for no_structure entry
	kCmpdTypeNoStrucID = 2
	'for compatibitliy
	kSaltsUsed = CBOOL(Application("Salts_Used"))
	kBatchLevel = Application("Batch_Level")
	kNotebookLookup = CBool(Application("Notebook_Lookup"))

Dim fso
Set fso = Server.CreateObject("Scripting.FileSystemObject")

'********************************************************************************************
'FUNCTION NAME: BuildRegNum
'PURPOSE: build registry number based on corporate needs.
'CALLED BY: reg_ctbt_result_list.asp AND reg_ctbt_commit_result_form.asp
'INPUTS :	RootNumber, RS Object for gathering data, Connection Object for using AND TempRS for getting data
			'from Temp Table
'RETURNS: full corporate reg number
'CUSTOMIZATION: Change the final value of BuildRegNum that will be the corporate ID
'******************************************************************

Function BuildRegNum(ByVal dbkey, ByVal formgroup, ByVal RootNumber,ByVal tempID)
	Dim Temp_SaltCode, SaltName
	'stop
	if UCase(Application("Batch_Level")) = "SALT" then
		'if tempID = "reg_format" or tempid = "NO_TEMP_TABLE" then
		'SYAN modified on 10/19/2004 to fix CSBR-48404 
		if tempID = "reg_format" then
			Salt_Code = "1"
		Else
			'SYAN modified to fix Ben Bracke's salt loading problem
			if Session("SearchData" & "Temporary_Structures.Salt_Name" & dbkey & formgroup) <> "" then
				SaltName = Session("SearchData" & "Temporary_Structures.Salt_Name" & dbkey & formgroup)
				Salt_Code = GetSaltCodeFromSaltName(saltName)
			end if
	
			if Salt_Code = "" then
				Salt_Code = getValueFromTemp(dbkey, formgroup, "Salt_Code", tempID)
			end if
			'End of SYAN modification
		End if
			
		SaltName = getValueFromTable(dbkey, formgroup,"salts", "salt_code", Salt_Code, "salt_name")
		
		'SYAN rewrote on 5/27/2005 to fix CSBR-50860
	
		'BuildRegNum = RootNumber & Application("Reg_Delimiter") & SaltName
		
		'SYAN modified on 10/23/2005 to fix CSBR-59186
		'if IsEmpty(regDelimiter) then
		'	regDelimiter = Application("Reg_Delimiter")
		'end if
		'End of SYAN modification
		
		'SYAN added on 12/14/2005 to fix CSBR-62505
		'stop
		if IsNumeric(tempID) and (regDelimiter = "" or IsNull(regDelimiter) or IsEmpty(regDelimiter))then 
			if not isObject(Dataconn) then
				Set DataConn = GetNewConnection(dbkey, formgroup, "base_connection")
			end if
	
			sql = "select sequence.REG_DELIMITER from sequence, reg_numbers where sequence.sequence_id = reg_numbers.sequence_internal_id and Upper(reg_numbers.root_number) = ?"
		
			Set cmd = Server.CreateObject("adodb.command")
			cmd.ActiveConnection = RegConn
			cmd.CommandType = adCmdText
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("pRoot_Number", 200, 1, len(RootNumber), RootNumber)
		
			Set sequenceRS = Server.CreateObject("ADODB.Recordset")
			sequenceRS.Open cmd
	
			cmd.Parameters.Delete "pRoot_Number"
		
			if not (sequenceRS.BOF and sequenceRS.EOF) then
				sequenceRS.MoveFirst
				regDelimiter = sequenceRS("REG_DELIMITER")
			else
				regDelimiter = Application("Reg_Delimiter")
			end if
	
			sequenceRS.Close
			Set sequenceRS = nothing
		end if
		'End of SYAN modification
		
		BuildRegNum = RootNumber & regDelimiter & SaltName 'regDelimiter is a global variable. This is to avoid change of function signature.
		
		'End of SYAN modification
	else
		BuildRegNum = RootNumber 
	end if
End Function


Function GetOracleDate()
	' Returns the current date in an Oracle-friendly format
	Dim lsDate
	Dim lsMonth, lsDay, lsYear, ls3Month
	Dim lsNow
	Dim theMonths(13)

	theMonths(1)="Jan"
	theMonths(2)="Feb"
	theMonths(3)="Mar"
	theMonths(4)="Apr"
	theMonths(5)="May"
	theMonths(6)="Jun"
	theMonths(7)="Jul"
	theMonths(8)="Aug"
	theMonths(9)="Sep"
	theMonths(10)="Oct"
	theMonths(11)="Nov"
	theMonths(12)="Dec"
	
	lsNow = Date()
	lsMonth=CLng(Month(lsNow))
	ls3Month=theMonths(lsMonth)
	lsDay=Day(lsNow)
	lsYear=Year(lsNow)
	
	lsDate = lsDay & "-" & ls3Month & "-" & lsYear
	
	GetOracleDate = lsDate	
End Function


'********************************************************************************************
'FUNCTION NAME: buildRootNumber
'PURPOSE: build root number based on corporate needs - e.g. padding
'CALLED BY: do_commit AND others
'INPUTS :	dbkey
'			formgroup
'			seqID - uniqued id from tempRS for sequence to use in sequence table
'			RegConn, active connection object
'
'RETURNS: full root number 

'******************************************************************

Function padNumber(ByVal thePadLength, ByVal theNum)

	theNumLength = Len(Trim(theNum))
	zeroPadding = CLng(thePadLength - theNumLength)
	for i = 1 to zeroPadding
		if thePad <> "" then
			thePad ="0" & thePad 
		else
			thePad = "0"
		end if
	next
		
	theNumFinal =  thePad & theNum
		 
	PadNumber=theNumFinal 
End Function

'Function buildRootNumber(ByVal dbkey, ByVal formgroup,ByVal Prefix, ByVal RootNumberVal)
'	stop
'	RootLength = Len(Trim(RootNumberVal))
'	zeroPadding = CLng(Application("Root_Number_Length") - RootLength)
'	for i = 1 to zeroPadding
'		if thePad <> "" then
'			thePad ="0" & thePad 
'		else
'			thePad = "0"
'		end if
'	next
'	RootNumber = Prefix & Application("Prefix_Delimiter") & thePad & RootNumberVal
'		 
'	buildRootNumber=RootNumber 
'End Function

'SYAN rewrote on 5/27/2005 to fix CSBR-50860
Function buildRootNumber(ByVal dbkey, ByVal formgroup,ByVal Prefix, ByVal RootNumberVal)
	'stop
		
	if not isObject(dataconn) then
		Set DataConn = GetNewConnection(dbkey, formgroup, "base_connection")
	end if
	
	sql = "SELECT * FROM SEQUENCE WHERE PREFIX = '" & prefix & "'"
	
	set sequenceRS = DataConn.Execute(sql)
	
	if not (sequenceRS.BOF and sequenceRS.EOF) then
		sequenceRS.MoveFirst
		prefixDelimiter = sequenceRS("PREFIX_DELIMITER")
		RootNumberLength = sequenceRS("Root_Number_Length")
		regDelimiter = sequenceRS("REG_DELIMITER")
	else
		prefixDelimiter = Application("PREFIX_DELIMITER")
		RootNumberLength = Application("Root_Number_Length")
		regDelimiter = Application("Reg_Delimiter")
	end if
	
	sequenceRS.Close
	Set sequenceRS = nothing
	
	RootLength = Len(Trim(RootNumberVal))
	zeroPadding = CLng(CInt(RootNumberLength) - CInt(RootLength))
	for i = 1 to zeroPadding
		if thePad <> "" then
			thePad ="0" & thePad 
		else
			thePad = "0"
		end if
	next
	RootNumber = Prefix & prefixDelimiter & thePad & RootNumberVal
		 
	buildRootNumber=RootNumber 
End Function


Function buildSeqNumber(ByVal dbkey, ByVal formgroup, ByVal RootNumberVal)
	RootLength = Len(Trim(RootNumberVal))
	zeroPadding = CLng(Application("Root_Number_Length") - RootLength)
	for i = 1 to zeroPadding
		if thePad <> "" then
			thePad ="0" & thePad 
		else
			thePad = "0"
		end if
	next
	SeqNumber = thePad & RootNumberVal
		 
	buildSeqNumber=SeqNumber 
End Function



'********************************************************************************************
'FUNCTION NAME: getExample
'PURPOSE: Get an example of the reg or root number for showing in Add Batch, Salt AND identifiers forms.
'CALLED BY: get_registered.asp
'INPUTS: theRegtype = "RegNum" or "RootNum"
'RETURNS: a properly formatted number
'********************************************************************************************

Function getExample(dbkey, formgroup,theRegType)
	'stop
	'SYAN modified on 11/27/2006 to fix CSBR-61449
	PrefixValue = Application("DEFAULT_PREFIX")
	if IsNull(PrefixValue) or IsEmpty(PrefixValue) or PrefixValue = "" or UCase(PrefixValue) = "NULL" then
		PrefixValue=getValueFromTable(dbkey, formgroup,"sequence", "sequence_id","1", "prefix")
	end if
	'End SYAN modification
	
	'DGB 10/2003 added support for null prefix
	If Ucase(PrefixValue) = "NO PREFIX" then PrefixValue = ""
	Select Case UCase(theRegType)
		Case "ROOT_NUM"
			theResult = buildRootNumber(dbkey, formgroup, PrefixValue,1)
			'theResult = buildRegNum (dbkey, formgroup, RootNumber, "reg_format")
			'theResult = RootNumber 
		Case "REG_NUM"
			RootNumber = buildRootNumber(dbkey, formgroup, PrefixValue,1)
			theResult = buildRegNum (dbkey, formgroup, RootNumber, "reg_format")
		Case "SEQ_NUM"
			theSeqNumber = buildSeqNumber (dbkey, formgroup, 1) 
			theResult = theSeqNumber
	End Select
	getExample = theResult
End Function


'********************************************************************************************
'FUNCTION NAME: getPrimaryStrWhere
'NOTE: an initial check is always done with mol_id's AND prefix.  This 
'is the secondary dup check for further customization.
'PURPOSE: this is the function to change the relational data that is used for duplicate matching
'CALLED BY: checkForDuplicates
'INPUTS: dbkey = name of dataview (Application("appkey")), 
'		formgroup = formgroup in ini file from which data is gathered
'		TempTableID = the id from the temp table that identifies the record
'RETURNS: text for where clause
'CUSTOMIZATION NOTES: to change the relational information to check whether a 
'compound is a duplicate, alter the RelStrWhere returned by this function.
'********************************************************************************************

Function getPrimaryStrWhere (ByVal dbkey, ByVal formgroup, ByVal primaryStrWhereCriteria, ByVal TempTableID, ByVal ids)
	compound_table ="compound_molecule"
	compound_table_strucid = GetTableVal(dbkey, compound_table, kStrucFieldID)
	compound_table_baseid =  GetTableVal(dbkey, compound_table, kPrimaryKey)
		
	Select Case UCase(primaryStrWhereCriteria)
		Case "COMPOUND_ONLY" 
			if inStr(ids, ",")> 0 then
				' if more then one mol_id was found then use the IN clase
				RelStrWhere =  compound_table & "." & "MOL_ID"  & " IN (" & ids & ")" 
			else
				RelStrWhere = compound_table & "." & "MOL_ID" & "= " & ids 
			end if
		Session("SubForms" & dbkey & formgroup) = "compound_molecule" ' this is for building the final sql statement.  If you add another table, make sure it
		'is within this list (comma delimeted).
		Case "COMPOUND_PREFIX"
			'stop
			sequence_id =getValueFromTemp(dbkey, formgroup, "Sequence_ID", TempTableID)
			
			if Not Len(sequence_id)> 0 then
				RelStrWhere = ""
			else
				if inStr(ids, ",")> 0 then
					' if more then one mol_id was found then use the IN clase
					RelStrWhere =  compound_table & "." & "MOL_ID"  & " IN (" & ids & ") AND " & compound_table & ".sequence_internal_id=" & sequence_id
				else
					RelStrWhere = compound_table & "." & "MOL_ID" & "= " & ids & " AND " & compound_table & ".sequence_internal_id=" & sequence_id
				end if
			end if
		Session("SubForms" & dbkey & formgroup) = "compound_molecule" ' this is for building the final sql statement.  If you add another table, make sure it
		'is within this list (comma delimeted).
		Case "COMPOUND_PROJECT"
			
			project_id =getValueFromTemp(dbkey, formgroup, "Project_id", TempTableID)
			
			if Not Len(project_id)> 0 then
				RelStrWhere = ""
			else
				if inStr(ids, ",")> 0 then
					' if more then one mol_id was found then use the IN clase
					RelStrWhere =  compound_table & "." & "MOL_ID"  & " IN (" & ids & ") AND " & "compound_project.project_internal_id=" & project_id
				else
					RelStrWhere = compound_table & "." & "MOL_ID" & "= " & ids & " AND " & "compound_project.project_internal_id=" & project_id
				end if
			end if
			Session("SubForms" & dbkey & formgroup) = "compound_molecule,compound_project" ' this is for building the final sql statement.  If you add another table, make sure it
			'is within this list (comma delimeted).
		Case Else
			thefield = UCase(Application("Primary_StrWhere"))
			if thefield <> "" then
				thefield_val = getValueFromTemp(dbkey, formgroup,thefield, TempTableID)
				RelStrWhere = compound_table & "." & "MOL_ID" & "= " & ids & " AND " & " upper(" & compound_table & "." & thefield & ")='" & thefield_val & "'"
			else
				RelStrWhere = ""
			end if
		Session("SubForms" & dbkey & formgroup) = "compound_molecule" ' this is for building the final sql statement.  If you add another table, make sure it
		'is within this list (comma delimeted).
	end Select
	

	'return result
	getPrimaryStrWhere = RelStrWhere

End Function



Function NonCompoundDupCheck(dbkey, formgroup, thePrimaryStrWhereCriteria,TempTableID)
	thefield_array = Split(thePrimaryStrWhereCriteria, ":", -1)
	theTableandField = thefield_array(1)
	theTableandField_array = Split(theTableandField, ".", -1)
	
	theTable = theTableandField_array(0)
	theField = theTableandField_array(1)
	if UBound(thefield_array) > 1 then
		theTempField = thefield_array(2)
	else
		theTempField = theField
	end if
	if theField <> "" then
		if TempTableID = "NO_TEMP_TABLE" then
			if instr(UCase(theTempField), "TEMPORARY_STRUCTURES.")> 0 then
				thefield_val = request(theTempField)
			else
				thefield_val = request("TEMPORARY_STRUCTURES." & theTempField)
			end if
		else
			thefield_val =getValueFromTemp(dbkey, formgroup, theTempField, TempTableID)
		end if
		RelStrWhere = "upper(" & theTableandField & ")='" & thefield_val & "'"
	else
		RelStrWhere = ""
	end if
	Session("SubForms" & dbkey & formgroup) = theTable
	NonCompoundDupCheck = RelStrWhere
end Function 


'********************************************************************************************
'FUNCTION NAME: getValueFromTable
'PURPOSE: get a field value for given criteria - no joins
'CALLED BY: BuildRegNum AND others
'INPUTS :	dbkey = the database key(dbname)
'			formgroup = the formgroup
'			table_name = the name of the table
'			table_link_field = the name of the field 
'			table_link_value - the value to the linking field
'			return_field = the field from the recordset whose value you want.
'RETURNS: return_field value
'******************************************************************
Function getValueFromTable(ByVal dbkey, ByVal formgroup, ByVal table_name, ByVal table_link_field, ByVal table_link_value, ByVal return_field)	
	'open connection table_name
	if Not isObject(RegConn) then
		Set RegConn=GetRegConn(dbkey, formgroup)
	end if
	getValueFromTable =getValueFromTablewConn(RegConn, table_name, table_link_field, table_link_value, return_field)

End Function


'********************************************************************************************
'FUNCTION NAME: getSecondaryStrWhere
'NOTE: an initial check is always done with mol_id's AND prefix.  This 
'is the secondary dup check for further customization.
'PURPOSE: this is the function to change the relational data that is used for duplicate matching
'CALLED BY: checkForDuplicates
'INPUTS: dbkey = name of dataview (Application("appkey")), 
'		formgroup = formgroup in ini file from which data is gathered
'		TempTableID = the id from the temp table that identifies the record
'RETURNS: text for where clause
'CUSTOMIZATION NOTES: to change the relational information to check whether a 
'compound is a duplicate, alter the RelStrWhere returned by this function.
'********************************************************************************************

Function getSecondaryStrWhere (ByVal dbkey, ByVal formgroup, ByVal TempTableID, ByVal cpdID )
	'stop
	
	'SYAN added on 9/23/2005 to fix Ben Bracke's load salt problem.
	if Session("SearchData" & "Temporary_Structures.Salt_Name" & dbkey & formgroup) <> "" then
		saltName = Session("SearchData" & "Temporary_Structures.Salt_Name" & dbkey & formgroup)
		SaltCode = GetSaltCodeFromSaltName(saltName)
	end if
	
	if SaltCode = "" then
		SaltCode = getValueFromTemp(dbkey, formgroup, "Salt_Code", TempTableID)
	end if
	'End of SYAN modification
	
	StrWhere = "Compound_Salt.CPD_Internal_ID="& cpdID & " AND " & "Compound_Salt.salt_internal_id="  & SaltCode 
	Session("SubForms" & dbkey & formgroup) = "Compound_Salt"
	'return result
	getSecondaryStrWhere = StrWhere
End Function

'SYAN added on 9/23/2005 to fix Ben Bracke's load salt problem.
Function GetSaltCodeFromSaltName(sName)
	'stop
	Dim retVal
	
	if Not isObject(RegConn)  then
		Set RegConn = GetRegConn(dbkey, formgroup)
	end if
	
	Set SaltCodeRS = Server.CreateObject("ADODB.Recordset")
	
	sql = "select salt_code from salts where Upper(salt_name) = '" & UCase(sName) & "'"

	on error resume next
	SaltCodeRS.Open sql, RegConn
	
	if NOT (SaltCodeRS.EOF AND SaltCodeRS.BOF) then
		SaltCodeRS.MoveFirst
		retVal = SaltCodeRS("SALT_CODE")
	Else
		retVal = DefaultCode
	End if
	
	CloseRS(SaltCodeRS)
	
	GetSaltCodeFromSaltName = retVal
	
End Function
'End of SYAN modification
'DGB added on 8/20/2007 to fix invalid solvate id values
Function GetSolvateCodeFromSolvateName(sName)
	'stop
	Dim retVal
	
	if Not isObject(RegConn)  then
		Set RegConn = GetRegConn(dbkey, formgroup)
	end if
	
	Set SCodeRS = Server.CreateObject("ADODB.Recordset")
	
	sql = "select solvate_id from solvates where Upper(solvate_name) = '" & UCase(sName) & "'"

	on error resume next
	SCodeRS.Open sql, RegConn
	
	if NOT (SCodeRS.EOF AND SCodeRS.BOF) then
		SCodeRS.MoveFirst
		retVal = SCodeRS("SOLVATE_ID")
	Else
		retVal = DefaultCode
	End if
	
	CloseRS(SCodeRS)
	
	GetSolvateCodeFromSolvateName = retVal	
End Function
'End of DGB modification


'******************************************************************
'FUNCTION:	 checkForDuplicates
'PURPOSE:	called prior to commit. Checks if submitted structure is a duplicate
'			duplicate checking is based on the structure AND the prefix in the temp table.
'CALLED BY: DoRegCommit
'INPUTS:	dbkey = name of dataview
'			formgroup = name of formgroup in ini file to get data from
'			TempTableID = id that uniquely identifies record in temp table
'RETURNS:	the primary key(s) for the compound base table (compound_molecule) are returned if dups are found
'			AND the type of commit, batch or add_salt
'******************************************************************
Function checkForDuplicates(ByVal dbkey, ByVal formgroup, ByVal TempTableID, ByVal reg_mode, ByRef RegConn)
	'stop
	Dim cpdSaltReturned, Reg_IDReturned
	Session("DuplicateCompounds" & dbkey & formgroup) = ""
	Session("DuplicateSalts" & dbkey & formgroup)= ""
	Dim Compound_RegIDSReturned 
	Dim theResultStr 
	if Not isObject(RegConn) then
		set RegConn = getRegConn(dbkey, formgroup)
	end if
	' this variable is used to keep track of system duplicates when the RLS is invoked.
	Session("MarkAsDuplicateOnRegister")=""
	'pass-by gui
	Session("no_gui" & dbkey & formgroup) = True
	bMultipleCmpds = False
	primaryStrWhereCriteria = Application("Primary_StrWhere")

	'start BEFORE_COMPOUND: if before compound is in primary_strwhere in the cfserver.ini a search for a key field take precendence over the duplicate checking
	'duplicate checking will only be done if the key field is unique - otherwise the item is rejected as a duplicate
	if inStr(primaryStrWhereCriteria, "BEFORE_COMPOUND")> 0 then
		'stop
		primary_relData=NonCompoundDupCheck(dbkey, formgroup,primaryStrWhereCriteria,TempTableID)
		
		Compound_RegIDSReturned = doPrimaryDupsSearch(dbkey, formgroup,primary_relData,RegConn)
		if Compound_RegIDSReturned <> "" then
			NonCmpdDupCheckString = Compound_RegIDSReturned
		else
			Compound_RegIDSReturned = ""
			primaryStrWhere=""
			NonCmpdDupCheckString = ""
			primaryStrWhereCriteria = "COMPOUND_ONLY"
		end if
	End if

	if Not NonCmpdDupCheckString <> "" then
		outmolstr = doCompoundDupsSearch(dbkey, formgroup, "new", "moltable", TempTableID, RegConn)
	end if
	'end BEFORE_COMPOUND
	'perform search of mst file using molserver/csdo 
	if (outmolstr <> "" and Not inStr(UCase(outmolstr), "ERROR")> 0) OR NonCmpdDupCheckString <> "" then
		'get strWhere that contains the prefix.  This is used to determine whether
		'a duplicate compound should be commited since it differs in prefix.
		if Not NonCmpdDupCheckString <> "" then
			'build a strWhere clause based on the primary_strwhere in the cfserver.ini. This allows for duplicates
			'that are possibly in the system but not for a particular prefix, project, etc.
			
			primary_relData = getPrimaryStrWhere(dbkey, formgroup, primaryStrWhereCriteria, TempTableID, outmolstr)
			'return the reg_ids for the duplicate + field check
			
			'stop
			Compound_RegIDSReturned = doPrimaryDupsSearch(dbkey, formgroup,primary_relData,RegConn)
			'CSBR-55879 comment the if statement out to have it add entries to DUPLICATES table
			'if not Compound_RegIDSReturned <> "" then
				'populate the system duplicates variable since one or more of the items was found to be a duplicate base
				'on the primary strWhere clause. This data is later used after the commit to add items to the duplicates table
				'for administrative tracking of system duplicates.
				Session("MarkAsDuplicateOnRegister") = outmolstr
			'end if
		else
			Compound_RegIDSReturned = NonCmpdDupCheckString
		end if
		
		Session("DuplicateCompounds" & dbkey & formgroup) = Compound_RegIDSReturned
		Select Case UCase(reg_mode)
			'Case "BATCH_MODE" 
				'if Compound_RegIDSReturned <> "" then
					'theResultStr = "duplicates_found" & Compound_RegIDSReturned ' don't go any farther if batch mode
				'else
					'theResultStr = ""
				'end if
			Case "SINGLE_MODE", "BATCH_MODE"  
				'if Compound_RegIDSReturned <> "" then 'there is a duplicate compound/prefix or project etc...
				'	compoundArray = Split(Compound_RegIDSReturned, ",", -1)
				'	For i = 0 to UBound(compoundArray)
				'		if UCase(Application("Batch_Level")) = "SALT" then
				'			
				'			'SYAN modified on 8/30/2004 to fix CSBR-47199
				'			''get strWhere clause for the secondary search to perform basde on a structure
				'			''AND prefix, project etc...  found.  If a dup is found here then user will
				'			''be prompted with add batch, edit strucutre AND skip.  Otherwise,
				'			''a new salt will be added for the compound root number found in
				'			''the last search.
				'			stop
				'			'cpd_id=GetValueFromTable(dbkey, formgroup,"REG_NUMBERS","reg_id",compoundArray(i),"cpd_internal_id")
				'			cpd_id=GetValueFromTable(dbkey, formgroup,"REG_NUMBERS","reg_id",compoundArray(i),"reg_id")
				'			
				'			secondary_relData = getSecondaryStrWhere(dbkey, formgroup, TempTableID, cpd_id)
				'							
				'			Reg_IDReturned = doSecondaryDupsSearch(dbkey, formgroup, secondary_relData)
				'			'Reg_IDReturned = compoundArray(i)
				'			'End of SYAN modification
				'			Session("DuplicateSalts" & dbkey & formgroup) = Reg_IDReturned
				'		Else
				'			Reg_IDReturned = compoundArray(i) ' makes compound the batch level
				'
				'		End if
				'		'build return string
				'		if  Reg_IDReturned <> "" then 'new batch
				'			if theResultStr <> "" then
				'				theResultStr = theResultStr & "," & "Batch_Commit" & ":" &  Reg_IDReturned
				'			else
				'				theResultStr = "Batch_Commit" & ":" &  Reg_IDReturned
				'			end if 
				'		Else
				'			'SYAN modified on 9/19/2005 to fix CSBR-47199 more thoroughly
				'			'if UCase(Application("Batch_Level")) <> "SALT" then
				'			'End of SYAN modification
				'				if Not Reg_IDReturned <> "" then 'new salt
				'					cpd_id=GetValueFromTable(dbkey, formgroup,"REG_NUMBERS","reg_id",compoundArray(i),"cpd_internal_id")
				'					if theResultStr <> "" then
				'						theResultStr = theResultStr & "," & "Add_Salt" & ":" &  cpd_id
				'					else
				'						theResultStr = "Add_Salt" & ":" & cpd_id
				'					end if 
				'				Else
				'					if Not Compound_RegIDSReturned <> "" then
				'						if theResultStr <> "" then
				'							theResultStr = theResultStr & "," & ""
				'						else
				'							theResultStr = ""
				'						end if
				'					End if
				'				End if
				'			'SYAN modified on 9/19/2005 to fix CSBR-47199 more thoroughly
				'			'End if
				'			'End of SYAN modification
				'
				'		End if
				'	Next 'i
				'Else 'Compound_RegIDSReturned <> ""
				''there is no duplicate
				'theResultStr = ""
			'End if 'Compound_RegIDSReturned <> ""
		
			'=======================================
			'SYAN rewrote on 9/19/2005 to fix CSBR-59182
			if Compound_RegIDSReturned <> "" then 'there is a duplicate compound/prefix or project etc...
					compoundArray = Split(Compound_RegIDSReturned, ",", -1)
					For i = 0 to UBound(compoundArray)
						if UCase(Application("Batch_Level")) = "SALT" then
							'stop
							cpd_id=GetValueFromTable(dbkey, formgroup,"REG_NUMBERS","reg_id",compoundArray(i),"cpd_internal_id")
							secondary_relData = getSecondaryStrWhere(dbkey, formgroup, TempTableID, cpd_id)
							Reg_IDReturned = doSecondaryDupsSearch(dbkey, formgroup, secondary_relData)
							Session("DuplicateSalts" & dbkey & formgroup) = Reg_IDReturned
							
							if Reg_IDReturned <> "" then 'new batch
								if theResultStr <> "" then
									theResultStr = theResultStr & "," & "Batch_Commit" & ":" &  Reg_IDReturned
								else
									theResultStr = "Batch_Commit" & ":" &  Reg_IDReturned
									exit for
								end if 
							else
								if Reg_IDReturned = "" then 'new salt
									cpd_id = GetValueFromTable(dbkey, formgroup, "REG_NUMBERS", "reg_id", compoundArray(i), "cpd_internal_id")
									if theResultStr <> "" then
										theResultStr = theResultStr & "," & "Add_Salt" & ":" &  cpd_id
									else
										theResultStr = "Add_Salt" & ":" & cpd_id
										exit for
									end if 
								End if
							end if
						
						else 'UCase(Application("Batch_Level")) <> "SALT"
							Reg_IDReturned = compoundArray(i) ' makes compound the batch level

							if Reg_IDReturned <> "" then 'new batch
								if theResultStr <> "" then
									theResultStr = theResultStr & "," & "Batch_Commit" & ":" &  Reg_IDReturned
								else
									theResultStr = "Batch_Commit" & ":" &  Reg_IDReturned
								end if 
							end if
						end if
					Next 'i
				Else 'Compound_RegIDSReturned <> ""
				'there is no duplicate
				theResultStr = ""
			End if 'Compound_RegIDSReturned <> ""
			'End of SYAN modification
		End Select
	Else
		'there where no duplicate structures
		if outmolstr = "" then
			theResultStr = ""
		else
			theResultStr = "parsing_errors_found" & "" ' don't go any farther if batch mode
		end if
	End if 
	
	checkForDuplicates = theResultStr
	
	'set these constants so errors will not be returned
	Session("fEmptyRecordset" & dbkey & formgroup) = False
	Session("error" & dbkey & formgroup)= False
	Session("no_gui" & dbkey & formgroup) = False

End Function	




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'GetMoleculeParamsAsString(MoleculeAsArray byRef)
'Returns string with text required to pass a molecule to
'the cartridge as parametrized ADO operators.
'It uses the xarray constructor syntax if needed.  
Function GetMoleculeParamsAsString(byRef MoleculeAsArray)
	Dim numSegments, buff, i
	
	numSegments = Ubound(MoleculeAsArray) + 1
	if numSegments = 2 then
		buff = "?,?"
	Else
		buff = "CsCartridge.XArray("
		For i = 1 to numSegments -1
			buff = buff & "?,"
		Next
		buff = buff & "?)"
	 End if
	 GetMoleculeParamsAsString = buff
End function

'''''''''''''''''''''''''''''''''''''''''''''''
'Function ConvertStrToArray(str, segmentLength)
'Breaks a string into segments and returns and  
'an array of string segments
Function ConvertStrToArray(str, segmentLength)
	dim n, pos, i, si, buff, del
	
	del = "|~"
	n = Len(str) 'number of characters
	pos = 1 'starting position
	i = 0 'starting index		
	while pos < n 
		si = Mid(str, pos, segmentLength)
		if buff <> "" then
			buff = buff & del & si
		else
			buff = si
		end if
		pos = pos + segmentLength 
		i = i + 1 
	wend
	'add an extra delimeter to the end to ensure a minimum of two segments
	if n <= segmentLength then buff = buff & del
	ConvertStrToArray = split(buff, del)	
	'ConvertStrToArray = buff
End function

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'AddMoleculeParametersToADOCommand(cmd byref, MoleculeAsArray byRef)
'Creates appends and populates parameters used to pass a molecule to
'the the cscartridge using ADO.
'Since Oracle parameters must be passed in the expected order, this  
'sub needs to be called at the appriate place in the parameter population
'process
Sub AddMoleculeParametersToADOCommand(byref cmd, byRef MoleculeAsArray)
	Dim i, parValue
	
	For i = 0 to Ubound(MoleculeAsArray)
		Cmd.Parameters.Append Cmd.CreateParameter("xpar" & i, adLongVarchar, adParamInput, Len(MoleculeAsArray(i)) + 1, MoleculeAsArray(i))
	Next
End sub

'******************************************************************
'FUNCTION:	doCompoundDupsSearch
'PURPOSE:	called to perform Cartridge search. 
'CALLED BY: checkForDuplicates
'INPUTS:	dbkey = name of dataview
'			formgroup = name of formgroup in ini file to get data from
'			reltype = what type of search to perform.  This is normally "new"
'			tablename= the name of the table for the cartridge to search			
'			TempTableID = id that uniquely identifies record in temp table
'RETURNS:	the structure id(s) from the commit moltable (compound_molecule) are returned if dups are found
'******************************************************************

Function doCompoundDupsSearch(dbkey, formgroup, reltype, tablename, TempTableID, ByRef RegConn)
	Session("ContentsField" & dbkey & formgroup)=""
	if UCase(TempTableID) = "NO_TEMP_TABLE" then
		Base64Str=trim(request("temporary_structures.structure"))
	else
		Base64Str = getValueFromTemp(dbkey, formgroup, "BASE64_CDX", TempTableID )
	end if
	
	if Not isObject(RegConn) then
		set RegConn= getRegConn(dbkey, formgroup)
	end if
	on error resume next
	DupStr=DoCartridgeDuplicateSearch(dbkey, formgroup, "STRUCTURES.BASE64_CDX", Base64Str,  RegConn,"MOL_ID")
	if DupStr<> "" then
		on error resume next
		mypath = Application("TempFileDirectory" & dbkey) & "SessionDir\" & Session.SessionID & "\compound_moleculeStructure" & ".cdx"
		Session("RegCandidateStructurePath" & dbkey)=mypath
		DecodeBase64 Base64Str, mypath
	end if
	if err.number <> 0 then
		logaction("doCompoundDupsSearch" & err.number & err.Description)
	end if
	doCompoundDupsSearch = DupStr
End Function

'********************************************************************************************
'FUNCTION NAME: doPrimaryDupsSearch
'PURPOSE: this is performs a search with structure ids  AND the prefix in the tempstable
'CALLED BY: doPrimaryDupsSearch
'INPUTS: dbkey = name of dataview (Application("appkey")), 
'		formgroup = formgroup in ini file from which data is gathered
'		ids = the structure ids from a chemfinder search
'		relData = relational string for Where Clause of search
'RETURNS: root_number if compound - prefix criteria is matched.
'********************************************************************************************


Function doPrimaryDupsSearch(ByVal dbkey, ByVal formgroup, ByVal prefixrelData, ByRef RegConn)

	compound_table =Application(formgroup & dbkey & "RegCommitBaseTable")
	compound_table_strucid = GetTableVal(dbkey, compound_table, kStrucFieldID)
	compound_table_baseid =  GetTableVal(dbkey, compound_table, kPrimaryKey)
	'create full sql for search
	
	
	fullselect = BuildSelectStatement(dbkey, formgroup, "reg_numbers", Session("SubForms" & dbkey & formgroup), "Reg_ID","")
	
	fullSQl = fullselect  & prefixrelData

	'fullselect = BuildSelectStatement(dbkey, formgroup, compound_table, Session("SubForms" & dbkey & formgroup), compound_table_baseid,"")
	'fullSQl = fullselect  & prefixrelData
	on error resume next
	if Not isObject(RegConn) then
		set RegConn = getRegConn(dbkey, formgroup)
	end if
	set rs = RegConn.Execute(fullSQL)
	if not (rs.BOF and rs.EOF) then
		do while not rs.EOF
			If theResult = "" then
				theResult = rs.Fields("reg_id")
			else	
				theResult = theResult & "," & rs.Fields("reg_id")
			end if
			rs.MoveNext
		loop
		CloseRS(rs)
	else
		theResult = ""
	end if
	doPrimaryDupsSearch = theResult
End Function	

'********************************************************************************************
'FUNCTION NAME: doSecondaryDupsSearch
'PURPOSE: this is performs a secondary search that occurs after a compound/prefix has been found.
' this search determines is a new batch or new salt should be added(this is the current
'implementation - e.g. checking for salt, but this is the function to customize
'if you want to further identifiy a duplicate by other data
'CALLED BY: checkForDuplicates
'INPUTS: dbkey = name of dataview (Application("appkey")), 
'		formgroup = formgroup in ini file from which data is gathered
'		ids = the root_number returned from 
'		relData = relational string for Where Clause of search
'RETURNS: reg_id for compound-salt found
'********************************************************************************************
Function doSecondaryDupsSearch(byval dbkey, byval formgroup, byVal secondaryRelData)
	'create full sql for search
	fullselect = BuildSelectStatement(dbkey, formgroup, "reg_numbers", Session("SubForms" & dbkey & formgroup), "Reg_ID","")
	fullSQl = fullselect  & secondaryRelData

	if Not isObject(RegConn)  then
		Set RegConn = GetRegConn(dbkey, formgroup)
	end if
	Set DupsRS = Server.CreateObject("ADODB.Recordset")
	on error resume next
	DupsRS.Open fullSQL, RegConn
	
	if NOT (DupsRS.EOF AND DupsRS.BOF) then
		DupsRS.MoveFirst
		if theResult <> "" then
			theResult = theResult & "," & DupsRS("reg_id")
		else
			theResult = DupsRS("reg_id")
		end if
		
		CloseRS(DupsRS)
		'CloseConn(DupsConn)
	Else
		theResult = ""
	End if
	doSecondaryDupsSearch = theResult
	
end function

'********************************************************************************************
'FUNCTION NAME: getDuplicateAction
'PURPOSE: redirect to dups window form user input. 
'		send the user back to the same page where they clicked the register button
'		a flag is attached that indicates question about duplicate is asked
'		the current location is stored for later use once user makes a duplicate action decision
'CALLED BY: DoRegCommit
'INPUTS: dbkey = name of dataview (Application("appkey")), 
'		formgroup = formgroup in ini file from which data is gathered
'		duplicateids = the primary key of the compound table found in the duplicates check
'		tempId = primary key of the temporary table for the record that is the commit candidate
'send the user back to the same page where they clicked the register button
'a flag is attached that indicates question about duplicate is asked
'******************************************************************
Sub getDuplicateAction(dbkey, formgroup)
	Session("PreDupCheckLocation" & dbkey) = Request("CurrentLocation")
	TimerVal = Timer
	if inStr(Session("PreDupCheckLocation" & dbkey) , "&DupCheckStart=true")> 0 then
		thearray = Split(Session("PreDupCheckLocation" & dbkey), "&DupCheckStart=true", -1)
		basestring = thearray(0)
		Session("CurrentLocation" & dbkey & formgroup) = basestring & "&DupCheckStart=true&uniqueid=" & TempTableID & "&Timer=" & TimerVal & "&duplicates_check=true"
	else
		Session("CurrentLocation" & dbkey & formgroup) = Session("PreDupCheckLocation" & dbkey) & "&DupCheckStart=true&uniqueid=" & TempTableID & "&Timer=" & TimerVal & "&duplicates_check=true"
	end if
	redirectpath=Session("CurrentLocation" & dbkey & formgroup)
	

	if detectNS4 = true or detectIE5()= true then
		response.redirect redirectpath
	else
		DoRedirect dbkey, redirectpath
	end if
	
End Sub	


'********************************************************************************************
'FUNCTION NAME: checkRegTracking
'PURPOSE: check whether a record has been process when displayed in list or form view
'CALLED BY: reg_ctbt_result_list.asp and reg_ctbt_commit_result_form.asp
'INPUTS :	uniqueid = baseid of record being displayed
'RETURNS: returns a value if id found in list (Session('RegTrackingStr & dbkey & formgroup) or empty if not
'******************************************************************
Function checkRegTracking(uniqueid)
	on error resume next
	id_found = "" 'set initial value
	commit_results = Split(Session("RegTrackingStr" & dbkey), ";",-1)
	for i = 1 to UBound(commit_results) 'skip 0 index since it is always 0
		temp = split(commit_results(i), ",", -1)
		if CLng(uniqueid) = CLng(temp(1))then
			id_found = commit_results(i)
		end if
	next
	checkRegTracking = id_found
End Function



Function checkDupTracking(uniqueid)
	id_found = "" 'set initial value
	commit_results = Split(Session("DupTrackingStr" & dbkey), ";",-1)
	for i = 1 to UBound(commit_results) 'skip 0 index since it is always 0
		temp = split(commit_results(i), ",", -1)
		if CLng(uniqueid) = CLng(temp(1))then
			id_found = commit_results(i)
		end if
	next
	checkDupTracking = id_found
End Function


'********************************************************************************************
'FUNCTION NAME: RegMessageOutput
'PURPOSE: writes appropriate message for compound that is registerd
'CALLED BY: reg_ctbt_result_list.asp and reg_ctbt_commit_result_form.asp
'INPUTS :	compound_registerd = baseid of record that is registerd
'RETURNS: writes an appropriate message depending on the original commit_type 
'******************************************************************

Function RegMessageOutput(compound_registered)
	theMsg = buildRegMessage(compound_registered, "output")
	RegMessageOutput = theMsg
End Function

Function determinePostRegScreen(compound_registered)
	dim returnboolean
	on error resume next
	temp = Split(compound_registered, ",", -1)	
	msg_type = temp(0)
	Select Case msg_type
		Case "full_commit"
			returnBoolean = true
		Case "batch_only"
		    returnBoolean = true
		Case "add_identifiers"
			returnBoolean = true
		Case "skip"
			returnBoolean = false
		Case "record_deleted"
			returnBoolean = false
		Case "temp_missing"
			returnBoolean = false
		Case "add_salt"
			returnBoolean = true
		Case "duplicate_found"
			returnBoolean = false
		Case "multiple_duplicates_found"
			returnBoolean = false
		Case "parsing_errors_found"
			returnBoolean = false
		case "unapproved_compound_with_duplicates"
			returnBoolean = false
		case "unapproved_compound_no_duplicates"
			returnBoolean = false
	End Select
	on error goto 0
	determinePostRegScreen = returnBoolean
End function 


Function buildRegMessage(string_input, output_type)
	on error resume next
	temp = Split(string_input, ",", -1)	
	msg_type = temp(0)
	temp_id = temp(1)
	Reg_number = temp(2)
	Batch_Number = temp(3)
	reg_id = temp(4)
	cpdDBCounter = temp(5)
	
	if Not isObject(RegConn) then
		Set RegConn = getRegConn(dbkey, formgroup)
	end if
	Select Case msg_type
		Case "full_commit"
			theMsg = "This compound was successfully registered.<br><br>"
			if output_type = "log" then
				theMsg = theMsg & "Temp Table ID: " & temp_id& "<br>"
			end if
			theMsg = theMsg & "Registration Number: " & Reg_number & "<br>"
			theMsg = theMsg & "Batch Number: " & padNumber(Application("BATCH_NUMBER_LENGTH_GUI"),Batch_Number) & "<br>"
			if not Ucase(Request("formmode")) = "LIST" then
				GetRegData RegConn,reg_id, cpdDbCounter,"Reg_Number"
			end if
			'theMsg = theMsg & "Registration Number: " & Reg_number & "/" & PadNumber(3,Batch_Number) & "<br>"
			
		Case "batch_only"
		    theMsg =  "A new batch was successfully added for this compound.<br><br>"
			if output_type = "log" then
				theMsg = theMsg & "Temp Table ID: " & temp_id& "<br>"
			end if
			theMsg = theMsg & "Registration Number: " & Reg_number & "<br>"
			theMsg = theMsg & "Batch Number: "  & padNumber(Application("BATCH_NUMBER_LENGTH_GUI"),Batch_Number) & "<br>"
			if not Ucase(Request("formmode")) = "LIST" then
				GetRegData RegConn,reg_id, cpdDbCounter,"Reg_Number"
			end if
			
		Case "add_identifiers"
		    theMsg =  "Identifiers where successfully added for this compound.<br><br>"
			if output_type = "log" then
				theMsg = theMsg & "Temp Table ID: " & temp_id& "<br>"
			end if
			theMsg = theMsg & "Registration Number: " & Reg_number & "<br>"
				'GetRegData(RegConn,reg_id, cpdDbCounter,Reg_num)
		Case "skip"
			theMsg =  "This record has been skipped.<br><br>"
			if output_type = "log" then
				theMsg = theMsg & "Temp Table ID: " & temp_id& "<br>"
			end if
		Case "record_deleted"
			theMsg =  "This record was deleted from the temporary table.<br><br>"
			if output_type = "log" then
				theMsg = theMsg & "Temp Table ID: " & temp_id& "<br>"
			end if
		Case "temp_missing"
			theMsg =  "The record was no longer in the temporary table.<br>"
			theMsg = theMsg & "Another may have commited or deleted it.<br><br>"
			if output_type = "log" then
				theMsg = theMsg & "Temp Table ID: " & temp_id& "<br>"
			end if
		Case "add_salt"
			theMsg =  "A new salt was successfully added to the parent compound.<br><br>"
			theMsg = theMsg  & "New Registration Number: " & Reg_number &"<br>"
			theMsg = theMsg & "Batch Number: " & Batch_Number & "<br>"
			if output_type = "log" then
				theMsg = theMsg & "Temp Table ID: " & temp_id& "<br>"
			end if
			if not Ucase(Request("formmode")) = "LIST" then
				GetRegData RegConn,reg_id, cpdDbCounter,"Reg_Number"
			end if
		Case "duplicate_found"
			theMsg =  "This compound has duplicates and could not be registered without user input.<br><br>"
			if output_type = "log" then
				theMsg = theMsg & "Temp Table ID: " & temp_id& "<br>"
			end if
			theMsg =  theMsg  & "Please register this compound manually where you will be given "&"<br>"
			theMsg =  theMsg  & "options for processing the duplicate.<br><br>"
			
		Case "unapproved_compound_with_duplicates"
			theMsg =  "The duplicate for this compound is not approved. A batch could not be added.<br><br>"
			if output_type = "log" then
				theMsg = theMsg & "Temp Table ID: " & temp_id& "<br>"
			end if
			if not Ucase(Request("formmode")) = "LIST" then
				GetRegData RegConn,reg_id, cpdDbCounter,"Reg_Number"
			end if
		Case "unapproved_compound_no_duplicates"
			theMsg =  "This compound is unapproved. A batch cannot be added.<br><br>"
			if output_type = "log" then
				theMsg = theMsg & "Temp Table ID: " & temp_id& "<br>"
			end if
			if not Ucase(Request("formmode")) = "LIST" then
				GetRegData RegConn,reg_id, cpdDbCounter,"Reg_Number"
			end if
		Case "multiple_duplicates_found"
			theMsg =  "This compound has multiple_duplicates and could not be registered without user input.<br><br>"
			if output_type = "log" then
				theMsg = theMsg & "Temp Table ID: " & temp_id& "<br>"
			end if
			theMsg =  theMsg  & "Please register this compound manually where you will be given "&"<br>"
			theMsg =  theMsg  & "options for processing the duplicate.<br><br>"

		Case "parsing_errors_found"
			theMsg =  "This compound cannot be registered due to parsing errors.<br><br>"
			if output_type = "log" then
				theMsg = theMsg & "Temp Table ID: " & temp_id& "<br>"
			end if
			theMsg =  theMsg  & "Common parsing errors include:" & "<br>"
			theMsg =  theMsg  & "a. atom labels that are in lowercase. Form example, ""oh"" rather then ""OH"".<br>"
			theMsg =  theMsg  & "b. captions that do not have formula style applied.  For example, ""Na2SO4"" rather then ""Na<SUB>2</SUB>SO<SUB>4</SUB>""<br><br>"
			theMsg =  theMsg  & "Please edit the Structure and then try to register again.<br><br>"

	End Select
	on error goto 0
	buildRegMessage = theMsg

end function 



'********************************************************************************************
'FUNCTION NAME: DoRegTemp
'PURPOSE: call addreltoTemp for adding data to temp table, and stroing and setting return path once complete.
'CALLED BY: form_action_vbs.asp action = add_record 
'INPUTS :	dbkey
'			formgroup
'RETURNS: recordid of new temp table record
'******************************************************************
Function DoRegTemp(ByVal dbkey, ByVal formgroup, ByVal commit_type) 
	'stop
	Session("Reagent_is_Duplicate")=false
	Session("Current_Reg_Number")= ""
	Session("DateTime_Stamp") = Time() &  ":" &  Date()
	'default to full_commit if no value if found
	if not commit_type <> "" then commit_type = "FULL_COMMIT"
	'add relational and structureal data to temporary table
	
	tempID = AddRelToTemp(dbkey, formgroup, commit_type)
	

	'determine page for return based on commit_type
	Select Case UCase(commit_type)
		Case "FULL_COMMIT"
			Select Case UCase(formgroup)
				case "REG_CTRBT_FORM_GROUP"
					reg_input_form =Application("AppPathHTTP") & "/" & dbkey & "/" & GetFormGroupVal(dbkey, formgroup, kInputFormPath)
				
					if request("button_override") <> "" and not instr(Session("PreAddLocation" & dbkey), "button_override") >0  then
						Session("PreAddLocation" & dbkey)= reg_input_form & "?formgroup=reg_ctrbt_form_group&formmode=add_compounds&dbname=reg" & "&button_override=" & request("button_override") & "&preserve_items=" & request("preserve_items")
					else
						Session("PreAddLocation" & dbkey)= reg_input_form & "?formgroup=reg_ctrbt_form_group&formmode=add_compounds&dbname=reg" 
					end if
					
					Session("CurrentLocation" & dbkey & formgroup) =Session("PreAddLocation" & dbkey) & "&record_added=true&commit_type=full_commit&Timer=" & Timer()

				case "ADD_REAGENT_CTRBT_FORM_GROUP"
					If  CBool(Application("Reagents_To_Temp")) = False then
						Session("DuplicatesFound" & dbkey) = ""
						Session("RegCandidateStructurePath" & dbkey)=""
						commit_unique_id = ""
						Session("tempUniqueID" & dbkey)=tempID
						tableorder = "Compound_Molecule,Reg_Numbers,Compound_Salt,Structures,Compound_Project"	
						
						duplicates_found = checkForDuplicates(dbkey, "REG_CTRBT_COMMIT_FORM_GROUP", tempID, "SINGLE_MODE","") 'returns number of duplicates found
						
						
						if duplicates_found <> "" then
							if CBool(Application("REAGENT_BYPASS_DUPLICATES")) = True then
								commit_numbers = DoCommit(dbkey, "REG_CTRBT_COMMIT_FORM_GROUP", tableorder, Session("tempUniqueID" & dbkey), commit_uniqueid, "full_commit", "")
								temp_array = split(commit_numbers, ":", -1)
								reg_number = temp_array(0)
								RemoveFromTemp dbkey, formgroup, Session("tempUniqueID" & dbkey),""
								reg_input_form =Application("AppPathHTTP") & "/" & dbkey & "/" & GetFormGroupVal(dbkey, formgroup, kInputFormPath)
								Session("PreAddLocation" & dbkey)= reg_input_form & "?formgroup=add_reagent_ctrbt_form_group&formmode=add_compounds&dbname=reg"
								Session("CurrentLocation" & dbkey & formgroup) =Session("PreAddLocation" & dbkey) & "&record_added=true&commit_type=full_commit&reg_number="& reg_number
							else
								Session("Reagent_is_Duplicate")=TRUE
								reg_input_form =Application("AppPathHTTP") & "/" & dbkey & "/" & GetFormGroupVal(dbkey, formgroup, kInputFormPath)
								Session("PreAddLocation" & dbkey)= reg_input_form & "?formgroup=add_reagent_ctrbt_form_group&formmode=add_compounds&dbname=reg"
								Session("CurrentLocation" & dbkey & formgroup) =Session("PreAddLocation" & dbkey) & "&record_added=false&commit_type=full_commit"
							end if
						else
								commit_numbers = DoCommit(dbkey, "REG_CTRBT_COMMIT_FORM_GROUP", tableorder, Session("tempUniqueID" & dbkey), commit_uniqueid, "full_commit", "")
								temp_array = split(commit_numbers, ":", -1)
								reg_number = temp_array(0)
								RemoveFromTemp dbkey, formgroup, Session("tempUniqueID" & dbkey) ,""
								reg_input_form =Application("AppPathHTTP") & "/" & dbkey & "/" & GetFormGroupVal(dbkey, formgroup, kInputFormPath)
								Session("PreAddLocation" & dbkey)= reg_input_form & "?formgroup=add_reagent_ctrbt_form_group&formmode=add_compounds&dbname=reg"
								Session("CurrentLocation" & dbkey & formgroup) =Session("PreAddLocation" & dbkey) & "&record_added=true&commit_type=full_commit&reg_number="& reg_number
						end if
					else
						reg_input_form =Application("AppPathHTTP") & "/" & dbkey & "/" & GetFormGroupVal(dbkey, formgroup, kInputFormPath)
						Session("PreAddLocation" & dbkey)= reg_input_form & "?formgroup=add_reagent_ctrbt_form_group&formmode=add_compounds&dbname=reg"
						Session("CurrentLocation" & dbkey & formgroup) =Session("PreAddLocation" & dbkey) & "&record_added=true&commit_type=full_commit"
					end if
				case else
					reg_input_form =Application("AppPathHTTP") & "/" & dbkey & "/" & GetFormGroupVal(dbkey, formgroup, kInputFormPath)
					Session("PreAddLocation" & dbkey)= reg_input_form & "?formgroup=reagent_ctrbt_form_group&formmode=add_compounds&dbname=reg"
					Session("CurrentLocation" & dbkey & formgroup) =Session("PreAddLocation" & dbkey) & "&record_added=true&commit_type=full_commit&Timer=" & Timer()
			end select
		
		Case "EDIT_TEMP"
			reg_input_form =Application("AppPathHTTP") & "/" & dbkey & "/" & GetFormGroupVal(dbkey, formgroup, kInputFormPath)
			Session("PreAddLocation" & dbkey)= reg_input_form & "?formgroup=reg_ctrbt_form_group&formmode=add_compounds&dbname=reg"
			Session("CurrentLocation" & dbkey & formgroup) =Session("PreAddLocation" & dbkey) & "&record_added=true&commit_type=edit_temp"

		Case "BATCH_COMMIT"
			
			If  CBool(Application("Batches_To_Temp")) = False then
				 commit_id =DoRegCommit(dbkey, formgroup, "single_mode", tempID, "", "","")
			end if
			reg_input_form =Application("AppPathHTTP") & "/" & dbkey & "/" & GetFormGroupVal(dbkey, formgroup, kInputFormPath)
			if UCase(request("BATCH_ADD_FROM_RESULTS"))<> "" then
				Session("CurrentLocation" & dbkey & formgroup) = Session("PreBatchAddLocation"  & dbkey & request("BATCH_ADD_FROM_RESULTS"))
				
			else
				Session("PreAddLocation" & dbkey)= "/" & Application("appkey") & "/source/get_registered.asp" &  "?formgroup=batch_ctrbt_form_group&formmode=get_registered&dbname=reg"
				Session("CurrentLocation" & dbkey & formgroup) =Session("PreAddLocation" & dbkey) & "&record_added=true&commit_type=batch_commit"
			end if
		Case "EDIT_STRUCTURE"
			reg_input_form =Application("AppPathHTTP") & "/" & dbkey & "/" & GetFormGroupVal(dbkey, formgroup, kInputFormPath)
			Session("PreAddLocation" & dbkey)= reg_input_form & "?formgroup=reg_ctrbt_form_group&formmode=add_compounds&dbname=reg"
			Session("CurrentLocation" & dbkey & formgroup) =Session("PreAddLocation" & dbkey) & "&record_added=true&commit_type=edit_structure"

		Case "ADD_IDENTIFIERS"
			if CBool(Application("Identifiers_To_Temp")) = false then
				 commit_id =DoRegCommit(dbkey, formgroup, "single_mode", tempID, "", "","")
			end if
			reg_input_form =Application("AppPathHTTP") & "/" & dbkey & "/" & GetFormGroupVal(dbkey, formgroup, kInputFormPath)
			Session("PreAddLocation" & dbkey)= "/" & Application("appkey") & "/source/get_registered.asp" &  "?formgroup=identifier_ctrbt_form_group&formmode=get_registered&dbname=reg"
			Session("CurrentLocation" & dbkey & formgroup) =Session("PreAddLocation" & dbkey) & "&record_added=true&commit_type=add_identifiers"
		
		Case "ADD_SALT"
			reg_input_form =Application("AppPathHTTP") & "/" & dbkey & "/" & GetFormGroupVal(dbkey, formgroup, kInputFormPath)
			Session("PreAddLocation" & dbkey)= "/" & Application("appkey") & "/source/get_registered.asp" &  "?formgroup=salt_ctrbt_form_group&formmode=get_registered&dbname=reg"
			Session("CurrentLocation" & dbkey & formgroup) =Session("PreAddLocation" & dbkey) & "&record_added=true&commit_type=add_salt"

	End Select
		
	DoRegTemp = tempID
End Function


'********************************************************************************************
'FUNCTION NAME: AddRelToTemp
'PURPOSE: add data from user input form to temporary table
' the field containing data are stored in Session("SearchData" & "Relational" & dbkey & formgroup)
' actual field data is store in Session("SearchData" & fullfieldname & dbkey & formgroup) where fullfieldname
' is an item in Session("SearchData" & "Relational" & dbkey & formgroup)'s comma delimeted string value
'CALLED BY: form_action_vbs.asp action = add_record 
'INPUTS :	dbkey
'			formgroup
'			commit_type : text = add_identifiers, add_salt, new_batch, full_commit
'RETURNS: recordid of new temp table record
'******************************************************************
Function AddRelToTemp(ByVal dbkey, ByVal formgroup, ByVal commit_type)
	'stop
	commit_type = UCase(commit_type)
	'get fields submitted in form
	RelationalSearchNames =Session("SearchData" & "Relational" & dbkey & formgroup)
	'get basetable and moltable values from ini file for formgroup
	temp_basetable="Temporary_Structures" 'in this case return temp table
	temp_baseid="Temp_Compount_ID"
	temp_moltable = "Temporary_Structures" 
	temp_strucIDField ="Temp_Compount_ID"
	'create data connection and recordset object for adding data to temporary table
	on error resume next
	
	Set RegConn= GetRegConn(dbkey, formgroup)
	SetOracleSessionCursorSharingParameter RegConn, "force"
	
	RegConn.BeginTrans
	
	Set TempRS = Server.CreateObject("ADODB.Recordset")
	
	if RegConn.State=0 then ' assume user has been logged out
		DoLoggedOutMsg()
	end if
	
	Set cmd = Server.CreateObject("adodb.command")
	cmd.ActiveConnection =  RegConn
	sql = "INSERT INTO temporary_structures (entry_date) values(sysdate) RETURNING rowid INTO ?"
	cmd.commandType = 1
	cmd.commandtext = sql
	cmd.Parameters.Append cmd.CreateParameter("pOut", 200, 2,20) 
	cmd.execute
	rowid = cmd.parameters(0).value
	'LJB 5/6 add error trapping here since very often we are finding that the errors output later on are not relevant to errors occureing at the insert step
	if err.number <> 0 then
		logaction("Error occured on inserting into Temporary_structures" & err.number & err.description)
	end if

	Set TempRS = Server.CreateObject("adodb.recordset")
	Set cmd2 = Server.CreateObject("adodb.command")
	cmd2.ActiveConnection =  RegConn
	cmd2.CommandType = adCmdText
	sql = "Select * from temporary_structures where rowid =?"
	cmd2.CommandText = sql
	cmd2.Parameters.Append cmd.CreateParameter("pRootNumber", 200, 1, len(rowid), rowid) 
	'LJB 5/6 add error trapping here since very often we are finding that the errors output later on are not relevant to errors occureing at the insert step
	if err.number <> 0 then
		logaction("Error occured on selecting newly inserted record from Temporary_structures" & err.number & err.description)
	end if
	TempRS.LockType=3
	TempRS.CursorType=1
	TempRS.Open cmd2
	
	
	if (TempRS.EOF and TempRS.BOF) then
		RegConn.RollbackTrans
		if Session("no_gui" & dbkey & formgroup) = True then
			 AddRelToTemp="LOAD_TERMINATED: commit to temp table failed " & err.number & err.description
			 exit function
			 logaction("commit to temp table failed. See /inetpub/cfwlog.txt for additional information." & err.number & err.description)
			Post_String = replace(Request.Form, "user_pwd=" & request("user_pwd"),"user_pwd=XXXXX")
			logaction("full post:" & Post_String)	
		else
			response.Write "commit to temp table failed. See /inetpub/cfwlog.txt for additional information." & "<br>"
			for i = 0 to RegConn.Errors.count
				response.Write RegConn.Errors(i).description
			next
			response.write err.number & err.description
			response.Write sql_insert
			response.end
		end if
	else
		temp_id = TempRS("temp_compound_id")
		mol_id = TempRS("mol_id")
		TempRS("chemical_name") = ""
		'loop through data from form groups ado searchable fields and commit each fields data to temp table
		field_array = Split(RelationalSearchNames, ",", -1)'
		
		'stop
		for i = 0 to UBound(field_array)
			fullfieldnamearray =split(field_array(i), ";", -1)
			fullfieldname =fullfieldnamearray(0)
			fieldnamearray = split(fullfieldname, ".", -1)
			fieldname = fieldnamearray(1)
			'stop
			on error resume next
			'SYAN changed on 12/16/2003 to fix CSBR-35466
			if (TempRS.Fields(fieldname).Type = 135 or TempRS.Fields(fieldname).Type = 7) then
				dateVal = Trim(Session("SearchData" & fullfieldname & dbkey & formgroup))
				'allow other date field types form chemloader loads
				if instr(dateVal, "/")> 0 then
					TempRS.Fields(fieldname).Value = ConvertStrToDate(Application("DATE_FORMAT"), dateVal)
				end if
			'SYAN changed on 9/23/2004 to fix CSBR-46729
			elseif (TempRS.Fields(fieldname).Type = 5 or TempRS.Fields(fieldname).Type = 139) then 'adDouble or adVarNumeric
				'stop
				TempRS.Fields(fieldname).Value = CDbl(Trim(Session("SearchData" & fullfieldname & dbkey & formgroup)))
			else
        'stop
				TempRS.Fields(fieldname).Value=Trim(Session("SearchData" & fullfieldname & dbkey & formgroup))
			end if
			TempRS.Update
			if err.number <> 0 then
				err_number = err.number
				err_description = err.description
				Dim theType
				theType = TempRS.Fields(fieldname).Type
				RegConn.RollbackTrans
				
				'start tests of err_description
				'note any time you go through logaction you loose the err because of on error resum next.  Need to store original error and raise a new one.
				if instr(UCase(err_description), "MISMATCH") >0 then
					mappedField = getLabelName(fieldname)
						logaction(fieldname & ":" & err_number & err_description&  mappedField & "(" & fieldname & ")" & " is mapped to a field with the wrong data type.")
						err.Raise err_number,,err_description &  mappedField & "(" & fieldname & ")"  & " is mapped to a field with the wrong data type."
				else 
					if instr(UCase(err_description), "SUBSCRIPT")>0 then
						if theType = 7 or theType = 135 then
							logaction(fieldname & ":" & err_number & err_description &  mappedField & "(" & fieldname & ")" & " date format is unsupported.")
							err.Raise err_number,,err_description &  mappedField & "(" & fieldname & ")"  & " date format is unsupported."
						else
							logaction(fieldname & ":" & err_number & err_description)
							err.Raise err_number,,err_description & ":" & fieldname
						end if
					else
						if instr(UCase(err_description), "PRECISION")>0 then
							logaction(fieldname & ":" & err_number & err_description &  mappedField & "(" & fieldname & ")" & " precision of field is greate than acceptable for current data type")
							err.Raise err_number,,err_description &  mappedField & "(" & fieldname & ")"  & " precision of field is greater than acceptable for current data type"
						else
							if instr(UCase(err_description), "CONTEXT")>0 then
								logaction(fieldname & ":" & err_number & err_description &  mappedField & "(" & fieldname & ")" & " numeric field is mapped to a field with lower precision.")
								err.Raise err_number,,err_description &  mappedField & "(" & fieldname & ")"  & " numeric field is mapped to a field with lower precision."
							else 
								logaction(fieldname & ":" & err_number & err_description)
								err.Raise err_number,,err_description & ":" & fieldname
							end if
						end if
					end if
				end if 'end test of err_description
				
				if Session("no_gui" & dbkey & formgroup) = True then
					AddRelToTemp="LOAD_TERMINATED: commit to temp table failed " & err.number  & err.description
					logaction("commit to temp table failed " & err.number & err.description)
					Post_String = replace(Request.Form, "user_pwd=" & request("user_pwd"),"user_pwd=XXXXX")
					logaction("full post:" & Post_String)	
					err.Raise err_number,,err_description & ":" & fieldname
					exit function
				else
					response.Write "commit to temp table failed" & "<br>"
					for m = 0 to RegConn.Errors.count
						response.Write RegConn.Errors(m).description
					next
					response.write err.number & err.description
					response.Write sql_insert
					response.end
				end if
			end if 'end if err.number <> -
	
		Next
		
		'stop
		'enter commit_type specific data
		TempRS("Commit_Type") = commit_type
		
		'SYAN added on 6/8/2005 to fix CSBR-54461
		if CBool(Application("LEGACY_IMPORT_ENABLED")) = true then
			TempRS("LEGACY_REG_NUMBER") = request("TEMPORARY_STRUCTURES.LEGACY_REG_NUMBER")
		end if
				

		'End of SYAN modification
		
		Select Case UCase(commit_type)
			Case "BATCH_COMMIT"
				reg_number = Request("reg_number")
				reg_int_id = Request("reg_internal_id")
				TempRS("Reg_Internal_ID") = reg_int_id
				if CBOOL(Application("NOTEBOOK_LOOKUP")) = True then
					Notebook_Number = Trim(Session("SearchData" & "TEMPORARY_STRUCTURES.NOTEBOOK_NUMBER" & dbkey & formgroup))
					User_Code = getValueFromTablewConn (RegConn,"notebooks", "notebook_number", Notebook_Number, "user_code")
					TempRS("Scientist_ID") = User_Code
				else
					if Not Session("SearchData" & "Temporary_structures.Scientist_ID" & dbkey & formgroup) <> "" then
						DBMSUser_ID = Session("CurrentUser" & dbkey)
						PersonID = getValueFromTablwConn (RegConn,"People", "User_ID",DBMSUser_ID,"Person_ID")
						TempRS("Scientist_ID") =PersonID
					end if
				end if
				'apply integrity constraints
				if Not request("TEMPORARY_STRUCTURES.Notebook_Number") <> "" then
					TempRS("NOTEBOOK_NUMBER") = 1
				end if
				if Not request("TEMPORARY_STRUCTURES.Salt_Code") <> "" then
					TempRS("SALT_CODE") = 1
				end if
				
			Case "ADD_IDENTIFIERS"
				reg_number = Request("reg_number")
				reg_int_id = Request("reg_internal_id")
				TempRS("project_id") = Trim(request("TEMPORARY_STRUCTURES.PROJECT_ID"))
				TempRS("Reg_Internal_ID") = reg_int_id

			Case "ADD_SALT"
				if CBOOL(Application("NOTEBOOK_LOOKUP")) = True then
					Notebook_Number = Trim(Session("SearchData" & "NOTEBOOK_NUMBER" & dbkey & formgroup))
					User_Code = getValueFromTablewConn(RegConn, "notebooks", "notebook_number",Notebook_Number,"user_code")
					TempRS("Scientist_ID") = User_Code
				end if
				cpdDBcounter = Request("cpdDBcounter")
				if not cpdDBCounter > 0 then
					if Not Session("no_gui" & dbkey & formgroup) = True then
						Response.Write "commit failed"
						logaction("commit failed at:" & temp_id & "error: " & err.number & err.Description)
						TempRS.Close
						Set TempRS = Nothing
						Response.End
					else
						Response.Write "commit failed"
						logaction("commit failed at:" & tempid & "error: " & err.number & err.Description)
						Post_String = replace(Request.Form, "user_pwd=" & request("user_pwd"),"user_pwd=XXXXX")
						logaction("full post:" & Post_String)	
						TempRS.Close
						Set TempRS = Nothing
						exit function
					end if
				end if
				TempRS("CPD_Internal_ID") = CLng(cpdDBcounter)
				TempRS("project_id") = Trim(request("TEMPORARY_STRUCTURES.PROJECT_ID"))
				'apply integrity contraints
				if Not Trim(request("TEMPORARY_STRUCTURES.Notebook_Number")) <> "" then
					TempRS("NOTEBOOK_NUMBER") = 1
				end if
				if Not Trim(request("TEMPORARY_STRUCTURES.Salt_Code")) <> "" then
					TempRS("SALT_CODE") = 1
				end if
				if Not Trim(request("TEMPORARY_STRUCTURES.Project_ID")) <> "" then
					TempRS("Project_ID") = 1
				end if
			Case "FULL_COMMIT", "EDIT_TEMP", "EDIT_STRUCTURE"
				
				if CBOOL(Application("NOTEBOOK_LOOKUP")) = True then
					Notebook_Number = Trim(Session("SearchData" & "TEMPORARY_STRUCTURES.NOTEBOOK_NUMBER" & dbkey & formgroup))
					User_Code = getValueFromTablewConn(RegConn, "notebooks", "notebook_number", Notebook_Number, "user_code")
					TempRS("Scientist_ID") = User_Code
				end if
				
				
				if Not Trim(request("TEMPORARY_STRUCTURES.Notebook_Number")) <> "" then
					TempRS("NOTEBOOK_NUMBER") = 1
				end if
				if Not Trim(request("TEMPORARY_STRUCTURES.Salt_Code")) <> "" then
					TempRS("SALT_CODE") = 1
				end if
				if Not Trim(request("TEMPORARY_STRUCTURES.Project_ID")) <> "" then
					TempRS("Project_ID") = 1
				end if
				if Not Trim(request("TEMPORARY_STRUCTURES.Compound_type")) <> "" then
					TempRS("Compound_type") = 1
				end if
				if CBool(Application("PROJECTS_NAMED_OWNER")) = true then
			
					batch_project_id = TempRS("batch_project_id")
					project_id = getValueFromTablewConn(RegConn, "batch_projects", "batch_project_id", batch_project_id, "owner_id")
				
					if isEmpty(project_id) or isZero(project_id) then
						project_id = "1"
					end if
				
					TempRS("project_id") = project_id
					
				end if
		End Select
		TempRS("LOAD_ID") = Trim(request("temporary_structures.load_id"))
		DBMSUser_ID = Session("CurrentUser" & dbkey)
		PersonID = getValueFromTablewConn(RegConn, "People", "User_ID",DBMSUser_ID,"Person_ID")
		'enter  non-specific commit_type specific data
		TempRS("Entry_Date") = Date()
		TempRS("DATETIME_STAMP") = Session("DateTime_Stamp")
		if not isEmpty(PersonID) then
			TempRS("Entry_Person_ID") = CLng(PersonID)
		end if
		
		'add structure 
		'stop
		StructureFields= Session("SearchData" & "Exact" & dbkey & formgroup) 
		If  UCase(commit_type) = "FULL_COMMIT" then
			base64string = Session("SearchData" & temp_basetable & ".Structure" & dbkey & formgroup)
				if base64string <> "" then				
						mol_id = TempRS("mol_id")
						
						'SYAN added on 5/1/2006 for ChemScript integration -- need to move to a function
						'stop
						salt_id = ""
						Salt_Equivalents = ""
						saltBase64 = ""
						
						solvate_id = ""
						Solvate_Equivalents= ""
						solvateBase64 = ""
						
						ApplyChemScriptRules base64string, TempRS, salt_id, Salt_Equivalents, saltBase64, solvate_id, Solvate_Equivalents, solvateBase64
						
						'base64string_original = base64string
						'base64string = replace(base64string, chr(13), "")
						'base64string = replace(base64string, chr(10), "")

						'if Application("MOLECULE_PROCESS") = 1 and Application("MOLECULE_PROCESS_SCRIPT") <> "" then
						'	splitted = ""
						'	status = "UNCHANGED"
						'	logEntry = ""
						'	ProcessMolecule base64string, splitted, status, logEntry
						'end if
							
						'mainBase64 = base64string
						'mainFragLog = splitted
									
						'stop
									
						'mainFragArr = Split(splitted, ",")
						
						'if UBound(mainFragArr) > 1 then			
						'	'mainBase64 = mainFragArr(0)
						'	'mainBase64 = replace(mainBase64, "\r\n", "")
						'	'mainBase64 = Right(mainBase64, len(mainBase64) - 2) 'Get rid of leading ['
						'				
						'	'base64string = mainBase64
									
									
						'	saltArr = mainFragArr(1)
						'	saltInfoArr = Split(saltArr, "$$$$")
										
						'	Salt_Equivalents = right(saltInfoArr(0), len(saltInfoArr(0)) - 2)
										
						'	saltBase64 = saltInfoArr(1)
						'	saltBase64 = replace(saltBase64, "\r\n", "")
								
						'	Salt_Equivalents = CInt(Salt_Equivalents)

						'	salt_exist = DoCartridgeDuplicateSearch(dbkey, formgroup, "REGDB.SALTS.BASE64_CDX", saltBase64, RegConn, "SALT_CODE")
								
						'	if salt_exist = "" then
						'		status = "warning"
						'		message = "There are multiple salts in the structure need to be combined."
						'	end if
										
						'	solvateArr = mainFragArr(2)
						'	solvateInfoArr = Split(solvateArr, "$$$$")
										
						'	Solvate_Equivalents = right(solvateInfoArr(0), len(solvateInfoArr(0)) - 2)
										
						'	solvateBase64 = solvateInfoArr(1)
						'	solvateBase64 = replace(solvateBase64, "\r\n", "")

						'	Solvate_Equivalents = CInt(Solvate_Equivalents)
								
						'	solvate_exist = DoCartridgeDuplicateSearch(dbkey, formgroup, "REGDB.SOLVATES.BASE64_CDX", solvateBase64, RegConn, "SOLVATE_ID")
								
						'	if solvate_exist = "" then
						'		status = "warning"
						'			
						'		if message <> "" then
						'			message = "There are multiple salts and solvates in the structure need to be combined."
						'		else
						'			message = "There are multiple solvates in the structure need to be combined."
						'		end if
						'	end if
												
						'	if saltStrippingLog <> "" then
						'		logEntry = saltStrippingLog
						'	end if
										
											
						'	if saltStrippingStatus = "" then
						'		if status = "warning" then
						'			mainBase64 = base64string_original
						'			saltBase64 = ""
						'			solvateBase64 = ""
						'			status = "STRIPPING FAILED"
						'			showmessagedialog(message)
						'		elseif saltBase64 <> "" or solvateBase64 <> "" then
						'			status = "STRIPPING SUCCEEDED"
						'		end if
						'	else
						'		status = saltStrippingStatus
						'	end if
						'
						'else
						'	saltBase64 = ""
						'	solvateBase64 = ""
						'end if
								
						'stop
						'TempRS("base64_cdx") = mainBase64
						'TempRS("base64_cdx_original") = base64string_original
						'TempRS("status") = status
						'TempRS("log") = logEntry
						
						'if status = "STRIPPING SUCCEEDED" then
						'	TempRS("stripping_succeeded") = 1
						'	TempRS("stripping_failed") = 0
						'else
						'	TempRS("stripping_succeeded") = 0
						'	TempRS("stripping_failed") = 1
						'end if
						

						
						theChemData = getMW_and_Formula(dbkey, formgroup,"temporary_structures",mol_id,RegConn,base64string )
						theChemData_array = Split(theChemData, ":", -1)
						theMW=theChemData_array(0)
							if theMW = "0" or theMW = -1 or theMW = "-1" or theMW = 0 then
								theMW = null
							end if
						
						''SYAN added9/21/2004 to fix CSBR-46729
						'Set cmd = Server.CreateObject("ADODB.COMMAND")
						'cmd.ActiveConnection =  RegConn
						'cmd.CommandType = adCmdText
						'sql ="ALTER SESSION SET NLS_NUMERIC_CHARACTERS=',.'"
						'cmd.CommandText = sql
						'cmd.execute
						''End of SYAN modification
						
						'TempRS("MW2") = theMW
						
						'SYAN modified 9/21/2004 to fix CSBR-46729
						TempRS("MW2") = ConvertToDbl(theMW)
						'End of SYAN modification
						
						''SYAN added 9/21/2004 to fix CSBR-46729
						'Set cmd = Server.CreateObject("ADODB.COMMAND")
						'cmd.ActiveConnection =  RegConn
						'cmd.CommandType = adCmdText
						'sql ="ALTER SESSION SET NLS_NUMERIC_CHARACTERS='.,'"
						'cmd.CommandText = sql
						'cmd.execute
						''End of SYAN modification
            'stop
						TempRS("Formula2") = theChemData_array(1)
						if Not (theChemData_array(1) <> "") AND UCASE(Application("NON_CHEMICAL_SUBMIT")) = "DISALLOW" then
							TempRS("base64_cdx") = ""
							base64string=""
						end if
					if CBool(Application("AUTOGENERATED_CHEMICAL_NAME")) = True then
						'myPath = Application("TempFileDirectory" & dbkey) & "SessionDir\" & Session.SessionID & "\RegTemp.cdx"
						'chem_inputstring = request("temporary_structures.chem_name_autogen")
						'stop
						autogen_name = getAutoGeneratedName(base64string," for temporary_structures.temp_compound_id" & temp_id)
						TempRS("CHEM_NAME_AUTOGEN") = autogen_name
					end if
				end if
		end if
		
		if (UCase(commit_type) = "BATCH_COMMIT") OR (UCase(commit_type) = "FULL_COMMIT") or (UCase(commit_type)= "ADD_SALT") then
				'stop
				'SYAN modified on 11/27/2006 to fix CSBR-71619
				saltName = Session("SearchData" & "Temporary_Structures.Salt_Name" & dbkey & formgroup)
        salt_code = GetSaltCodeFromSaltName(saltName)
        if salt_code = "" then
        salt_code = 1
        end if
        TempRS("SALT_CODE") = salt_code
        if salt_code <> "1" then
        salt_id = salt_code
        end if
        'End of SYAN modification

        if Salt_Equivalents = "" then
        Salt_Equivalents =  Trim(Session("SearchData" & "Temporary_Structures.Salt_Equivalents" & dbkey & formgroup)) 
				end if
				
				if Salt_Equivalents <> "" then
					'SYAN modified 9/21/2004 to fix CSBR-46729
					TempRS("Salt_Equivalents") = CDbl(Salt_Equivalents)
					'End of SYAN modification
				end if
				Salt_MW =  Trim(Session("SearchData" & "Temporary_Structures.Salt_MW" & dbkey & formgroup))
				
				
				'stop
				'SYAN modified on 9/11/2006 to support salt stripping
				if IsNull(TempRS("Salt_MW")) or  TempRS("Salt_MW") = "" then
					if Salt_MW <> "" then
						'SYAN modified 9/21/2004 to fix CSBR-46729
						Salt_MW = cdbl(Salt_MW)
						'End of SYAN modification
					else
						Salt_MW=null
					end if
					TempRS("Salt_MW").value = Salt_MW
				end if
				'End of SYAN modification
				
				if Solvate_Equivalents = "" then
					Solvate_Equivalents =  Trim(Session("SearchData" & "Temporary_Structures.Solvate_Equivalents" & dbkey & formgroup))
				end if
				
				if Solvate_Equivalents <> "" then
					'SYAN modified 9/21/2004 to fix CSBR-46729
					TempRS("Solvate_Equivalents") = CDbl(Solvate_Equivalents)
					'End of SYAN modification
				end if
				Solvate_MW =  Trim(Session("SearchData" & "Temporary_Structures.Solvate_MW" & dbkey & formgroup))
			
				if Solvate_MW <> "" then
          Solvate_MW = Cdbl(Solvate_MW)
          else
          Solvate_MW = Null
          end if
          TempRS("Solvate_MW").value = Solvate_MW

          'DGB Ensure solvate id is properly populated
          solvateName = Session("SearchData" & "Temporary_Structures.Solvate_Name" & dbkey & formgroup)

          solvate_code = GetSolvateCodeFromSolvateName(solvateName)
          TempRS("Solvate_ID") = solvate_code

          if solvate_code <> "1" then
          solvate_id = solvate_code
          end if

          if Not UCase(commit_type) = "FULL_COMMIT" then
          cpd_internal_id = Trim(Session("SearchData" & "Temporary_Structures.CPD_Internal_ID" & dbkey & formgroup))
					'if this is batch or add_salt you need to figure out if there really is a structure
					theMW = getValueFromTablewConn(RegConn, "compound_molecule", "cpd_database_counter",cpd_internal_id,"MW2")
					if Not (theMW = NULL or theMW = "" or theMW = -1) then
						theMW = CDbl(theMW)
					else
						theMW = 0
					end if
				end if
				
			
				'stop
				'don't bother calculating this is there is no structure!!
				if theMW > 0 then
          TempRS("mw2") = theMW
					FormulaWt = DoFormulaWtCalc(dbkey, formgroup,  RegConn, theMW, cpd_internal_id, Salt_MW, Salt_Equivalents, Solvate_MW, Solvate_Equivalents)
				else
					FormulaWt = Null
				end if
				if isEmpty(FormulaWt) then
					TempRS("Formula_Weight") = Null
				else
					TempRS("Formula_Weight").value = Cdbl(FormulaWt)
				end if
				if  Session("DERIVED_FIElDS").Exists("PERCENT_ACTIVE") then
					'don't bother calculatin percent active if formulawt is empty
					if FormulaWt <> "" then
						PercentActive = DoPercentActiveCalc(dbkey, formgroup,  RegConn, theMW, cpd_internal_id,FormulaWt)
					else
						PercentActive = ""
					end if
					if isEmpty(PercentActive) then
						TempRS("Percent_Active") = Null
					else
						'SYAN modified on 9/27/2004 to fix CSBR-46729
						TempRS("Percent_Active") = CDbl(PercentActive)
						'End of SYAN modification
					end if
				end if
			
		end if
	end if 'if Not(temprs.eof and temprs.bof)
	
	TempRS.Update
	TempRS.Close
  'stop
	'temp_id = TempRS("temp_compound_id")
	if err.number <> 0 then
		err_number = err.number
		err_description = err.description
		RegConn.RollbackTrans
		if inStr(UCase(err_description), "CONTEXT")> 0 then
			addToErr = " inegrity contraint error, or numeric precision error"
		else
			addToErr = ""
		end if
		if Session("no_gui" & dbkey & formgroup) = True then
			AddRelToTemp = "LOAD_TERMINATED: commit to temp failed. See /inetpub/cfwlog.text for more information. " & err_number & err_description & addToErr
			logaction("commit to temp table failed " & err_number & err_description & addToErr)
			Post_String = replace(Request.Form, "user_pwd=" & request("user_pwd"),"user_pwd=XXXXX")
			logaction("full post:" & Post_String)	
			err.Raise err_number,,err_description
		else
			AddRelToTemp = 0
			response.Write  "commit to temp failed. transaction rolled back: " & err_number & err_description & addToErr
    end if
    else
    RegConn.CommitTrans
    'SYAN added on 9/13/2006 to support salt stripping
    'stop
    'salt_id = DoCommitFrag(dbkey, formgroup, RegConn, saltBase64, "SALT")
    'solvate_id = DoCommitFrag(dbkey, formgroup, RegConn, solvateBase64, "SOLVATE")
    'stop

    FillSaltSolvateInTemp temp_id, salt_id, solvate_id

    'Set sRS = Server.CreateObject("adodb.recordset")
    'Set tRS = Server.CreateObject("adodb.recordset")
    'Set cmd3 = Server.CreateObject("adodb.command")
    'cmd3.ActiveConnection =  RegConn
    'cmd3.CommandType = adCmdText
    'sql = "select * from salts where salt_code = ?"
    'cmd3.CommandText = sql
    'cmd3.Parameters.Append cmd.CreateParameter("psaltID", 139, 1, 0, salt_id)
    'sRS.LockType=3
    'sRS.CursorType=1
    'sRS.Open cmd3

    'cmd3.Parameters.Delete "psaltID"

    'Set solRS = Server.CreateObject("adodb.recordset")
    'Set cmd4 = Server.CreateObject("adodb.command")
    'cmd4.ActiveConnection =  RegConn
    'cmd4.CommandType = adCmdText
    'sql = "select * from solvates where solvate_id = ?"
    'cmd4.CommandText = sql
    'cmd4.Parameters.Append cmd.CreateParameter("psolvateID", 139, 1, 0, solvate_id)
    'solRS.LockType=3
    'solRS.CursorType=1
    'solRS.Open cmd4

    'cmd4.Parameters.Delete "psolvateID"

    'if not (sRS.BOF and sRS.EOF) then
    '	sql = "select salt_code, salt_name, salt_mw, solvate_id, solvate_name, solvate_mw from temporary_structures where temp_compound_id = ?"
    '	cmd3.Parameters.Append cmd.CreateParameter("ptempID", 139, 1, 0, temp_id)
    '	cmd3.CommandText = sql
    '	tRS.LockType=3
    '	tRS.CursorType=1
    '	tRS.Open cmd3
    '	if not (tRS.BOF and tRS.EOF) then
    '		tRS("salt_code") = sRS("SALT_CODE")
    '		tRS("salt_name") = sRS("SALT_NAME")
    '		tRS("salt_mw") = sRS("SALT_MW")
    '		if not (solRS.BOF and solRS.EOF) then
    '			tRS("solvate_id") = solRS("SOLVATE_ID")
    '			tRS("solvate_name") = solRS("SOLVATE_NAME")
    '			tRS("solvate_mw") = solRS("SOLVATE_MW")

    '		end if
    '		tRS.Update
    '	end if

    '	tRS.Close
    'end if
    'sRS.Close
    'solRS.Close
    'set sRS = nothing


    'set tRS = nothing
    'set cmd3 = nothing
    'set cmd4 = nothing


    'End of SYAN modification

    UpdateTableRecordCount2 dbkey, "temporary_structures", +1
    AddRelToTemp = temp_id
    end if
    'CloseConn(RegConn)
    Session("DateTime_Stamp")=""

    End Function

    'for backwards compatibility
    Sub UpdateTempRecordCount(ByRef RegConn)
    UpdateTableRecordCount request("dbname"), request("formgroup"), "temporary_structures", RegConn
    end sub

    'for backwards compatibility
    Sub UpdateBaseRecordCount(dbkey, formgroup, ByRef RegConn)
    on error resume next
    sql = "Select Count(*) From REG_NUMBERS"
    if Not isObject(DataConn) then
    Set DataConn = GetConnection("REG", "BASE_FORM_GROUP", "REG_NUMBERS")
    end if
    Set RS = DataConn.Execute(sql)
    If Not (RS.BOF AND RS.EOF)then
    theCount = RS.Fields(0)
    if CBool(Application("Use_Session_Record_Counts")) = true then
    Session("REG_NUMBERS" & "RecordCount" & "REG") = theCount
		else
			Application.Lock
				Application("REG_NUMBERS" & "RecordCount" & "REG") = theCount
			Application.UnLock
		end if
		RS.Close
	End if
	'if not Session("no_gui" & dbkey & formgroup) = true then
		'call DoMainWindowUpdate()
	'end if
end sub

sub DoMainWindowUpdate()
%><script language = "javascript">
	MainWindow.db_record_count = "<%=Application("REG_NUMBERS" & "RecordCount" & "REG") %>"
	</script><%
end sub


'********************************************************************************************
'SUB NAME: verifyReg
'PURPOSE: verify that a registry number entered by a user is valid
'CALLED BY: istryNumber
'INPUTS :	dbkey
'			formgroup
'			unique_reg_val  = reg_number to verify as text
'			commit_type = commit type (add_identifiers|add_salt|Batch_Commit)
'RETURNS: reg_id : cpd_id
'******************************************************************
Function verifyReg(ByVal dbkey, ByVal formgroup, ByVal unique_reg_val, ByVal commit_type)
	theValue = ""
	noConn = false
	reg_table = "reg_numbers"
	reg_field = "reg_number"
	root_field = "root_number" 'used for salt search since you only need the compounds' root number
	reg_baseid = GetTableVal(dbkey, reg_table, kPrimaryKey)
	delimeter = "'"
	'unique_reg_val = Trim(unique_reg_val)
	Select Case UCase(commit_type)
		Case "BATCH_COMMIT"
			fullfieldname = reg_table & "." & reg_field
			datatype =getDataType(dbkey,  formgroup,  fullfieldname)
			sql = buildSimpleSQL(reg_table, reg_field, unique_reg_val, datatype)
			 if Not isObject(RegConn)  then
				Set RegConn= GetRegConn(dbkey, formgroup)
			end if
		Case "ADD_ANALYTICS_DATA"
		
			if inStr(unique_reg_val,"/")> 0 then
				thearray= split(unique_reg_val, "/", -1)
				if UBound(thearray)=2 then
					new_unique_reg_val = thearray(0) & "/" & thearray(1)
					unique_batch_val = thearray(2)
				else
					new_unique_reg_val = thearray(0)
					unique_batch_val = thearray(1)
				end if
			
				if not isEmpty(unique_batch_val) then
					on error resume next
					unique_batch_val = CLng(unique_batch_val)
			
					if Not err.number <> 0 then
						on error goto 0
						fullfieldname = reg_table & "." & reg_field
						datatype =getDataType(dbkey,  formgroup,  fullfieldname)
						sql = buildSimpleSQL("reg_numbers", "reg_number", new_unique_reg_val, datatype)
						 if Not isObject(RegConn)  then
							Set RegConn= GetRegConn(dbkey, formgroup)
						end if
						
						Set RS= RegConn.Execute(sql)

						if not (RS.BOF AND RS.EOF)then
							reg_id = RS("reg_id")
							CloseRS(RS)
							sql = "Select batch_internal_id from batches where reg_internal_id = " & reg_id & " AND batch_number='" & unique_batch_val & "'"
							on error resume next 
							Set RS= RegConn.Execute(sql)
							if not (RS.EOF AND RS.BOF)then
								theValue = RS("batch_internal_id")& ":" & reg_id
							end if
							CloseRS(RS)
							if err.number <> 0  then
								theValue = ""
							end if
						else
							theValue = ""
						end if

					else
						noConn=true
						theValue = ""
					end if
				else
					noConn= true
					theValue = ""
				end if
			else
				noConn= true
				theValue = ""
			end if

		Case "ADD_IDENTIFIERS"
			fullfieldname = reg_table & "." &  reg_field
			datatype =getDataType(dbkey,  formgroup,  fullfieldname)
			sql = buildSimpleSQL( reg_table, reg_field, unique_reg_val, datatype)
			if Not isObject(RegConn)  then
				Set RegConn= GetRegConn(dbkey, formgroup)
			end if
			
		Case "ADD_SALT"
			fullfieldname = reg_table & "." &  root_field
			datatype =getDataType(dbkey,  formgroup,  fullfieldname)
			sql = buildSimpleSQL( reg_table, root_field, unique_reg_val, datatype)
			if Not isObject(RegConn)  then
				Set RegConn= GetRegConn(dbkey, formgroup)
			end if
		'Start Givaudan EVAL customization
	Case "ADD_EVAL_DATA"
	bDoSQL = false
	if inStr(unique_reg_val,"/")> 0 then
		thearray= split(unique_reg_val, "/", -1)
		new_unique_reg_val = thearray(0)
		unique_batch_val = thearray(1)
		if not isNull(unique_batch_val) then
			on error resume next
			unique_batch_val = CLng(unique_batch_val)
			
			if Not err.number <> 0 then
			on error goto 0
				fullfieldname = reg_table & "." & reg_field
				datatype =getDataType(dbkey,  formgroup,  fullfieldname)
				sql = buildSimpleSQL("reg_numbers", "reg_number", new_unique_reg_val, datatype)
		
				Set DataConn = GetConnection(dbkey, formgroup, reg_table)
				if DataConn.State=0 then ' assume user has been logged out
					DoLoggedOutMsg()
				end if
				Set RS= DataConn.Execute(sql)
				if not (RS.BOF AND RS.EOF)then
					reg_id = RS("reg_id")
					CloseRS(RS)
					sql = "Select batch_internal_id from batches where reg_internal_id = " & reg_id & " AND batch_number='" & unique_batch_val & "'"
					on error resume next 
						Set RS= DataConn.Execute(sql)
						if not (RS.EOF AND RS.BOF)then
							batch_id = RS("batch_internal_id")
							theValue = batch_id & ":" & reg_id
							
						end if
						CloseRS(RS)
						if batch_id <> "" then
							sql = "Select * from evscreen where batch_id = " & batch_id
							set RS = DataCOnn.execute(sql)
							if not (RS.BOF and RS.EOF) then
								theValue="eval_already_exists" & ":" & reg_id
							end if
							CloseRS(RS)
						end if
							
						if err.number <> 0  then
							theValue = ""
						end if
				else
				theValue = ""
				end if
			else
				noConn=true
				theValue = ""
			end if
		else
			noConn= true
			theValue = ""
		end if
			
	else
		noConn= true
		theValue = ""
	end if
	
	'End Givaudan EVAL customization
	End Select
	
	on error resume next
	Set RS= RegConn.Execute(sql)
	if not (RS.EOF AND RS.BOF)then
		RS.MoveFirst
		Select Case UCase(commit_type)
			Case "BATCH_COMMIT"
				theValue = RS("reg_id")& ":" & RS("cpd_internal_id")
			Case "ADD_IDENTIFIERS"
				theValue =RS("reg_id")& ":" & RS("cpd_internal_id")
			Case "ADD_SALT"
				'there could be more then one, but we only need to find one to verify existence of the root
				cpdID =  RS("cpd_internal_id")				
				theAvailValue = CheckAvailSalts(dbkey, formgroup, cpdID)
				if theAvailValue = "all_available" then
					theValue="none" &  ":" & "all_available"
				else
					theValue = "none" &  ":" & RS("cpd_internal_id")
				End if
		End Select
		CloseRS(RS)
	else
		theValue = ""
	end if
	if noConn = false then
		'CloseConn(RegConn)
	end if

	verifyReg = theValue
End Function



Function CheckAvailSalts(Byval dbkey, ByVal formgroup, ByVal cpdID)
	 if Not isObject(RegConn)  then
		Set RegConn= GetRegConn(dbkey, formgroup)
	end if

	sql  = "Select Compound_Salt.salt_internal_id From Compound_Salt Where cpd_internal_id =" & cpdID
	Set CompoundSaltRS = RegConn.Execute(sql)
	CompoundSaltRS.MoveFirst

	while CompoundSaltRS.EOF <> TRUE  
		if RegSalts <> "" then
			RegSalts = RegSalts  & "," & Trim(CompoundSaltRS("salt_internal_id") )
		else
			RegSalts =  Trim(CompoundSaltRS("salt_internal_id"))
		end if
		CompoundSaltRS.MoveNext
	wend

	Set SaltsRS = Server.CreateObject("ADODB.Recordset")
	sql = "Select * From Salts Where Salt_Code NOT IN(" & RegSalts & ")"
	SaltsRS.Open sql, RegConn

	if isObject(SaltsRS) AND NOT (SaltsRS.EOF AND SaltsRS.BOF) then
		CheckAvailSalts = ""
	Else
		CheckAvailSalts = "all_available"
	End if

	CloseRS(CompoundSaltRS)
	CloseRS(SaltsRS)
	'CloseConn(RegConn)
End Function


'********************************************************************************************
'FUNCTION NAME: getValueFromTemp
'PURPOSE: get a value for a field in the temporary table for a particular record
'CALLED BY: DoRegCommit
'INPUTS :	dbkey
'			formgroup
'			fieldname : text= name of the field in the temporary table
'			tempID: number = id of the record in the temp table
'RETURNS: value of the field
'******************************************************************

Function getValueFromTemp(ByVal dbkey, ByVal formgroup, ByVal fieldname, ByVal tempID)
	Dim temp_basetable,temp_baseid,sql,theValue

	if tempID = "NO_TEMP_TABLE" then
		if instr(UCase(fieldname), "TEMPORARY_STRUCTURES.")> 0 then
			theValue = Session("SearchData" & fieldname & dbkey & formgroup)
			
		else
			theValue = Session("SearchData" &  "TEMPORARY_STRUCTURES." & fieldname & dbkey & formgroup)
			
		end if
	else
		
		on error resume next
		 if Not isObject(RegConn)  then
			Set RegConn= GetRegConn(dbkey, formgroup)
		end if

		Set cmd = Server.CreateObject("adodb.command")
		Set TempRS =  Server.CreateObject("adodb.recordset")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		sql = "SELECT " & fieldname & " FROM Temporary_structures where temp_compound_id=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pTempID", 139, 1, 0, tempID) 
		TempRS.Open cmd
		if not (TempRS.BOF AND TempRS.EOF)then
			'TempRS.MoveFirst
			'get the value for the input fieldname
			theValue = TempRS(fieldname)
			'clean up
			CloseRS(TempRS)
		end if
		'if temp table record was committed by someone, while user was browsing, report the error
		if err.number > 0 then
			HandleRegError "Record is no longer in Temporary Table"
		end if
	end if
	getValueFromTemp = theValue
End Function


'********************************************************************************************
'FUNCTION NAME: checkTemp
'PURPOSE: check that temp table record exists
'CALLED BY: DoRegCommit
'INPUTS :	dbkey
'			formgroup
'			tempID: number = id of the record in the temp table
'RETURNS: boolean. true if records exists, false otherwise
'******************************************************************
Function checkTemp(ByVal dbkey, ByVal formgroup, ByVal tempID)
	Dim returnVal, temp_basetable, temp_baseid, sql, theValue
	returnVal=True
	temp_basetable=Application(formgroup & dbkey & "RegTempBaseTable")
	temp_baseid=GetTableVal(dbkey, temp_basetable, kPrimaryKey)
	sql = "Select temp_compound_id FROM temporary_structures WHERE temp_compound_id=?" 
	on error resume next
	if Not isObject(RegConn)  then
		Set RegConn= GetRegConn(dbkey, formgroup)
	end if

	Set TempRS = server.CreateObject("adodb.recordset")
	Set Cmd = server.CreateObject("adodb.command")
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("ptempID", 139, 1, 0, tempID) 
	TempRS.Open cmd
	if Not (TempRS.EOF AND TempRS.BOF)  then
		CloseRS(TempRS)
		'CloseConn(TempConn)
		returnVal = True
	else
		returnVal = False
	end if
	checkTemp =returnVal
End Function


'******************************************************************
'FUNCTION NAME: DoRegCommit
'PURPOSE:  check for duplicates and commit temp data to commit tables.
'CALLED FROM:  form_action_vbs.asp dataaction = register
'ACTIONS:
	'If compound/reldata combination is a duplicate, redirect to original page and
	'ask user what to do with duplicate: Following are the options
		'create a new batch
		'edit the structure
		'skip this record
	'If not a duplicated then do full commit by calling
		'DoCommit--add relational data to real table 
		'RemoveFromTemp--remove the record from temp table
'******************************************************************
Function DoRegCommit(ByVal dbkey, ByVal formgroup, ByVal commit_mode, ByVal tempTableUniqueID, ByVal duplicate_action, ByVal duplicate_ids, ByRef RegConn)
	Session("Current_Reg_Number")=""
	Session("DateTime_Stamp") = Time() &  ":" &  Date()
	Dim temp_table
	On Error goto 0
	commit_mode = UCase(commit_mode)
	temp_table = Application(formgroup & dbkey & "RegTempBaseTable")
	'store the id that is in the temp table for later committing. If list view
	'id will come form the query string since there are more then one structure in the view
	'edit view gets it from the store id there.
	Session("tempUniqueID" & dbkey)= tempTableUniqueID
	'response.write "here"
	'response.end
	if not Session("no_gui" & dbkey & formgroup) = true then
		theBool = checkTemp(dbkey, formgroup, tempTableUniqueID)
	else
		theBool = true
	end if

	if Not theBool = true then
			Session("ReturnLocation" & dbkey & formgroup)=Request("CurrentLocation") & "&RegActionCompleted=temp_missing"
			RegReturn = "temp_missing" & "," & tempTableUniqueID & "," & reg_number  & "," & batch_number
	else
		'get type of commit from querystring, this was previously taken from the commit_type field of 
		'the temporary table for the current candidate
		if not commit_type <> "" then
			commit_type = Request.QueryString("commit_type")
		end if
		
		if NOT UCase(commit_type) = "DELETE_RECORD" then 'getValueFromTemp will error if commit_type is delete record
			
		if Not isObject(RegConn) then
			set RegConn = getRegConn(dbkey, formgroup)
		end if

			
			
			Set cmd = server.CreateObject("adodb.command")
			Set TempRS = server.CreateObject("adodb.recordset")
			cmd.ActiveConnection =  RegConn
			cmd.CommandType = adCmdText
			sql = "Select Commit_Type, Mol_ID, base64_cdx from temporary_structures where temp_compound_id=?"	
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("pTempID", 139, 1, 0, tempTableUniqueID) 	
			TempRS.Open cmd
			
			commit_type = TempRS("commit_type")			
			base64=TempRS("base64_cdx")
			the_mol_id = TempRS("mol_id")
			
			CloseRS(TempRS)
			if isEmpty(the_mol_id) then 
				the_mol_id = 0
			else
				the_mol_id = CLng(the_mol_id)
			end if
		end if
	'stop
	Select Case UCase(commit_type)
		Case "FULL_COMMIT"
			'stop
			Select Case UCase(commit_mode)
				Case "SINGLE_MODE"
				
					duplicates_check = Request.QueryString("duplicates_check")
					'the url that calls the Register action may have a query string identifier "duplicate_check".
					if not duplicates_check = "true" then 'if duplicate_check != true, it means the sub is-
						'called for the first time, need to check to see if there is duplicate
						Session("DuplicatesFound" & dbkey)= ""
						'search compound_molecule table for exact matches. this returns a list of ids found, or an empty string
						if the_mol_id > 0 and not(UCase(base64) = "NO_STRUCTURE" OR UCase(base64) = "VmpDRDAxMDAEAwIBAAAAAAAAAAAAAAAAAAAAAAMAEAAAAENoZW1EcmF3IDYuMC4xCAAMAAAAbXl0ZXN0LmNkeAADMgAIAP///////wAAAAAAAP//AAAAAP////8AAAAA//8AAAAA/////wAAAAD/////AAD//wEJCAAAAFkAAAAEAAIJCAAAAKcCAAAXAgIIEAAAAAAAAAAAAAAAAAAAAAAAAwgEAAAAeAAECAIAeAAFCAQAAJoVAAYIBAAAAAQABwgEAAAAAQAICAQAAAACAAkIBAAAswIACggIAAMAYAC0AAMACwgIAAQAAADwAAMADQgAAAAIeAAAAwAAAAEAAQAAAAAACwARAAAAAAALABEDZQf4BSgAAgAAAAEAAQAAAAAACwARAAEAZABkAAAAAQABAQEABwABJw8AAQABAAAAAAAAAAAAAAAAAAIAGQGQAAAAAAJAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAEAhAAAAD+/wAA/v8AAAIAAAACAAABJAAAAAIAAwDkBAUAQXJpYWwEAOQEDwBUaW1lcyBOZXcgUm9tYW4BgAEAAAAEAhAAAAD+/wAA/v8AAAIAAAACAA8IAgABABAIAgABABYIBAAAACQAGAgEAAAAJAAAAAAA") then 'only look for duplicates if there is for sure a structure
							duplicates_found = checkForDuplicates(dbkey, formgroup, tempTableUniqueID, "SINGLE_MODE",RegConn) 'returns number of duplicates found
						else
							duplicates_found="" 
						end if
						'if it is a duplicate
						if Len(duplicates_found) > 0 then 
							if Not instr(UCase(duplicates_found), "ERROR") > 0 then
								Session("DuplicatesFound" & dbkey) = duplicates_found
								'if it is a duplicate
								'get the action the user clicked and perform it.
								getDuplicateAction  dbkey, formgroup					
							else
								Session("ReturnLocation" & dbkey & formgroup)=Request("CurrentLocation") & "&RegActionCompleted=parsing_errors"
								RegReturn = "parsing_errors_found" & "," & Session("tempUniqueID" & dbkey) & "," & ""  & "," & ""
							end if
						else 'if not a duplicate then go through a full commit
							Session("DuplicatesFound" & dbkey) = ""
 							'commit structure and return mol_id to pass to DoRelCommit
							'both the cpd_database counter and reg number are returned
							'commit relational data
							commit_unique_id = ""
							'tableorder = Application(formgroup & dbkey & "TableOrderFullCommit")
							tableorder = Application("Full_Commit_Table_Order")
							'stop
							commit_numbers = DoCommit(dbkey, formgroup, tableorder, Session("tempUniqueID" & dbkey), commit_uniqueid, "full_commit",RegConn)
							'remove from temp
							RemoveFromTemp dbkey, formgroup, Session("tempUniqueID" & dbkey),RegConn
							Session("ReturnLocation" & dbkey & formgroup)=Request("CurrentLocation") & "&RegActionCompleted=compound_registered"
							
							temp_array = split(commit_numbers, ":", -1)
							reg_number = temp_array(0)
							batch_number = temp_array(1)
							on error resume next
							reg_id = temp_array(2)
							cpdDBCounter = temp_array(3)
							on error goto 0
							RegReturn = "full_commit" & "," & Session("tempUniqueID" & dbkey) & "," & reg_number  & "," & batch_number & "," & reg_id & "," & cpdDBCounter
						end if
					else 'if duplicate_check = true, it means the sub has been called before and-
						  'a duplicate check is performed. Also there is input from user about what to do with this duplicate.
					
						duplicate_action_querystring = Request.QueryString("duplicate_action")
						Session("duplicateIDs" & dbkey)  = Request.QueryString("duplicate_ids")
					
						Select Case UCase(duplicate_action_querystring)
							Case "BATCH_COMMIT" 'in this case not commit the structre only create a new bactch
								reg_id = Session("duplicateIDs" & dbkey) 'what is a duplicate is customizable in getDupCheckRelData
								batchtable = Application(formgroup & dbkey & "RegBatchTable")
								tableorder = Application("New_Batch_Commit_table_order")
								
								commit_numbers = DoCommit(dbkey, formgroup, tableorder, Session("tempUniqueID" & dbkey), reg_id, "batch_commit",RegConn)
								temp_array = split(commit_numbers, ":", -1)
								if instr(commit_numbers, "unapproved")>0 then
									Session("ReturnLocation" & dbkey & formgroup) = Session("PreDupCheckLocation" & dbkey)& "&RegActionCompleted=Batch_Commit_Not_added"
									reg_number = temp_array(1)
									batch_number = temp_array(2)
									on error resume next
										reg_id = temp_array(3)
										cpdDBCounter = temp_array(4)
									on error goto 0
									if duplicates_found<> "" then
										if Not instr(UCase(duplicates_found), "ERROR") > 0 then
											RegReturn = "unapproved_compound_with_duplicates" & "," & Session("tempUniqueID" & dbkey) & "," & reg_number  & "," & batch_number & "," & reg_id & "," & cpdDBCounter
											Session("DuplicatesFound" & dbkey) = duplicates_found
											markTempRecAsDup dbkey, formgroup,Session("tempUniqueID" & dbkey),Session("DuplicatesFound" & dbkey)
										end if
										RegReturn = "unapproved_compound_with_duplicates" & "," & Session("tempUniqueID" & dbkey) & "," & reg_number  & "," & batch_number & "," & reg_id & "," & cpdDBCounter
									else
										RegReturn = "unapproved_compound_no_duplicates" & "," & Session("tempUniqueID" & dbkey) & "," & reg_number  & "," & batch_number & "," & reg_id & "," & cpdDBCounter
									end if
								else
									RemoveFromTemp dbkey, formgroup, Session("tempUniqueID" & dbkey),RegConn
									Session("ReturnLocation" & dbkey & formgroup) = Session("PreDupCheckLocation" & dbkey)& "&RegActionCompleted=Batch_Commit_added"
									
									reg_number = temp_array(0)
									batch_number = temp_array(1)
									on error resume next
										reg_id = temp_array(2)
										cpdDBCounter = temp_array(3)
									on error goto 0
									RegReturn = "batch_only" & "," & Session("tempUniqueID" & dbkey) & "," & reg_number  & "," & batch_number & "," & reg_id & "," & cpdDBCounter
								end if		
							Case "ADD_SALT" 'in this case not commit the structre only create a new bactch
								cpd_id = Session("duplicateIDs" & dbkey)
								'pass in the table order to the "single" DoRelCommit function.  There was too much duplication to support two functions
								tableorder = Application("Add_Salt_Commit_table_order")
								commit_numbers = DoCommit(dbkey, formgroup, tableorder, Session("tempUniqueID" & dbkey), cpd_id, "add_salt",RegConn)
								RemoveFromTemp dbkey, formgroup, Session("tempUniqueID" & dbkey),RegConn
								Session("ReturnLocation" & dbkey & formgroup) = Session("PreDupCheckLocation" & dbkey)& "&RegActionCompleted=Add_Salt_added"
								temp_array = split(commit_numbers, ":", -1)
								reg_number = temp_array(0)
								salt_name = temp_array(1)
								on error resume next
									reg_id = temp_array(2)
									cpdDBCounter = temp_array(3)
								on error goto 0
								RegReturn = "add_salt" & "," & Session("tempUniqueID" & dbkey) & "," & reg_number  & "," & salt_name  & "," & reg_id & "," & cpdDBCounter
							
							Case "EDIT_STRUCTURE" 
								Session("ReturnLocation" & dbkey & formgroup) = Session("PreDupCheckLocation" & dbkey)&  "&edit_structure=true" & "&RegActionCompleted=edit_structure"
								Response.Redirect Session("ReturnLocation" & dbkey & formgroup)

							Case "SKIP" 
								RegReturn = "skip" & "," & Session("tempUniqueID" & dbkey) & "," & " "  & "," & " "
								Session("ReturnLocation" & dbkey & formgroup) = Session("PreDupCheckLocation" & dbkey)& "&RegActionCompleted=skip"
								markTempRecAsDup dbkey, formgroup,Session("tempUniqueID" & dbkey),Session("DuplicatesFound" & dbkey)

							Case "NEW_COMPOUND" 
							
								Session("DuplicatesFound" & dbkey) = ""
 								'commit structure and return mol_id to pass to DoRelCommit
								'both the cpd_database counter and reg number are returned
								'commit relational data
								commit_unique_id = ""
								tableorder = Application("Full_Commit_Table_Order")
								
								commit_numbers = DoCommit(dbkey, formgroup, tableorder, Session("tempUniqueID" & dbkey), commit_unique_id, "full_commit",RegConn)
								'remove from temp
								RemoveFromTemp dbkey, formgroup, Session("tempUniqueID" & dbkey), RegConn
								Session("ReturnLocation" & dbkey & formgroup)=Request("CurrentLocation") & "&RegActionCompleted=compound_registered"
								temp_array = split(commit_numbers, ":", -1)
								reg_number = temp_array(0)
								batch_number = temp_array(1)
								on error resume next
									reg_id = temp_array(2)
									cpdDBCounter = temp_array(3)
								on error goto 0
								RegReturn = "full_commit" & "," & Session("tempUniqueID" & dbkey) & "," & reg_number  & "," & batch_number & "," & reg_id & "," & cpdDBCounter
						
					End Select 'dup action
				End if 'if not duplicates_check
			
			
				Case "BATCH_MODE" 'commit_mode
						duplicates_found = ""
						Session("DuplicatesFound" & dbkey)= ""
					if the_mol_id > 0 and not(UCase(base64) = "NO_STRUCTURE" OR UCase(base64) = "VmpDRDAxMDAEAwIBAAAAAAAAAAAAAAAAAAAAAAMAEAAAAENoZW1EcmF3IDYuMC4xCAAMAAAAbXl0ZXN0LmNkeAADMgAIAP///////wAAAAAAAP//AAAAAP////8AAAAA//8AAAAA/////wAAAAD/////AAD//wEJCAAAAFkAAAAEAAIJCAAAAKcCAAAXAgIIEAAAAAAAAAAAAAAAAAAAAAAAAwgEAAAAeAAECAIAeAAFCAQAAJoVAAYIBAAAAAQABwgEAAAAAQAICAQAAAACAAkIBAAAswIACggIAAMAYAC0AAMACwgIAAQAAADwAAMADQgAAAAIeAAAAwAAAAEAAQAAAAAACwARAAAAAAALABEDZQf4BSgAAgAAAAEAAQAAAAAACwARAAEAZABkAAAAAQABAQEABwABJw8AAQABAAAAAAAAAAAAAAAAAAIAGQGQAAAAAAJAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAEAhAAAAD+/wAA/v8AAAIAAAACAAABJAAAAAIAAwDkBAUAQXJpYWwEAOQEDwBUaW1lcyBOZXcgUm9tYW4BgAEAAAAEAhAAAAD+/wAA/v8AAAIAAAACAA8IAgABABAIAgABABYIBAAAACQAGAgEAAAAJAAAAAAA") then 'only look for duplicates if there is for sure a structure
						'stop
						duplicates_found = checkForDuplicates(dbkey, formgroup, tempTableUniqueID, "SINGLE_MODE",RegConn) 'returns number of duplicates found
						
						if  duplicates_found <> "" then
							Session("DuplicatesFound" & dbkey & formgroup)=duplicates_found
							bDups = True
							if inStr(duplicates_found, ",")> 0 then
								bMultiDups = True
							else
								bMultiDups = false
							end if
					
						else
							Session("DuplicatesFound" & dbkey & formgroup)=""
							bDups = False
						end if	
					end if				
							
					if bDups = true then
				
						if duplicate_action <> "" AND (bMultiDups = false or duplicate_action="NEW_COMPOUND") then
							duplicates_found_array = split(duplicates_found, ":", -1)
							dup_type = duplicates_found_array(0)
							dup_id = duplicates_found_array(1)
							if UCase(dup_type) = "SALT" then 
								dup_id_name = "cpd_database_counter"
							else
								dup_id_name = "reg_id"
							end if
							Select Case UCase(duplicate_action)
								Case "BATCH_COMMIT" 'in this case not commit the structre only create a new bactch
									reg_id = Session("duplicateIDs" & dbkey) 'what is a duplicate is customizable in getDupCheckRelData
									batchtable = Application(formgroup & dbkey & "RegBatchTable")
									tableorder = Application("New_Batch_Commit_table_order")
									commit_numbers = DoCommit(dbkey, formgroup, tableorder, Session("tempUniqueID" & dbkey), dup_id, "batch_commit",RegConn)
									temp_array = split(commit_numbers, ":", -1)
									if instr(commit_numbers, "unapproved")>0 then
										Session("ReturnLocation" & dbkey & formgroup) = Session("PreDupCheckLocation" & dbkey)& "&RegActionCompleted=Batch_Commit_Not_added"
										reg_number = temp_array(1)
										batch_number = temp_array(2)
										on error resume next
											reg_id = temp_array(3)
											cpdDBCounter = temp_array(4)
										on error goto 0
										if duplicates_found<> "" then
											if Not instr(UCase(duplicates_found), "ERROR") > 0 then
												RegReturn = "unapproved_compound_with_duplicates" & "," & Session("tempUniqueID" & dbkey) & "," & reg_number  & "," & batch_number & "," & reg_id & "," & cpdDBCounter
												Session("DuplicatesFound" & dbkey) = duplicates_found
												markTempRecAsDup dbkey, formgroup,Session("tempUniqueID" & dbkey),Session("DuplicatesFound" & dbkey)
											end if
											RegReturn = "unapproved_compound_with_duplicates" & "," & Session("tempUniqueID" & dbkey) & "," & reg_number  & "," & batch_number & "," & reg_id & "," & cpdDBCounter
										else
											RegReturn = "unapproved_compound_no_duplicates" & "," & Session("tempUniqueID" & dbkey) & "," & reg_number  & "," & batch_number & "," & reg_id & "," & cpdDBCounter
										end if
									else
										RemoveFromTemp dbkey, formgroup, Session("tempUniqueID" & dbkey),RegConn
										Session("ReturnLocation" & dbkey & formgroup) = Session("PreDupCheckLocation" & dbkey)& "&RegActionCompleted=Batch_Commit_added"
										
										reg_number = temp_array(0)
										batch_number = temp_array(1)
										on error resume next
											reg_id = temp_array(2)
											cpdDBCounter = temp_array(3)
										on error goto 0
										RegReturn = "batch_only" & "," & Session("tempUniqueID" & dbkey) & "," & reg_number  & "," & batch_number & "," & reg_id & "," & cpdDBCounter
									end if							
								Case "NEW_COMPOUND" 
									Session("DuplicatesFound" & dbkey) = ""
 									'commit structure and return mol_id to pass to DoRelCommit
									'both the cpd_database counter and reg number are returned
									'commit relational data
									commit_unique_id = ""
									tableorder = Application("Full_Commit_Table_Order")
											
									commit_numbers = DoCommit(dbkey, formgroup, tableorder, Session("tempUniqueID" & dbkey), commit_unique_id, "full_commit",RegConn)
									'remove from temp
									RemoveFromTemp dbkey, formgroup, Session("tempUniqueID" & dbkey),RegConn
									Session("ReturnLocation" & dbkey & formgroup)=Request("CurrentLocation") & "&RegActionCompleted=compound_registered"
									temp_array = split(commit_numbers, ":", -1)
									reg_number = temp_array(0)
									batch_number = temp_array(1)
									on error resume next
										reg_id = temp_array(2)
										cpdDBCounter = temp_array(3)
									on error goto 0
									RegReturn = "full_commit" & "," & Session("tempUniqueID" & dbkey) & "," & reg_number  & "," & batch_number & "," & reg_id & "," & cpdDBCounter
								Case Else
									if Not instr(UCase(duplicates_found), "ERROR") > 0 then
										Session("DuplicatesFound" & dbkey) = duplicates_found
										markTempRecAsDup dbkey, formgroup,Session("tempUniqueID" & dbkey),Session("DuplicatesFound" & dbkey)
										RegReturn = "duplicate_found" & "," & Session("tempUniqueID" & dbkey) & "," & ""  & "," & ""
									else
										RegReturn = "parsing_errors_found" & "," & Session("tempUniqueID" & dbkey) & "," & ""  & "," & ""
									end if
							End Select 'dup action
						else 'else : if duplicate_action <> "" AND bMultiDups = false then
							if Not instr(UCase(duplicates_found), "ERROR") > 0 then
								Session("DuplicatesFound" & dbkey) = duplicates_found
								markTempRecAsDup dbkey, formgroup,Session("tempUniqueID" & dbkey),Session("DuplicatesFound" & dbkey)
								if bMultiDups=true then
									RegReturn = "multiple_duplicates_found" & "," & Session("tempUniqueID" & dbkey) & "," & ""  & "," & ""
								else
									RegReturn = "duplicate_found" & "," & Session("tempUniqueID" & dbkey) & "," & ""  & "," & ""
								end if
							else
								RegReturn = "parsing_errors_found" & "," & Session("tempUniqueID" & dbkey) & "," & ""  & "," & ""
							end if
						end if 'end: if duplicate_action <> "" AND bMultiDups = false then
							
					else 'else: if bDups = true then
						Session("DuplicatesFound" & dbkey) = ""
	 					'commit structure and return mol_id to pass to DoRelCommit
						'both the cpd_database counter and reg number are returned
						'commit relational data
						commit_unique_id = ""
						'tableorder = Application(formgroup & dbkey & "TableOrderFullCommit")
						tableorder = Application("Full_Commit_Table_Order")

						commit_numbers = DoCommit(dbkey, formgroup, tableorder, Session("tempUniqueID" & dbkey), commit_unique_id, "full_commit",RegConn)
						'remove from temp
						RemoveFromTemp dbkey, formgroup, Session("tempUniqueID" & dbkey),RegConn 
						Session("ReturnLocation" & dbkey & formgroup)=Request("CurrentLocation") & "&RegActionCompleted=compound_registered"
						temp_array = split(commit_numbers, ":", -1)
						reg_number = temp_array(0)
						batch_number = temp_array(1)
						on error resume next
							reg_id = temp_array(2)
							cpdDBCounter = temp_array(3)
						on error goto 0
						RegReturn = "full_commit" & "," & Session("tempUniqueID" & dbkey) & "," & reg_number  & "," & batch_number & "," & reg_id & "," & cpdDBCounter
					end if 'end: if bDups = true then
				End Select
			
			Case "NEW_COMPOUND" 
			
				Session("DuplicatesFound" & dbkey) = ""
 				'commit structure and return mol_id to pass to DoRelCommit
				'both the cpd_database counter and reg number are returned
				'commit relational data
				commit_unique_id = ""
				'tableorder = Application(formgroup & dbkey & "TableOrderFullCommit")
				tableorder = Application("Full_Commit_Table_Order")
				commit_numbers = DoCommit(dbkey, formgroup, tableorder, Session("tempUniqueID" & dbkey), commit_unique_id, "full_commit",RegConn)
				
				'remove from temp
				RemoveFromTemp dbkey, formgroup, Session("tempUniqueID" & dbkey),RegConn
				Session("ReturnLocation" & dbkey & formgroup)=Request("CurrentLocation") & "&RegActionCompleted=compound_registered"
				temp_array = split(commit_numbers, ":", -1)
				reg_number = temp_array(0)
				batch_number = temp_array(1)
				on error resume next
					reg_id = temp_array(2)
					cpdDBCounter = temp_array(3)
				on error goto 0
				RegReturn = "full_commit" & "," & Session("tempUniqueID" & dbkey) & "," & reg_number  & "," & batch_number & "," & reg_id & "," & cpdDBCounter
		
			Case "BATCH_COMMIT"
			
				Session("tempUniqueID" & dbkey)=tempTableUniqueID
				if duplicate_ids <> "" then
					reg_id = duplicate_ids
				else
					reg_id =  getValueFromTemp(dbkey, formgroup, "reg_internal_id", Session("tempUniqueID" & dbkey))
				end if
				
				batchtable = "batches"
				'pass in the table order to the "single" DoRelCommit function.  There was too much duplication to support two functions
				tableorder = Application("New_Batch_Commit_table_order")
				commit_numbers = DoCommit(dbkey, formgroup, tableorder, Session("tempUniqueID" & dbkey), reg_id, "batch_commit",RegConn)
				temp_array = split(commit_numbers, ":", -1)
				
				if instr(commit_numbers, "unapproved")>0 then
					Session("ReturnLocation" & dbkey & formgroup)=Request("CurrentLocation") & "&RegActionCompleted=Batch_Commit_added"
					reg_number = temp_array(1)
					batch_number = temp_array(2)
					on error resume next
						reg_id = temp_array(3)
						cpdDBCounter = temp_array(4)
					on error goto 0
					if duplicates_found<> "" then
						if Not instr(UCase(duplicates_found), "ERROR") > 0 then
							RegReturn = "unapproved_compound_with_duplicates" & "," & Session("tempUniqueID" & dbkey) & "," & reg_number  & "," & batch_number & "," & reg_id & "," & cpdDBCounter
							Session("DuplicatesFound" & dbkey) = duplicates_found
							markTempRecAsDup dbkey, formgroup,Session("tempUniqueID" & dbkey),Session("DuplicatesFound" & dbkey)
						end if
						RegReturn = "unapproved_compound_with_duplicates" & "," & Session("tempUniqueID" & dbkey) & "," & reg_number  & "," & batch_number & "," & reg_id & "," & cpdDBCounter
					else
						RegReturn = "unapproved_compound_no_duplicates" & "," & Session("tempUniqueID" & dbkey) & "," & reg_number  & "," & batch_number & "," & reg_id & "," & cpdDBCounter
					end if
				else
					RemoveFromTemp dbkey, formgroup, Session("tempUniqueID" & dbkey),RegConn
					Session("ReturnLocation" & dbkey & formgroup)=Request("CurrentLocation") & "&RegActionCompleted=Batch_Commit_added"
					
					reg_number = temp_array(0)
					batch_number = temp_array(1)
					on error resume next
						reg_id = temp_array(2)
						cpdDBCounter = temp_array(3)
					on error goto 0
					RegReturn = "batch_only" & "," & Session("tempUniqueID" & dbkey) & "," & reg_number  & "," & batch_number & "," & reg_id & "," & cpdDBCounter
				end if			
			Case "ADD_SALT"
				Session("tempUniqueID" & dbkey)=tempTableUniqueID
				if duplicate_ids <> "" then
					cpd_database_counter = duplicate_ids
				else
					cpd_database_counter =  getValueFromTemp(dbkey, formgroup, "cpd_internal_id", Session("tempUniqueID" & dbkey))
				end if
				
				tableorder = Application("Add_Salt_Commit_table_order")
				commit_numbers = DoCommit(dbkey, formgroup, tableorder, Session("tempUniqueID" & dbkey), cpd_database_counter, "add_salt",RegConn)
				RemoveFromTemp dbkey, formgroup, Session("tempUniqueID" & dbkey),RegConn 
				Session("ReturnLocation" & dbkey & formgroup)=Request("CurrentLocation") & "&RegActionCompleted=Add_Salt_added"
				temp_array = split(commit_numbers, ":", -1)
				reg_number = temp_array(0)
				salt_number = temp_array(1)
				on error resume next
					reg_id = temp_array(2)
					cpdDBCounter = temp_array(3)
				on error goto 0
				RegReturn = "add_salt" & "," & Session("tempUniqueID" & dbkey) & "," & reg_number  & "," & salt_number & "," & reg_id & "," & cpdDBCounter

						
			Case "ADD_IDENTIFIERS"
			
			
				Session("tempUniqueID" & dbkey)=tempTableUniqueID
				if duplicate_ids <> "" then
					reg_id = duplicate_ids
				else
					reg_id =  getValueFromTemp(dbkey, formgroup, "reg_internal_id", Session("tempUniqueID" & dbkey))
				end if
				tableorder = Application("Add_Identifiers_Commit_table_order")
				commit_numbers = DoCommit(dbkey, formgroup, tableorder, Session("tempUniqueID" & dbkey), reg_id, "add_identifiers",RegConn)
				RemoveFromTemp dbkey, formgroup, Session("tempUniqueID" & dbkey),RegConn
				Session("ReturnLocation" & dbkey & formgroup)=Request("CurrentLocation") & "&RegActionCompleted=identifiers_added"
				temp_array = split(commit_numbers, ":", -1)
				reg_number = temp_array(0)
				RegReturn = "add_identifiers" & "," & Session("tempUniqueID" & dbkey) & "," & reg_number  & "," & " "

			Case "DELETE_RECORD"
				
				RemoveFromTemp dbkey, formgroup, tempTableUniqueID,RegConn
				Session("ReturnLocation" & dbkey & formgroup)=Request("CurrentLocation") & "&RegActionCompleted=record_deleted"
				Session("ReturnLocation" & dbkey & formgroup) = Replace(Session("ReturnLocation" & dbkey & formgroup), "formmode=edit_record", "formmode=edit")
				reg_number = ""
				batch_number = ""
				session("formmode_loaded") = "edit"
				RegReturn = "record_deleted" & "," & tempTableUniqueID & "," & reg_number  & "," & batch_number
		End Select
	end if
	
	'LogRegAction dbkey, formgoup, RegReturn
	DoRegCommit = RegReturn
End Function


'********************************************************************************************
'SUB NAME: LogRegMsg
'PURPOSE: Add entry to log file
'CALLED BY: Any
'RETURNS: Log entry in RegisterLog file
'INPUTS: dbkey,formgroup, theMsg string
'******************************************************************
Sub LogRegMessage(dbkey, formgroup, theMsg)
	on error resume next
	filepath = Application("AppPath")  & "\logfiles\" & "RegisterLog.html"
	Set fs = Server.CreateObject("Scripting.FileSystemObject")
	Set a = fs.OpenTextFile(filepath, 8, True) 
	user_array = split(Session("CurrentUser" & dbkey), ":" , -1)
	a.WriteLine Now & "<br>"
	a.WriteLine "Processed by: " & user_array(1) & "<br>"
	a.WriteLine theMsg & "<br>"
	a.WriteLine " "
	a.close
	Set fs = Nothing
	Set a = Nothing
End Sub


'********************************************************************************************
'SUB NAME: LogRegAction
'PURPOSE: Add entry to log file RegisterLog
'CALLED BY: DoRegCommit 
'RETURNS: Nothing
'INPUTS: dbkey,formgroup, RegReturn string
'******************************************************************
Sub LogRegAction(dbkey, formgroup, RegReturnString)
	' on error resume next
	On Error Goto 0
	
	filepath = Application("AppPath")  & "\logfiles\" & "RegisterLog.html"
	Set fs = Server.CreateObject("Scripting.FileSystemObject")
	Set a = fs.OpenTextFile(filepath, 8, True) 
	theMsg = buildRegMessage(RegReturnString, "log")
	user_array = split(Session("CurrentUser" & dbkey), ":" , -1)
	a.WriteLine Now & "<br>"
	if UBound(user_array)>0 Then
		a.WriteLine "Processed by: " & user_array(1) & "<br>"
	else
		a.WriteLine "Processed by: " & Session("CurrentUser" & dbkey) & "<br>"
	end if
	a.WriteLine theMsg & "<br>"
	a.WriteLine " "
	a.close
	Set fs = Nothing
	Set a = Nothing

End Sub


'********************************************************************************************
'SUB NAME: getAllTempIDS
'PURPOSE: get a string delimted list of all tempIDS in temporary table for batch register mode
'CALLED BY: formaction_vbs : dataaction = register_all 
'RETURNS: list of tempIDS
'									
'			
'INPUTS: dbkey,formgroup
'******************************************************************
Function getAllTempIDS(dbkey, formgroup)
	temp_table =Application(formgroup & dbkey & "RegTempBaseTable")
	temp_table_strucid = GetTableVal(dbkey, temp_table, kStrucFieldID)
	temp_table_baseid =  GetTableVal(dbkey, temp_table, kPrimaryKey)
	on error resume next
	 if Not isObject(RegConn)  then
		Set RegConn = GetRegConn(dbkey, formgroup)
	end if

	Set TempRS = Server.CreateObject("ADODB.Recordset")
	TempRS.Open "select * from " & temp_table, RegConn
	if not (TempRS.BOF AND TemprRS.EOF) then
		TempRS.MoveFirst		
		Do While Not TempRS.EOF	
			if theResult <> "" then
				theResult = theResult & "," & TempRS(temp_table_baseid)
			else
				theResult = TempRS(temp_table_baseid)
			End if
		TempRS.MoveNext
		Loop
	End if
	CloseRS(TempRS)
	'CloseConn(TempConn)
	getAllTempIDS = theResult
End Function


'********************************************************************************************
'SUB NAME: markTempRecAsDup
'PURPOSE: mark a temp record as a dup 
'									
'			
'INPUTS: dbkey,formgroup, temp_id, dup_id
'******************************************************************
sub markTempRecAsDup(dbkey, formgroup,tempID,dup_id)
	Dim temp_basetable,temp_baseid,sql,theValue
	on error resume next
	 if Not isObject(RegConn)  then
		Set RegConn = GetRegConn(dbkey, formgroup)
	end if

	Set cmd = server.CreateObject("adodb.command")
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	sql ="Update temporary_structures set duplicate=? Where temp_compound_id=?"
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("pDupID", 200, 1, Len(dup_id)+1, dup_id) 
	cmd.Parameters.Append cmd.CreateParameter("pTempID", 139, 1, 0, tempID) 
	cmd.execute
	
	'CloseConn(RegConn)

End sub

'********************************************************************************************
'SUB NAME: getRegistryNumber
'PURPOSE: verify that a registry number entered by a user is valid
'CALLED BY: formaction_vbs : dataaction = get_reg_number 
'			(used by add batch, add identifiers, add salt buttons on main screen).
'RETURNS VIA QUERYSTRING:	dbkey
'							formgroup
'							regnum_verified  = true|false
'									
'			
'INPUTS: none
'******************************************************************
Sub getRegistryNumber(dbkey, formgroup)
	dbkey = Request.QueryString("dbname")
	formgroup = Request.QueryString("formgroup")
	Commit_Type = Request.QueryString("commit_type")
	reg_number = Request.Form("reg_value")
	theValue = verifyReg(dbkey, formgroup, reg_number, commit_type)
	if theValue <> "" then
		reg_number_verified= true
		tempArray = Split(theValue, ":", -1)
		reg_id = tempArray(0)
		cpd_database_counter = tempArray(1)
	else
		reg_number_verified = false
	end if
	Select Case UCase(Commit_Type)
		Case "BATCH_COMMIT"
			if reg_number_verified = true then
					returnLocation= "/" & Application("appkey") & "/reg/batch_ctrbt_form.asp?formmode=add_compounds&formgroup=batch_ctrbt_form_group&dbname=reg&commit_type=batch_commit&the_regnum_verified=true&the_reg_id=" & reg_id & "&cpd_counter=" & cpd_database_counter
				else
					returnLocation= "/" & Application("appkey") & "/source/get_registered.asp?formmode=get_registered&formgroup=batch_ctrbt_form_group&dbname=reg&commit_type=batch_commit&the_regnum_verified=false&cpd_counter=" & "dne"				
			end if
			Case "ADD_IDENTIFIERS"
			if reg_number_verified = true then
				returnLocation= "/" & Application("appkey") & "/reg/identifier_ctrbt_form.asp?formmode=add_compounds&formgroup=identifier_ctrbt_form_group&dbname=reg&commit_type=add_identifiers&the_regnum_verified=true&the_reg_id=" & reg_id& "&cpd_counter=" & cpd_database_counter
			else
				returnLocation= "/" & Application("appkey") & "/source/get_registered.asp?formmode=get_registered&formgroup=identifier_ctrbt_form_group&dbname=reg&commit_type=add_identifiers&the_regnum_verified=false&cpd_counter=" & "dne"				
			end if
	
		Case "ADD_SALT"
			if reg_number_verified = true then
				if cpd_database_counter = "all_available" then
					returnLocation= "/" & Application("appkey") & "/source/get_registered.asp?formmode=get_registered&formgroup=salt_ctrbt_form_group&dbname=reg&commit_type=add_salt&the_regnum_verified=false&cpd_counter=" & "all_available"				
				else
					returnLocation= "/" & Application("appkey") & "/reg/salt_ctrbt_form.asp?formmode=add_compounds&formgroup=salt_ctrbt_form_group&dbname=reg&commit_type=add_salt&the_regnum_verified=true&cpd_counter=" & cpd_database_counter				
				end if
			else
				returnLocation= "/" & Application("appkey") & "/source/get_registered.asp?formmode=get_registered&formgroup=salt_ctrbt_form_group&dbname=reg&commit_type=add_salt&the_regnum_verified=false&cpd_counter=" & "dne"				
			end if

		Case "ADD_ANALYTICS_DATA"
			if reg_number_verified = true then
				batch_id = reg_id
				returnLocation= "/" & Application("appkey") & "/analytics/analytics_DE_start.asp?formmode=edit&formgroup=add_analytics_form_group&dbname=reg&commit_type=add_analytics_data&alt_unique_id=" & batch_id & "&indexvalue=0"
			else
				returnLocation= "/" & Application("appkey") & "/source/get_registered.asp?formmode=get_registered&formgroup=add_analytics_form_group&dbname=reg&commit_type=add_analytics_data&the_regnum_verified=false&cpd_counter=" & "dne"				
			end if
		'Start Givaudan EVAL customization
		Case "ADD_EVAL_DATA"
		
		if reg_number_verified = true then	
			if reg_id="eval_already_exists" then
				returnLocation= "/" & Application("appkey") & "/source/get_registered.asp?formmode=get_registered&formgroup=add_eval_data_form_group&dbname=reg&commit_type=add_eval_data&the_regnum_verified=false&cpd_counter=" & "eval_already_exists"				
			else
				batch_id = reg_id
				returnLocation= "/" & Application("appkey") & "/evscreen/add_eval_data_form.asp?formmode=add_eval_data&formgroup=add_eval_data_form_group&dbname=reg&commit_type=add_eval_data&alt_unique_id=" & batch_id & "&indexvalue=0"
			end if 
		else
			returnLocation= "/" & Application("appkey") & "/source/get_registered.asp?formmode=get_registered&formgroup=add_eval_data_form_group&dbname=reg&commit_type=add_eval_data&the_regnum_verified=false&cpd_counter=" & "dne"				
		end if
		'End Givaudan EVAL customization
	End Select
	
	Session("ReturnLocation" & dbkey & formgroup) = returnLocation
End Sub




'********************************************************************************************
'FUNCTION NAME: DoCommitStrucByID
'PURPOSE: commit structure to compound using ChemFinder
'CALLED BY: DoCommit
'RETURNS: mol_id of commited structure
'INPUTS:	dbkey
'			formgroup
'			Compound_CPD_ID = the compound table base id for the new record added to which the structure
'			will be committed
'			
'******************************************************************
Function DoCommitStrucByID(ByVal cpd_internal_id, ByVal dbkey, ByVal formgroup,  ByRef RegConn, ByVal base64_cdx)
			'stop
			if Not isObject(RegConn) then
				set RegConn = getRegConn(dbkey, formgroup)
			end if
			on error resume next
			
			dateTimeStamp =  Session("DateTime_Stamp")
			LoadID=Session("Load_ID")
			if  isNull(LoadID) then
				LoadID = ""
			end if
			on error resume next
			'add empty base64 record
			Set StrucRS = Server.CreateObject("ADODB.RECORDSET")
			sql =	"INSERT INTO STRUCTURES (CPD_INTERNAL_ID,LOAD_ID,DATETIME_STAMP,BASE64_CDX ) VALUES (?,?,?,empty_clob())"
			'err.Clear()
			Set cmd = Server.CreateObject("adodb.command")
			cmd.ActiveConnection =  RegConn
			cmd.CommandType = adCmdText
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("pCPD", 139, 1, 0, cpd_internal_id) 
			cmd.Parameters.Append cmd.CreateParameter("pLoadID", 200, 1,Len(LoadID)+1, Cstr(LoadID))
			cmd.Parameters.Append cmd.CreateParameter("pSessionID", 200, 1, Len(dateTimeStamp)+1, Cstr(dateTimeStamp))
			cmd.Execute 
			if err.number <> 0 then
				err_number = err.number
				err_description = err.Description
				logaction("insert empty base64 error. cpd:" & cpd_internal_id & ":" &  err.number & err.Description)
				err.Raise err_number, , "insert empty base64 error. cpd:" & cpd_internal_id & ":" &  err_number & err_Description
			end if
		
			'add structure
			on error resume next
			sql = "SELECT BASE64_CDX,MOL_ID FROM STRUCTURES WHERE CPD_INTERNAL_ID=?"
			Set cmd = Server.CreateObject("adodb.command")
			cmd.ActiveConnection =  RegConn
			cmd.CommandType = adCmdText
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("pCPD", 139, 1, 0, cpd_internal_id) 
			
			
			Set RS = Server.CreateObject("adodb.recordset")
			StrucRS.LockType= 3
			StrucRS.CursorType=1
			StrucRS.Open cmd
			  
			if 	base64_cdx <> "" then
				StrucRS("BASE64_CDX").value= base64_cdx
			end if
			StrucRS.Update
			
			'SYAN added on 12/15/2004 to fix CSBR-49812
			if err.number <> 0 then
				logaction "In DoCommitStrucByID, structure is not successfully inserted into STRUCTURES table, returned error is: " & err.number & " -- " & err.Description
			end if
			'End of SYAN modification
			
			mol_id = StrucRS("MOL_ID")
			StrucRS.Close

			'SYAN added on 12/15/2004 to fix CSBR-49812
			if err.number <> 0 then
				logaction "In DoCommitStrucByID, StrucRS is not successfully closed, returned error is: " & err.number & " -- " & err.Description
			end if
			'End of SYAN modification

			if err.number <> 0 then
				err_number = err.number
				err_description = err.Description
				logaction("add structure error. cpd:" & cpd_internal_id & ":" &  err.number & err.Description)
				err.Raise err_number, , "add structure error. cpd: " & cpd_internal_id & ":" &  err_number & err_Description
			end if
			if mol_id = ""  then
				mol_id=0
			else
				DoCommitStrucByID =	 CLng(mol_id)
			end if
		
		
End Function

'SYAN added on 6/1/2006 to support salt stripping
Function DoCommitFrag( ByVal dbkey, ByVal formgroup, Byref RegConn, ByVal base64_cdx, ByVal fragType)
	'stop
	If not IsObject(RegConn) then
		set RegConn = getRegConn(dbkey, formgroup)
	end if
	
	if fragType = "SALT" then
		duplicates_found = DoCartridgeDuplicateSearch(dbkey, formgroup, "REGDB.SALTS.BASE64_CDX", base64_cdx, RegConn, "SALT_CODE")
	elseif fragType = "SOLVATE" then
		duplicates_found = DoCartridgeDuplicateSearch(dbkey, formgroup, "REGDB.SOLVATES.BASE64_CDX", base64_cdx, RegConn, "SOLVATE_ID")
	end if
	
	'SYAN removed this for Cara on 6/11/2007 as the first step to sync between reg salts table and ChemScript salts table.
	'Only salts existing in reg will be stripped. Salts don't exist in reg will not be stripped.
	if duplicates_found = "" then
	'	dateTimeStamp =  Session("DateTime_Stamp")

	'	sql = "INSERT INTO REGDB.FRAGMENTS (BASE64_CDX, DATETIME_STAMP) VALUES (empty_clob(), ?) returning FRAGMENT_ID INTO ?"

	'	Set cmd = Server.CreateObject("adodb.command")
	'	cmd.ActiveConnection =  RegConn
	'	cmd.CommandType = adCmdText
	'	cmd.CommandText = sql
	'	cmd.Parameters.Append cmd.CreateParameter("pSessionID", 200, 1, Len(dateTimeStamp)+1, Cstr(dateTimeStamp))
	'	cmd.Parameters.Append cmd.CreateParameter("pOut", 139, 2, 20) 
	'	cmd.Execute 
	'
	'	frag_id = cmd.parameters(1).value
	'
	'	cmd.Parameters.Delete "pSessionID"
	'	cmd.Parameters.Delete "pOut"
	'	
	'	Set FragRS = Server.CreateObject("ADODB.RECORDSET")
	'
	'	sql = "SELECT BASE64_CDX FROM REGDB.FRAGMENTS WHERE FRAGMENT_ID=?"
	'	cmd.ActiveConnection =  RegConn
	'	cmd.CommandType = adCmdText
	'	cmd.CommandText = sql
	'	cmd.Parameters.Append cmd.CreateParameter("frag_id", 139, 1, 0, frag_id) 
	'			
	'	FragRS.LockType= 3
	'	FragRS.CursorType=1
	'	FragRS.Open cmd
	'			  
	'	if 	base64_cdx <> "" then
	'		FragRS("BASE64_CDX").value= base64_cdx
	'	end if
	'	FragRS.Update
	'	FragRS.Close
	'		
	'		
	'	fragMwFormula = getMW_and_Formula(dbkey, formgroup, "FRAGMENTS", frag_id, RegConn, base64_cdx)
	'	
	'	fragMwFormulaArray = Split(fragMwFormula, ":", -1)
	'	
	'	fragMw=fragMwFormulaArray(0)
	'	
	'	if fragMw = "0" or fragMw = -1 or fragMw = "-1" or fragMw = 0 then
	'		fragMw = null
	'	end if
	'
	'	if Not isNull(fragMw) then
	'		fragMw= Cdbl(fragMw)
	'	end if	
	'	
	'	fragFormula = fragMwFormulaArray(1)						
	'
	'	sql = "INSERT INTO REGDB.SALTS (SALT_NAME, SALT_MW, SALT_MF, FRAGMENT_ID) VALUES (?, ?, ?, ?) returning SALT_CODE INTO ?"
	'
	'	Set cmd = Server.CreateObject("adodb.command")
	'	cmd.ActiveConnection =  RegConn
	'	cmd.CommandType = adCmdText
	'	cmd.CommandText = sql
	'	cmd.Parameters.Append cmd.CreateParameter("pSaltName", 200, 1, Len(fragFormula) + 1, fragFormula)
	'	cmd.Parameters.Append cmd.CreateParameter("pSaltMW", 139, 1, 0, fragMw) 
	'	cmd.Parameters.Append cmd.CreateParameter("pSaltMF", 200, 1,Len(fragFormula) + 1, fragFormula) 
	'	cmd.Parameters.Append cmd.CreateParameter("pFragmentID", 139, 1, 0, frag_id) 
	'	cmd.Parameters.Append cmd.CreateParameter("pOut", 139, 2, 20) 
	'	cmd.Execute 
	'	
	'	session("salt_id") = ""
	'	session("salt_id") = cmd.parameters(4).value
	'
	'	if err.number = 0 then
	'	else
	'		err_number = err.number
	'		err_description = err.Description
	'		logaction("insert  base64 into FRAGMENTS error. " & err.number & err.Description)
	'		err.Raise err_number, , "insert empty base64 into FRAGMENTS error. " & err.number & err.Description
	'	end if
	'			
	'	if frag_id = ""  then
	'		frag_id = 0
	'	else
	'		retVal = CLng(frag_id)
	'	end if
	else 'duplicate found
		'stop
		retVal = duplicates_found
		if fragType = "SALT" then
			session("salt_id") = duplicates_found
		elseif fragType = "SOLVATE" then
			session("solvate_id") = duplicates_found
		end if
	end if 
	
	DoCommitFrag = retVal
End Function

'End of SYAN modification

Function DoCommit(ByVal dbkey, ByVal formgroup, ByVal tableorder, ByVal tempid, ByVal unique_id, ByVal commit_type, ByRef RegConn)
		'stop
		on error resume next
		Session("Current_Reg_Number")=""
		reg_table = "Reg_Numbers"
		reg_table_baseid = "Reg_ID"
		compound_table = "compound_molecule"
		temp_table ="temporary_structures"
		compound_table_strucid = "CPD_Database_Counter"
		compound_table_baseid =   "CPD_Database_Counter"
		batches_table = "batches"
		batch_table_baseid = "reg_internal_id"
		
		
		set RegConn = getRegConn(dbkey, formgroup)
		
		failtrans = ""
		RegConn.BeginTrans
		on error resume next
		'Start Transaction
		DBMSUser_ID = Session("CurrentUser" & dbkey)
		if Not temp_id = "NO_TEMP_TABLE" then
			temp_table_strucid = GetTableVal(dbkey, temp_table, kStrucFieldID)
			temp_table_baseid =  GetTableVal(dbkey, temp_table, kPrimaryKey)
		
			
			Set TempRS = Server.CreateObject("ADODB.Recordset")
			Set cmd = Server.CreateObject("adodb.command")
			cmd.ActiveConnection = RegConn
			cmd.CommandType = adCmdText	
			sql = "select * from temporary_structures where temp_compound_id=?"
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("ptempid", 139, 1, 0, tempid) 
			TempRS.Open Cmd
			Session("load_id") = TempRS("Load_ID")
			bTEMPTABLE = true
		else
			'Session("load_id") = Session("SearchData" & "Temporary_Structures.Load_id" & dbkey)
			Session("load_id") =Request("Temporary_Structures.Load_id")
			bTEMPTABLE = false
		end if
		
		'stop
		if CBool(Application("USE_BATCH_SCIENTIST_AS_REGISTRAR")) = true then
			if bTEMPTABLE = false then
				registry_person_id= Session("SearchData" & "Temporary_Structures.Scientist_ID" & dbkey & formgroup) 
			else
				registry_person_id = TempRS("Scientist_ID")
			end if
		else
			registry_person_id = getValueFromTablewConn(RegConn,"People", "User_ID",UCase(DBMSUser_ID),"Person_ID")
		end if
		
		Set CommitRS = Server.CreateObject("ADODB.Recordset")
		CommitRS.LockType= 3
		CommitRS.CursorType=1
		'open the temp table record
	
		commit_type = UCase(commit_type)
		'get the cpdDBCounter and reg_number depending on the type of commit
		Select Case commit_type
			Case "BATCH_COMMIT"
			
				reg_id = unique_id
				'get current batch number from reg table
				sql = "Select LAST_BATCH_NUMBER From reg_numbers where reg_id=?"
				Set cmd = Server.CreateObject("adodb.command")
				cmd.ActiveConnection = RegConn
				cmd.CommandType = adCmdText
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("preg_id", 139, 1, 0, reg_id) 
				CommitRS.Open cmd
				
				
				LastBatchNumber = CommitRS("LAST_BATCH_NUMBER")
				LastBatchNumber = CLng(LastBatchNumber)
				currentBatchNumber = CLng(LastBatchNumber + 1)
				
				CommitRS("LAST_BATCH_NUMBER") = currentBatchNumber
				
				CommitRS.Update
				CommitRS.Close
				Set cmd = Server.CreateObject("adodb.command")
				cmd.ActiveConnection = RegConn
				cmd.CommandType = adCmdText
				sql ="select cpd_internal_id, reg_number from reg_numbers where reg_id = ?"
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("preg_id", 139, 1, 0, reg_id) 
				CommitRS.Open cmd
				
				
				cpd_id = CommitRS("cpd_internal_id")
				cpdDBCounter=cpd_id
				RegNumber = CommitRS("reg_number")
				CommitRS.Close
				
				if CBool(Application("APPROVED_FLAG_USED")) = True and CBool(Application("ALLOW_BATCH_FOR_UNAPPROVED_CMPD")) = false then
					firstBatchID = getFirstBatchID(RegConn, reg_ID)
					bFBApproved = getApprovedFlag(RegConn, reg_ID, firstBatchID)
					if bFBApproved = false then
						if bTEMPTABLE = false then 'put it in the temp table if not already there.
							temp_id = DoRegTemp(dbkey, formgroup, "BATCH_COMMIT")
						end if
						DoCommit= "unapproved_compound" & ":"  & RegNumber & ":" & "1" & ":" & reg_id & ":" & cpdDBCounter
						exit function
					end if
					
				end if
				sql = "select Root_Number,MOL_ID,Sequence_internal_id from compound_molecule where cpd_database_counter = ?"
				Set cmd = Server.CreateObject("adodb.command")
				cmd.ActiveConnection = RegConn
				cmd.CommandType = adCmdText
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("preg_id", 139, 1, 0, cpd_id) 
				CommitRS.Open cmd
				
				
				RootNumber = CommitRS("Root_Number")
				compound_molid = CommitRS("MOL_ID")
				Sequence_id = CommitRS("Sequence_internal_id")
				
				CommitRS.Close
				
			Case "ADD_IDENTIFIERS"
				reg_id =  getValueFromTemp(dbkey, formgroup, "reg_internal_id", Session("tempUniqueID" & dbkey))
				RegNumber = getValueFromTableWCOnn(RegConn, "reg_numbers", "reg_id",reg_id,"Reg_number")

			Case "FULL_COMMIT"
			
				'get  next sequence number for prefix specified in temporary table
				
				' CODE TO USE  Legacy Support
				LegacyRegNumber = ""
				if CBool(Application("LEGACY_IMPORT_ENABLED")) = true then
					if bTEMPTABLE = true then
						LegacyRegNumber = TempRS("LEGACY_REG_NUMBER")
						Sequence_ID = TempRS("SEQUENCE_ID")
					else
						LegacyRegNumber = request("TEMPORARY_STRUCTURES.LEGACY_REG_NUMBER")
						Sequence_ID = request("TEMPORARY_STRUCTURES.SEQUENCE_ID")
					end if
					RootNumber = LegacyRegNumber
					'DGB 10/2003 Introduced smarter sequence parsing to support suffixes
					sequence_number = ParseSequence(LegacyRegNumber, Application("Prefix_Delimiter"))
				end if
				
				'SYAN modified on 11/29/2004 to fix Fujitsu problem
				'If LegacyRegNumber = "" then 'if not regnumber is passed we need to genarate it
				If IsNull(LegacyRegNumber) or LegacyRegNumber = "" then 'if not regnumber is passed we need to genarate it
				'End of SYAN modification
					'get  next sequence number for prefix specified in temporary table
					if bTEMPTABLE = true then
						Sequence_ID = TempRS("SEQUENCE_ID")
					else
						Sequence_ID = Session("SearchData" & "temporary_structures.sequence_id" & dbkey & formgroup)
					end if
						if inStr(Sequence_ID, ".") > 0 then
							RegConn.RollbackTrans
							logaction("commit failed. prefix value is incorrect data type must be an integer.")
							docommit = "commit failed. prefix value is incorrect data type must be an integer."
							exit function
						end if
						sql = "select PREFIX from sequence where sequence_id = ?"
						Set cmd = Server.CreateObject("adodb.command")
						cmd.ActiveConnection = RegConn
						cmd.CommandType = adCmdText
						cmd.CommandText = sql
						cmd.Parameters.Append cmd.CreateParameter("pSequence_ID", 139, 1, 0, Sequence_ID) 
						CommitRS.Open cmd
						
						if err.number <> 0 then
							err_number = err.number
							err_description = err.Description
							RegConn.RollbackTrans
							logaction("commit failed. prefix value is incorrect data type. Prefix must be an integer. " & err_number & err_description)
							docommit = "commit failed. prefix value is incorrect data type. Prefix must be an integer. " & err_number & err_description
							exit function
						end if
						
						Prefix = CommitRS("PREFIX")
						if Prefix = "" then
							if err.number <> 0 then
								err_number = err.number
								err_description = err.Description
								RegConn.RollbackTrans
								logaction("commit failed. prefix value does not exist in sequence table. ")
								docommit = "commit failed. prefix value does not exist in sequence table."
								exit function
							end if
						end if
						'DGB 10/2003 added support for null prefix
						If Ucase(Prefix) = "NO PREFIX" then 
							Prefix = ""
						end if
						CommitRS.Close
					
							
					RootNumOK = False
					DisplayMsg = False

					' Find the next available Root_Number in a sequence by searching
					' for all possible ones from the stated last and only processing
					' the record if the Compound_Molecule table has a count of 0 for that
					' root number.
					Do while RootNumOK = False
						sql = "select NEXT_IN_SEQUENCE from sequence where sequence_id = ?"
						Set cmd = Server.CreateObject("adodb.command")
						cmd.ActiveConnection = RegConn
						cmd.CommandType = adCmdText
						cmd.CommandText = sql
						cmd.Parameters.Append cmd.CreateParameter("pSequence_ID", 139, 1, 0, Sequence_ID) 
						CommitRS.Open cmd
						cmd.Parameters.Delete "pSequence_ID"
						RootNumberVal = CommitRS("NEXT_IN_SEQUENCE")

						on error resume next
						Regtest = CLng(RootNumberVal)
						if err.number <> 0 then	
							CommitRS.Close				
							sql = "Select Root_Number from Compound_Molecule where sequence_id=? order by root_number ascending"
							Set cmd = Server.CreateObject("adodb.command")
							cmd.ActiveConnection = RegConn
							cmd.CommandType = adCmdText
							cmd.CommandText = sql
							cmd.Parameters.Append cmd.CreateParameter("pSequence_ID", 139, 1, 0, Sequence_ID) 
							CommitRS.Open cmd
							

							if Not (CommitRS.EOF AND COmmitRS.BOF) then
								CommitRS.MoveLast
								lastRootNum = CommitRS("Root_Number")
								Prefixlength = Len(Prefix)
								lastRootNumLen = Len(lastRootNum)
								lastRootNum = Right(LastRootNum,(lastRootNumLen-PrefixLength))
								lastNum = CLng(lastRootNum)
								Regtest = lastNum
								CommitRS.Close
								
								sql = "Select NEXT_IN_SEQUENCE from sequence where sequence_id=?"
								Set cmd = Server.CreateObject("adodb.command")
								cmd.ActiveConnection = RegConn
								cmd.CommandType = adCmdText
								cmd.CommandText = sql
								cmd.Parameters.Append cmd.CreateParameter("pSequence_ID", 139, 1, 0, Sequence_ID) 
								CommitRS.Open cmd
								cmd.Parameters.Delete "pSequence_ID"
							else
								RegTest = 1
							end if
						end if
						on error goto 0
						if Not (Regtest>0) then 
							Regtest = 1
						end if
						' RootNumber = buildRootNumber(dbkey, formgroup,Prefix,RootNumberVal)
						RootNumber = buildRootNumber(dbkey, formgroup,Prefix,Regtest)
						sequence_number = Regtest
						nextRegNumber = CLng(Regtest + 1)
						CommitRS("NEXT_IN_SEQUENCE") = nextRegNumber
						CommitRS.Update
						CommitRS.Close
						
						Set TestRS = Server.CreateObject("adodb.recordset")
						sql = "Select count(*) as nMols From Compound_Molecule where Root_Number =?"
						Set cmd = Server.CreateObject("adodb.command")
						cmd.ActiveConnection = RegConn
						cmd.CommandType = adCmdText
						cmd.CommandText = sql
						cmd.Parameters.Append cmd.CreateParameter("pRootNumber", 200, 1, Len(RootNumber), RootNumber) 
						TestRS.Open cmd
						
						TestRS.MoveFirst
						temp_count = TestRS("nMols").Value
						theCount = CLng(temp_count)
						CloseRS(TestRS)
								
						if theCount > 0 then
							RootNumOK = False
						else
							RootNumOK = True
						end if
					Loop
				end if 'END Legacy Support
				'end get unique sequence number
				on error resume next	
							
				Set cmd = Server.CreateObject("adodb.command")
				cmd.ActiveConnection = RegConn
						
				sql = "INSERT INTO compound_molecule (Root_Reg_Date) values(sysdate) RETURNING rowid INTO ?"
				cmd.commandType = 1
				cmd.commandtext = sql
				cmd.Parameters.Append cmd.CreateParameter("pOut", 200, 2,20) 
				cmd.execute
				rowid = cmd.parameters(0).value
				
				'DGB do not resue the command object
				set cmd = nothing
				Set cmd = Server.CreateObject("ADODB.Command")
				cmd.ActiveConnection = RegConn
				cmd.CommandType = adCmdText
				sql = "Select * from compound_molecule where rowid =?"
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("pRootNumber", 200, 1, len(rowid), rowid) 
				CommitRS.Open cmd
				
				
				
								'loop through fields in temp table and get relevant information for current table

				if bTEMPTABLE=false then
					'stop
					CommitFromHTTPRequest dbkey, formgroup,"compound_molecule", CommitRS,RegConn
					CommitRS("root_number") = RootNumber
					CommitRS("Sequence_internal_id") = Sequence_ID
					CommitRS("LOAD_ID") = Session("load_id")
					current_prefix = Prefix
					CommitRS("DATETIME_STAMP") = Session("DateTime_Stamp")
				else		
					CommitFromTempTableRS dbkey, formgroup,"compound_molecule", CommitRS,RegConn,TempRS
					CommitRS("root_number") = RootNumber
					CommitRS("Sequence_internal_id") = Sequence_ID
					CommitRS("LOAD_ID") = Session("load_id")
					current_prefix = Prefix
				end if 'get information directly from post
				CommitRS("DATETIME_STAMP") = Session("DateTime_Stamp")
				
				CommitRS.Update
				if err.number <> 0 then
					err_number = err.number
					err_description = err.Description
					RegConn.RollbackTrans
					returnVal= DoManualRollbackSequence(dbkey,formgroup,RegConn,RootNumberVal, Sequence_id)
					if Not Session("no_gui" & dbkey & formgroup) = True then
						response.write "Compound_Molecule commit failed"
						if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
							response.write "commit failed at compound_molecule table. See \inetpub\cfwlog.txt filefor more information. Transaction could not be rolled-back. " & returnval
						else
							response.write "commit failed at compound_molecule table. See \inetpub\cfwlog.txt filefor more information. Transaction rolled back." 
						end if
						logaction("commit failed at compound_molecule table. temp_compound_id " & tempid & " error: " & err_number & err_description)
						response.end
					else
						if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
							DoCommit=  "commit failed at compound_molecule table. See \inetpub\cfwlog.txt filefor more information. Transaction could not be rolled-back.  " & returnval
						else
							DoCommit=  "commit failed at compound_molecule table. See \inetpub\cfwlog.txt filefor more information. Transaction rolled-back. " & ""
						end if
						logaction("commit failed  at compound_molecule table. Error: " & err_number & err_description)
						Post_String = replace(Request.Form, "user_pwd=" & request("user_pwd"),"user_pwd=XXXXX")
						logaction("full post:" & Post_String)		
						exit function
					end if

				end if
				cpdDBCounter = CommitRS(compound_table_baseid)
				' DGB delay deletion of parameter until we are done with RS 
				cmd.Parameters.Delete "pRootNumber"
				if CBool(Application("PROJECT_LEVEL_ROW_SECURITY")) = true then
				
					AddCmpdProject dbkey, formgroup, bTEMPTABLE, RegConn,TempRS,cpdDBCounter
				end if
				'now commit structure
		
				if bTEMPTABLE=false then
				
					base64 = Session("SearchData" & "temporary_structures.structure" & dbkey & formgroup)
				else	
					'SYAN modified on 6/11/2007 for Cara
					'stop
					if Request("KeepRadio") = "modified" then
						base64 = TempRS("BASE64_CDX")
					elseif Request("KeepRadio") = "original" then
						base64 = TempRS("BASE64_CDX_ORIGINAL")
					else
						base64 = TempRS("BASE64_CDX")
					end if
					'end of SYAN modification
					
				end if
				If UCase(base64) = "NO_STRUCTURE"  then
				'create blank cdx record so that a mol_id is generated
					base64=""
				end if
				
				'stop
				''SYAN modified on 6/1/2005 to support salt stripping
				'if Application("SALT_STRIPPING") = 1 then
				'	mainAndFrag = SaltStripping(base64)
				'	if instr(mainAndFrag, "|||||") then
				'		mainAndFragArr = Split(mainAndFrag, "|||||")
				'		mainBase64 = mainAndFragArr(0)
				'		fragBase64 = mainAndFragArr(1)
					
				'		compound_molid = DoCommitStrucByID(cpdDBCounter, dbkey, formgroup,RegConn, mainBase64)
				'		fragment_id = DoCommitFrag(dbkey, formgroup, RegConn, fragBase64)
				'	else
				'		compound_molid = DoCommitStrucByID(cpdDBCounter, dbkey, formgroup,RegConn, base64)
				'	end if
				'end if	
				compound_molid = DoCommitStrucByID(cpdDBCounter, dbkey, formgroup,RegConn, base64)
				'End of SYAN modification
				
				if compound_molid = 0 or err.number <> 0 then
					err_number = err.number
					err_description = err.Description
					RegConn.RollbackTrans
					returnVal= DoManualRollbackSequence(dbkey,formgroup,RegConn,RootNumberVal, Sequence_id)
					returnVal = doManualRollbackCompd(dbkey, formgroup, RegConn, cpdDBCounter)
							
					if Not Session("no_gui" & dbkey & formgroup) = True then
						response.write "Compound_Molecule commit failed after call to DoCommitStrucByID(cpdDBCounter:" & cpdDBCounter & ")=MOL_ID:" & compound_molid
						if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
							response.write "commit failed at structure commit.  See \inetpub\cfwlog.txt filefor more information. transaction could not be rolled-back: " & returnval
						else
							response.write "commit failed at structure commit.  See \inetpub\cfwlog.txt filefor more information. transaction rolled back." 
						end if
						logaction("commit failed at structures table. temp_compound_id: " & tempid & "error: " & err_number & err_description)
						response.end
					else
						if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
							DoCommit=  "commit failed at structure commit. See \inetpub\cfwlog.txt filefor more information. transaction could not be rolled-back: " & returnval
						else
							DoCommit=  "commit failed at structure commit. See \inetpub\cfwlog.txt filefor more information. transaction rolled-back. " & ""
						end if
						logaction("commit failed failed at structures table. Error: " & err_number & err_description)
						Post_String = replace(Request.Form, "user_pwd=" & request("user_pwd"),"user_pwd=XXXXX")
						logaction("full post:" & Post_String)		
						exit function
					end if

				else
					
					CommitRS("mol_id") = compound_molid
					if bTEMPTABLE = false then
				
						'this means the MW and FORMULA need to be populated
						myPath = Session("RegCandidateStructurePath" & dbkey)
						if not myPath <> "" then
							mypath = Application("TempFileDirectory" & dbkey) & "SessionDir\" & Session.SessionID & "\compound_moleculeStructure" & ".cdx"
						end if		
										
						theChemData = getMW_and_Formula(dbkey, formgroup,"structures",compound_molid,RegConn,base64)
						theChemData_array = Split(theChemData, ":", -1)
						theMW=theChemData_array(0)
							if theMW = "0" or theMW = -1 or theMW = "-1" or theMW = 0 then
								theMW = null
							end if
						on error resume next
						if Not isNull(theMW) then
							'SYAN modified 9/27/2004 to fix CSBR-46729
							CommitRS("MW2").value= Cdbl(theMW)
							'End of SYAN modification
							
						else
							CommitRS("MW2").value= NULL
								base64=""
						
						end if
						on error goto 0
							
						CommitRS("FORMULA2")= theChemData_array(1)
						if CBool(Application("AUTOGENERATED_CHEMICAL_NAME")) = True then
							'chem_inputstring = request("temporary_structures.chem_name_autogen")
							autogen_name = getAutoGeneratedName(base64, " for reg_numbers.reg_id:" & reg_id)
						end if
						Session("SearchData" & "Temporary_structures.CHEM_NAME_AUTOGEN" & dbkey & formgroup)=autogen_name
					else
						'SYAN modified to fix CSBR-83623, it will be a little expensive, but it does the right thing
						'if TempRS("MW2")= "" or TempRS("MW2")= NULL or TempRS("FORMULA2")="" or TempRS("FORMULA2")= NULL then
							theChemData = getMW_and_Formula(dbkey, formgroup,"structures",compound_molid,RegConn,base64)
							theChemData_array = Split(theChemData, ":", -1)
							theMW=theChemData_array(0)
								if theMW = "0" or theMW = -1 or theMW = "-1" or theMW = 0 then
									theMW = null
								end if
							on error resume next
							if Not isNull(theMW) then
								'SYAN modified 9/27/2004 to fix CSBR-46729
								CommitRS("MW2").value= Cdbl(theMW)
								'End of SYAN modification									
							else
								CommitRS("MW2").value= NULL
								base64=""
							end if
							
							theFormula = theChemData_array(1)
							CommitRS("FORMULA2").value = theFormula
						'end if
						'End of SYAN modification
					end if
					
					
					if Application("OUTPUT_AS_GIF_ON_REG") = 1 then
						if Not UseCartridge(dbkey, formgroup) then
							CSDOGetChemData dbkey, formgroup, "Compound_Molecule", "Structure", cpdDBCounter,  "gif", ""
						end if
					end if
				end if
						
			
					
				CommitRS.Update
				CommitRS.Close
				
				if err.number <> 0 then
					err_number=err.number
					err_description = err.description
					RegConn.RollbackTrans
					returnVal= doManualRollbackCompd(dbkey, formgroup, RegConn, cpdDBCounter)
					if Session("no_gui" & dbkey & formgroup) = True then
						if returnVal <> 0 then
							DoCommit=  "commit failed at compound_molecule table. See file for more information. Transaction could not be rolled-back: " & returnval
						else
							DoCommit=  "commit failed at compound_molecule table. See file for more information. Transaction rolled-back: " & ""
						end if
						logaction("commit failed at compound_molecule table. error: " & err_number & err_description)
						
						Post_String = replace(Request.Form, "user_pwd=" & request("user_pwd"),"user_pwd=XXXXX")
						logaction("full post:" & Post_String)	
						exit function
					else
						if returnVal <> 0 then
							response.write  "commit failed at compound_molecule table. See file for more information. Transaction could not be rolled-back: " & returnval
						else
							response.write  "commit failed at compound_molecule table. See file for more information. Transaction rolled-back: " & ""
						end if
						logaction("commit failed at compound_molecule table temp_compound_id: " & tempid & " error: " & err_number & err_description)
						response.end
					end if
				else 'if no errors continue with reg_number commit
					'stop
					Set cmd = Server.CreateObject("adodb.command")
					cmd.ActiveConnection = RegConn
					cmd.CommandType = adCmdText
					sql = "INSERT into reg_numbers(cpd_internal_id) values(?)"
					cmd.CommandText = sql
					cmd.Parameters.Append cmd.CreateParameter("pcpdDBCounter", 139, 1, 0, cpdDBCounter) 
					cmd.execute
					cmd.Parameters.Delete "pcpdDBCounter"
					
					Set cmd = Nothing
					
					
					Set cmd = Server.CreateObject("adodb.command")
					cmd.ActiveConnection =  RegConn
					cmd.CommandType = adCmdText
				
					sql = "Select * from reg_numbers where cpd_internal_id=?" 
					cmd.CommandText = sql
					cmd.Parameters.Append cmd.CreateParameter("pcpdDBCounter", 139, 1, 0, cpdDBCounter) 
					CommitRS.Open cmd
					
					CommitRS("root_number") = RootNumber
					CommitRS("Sequence_Internal_ID") = sequence_id
					CommitRS("Sequence_Number").value = sequence_number
					CommitRS("registry_date") = Date()
					'stop
					CommitRS("registrar_person_id") = registry_person_id
					'create new reg_number based on corporate needs.  Customize BuildRegNum to change the value
					RegNumber = BuildRegNum(dbkey, formgroup, RootNumber, tempid)
					
					CommitRS("reg_number") = RegNumber
					CommitRS("DATETIME_STAMP") =Session("DATETIME_STAMP")
					CommitRS("LOAD_ID") = Session("load_id")
					currentBatchNumber = Application("Start_Batch_Number")
					CommitRS("last_batch_number") = currentBatchNumber 'needs to move to reg_numbers
					CommitRS("MOL_ID")=compound_molid
					

					
					CommitRS.Update
					
					'SYAN added on 12/14/2004 to fix CSBR-49812
					if err.number <> 0 then
						logaction "In DoCommit, following error occurred: "  & err.number & " -- " & err.Description
						logaction "The operation is to updating fields of the following record: "
						logaction "SQL = Select * from reg_numbers where cpd_internal_id=" & cpdDBCounter
						logaction "Following values are attempted to be updated to REG_NUMBERS fields:"
						logaction "  REG_NUMBERS.ROOT_NUMBER = " & RootNumber
						logaction "  REG_NUMBERS.SEQUENCE_INTERNAL_ID = " & sequence_id
						logaction "  REG_NUMBERS.SEQUENCE_NUMBER = " & sequence_number
						logaction "  REG_NUMBERS.REGISTRY_DATE = " & Date()
						logaction "  REG_NUMBERS.REGISTRAR_PERSON_ID = " & registry_person_id
						logaction "  REG_NUMBERS.REG_NUMBER = " & RegNumber
						logaction "  REG_NUMBERS.DATETIME_STAMP = " & Session("DATETIME_STAMP")
						logaction "  REG_NUMBERS.LOAD_ID = " & Session("load_id")
						logaction "  REG_NUMBERS.LAST_BATCH_NUMBER = " & currentBatchNumber
						logaction "  REG_NUMBERS.MOL_ID = " & compound_molid						 
						logaction "The above values failed to be updated into to REG_NUMBERS fields, with following error returned: "  & err.number & " -- " & err.Description
					end if
					'End of SYAN modification
	
					reg_id = CommitRS("Reg_ID")
					
					'SYAN added on 12/14/2004 to fix CSBR-49812
					if err.number <> 0 then
						logaction "After update, reg_id = " & reg_id
					end if
					'End of SYAN modification

					CommitRS.Close
					
					'SYAN added on 12/14/2004 to fix CSBR-49812
					if err.number <> 0 then
						logaction "After update, the error is: " & err.number & " -- " & err.Description
					end if
					'End of SYAN modification

					cmd.Parameters.Delete "pcpdDBCounter"
					if err.number <> 0 then
						err_number = err.number
						err_description = err.description
						RegConn.RollbackTrans
						returnVal= DoManualRollbackSequence(dbkey,formgroup,RegConn,RootNumberVal, Sequence_id)
						
						'SYAN added on 1/13/2005 to fix Celera structure disappear problem
						if InStr(UCase(tableorder), "REG_NUMBERS") > 0 then  
							returnVal1 = DoManualRollbackRegNum(dbkey, formgroup, RegConn, cpdDBCounter, reg_id)
						end if
						if InStr(UCase(tableorder), "STRUCTURES") > 0 and InStr(UCase(tableorder), "TEMPORARY_STRUCTURES") <=0 then  
							returnVal2 = doManualRollbackCompd(dbkey, formgroup, RegConn, cpdDBCounter)
						end if
						'End of SYAN modification
						
						if Session("no_gui" & dbkey & formgroup) = True then
							if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
								
								DoCommit=  "commit failed at reg_numbers table. See \inetpub\cfwlog.txt filefor more information. Transaction could not be rolled-back: " & returnval & returnval2
							else
								DoCommit=  "commit failed at reg_numbers table. See \inetpub\cfwlog.txt filefor more information. Transaction rolled-back: " & ""
							end if
							logaction("commit failed at reg_numbers table. " & "error: " & err_number & err_description)
							Post_String = replace(Request.Form, "user_pwd=" & request("user_pwd"),"user_pwd=XXXXX")
							logaction("full post:" & Post_String)	
							exit function
						else
							if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
								response.write  "commit failed at reg_numbers table. See \inetpub\cfwlog.txt filefor more information. Transaction could not be rolled-back: " & returnval & returnval2
							else
								
								response.write  "commit failed at reg_numbers table. See \inetpub\cfwlog.txt filefor more information. Transaction rolled-back: " & ""
							end if
							logaction("commit failed at reg_numbers: temp_compound_id: " & tempid & " error: " & err_number & err_description)
							response.end
						end if
					end if ' end error <> 0
				end if

			Case "ADD_SALT"
			
				'get root number
				cpdDBCounter = unique_id
				
				'open compound_molecule table and get needed root molecule data
				sql = "select root_number,MOL_ID from compound_molecule where cpd_database_counter=?"
				Set cmd = Server.CreateObject("adodb.command")
				cmd.ActiveConnection = RegConn
				cmd.CommandType = adCmdText
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("pcpdDBCounter", 139, 1, 0, cpdDBCounter) 
				CommitRS.Open cmd
			
				'SYAN modified on 9/23/2005 to fix Ben Bracke's salt loading problem
				'stop
				LegacyRegNumber = ""
				if CBool(Application("LEGACY_IMPORT_ENABLED")) = true then
					if bTEMPTABLE = true then
						LegacyRegNumber = TempRS("LEGACY_REG_NUMBER")
						Sequence_ID = TempRS("SEQUENCE_ID")
					else
						LegacyRegNumber = request("TEMPORARY_STRUCTURES.LEGACY_REG_NUMBER")
						Sequence_ID = request("TEMPORARY_STRUCTURES.SEQUENCE_ID")
					end if
					RootNumber = LegacyRegNumber
					'DGB 10/2003 Introduced smarter sequence parsing to support suffixes
					sequence_number = ParseSequence(LegacyRegNumber, Application("Prefix_Delimiter"))
				else
					RootNumber = CommitRS("Root_Number")
					compound_molid = CommitRS("MOL_ID")
					CommitRS.Close
					'get sequence_internal_id and sequence number for cpdDBcounter
					Set cmd = Server.CreateObject("adodb.command")
					cmd.ActiveConnection = RegConn
					cmd.CommandType = adCmdText
					sql = "select Sequence_Number, Sequence_Internal_id from reg_numbers where cpd_internal_id =?"
					cmd.CommandText = sql
					cmd.Parameters.Append cmd.CreateParameter("pcpdDBCounter", 139, 1, 0, cpdDBCounter) 
					CommitRS.Open cmd
				
				
					CommitRS.MoveFirst
					Sequence_number = CommitRS("Sequence_Number")
					Sequence_id =CommitRS("Sequence_Internal_ID")
					CommitRS.Close
				end if

				
				
				RegNumber = BuildRegNum(dbkey, formgroup, RootNumber, tempid)
				'End of SYAN modification
				
				'SYAN added on 8/26/2004 to fix CSBR-47201
				currentBatchNumber = 1
				Set cmd = Server.CreateObject("adodb.command")
				cmd.ActiveConnection = RegConn
				cmd.CommandType = adCmdText
				sql = "select count(reg_number) as countRegNumber from reg_numbers where reg_number =?"
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("pregnumber", 200, 1, Len(RegNumber), RegNumber) 
				CommitRS.Open cmd
				
				CommitRS.MoveFirst
				countRegNumber = CommitRS("countRegNumber")
				CommitRS.Close
				
				If CInt(countRegNumber) = 0 then
				'End of SYAN modification
				
					Set cmd = Server.CreateObject("adodb.command")
					cmd.ActiveConnection =  RegConn
					cmd.CommandType = adCmdText
				
					sql = "INSERT into Reg_Numbers (root_number,registrar_person_id,CPD_Internal_ID,Sequence_Internal_ID,Sequence_Number,Reg_Number,last_batch_number,Mol_ID,registry_date,DATETIME_STAMP,LOAD_ID)" &_
						"Values(?,?,?,?,?,?,?,?,?,?,?)"
					'Open REG_NUBMERS table and adde new record and associated information.
					cmd.CommandText = sql
					cmd.Parameters.Append cmd.CreateParameter("proot_number", 200, 1, Len(rootnumber)+ 1, RootNumber) 
					cmd.Parameters.Append cmd.CreateParameter("pRegPersonId", 139, 1, 0, registry_person_id) 
					cmd.Parameters.Append cmd.CreateParameter("pCPD_Internal_ID", 139, 1, 0,cpdDBCounter ) 
					cmd.Parameters.Append cmd.CreateParameter("pSeqIntID", 139, 1, 0, Sequence_id) 
					cmd.Parameters.Append cmd.CreateParameter("pSeqNumber", 139, 1, 0, Sequence_number) 
					cmd.Parameters.Append cmd.CreateParameter("pReg_Number", 200, 1, Len(Regnumber)+ 1, Regnumber) 
					cmd.Parameters.Append cmd.CreateParameter("pLastBatch", 139, 1, 0, currentBatchNumber) 
					cmd.Parameters.Append cmd.CreateParameter("pmol_id", 139, 1, 0, compound_molid) 
					cmd.Parameters.Append cmd.CreateParameter("pRegistry_date", 7, 1, 30, Date()) 
					if isNull(load_id) then
						load_id = ""
					end if
					cmd.Parameters.Append cmd.CreateParameter("pload_id", 200, 1, Len(load_id) + 1, load_id) 
					cmd.Parameters.Append cmd.CreateParameter("pdatetime_stamp", 200, 1, Len(dateTimeStamp)+ 1, dateTimeStamp) 
						
					cmd.execute
			
				'SYAN added on 8/26/2004 to fix CSBR-47201
				end if
				'End of SYAN modification

				'create new reg_number based on corporate needs.  Customize BuildRegNum to change the value
				Set cmd = Server.CreateObject("adodb.command")
				cmd.ActiveConnection = RegConn
				cmd.CommandType = adCmdText
				sql = "select reg_id from reg_numbers where reg_number=?"
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("pReg_Number", 200, 1, Len(Regnumber)+ 1, Regnumber) 
				CommitRS.Open cmd
				reg_id = CommitRS("Reg_ID")
				
				CommitRS.Close

		End Select
		'start commiting to each of the tables.  Depend on the commit type.  See the constants at the
		'beginning of this file to see  the current order for each.
		tablenamesarray = Split(tableorder, ",", -1) 

		
		for i = 0 to UBound(tablenamesarray)
      'stop
			tablename = tablenamesarray(i)	
			table_conn_name = GetConnGroupVal(dbkey, tablename, kADOConnection)
			tablename_case = UCase(tablename)

			Select Case tablename_case
				Case "COMPOUND_MOLECULE"
		
					
				Case "COMPOUND_SALT" 'hard coded
					'stop
					on error resume next
					
					if bTEMPTABLE = false then
							
						'SYAN modified to fix Ben Bracke's salt loading problem
						if Session("SearchData" & "Temporary_Structures.Salt_Name" & dbkey & formgroup) <> "" then
							SaltName = Session("SearchData" & "Temporary_Structures.Salt_Name" & dbkey & formgroup)
							salt_internal_id = GetSaltCodeFromSaltName(saltName)
						end if
	
						if salt_internal_id = "" then
							if Session("SearchData" & "temporary_structures.salt_code" & dbkey & formgroup)= "" then
								'SYAN modified on 6/5/2006 to support salt stripping
								if Session("salt_id") = "" then 
									salt_internal_id = 1
								else
									salt_internal_id = Session("salt_id")
									Session("salt_id") = ""
								end if
								'End of SYAN modification
							else
								salt_internal_id =Session("SearchData" & "temporary_structures.salt_code" & dbkey & formgroup)
							end if
						end if
						'End of SYAN modification

					else
						'SYAN modified on 6/5/2006 to support salt stripping
						if Session("salt_id") = "" then 
							if TempRS("Salt_Code").value = "" then 
								salt_internal_id = 1
							else
								salt_internal_id = TempRS("Salt_Code")
							end if
						else
							salt_internal_id = Session("salt_id")
							Session("salt_id") = ""
						end if
						'End of SYAN modification
					end if

					
					Set cmd = Server.CreateObject("adodb.command")
					cmd.ActiveConnection = RegConn
					cmd.CommandType = adCmdText
					sql = "Insert into compound_salt(cpd_internal_id, root_number,reg_internal_id, salt_internal_id, mol_id, load_id, datetime_stamp) values" &_
						"(?,?,?,?,?,?,?)"
					cmd.CommandText = sql
					cmd.Parameters.Append cmd.CreateParameter("pcpd_internal_id", 139, 1, 0, cpdDBCounter) 
					cmd.Parameters.Append cmd.CreateParameter("proot_number", 200, 1, Len(RootNumber)+ 1, RootNumber) 
					cmd.Parameters.Append cmd.CreateParameter("preg_internal_id", 139, 1, 0, reg_id) 
					cmd.Parameters.Append cmd.CreateParameter("psalt_internal_id", 139, 1, 0, salt_internal_id)
					cmd.Parameters.Append cmd.CreateParameter("pmol_id", 139, 1, 0, compound_molid) 
					if isNull(load_id) then
						load_id = ""
					end if
					cmd.Parameters.Append cmd.CreateParameter("pload_id", 200, 1, Len(load_id) + 1, load_id) 
					cmd.Parameters.Append cmd.CreateParameter("pdatetime_stamp", 200, 1, Len(dateTimeStamp)+ 1, dateTimeStamp) 
					
					cmd.execute
					
				
				
						if err.number <> 0 then
							err_number = err.number
							err_description = err.description
							RegConn.RollbackTrans
							returnVal= DoManualRollbackSequence(dbkey,formgroup,RegConn,RootNumberVal, Sequence_id)

							'SYAN added on 1/13/2005 to fix Celera structure disappear problem
							if InStr(UCase(tableorder), "REG_NUMBERS") > 0 then  
								returnVal1 = DoManualRollbackRegNum(dbkey, formgroup, RegConn, cpdDBCounter, reg_id)
							end if
							if InStr(UCase(tableorder), "STRUCTURES") > 0 and InStr(UCase(tableorder), "TEMPORARY_STRUCTURES") <=0 then  
								returnVal2 = doManualRollbackCompd(dbkey, formgroup, RegConn, cpdDBCounter)
							end if
							'End of SYAN modification

							if Session("no_gui" & dbkey & formgroup) = True then
								if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
									DoCommit= "commit failed at " & tablename & ". transaction could not be rolled-back. See \inetpub\cfwlog.txt filefor more information. Record added to temp: " & returnval & returnval2
								else
									DoCommit= "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction rolled-back and added to temp: "  & failtrans
								end if
								logaction("commit failed at " & tablename & ":" & err_number & err_description)
								Post_String = replace(Request.Form, "user_pwd=" & request("user_pwd"),"user_pwd=XXXXX")
								logaction("full post:" & Post_String)	
								exit function
							else
								if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
									response.write  "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction could not be rolled-back: " & returnval & returnval2 & failtrans
								else
									response.write  "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction rolled-back: " & failtrans
								end if
								logaction("commit failed at " & tablename & ".   temp_compound_id: " & tempid & " error: " & err_number & err_description)
								response.end
							end if
						end if
					
	
				Case "REG_NUMBERS" 
					'done before this loop

				Case "STRUCTURES"
					'done in DoCommitStruc
					
				Case "BATCHES"
					'stop
					'SYAN added on 8/26/2004 to fix CSBR-47201
					'get the last batch number
					sql = "Select Max(Batch_number) as lastBatchNumber From batches where reg_internal_id=?"
					Set cmd = Server.CreateObject("adodb.command")
					cmd.ActiveConnection = RegConn
					cmd.CommandType = adCmdText
					cmd.CommandText = sql
					cmd.Parameters.Append cmd.CreateParameter("preg_id", 139, 1, 0, reg_id) 
					CommitRS.Open cmd
				
					LastBatchNumber = CommitRS("lastBatchNumber")
					'stop
					if IsNull(LastBatchNumber) then
						'SYAN modified on 9.20/2006 to fix Ben Brack's Givaudan issue
						'currentBatchNumber = 1
						currentBatchNumber = Application("START_BATCH_NUMBER")
						'End of SYAN modification
					else
						currentBatchNumber = CLng(LastBatchNumber) + 1
					end if
				
					CommitRS.Close
					
					Set cmd = Server.CreateObject("adodb.command")
					cmd.ActiveConnection = RegConn
					cmd.CommandType = adCmdText
					sql = "Update Reg_Numbers Set Last_Batch_Number=? where Reg_ID=?"
					cmd.CommandText = sql
					cmd.Parameters.Append cmd.CreateParameter("lastBatchNumber", 139, 1, 0, currentBatchNumber) 
					cmd.Parameters.Append cmd.CreateParameter("regid", 139, 1, 0, reg_id) 
				 	cmd.Execute
					
					
					'End of SYAN modification

					on error resume next
					DBMSUser_ID = Session("CurrentUser" & dbkey)
					PersonID = getValueFromTablewConn(RegConn, "People", "User_ID",DBMSUser_ID,"Person_ID")
					'DGB RegTunning
					'Use returning clause
					sql = "Insert Into Batches (Reg_Internal_ID, Batch_number) values(?,?) RETURNING rowid INTO ?"
					Set cmd = Server.CreateObject("adodb.command")
					cmd.ActiveConnection = RegConn
					cmd.CommandType = adCmdText
					cmd.CommandText = sql
					cmd.Parameters.Append cmd.CreateParameter("preg_id", 139, 1, 0, reg_id) 
					cmd.Parameters.Append cmd.CreateParameter("pcurrbatch", 139, 1, 0, currentBatchNumber) 
				 	cmd.Parameters.Append cmd.CreateParameter("pOut", 200, 2,20)
				 	cmd.Execute
				 	
				 	rid = cmd.parameters("pOut").value	
				 	
				 						 	
				 	sql = "Select * from Batches where rowid =?"
				 	Set cmd = Server.CreateObject("adodb.command")
					cmd.ActiveConnection = RegConn
					cmd.CommandType = adCmdText
				 	cmd.CommandText = sql
					cmd.Parameters.Append cmd.CreateParameter("rid", 200, 1, len(rid), rid) 
					
				 	CommitRS.Open cmd
				 	
				 	
					CommitRS("MOL_ID") = compound_molid
					CommitRS("CPD_Internal_ID") = cpdDBCounter
					CommitRS("BATCH_REG_DATE")= Date()
					
					CommitRS("LOAD_ID")=Session("load_id")
					CommitRS("DATETIME_STAMP") = Session("DateTime_Stamp")
					CommitRS("TEMP_ID") = tempid
					'loop through fields in temp table and get relevant information for current table
					
					'stop
					
					if bTEMPTABLE=false then
						CommitFromHTTPRequest dbkey, formgroup,"batches", CommitRS,RegConn
						
						if Salt_Equivalents = "" then
							Salt_Equivalents =  Trim(Session("SearchData" & "Temporary_Structures.Salt_Equivalents" & dbkey & formgroup)) 
						end if
						
						if Salt_Equivalents <> "" then
              'SYAN modified on 9/27/2004 to fix CSBR-46729
              CommitRS("Salt_Equivalents") = CDbl(Salt_Equivalents)
              'End of SYAN modification
              end if

              'stop


            
              Salt_MW =  Trim(Session("SearchData" & "Temporary_Structures.Salt_MW" & dbkey & formgroup))
						if Salt_MW <> "" then
              Salt_MW = Cdbl(Salt_MW)
              else
              Salt_MW = Null
              end if
              'SYAN modified on 9/27/2004 to fix CSBR-46729
              CommitRS("Salt_MW").value = ConvertToDbl(Salt_MW)
              'End of SYAN modification
              
              'SYAN added on 2/3/2008 to fix CSBR-90280
              if salt_internal_id = "" and Session("SearchData" & "temporary_structures.salt_code" & dbkey & formgroup) <> "" then
              salt_internal_id = Session("SearchData" & "temporary_structures.salt_code" & dbkey & formgroup)
              end if

              if salt_internal_id <> "" then
              FillBatchSaltInfo salt_internal_id, CommitRS
              end if
              'End of SYAN modification

              'DGB Ensure that solvate id is stored in direct to permanent case
              solvateName = Session("SearchData" & "Temporary_Structures.Solvate_Name" & dbkey & formgroup)
				        CommitRS("Solvate_ID")= GetSolvateCodeFromSolvateName(solvateName)
						
						Solvate_Equivalents =  Trim(Session("SearchData" & "Temporary_Structures.Solvate_Equivalents" & dbkey & formgroup))
						if Solvate_Equivalents <> "" then
							CommitRS("Solvate_Equivalents") = ConvertToDbl(Solvate_Equivalents)
						end if
						Solvate_MW =  Trim(Session("SearchData" & "Temporary_Structures.Solvate_MW" & dbkey & formgroup))
						if Solvate_MW <> "" then
							CommitRS("Solvate_MW") = CDbl(Solvate_MW)
						end if
						if err.number <> 0 then
							err_number = err.number
							err_description = err.description
							
							RegConn.RollbackTrans
							returnVal= DoManualRollbackSequence(dbkey,formgroup,RegConn,RootNumberVal, Sequence_id)
							
							'SYAN added on 1/13/2005 to fix Celera structure disappear problem
							if InStr(UCase(tableorder), "REG_NUMBERS") > 0 then  
								returnVal1 = DoManualRollbackRegNum(dbkey, formgroup, RegConn, cpdDBCounter, reg_id)
							end if
							if InStr(UCase(tableorder), "STRUCTURES") > 0 and InStr(UCase(tableorder), "TEMPORARY_STRUCTURES") <=0 then  
								returnVal2 = doManualRollbackCompd(dbkey, formgroup, RegConn, cpdDBCounter)
							end if
							'End of SYAN modification

							if Session("no_gui" & dbkey & formgroup) = True then
								if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
									DoCommit= "commit failed at " & tablename & ". transaction could not be rolled-back. See \inetpub\cfwlog.txt filefor more information. Record added to temp: " & returnval & returnval2
								else
									DoCommit= "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction rolled-back and added to temp: "  & failtrans
								end if
								logaction("commit failed at " & tablename & ":" & err_number & err_description)
								Post_String = replace(Request.Form, "user_pwd=" & request("user_pwd"),"user_pwd=XXXXX")
								logaction("full post:" & Post_String)	
								exit function
							else
								if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
									response.write  "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction could not be rolled-back: " & returnval & returnval2 & failtrans
								else
									response.write  "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction rolled-back: " & failtrans
								end if
								logaction("commit failed at " & tablename & ".   temp_compound_id: " & tempid & " error: " & err_number & err_description)
								response.end
							end if
						end if
							
						
						base64 = Session("SearchData" & "temporary_structures.structure" & dbkey & formgroup)
						'LJB 4/25 don't bother getting formulawt if there is no base 64 - causes and overflow message if you do.
						if base64 <> "" then
							FormulaWt = DoFormulaWtCalc(dbkey, formgroup,  RegConn, theMW, cpdDBCounter, Salt_MW, Salt_Equivalents, Solvate_MW, Solvate_Equivalents)
						else
							FormulaWt=""
						end if
						if isEmpty(FormulaWt) then
							CommitRS("Formula_Weight") = Null
						else	
							CommitRS("Formula_Weight").value = CDbl(FormulaWt)
						end if
						if err.number <> 0 then
							err_number = err.number
							err_description = err.description
							RegConn.RollbackTrans
							returnVal= DoManualRollbackSequence(dbkey,formgroup,RegConn,RootNumberVal, Sequence_id)
							
							'SYAN added on 1/13/2005 to fix Celera structure disappear problem
							if InStr(UCase(tableorder), "REG_NUMBERS") > 0 then  
								returnVal1 = DoManualRollbackRegNum(dbkey, formgroup, RegConn, cpdDBCounter, reg_id)
							end if
							if InStr(UCase(tableorder), "STRUCTURES") > 0 and InStr(UCase(tableorder), "TEMPORARY_STRUCTURES") <=0 then  
								returnVal2 = doManualRollbackCompd(dbkey, formgroup, RegConn, cpdDBCounter)
							end if
							'End of SYAN modification

							
							if Session("no_gui" & dbkey & formgroup) = True then
								if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
									DoCommit= "commit failed at " & tablename & ". transaction could not be rolled-back. See \inetpub\cfwlog.txt filefor more information. Record added to temp: " & returnval & returnval2
								else
									DoCommit= "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction rolled-back and added to temp: "  & failtrans
								end if
								logaction("commit failed at " & tablename & ":" & err_number & err_description)
								Post_String = replace(Request.Form, "user_pwd=" & request("user_pwd"),"user_pwd=XXXXX")
								logaction("full post:" & Post_String)	
								exit function
							else
								if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
									response.write  "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction could not be rolled-back: " & returnval & returnval2 & failtrans
								else
									response.write  "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction rolled-back: " & failtrans
								end if
								logaction("commit failed at " & tablename & ".   temp_compound_id: " & tempid & " error: " & err_number & err_description)
								response.end
							end if
						end if
							
						if  Session("DERIVED_FIElDS").Exists("PERCENT_ACTIVE") then
							'LJB 4/25 don't bother getting percentactive if there is no formulawt - causes and overflow message if you do.
							if not isEmpty(FormulaWt) then
								PercentActive = DoPercentActiveCalc(dbkey, formgroup,  RegConn, theMW, cpdDBCounter,FormulaWt)
							else
								PercentActive = ""
							end if
							if isEmpty(PercentActive) then
								CommitRS("Percent_Active") = Null
							else
								'SYAN modified on 9/27/2004 to fix CSBR-46729
								CommitRS("Percent_Active") = CDbl(PercentActive)
								'End of SYAN modification
							end if
							
							if err.number <> 0 then
								err_number = err.number
								err_description = err.description
								RegConn.RollbackTrans
								returnVal= DoManualRollbackSequence(dbkey,formgroup,RegConn,RootNumberVal, Sequence_id)

								'SYAN added on 1/13/2005 to fix Celera structure disappear problem
								if InStr(UCase(tableorder), "REG_NUMBERS") > 0 then  
									returnVal1 = DoManualRollbackRegNum(dbkey, formgroup, RegConn, cpdDBCounter, reg_id)
								end if
								if InStr(UCase(tableorder), "STRUCTURES") > 0 and InStr(UCase(tableorder), "TEMPORARY_STRUCTURES") <=0 then  
									returnVal2 = doManualRollbackCompd(dbkey, formgroup, RegConn, cpdDBCounter)
								end if
								'End of SYAN modification

								if Session("no_gui" & dbkey & formgroup) = True then
									if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
										DoCommit= "commit failed at " & tablename & ". transaction could not be rolled-back. See \inetpub\cfwlog.txt filefor more information. Record added to temp: " & returnval & returnval2
									else
										DoCommit= "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction rolled-back and added to temp: "  & failtrans
									end if
									logaction("commit failed at " & tablename & ":" & err_number & err_description)
									Post_String = replace(Request.Form, "user_pwd=" & request("user_pwd"),"user_pwd=XXXXX")
									logaction("full post:" & Post_String)		
									exit function
								else
									if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
										response.write  "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction could not be rolled-back: " & returnval & returnval2 & failtrans
									else
										response.write  "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction rolled-back: " & failtrans
									end if
									logaction("commit failed at " & tablename & ".   temp_compound_id: " & tempid & " error: " & err_number & err_description)
									response.end
								end if
							end if
						end if
					else 'if bTEMPTABLE=false then
						formgroup = "reg_ctrbt_commit_user_form_group"		
						CommitFromTempTableRS dbkey, formgroup,"batches", CommitRS,RegConn,TempRS
						
						'stop
						''SYAN added on 9/11/2005 to support salt stripping
						'if Application("SALT_STRIPPING") = 1 and salt_internal_id <> "" then
						'	sql = "select salt_name, salt_mw from salts where salt_code = ?"
						'	Set cmd = Server.CreateObject("adodb.command")
						'	Set saltRS = Server.CreateObject("ADODB.Recordset")
						'	cmd.ActiveConnection = RegConn
						'	cmd.CommandType = adCmdText
						'	cmd.CommandText = sql
						'	cmd.Parameters.Append cmd.CreateParameter("salt_code", 139, 1, 0, salt_internal_id) 
				 		'	saltRS.Open cmd
							
						'	cmd.parameters.delete "salt_code"
							
						'	'If not (saltRS.BOF and saltRS.EOF) then
						'	'	sql = "update Batches set salt_internal_id = ?, salt_name = ?, salt_mw = ? where rowid = ?"
						'	'	cmd.ActiveConnection = RegConn
						'	'	cmd.CommandType = adCmdText
						'	'	cmd.CommandText = sql
						'	'	cmd.Parameters.Append cmd.CreateParameter("salt_code", 139, 1, 0, salt_internal_id) 
						'	'	cmd.Parameters.Append cmd.CreateParameter("salt_name", 200, 1, Len(saltRS("salt_name")) + 1, saltRS("salt_name")) 
						'	'	cmd.Parameters.Append cmd.CreateParameter("salt_mw", 139, 1, 0, saltRS("salt_mw")) 
						'	'	cmd.Parameters.Append cmd.CreateParameter("batch_internal_id", 200, 1, Len(rid) + 1, rid) 
				 		'	'	cmd.Execute
				 		'	'end if
						'	'cmd.parameters.delete "salt_code"
						'	'cmd.parameters.delete "salt_name"
						'	'cmd.parameters.delete "salt_mw"
						'	'cmd.parameters.delete "batch_internal_id"
						'	CommitRS("salt_internal_id") = salt_internal_id
						'	CommitRS("salt_name") = saltRS("salt_name")
						'	CommitRS("salt_mw") = saltRS("salt_mw")
							
				 		'	saltRS.Close
				 		'end if
						''End of SYAN modification
					end if 'get information directly from post
					
					'stop
					if CBool(Application("USE_BATCH_SCIENTIST_AS_REGISTRAR")) = true then
						CommitRS("BATCH_REG_PERSON_ID")= Session("SearchData" & "Temporary_Structures.Scientist_ID" & dbkey & formgroup) 
					else
						CommitRS("BATCH_REG_PERSON_ID")= PersonID
					end if
					'stop
					
				 	
					CommitRS.Update
					

					batchID = CommitRS("batch_internal_id") 
					batch_project_id = CommitRS("batch_project_id") 
					
			
							if err.number <> 0 then
								err_number = err.number
								err_description = err.description
								
								RegConn.RollbackTrans
								'stop
								returnVal= DoManualRollbackSequence(dbkey,formgroup,RegConn,RootNumberVal, Sequence_id)
								'SYAN added on 1/13/2005 to fix Celera structure disappear problem
								if InStr(UCase(tableorder), "REG_NUMBERS") > 0 then  
									returnVal1 = DoManualRollbackRegNum(dbkey, formgroup, RegConn, cpdDBCounter, reg_id)
								end if
								if InStr(UCase(tableorder), "STRUCTURES") > 0 and InStr(UCase(tableorder), "TEMPORARY_STRUCTURES") <=0 then  
									returnVal2 = doManualRollbackCompd(dbkey, formgroup, RegConn, cpdDBCounter)
								end if
								'End of SYAN modification
								
								if Session("no_gui" & dbkey & formgroup) = True then
									if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
										DoCommit= "commit failed at " & tablename & ". transaction could not be rolled-back. See \inetpub\cfwlog.txt filefor more information. Record added to temp: " & returnval & returnval2
									else
										DoCommit= "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction rolled-back and added to temp: "  & failtrans
									end if
									logaction("commit failed at " & tablename & ":" & err_number & err_description)
									Post_String = replace(Request.Form, "user_pwd=" & request("user_pwd"),"user_pwd=XXXXX")
									logaction("full post:" & Post_String)		
									exit function
								else
									if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
										response.write  "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction could not be rolled-back: " & returnval & returnval2 & failtrans
									else
										response.write  "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction rolled-back: " & failtrans
									end if
									logaction("commit failed at " & tablename & ".   temp_compound_id: " & tempid & " error: " & err_number & err_description)
									response.end
								end if
							end if
					CommitRS.Close
					RegConn.CommitTrans
						
					'DGB Commented out the whole mess and make a call to a new update function
					'that calculates the Batch Formula in a single round trip
					
					UpdateBatchFormula RegConn, cpdDBCounter
					'SYAN added on 5/4/2007 to fix CSBR-64663
				 	'stop
				 	'DGB Modified to calcuate batch formula as formula not name
				 	'sql = "Select Batches.*, compound_molecule.formula2 from Batches, compound_molecule where compound_molecule.cpd_database_counter = batches.reg_internal_id and batches.rowid =?"

				 	'Set cmd = Server.CreateObject("adodb.command")
					'cmd.ActiveConnection = RegConn
					'cmd.CommandType = adCmdText
				 	'cmd.CommandText = sql
					'cmd.Parameters.Append cmd.CreateParameter("rid", 200, 1, len(rid), rid) 
					
				 	'CommitRS.Open cmd
				 	
				 	'compoundFormula = CommitRS("formula2")
					''salt_name = CommitRS("SALT_NAME")
					'saltCode = CommitRS("SALT_INTERNAL_ID")
					'salt_equivalents = CommitRS("SALT_EQUIVALENTS")
					
					'solvate_name = CommitRS("solvate_NAME")
					'solvate_equivalents = CommitRS("SALT_EQUIVALENTS")
					
					'CommitRS.Close
					
				 	'sql = "Select batch_formula from Batches where rowid =?"
					
					'set batchFormulaRS = Server.CreateObject("adodb.recordset")
					'batchFormulaRS.LockType= 3
					'batchFormulaRS.CursorType=1
					
				 	'Set cmd = Server.CreateObject("adodb.command")
					'cmd.ActiveConnection = RegConn
					'cmd.CommandType = adCmdText
				 	'cmd.CommandText = sql
					'cmd.Parameters.Append cmd.CreateParameter("rid", 200, 1, len(rid), rid) 
					
				 	'batchFormulaRS.Open cmd

					'if IsNull(saltCode) then
					'	'salt = "no_salt"
					'	salt = ""
					'else

					'	set saltMFcmd = Server.CreateObject("adodb.command")
					'	saltMFcmd.ActiveConnection = RegConn
					'    saltMFcmd.CommandType = adCmdText
				 	'    saltMFcmd.CommandText = "select salt_mf from salts where salt_code=?"
					'    saltMFcmd.Parameters.Append cmd.CreateParameter("saltCode", 139 , 1, 0, saltCode) 
					'	set saltMFRS = saltMFcmd.Execute
					'	saltMF = saltMFRS("salt_mf").value
					'	set saltMFcmd = Nothing
					'	set saltMFRS = Nothing
					'	if Cint(salt_equivalents) = 1 or Cint(salt_equivalents) = 0 then
					'		salt = "&middot" & saltMF
					'	else
					'		salt = "&middot" & salt_equivalents & "(" & saltMF & ")"
					'	end if
						
						
						
						
					'end if

					'if IsNull(solvate_name) then
					'	'solvate = "no_solvate"
					'    solvate = ""
					'else
					'	set solvMFcmd = Server.CreateObject("adodb.command")
					'	solvMFcmd.ActiveConnection = RegConn
					'    solvMFcmd.CommandType = adCmdText
				 	'    solvMFcmd.CommandText = "select solvate_mf from solvates where solvate_name=?"
					'    solvMFcmd.Parameters.Append cmd.CreateParameter("solvateName", 200 , 1, len(solvate_name), solvate_name) 
					'	set solvMFRS = solvMFcmd.Execute
					'	solvMF = solvMFRS("solvate_mf").value
					'	set solvMFcmd = Nothing
					'	set solvMFRS = Nothing
					'	if Cint(solvate_equivalents) = 1 or Cint(solvate_equivalents) = 0 then
					'		solvate = "&middot" & solvMF
					'	else
					'		solvate = "&middot" & solvate_equivalents & "(" & solvMF & ")"
					'	end if					
					'end if
					
					'batchFormulaRS("BATCH_FORMULA") = compoundFormula & " " & salt & " " & solvate
				 	'batchFormulaRS.Update
				 	'batchFormulaRS.Close
				 	'End of SYAN modification

				
				Case "CMPD_MOL_UTILIZATIONS"
					if CBool(Application("UTILIZATION_PERMISSIONS_USED")) = true then
						if Not isEmpty(batch_project_id) then
							sql = "select * from batch_proj_utilizations where batch_project_id =?"
							Set cmd = Server.CreateObject("adodb.command")
							cmd.ActiveConnection = RegConn
							cmd.CommandType = adCmdText
							cmd.CommandText = sql
							cmd.Parameters.Append cmd.CreateParameter("pbatch_project_id", 139, 1, 0, batch_project_id) 
						
				 			CommitRS.Open cmd
				 			
				 			
							LoadID=Session("Load_ID")
							if  isNull(LoadID) then
								LoadID = ""
							end if
						
							If Not (CommitRS.BOF and CommitRS.EOF) then
								CommitRS.MoveFirst
								Do While not CommitRS.EOF
									sql = "insert into cmpd_mol_utilizations(cpd_internal_id, utilization_id,load_id,utilization_boolean)values(?,?,?,?)"
									Set cmd = Server.CreateObject("adodb.command")
									cmd.ActiveConnection = RegConn
									cmd.CommandType = adCmdText
									cmd.CommandText = sql
									cmd.Parameters.Append cmd.CreateParameter("pcpdDBCounter", 139, 1, 0, cpdDBCounter)
									cmd.Parameters.Append cmd.CreateParameter("pUtil", 139, 1, 0,  CommitRS("utilization_id"))
									cmd.Parameters.Append cmd.CreateParameter("pLoadID", 200, 1, Len(LoadID)+1,LoadID)
									cmd.Parameters.Append cmd.CreateParameter("pUtilBool", 139, 1, 0, CommitRS("utilization_boolean")) 
									cmd.Execute
									
									CommitRS.MoveNext
								Loop
								
								CommitRS.Close
							end if
							if err.number <> 0 then
								err_number = err.number
								err_description = err.description
								RegConn.RollbackTrans
								returnVal= DoManualRollbackSequence(dbkey,formgroup,RegConn,RootNumberVal, Sequence_id)

								'SYAN added on 1/13/2005 to fix Celera structure disappear problem
								if InStr(UCase(tableorder), "REG_NUMBERS") > 0 then  
									returnVal1 = DoManualRollbackRegNum(dbkey, formgroup, RegConn, cpdDBCounter, reg_id)
								end if
								if InStr(UCase(tableorder), "STRUCTURES") > 0 and InStr(UCase(tableorder), "TEMPORARY_STRUCTURES") <=0 then  
									returnVal2 = doManualRollbackCompd(dbkey, formgroup, RegConn, cpdDBCounter)
								end if
								'End of SYAN modification

								if Session("no_gui" & dbkey & formgroup) = True then
									if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
										DoCommit= "commit failed at " & tablename & ". transaction could not be rolled-back. See \inetpub\cfwlog.txt filefor more information. Record added to temp: " & returnval & returnval2
									else
										DoCommit= "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction rolled-back and added to temp: "  & failtrans
									end if
									logaction("commit failed at " & tablename & ":" & err_number & err_description)
									Post_String = replace(Request.Form, "user_pwd=" & request("user_pwd"),"user_pwd=XXXXX")
									logaction("full post:" & Post_String)	
									exit function
								else
									if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
										response.write  "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction could not be rolled-back: " & returnval & returnval2 & failtrans
									else
										response.write  "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction rolled-back: " & failtrans
									end if
									logaction("commit failed at " & tablename & ".   temp_compound_id: " & tempid & " error: " & err_number & err_description)
									response.end
								end if
							end if
						end if

					end if

				Case "COMPOUND_PROJECT" ' hard coded
		
					if Not(CBool(Application("PROJECT_LEVEL_ROW_SECURITY")) = true) then
						on error resume next
						if bTEMPTABLE = false then
							if CBool(Application("PROJECTS_NAMED_OWNER")) = true then
								batch_project_id = Session("SearchData" & "TEMPORARY_STRUCTURES.BATCH_PROJECT_ID" & dbkey & formgroup)
								
								project_id = getValueFromTablewConn(RegConn, "batch_projects", "batch_project_id", batch_project_id, "owner_id")
								if isEmpty(project_id) or isZero(project_id) then
									project_id = "1"
								end if
							else
								project_id = Session("SearchData" & "temporary_structures.project_id" & dbkey & formgroup)
							end if
				
						else					
							project_id = TempRS("PROJECT_ID")
						end if
						if isEmpty(project_id) then 
							project_id = "1"
						end if
						
						dateTimeStamp = Session("DateTime_Stamp")
						sql = "INSERT INTO Compound_project (CPD_INTERNAL_ID, PROJECT_INTERNAL_ID,LOAD_ID,DATETIME_STAMP)values(?,?,?,?)"
						Set cmd = Server.CreateObject("adodb.command")
						cmd.ActiveConnection = RegConn
						cmd.CommandType = adCmdText
						cmd.CommandText = sql
						cmd.Parameters.Append cmd.CreateParameter("pcpdDBCounter", 139, 1, 0, cpdDBCounter)
						cmd.Parameters.Append cmd.CreateParameter("pproject_id", 139, 1, 0, project_id)
						load_id = Session("load_id")
						if isNull(load_id) then
							load_id = ""
						end if
						cmd.Parameters.Append cmd.CreateParameter("pload_id", 200, 1, Len(load_id) + 1, load_id) 
						cmd.Parameters.Append cmd.CreateParameter("pdatetime_stamp", 200, 1, Len(dateTimeStamp)+ 1, dateTimeStamp) 
					
						cmd.execute
					
		
							if err.number <> 0 then
								err_number = err.number
								err_description = err.description
								RegConn.RollbackTrans
								returnVal= DoManualRollbackSequence(dbkey,formgroup,RegConn,RootNumberVal, Sequence_id)
								
								'SYAN added on 1/13/2005 to fix Celera structure disappear problem
								if InStr(UCase(tableorder), "REG_NUMBERS") > 0 then  
									returnVal1 = DoManualRollbackRegNum(dbkey, formgroup, RegConn, cpdDBCounter, reg_id)
								end if
								if InStr(UCase(tableorder), "STRUCTURES") > 0 and InStr(UCase(tableorder), "TEMPORARY_STRUCTURES") <=0 then  
									returnVal2 = doManualRollbackCompd(dbkey, formgroup, RegConn, cpdDBCounter)
								end if
								'End of SYAN modification
								
								if Session("no_gui" & dbkey & formgroup) = True then
									if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
										DoCommit= "commit failed at " & tablename & ". transaction could not be rolled-back. See \inetpub\cfwlog.txt filefor more information. Record added to temp: " & returnval & returnval2
									else
										DoCommit= "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction rolled-back and added to temp: "  & failtrans
									end if
									logaction("commit failed at " & tablename & ":" & err_number & err_description)
									Post_String = replace(Request.Form, "user_pwd=" & request("user_pwd"),"user_pwd=XXXXX")
									logaction("full post:" & Post_String)		
									exit function
								else
									if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
										response.write  "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction could not be rolled-back: " & returnval & returnval2 & failtrans
									else
										response.write  "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction rolled-back: " & failtrans
									end if
									logaction("commit failed at " & tablename & ".   temp_compound_id: " & tempid & " error: " & err_number & err_description)
									response.end
								end if
							end if
						
					end if

				Case "ALT_IDS" 
				
					on error resume next
					CommitRS.Open "Select * from Identifiers", RegConn
					CommitRS.MoveFirst
					Do while not CommitRS.EOF
						if Identifier_str <> "" then
							Identifier_str = Identifier_str & "," & CommitRS("IDENTIFIER_DESCRIPTOR")
						else
							Identifier_str = CommitRS("IDENTIFIER_DESCRIPTOR")
						end if
						
						if Identifier_type_str <> "" then
							Identifier_type_str = Identifier_type_str & "," & CommitRS("IDENTIFIER_TYPE")
						else
							Identifier_type_str = CommitRS("IDENTIFIER_TYPE")
						end if
						if UCase(CommitRS("IDENTIFIER_DESCRIPTOR")) = "SYNONYM_R" then
							Synonym_Ident_id = CommitRS("IDENTIFIER_TYPE")
						end if
						
						CommitRS.MoveNext
					loop
					CommitRS.Close
					identifier_array= Split(Identifier_str, ",", -1)
					identifier_type_array= Split(Identifier_type_str, ",", -1)
					
					for l = 0 to UBound(identifier_array)
						if bTEMPTABLE = false then
							theValue = Session("SearchData" & "temporary_structures." & identifier_array(l) & dbkey & formgroup)
						else
							theValue = TempRS(identifier_array(l))
							
						end if
							if not isEmpty(theValue) then						
									Select Case UCase(commit_type)
										Case "BATCH_COMMIT"
											'first check and see if the identifier is already there for that reg_id
											Set cmd = Server.CreateObject("adodb.command")
											cmd.ActiveConnection = RegConn
											cmd.CommandType = adCmdText	
											sql = "Select Count(ID) as theCount FROM Alt_IDS where Upper(identifier)=? AND reg_internal_id=?"
											cmd.CommandText = sql
											cmd.Parameters.Append cmd.CreateParameter("pIdent", 200, 1, Len(theValue) + 1, UCase(theValue))
											cmd.Parameters.Append cmd.CreateParameter("preg_id", 139, 1, 0, reg_id)
											
											CommitRS.Open cmd
											
											
											
											theCount = CommitRS("theCount")
											CommitRS.Close
											if CLng(theCount)= 0 then								
												
												if UCase(commit_type) = "BATCH_COMMIT" and UCase(identifier_array(l))="CHEMICAL_NAME" then
													sql = "INSERT into ALT_IDS(reg_internal_id,identifier,identifier_type,load_id,Datetime_stamp)values(?,?,?,?,?)"
													Set cmd = Server.CreateObject("adodb.command")
													cmd.CommandText = sql
													cmd.ActiveConnection = RegConn
													cmd.CommandType = adCmdText	
													cmd.Parameters.Append cmd.CreateParameter("preg_id", 139, 1, 0, reg_id)
													cmd.Parameters.Append cmd.CreateParameter("pIdent", 200, 1, Len(theValue) + 1, theValue)
													cmd.Parameters.Append cmd.CreateParameter("pIdentType", 139, 1, 0, Synonym_Ident_id)
													if isNull(load_id) then
														load_id = ""
													end if
													cmd.Parameters.Append cmd.CreateParameter("pload_id", 200, 1, Len(load_id) + 1, load_id) 
													cmd.Parameters.Append cmd.CreateParameter("pdatetime_stamp", 200, 1, Len(dateTimeStamp)+ 1, dateTimeStamp) 
					
													cmd.execute
													
													
												else
												
													sql = "INSERT into ALT_IDS(reg_internal_id,identifier,identifier_type,load_id,Datetime_stamp)values(?,?,?,?,?)"
												
													Set cmd = Server.CreateObject("adodb.command")
													cmd.CommandText = sql
													cmd.ActiveConnection = RegConn
													cmd.CommandType = adCmdText	
													cmd.Parameters.Append cmd.CreateParameter("preg_id", 139, 1, 0, reg_id)
													cmd.Parameters.Append cmd.CreateParameter("pIdent", 200, 1, Len(theValue) + 1, theValue)
													cmd.Parameters.Append cmd.CreateParameter("pIdentType", 139, 1, 0, identifier_type_array(l))
													if isNull(load_id) then
														load_id = ""
													end if
													cmd.Parameters.Append cmd.CreateParameter("pload_id", 200, 1, Len(load_id) + 1, load_id) 
													cmd.Parameters.Append cmd.CreateParameter("pdatetime_stamp", 200, 1, Len(dateTimeStamp)+ 1, dateTimeStamp) 
					
													cmd.execute
													
													
												end if
											
											end if
										Case Else
											
											'commitIdent = replace(theValue, "'", "''")
											sql = "INSERT into ALT_IDS(reg_internal_id,identifier,identifier_type,load_id,Datetime_stamp)values(?,?,?,?,?)"
										
											Set cmd = Server.CreateObject("adodb.command")
											cmd.CommandText = sql
											cmd.ActiveConnection = RegConn
											cmd.CommandType = adCmdText	
											cmd.Parameters.Append cmd.CreateParameter("preg_id", 139, 1, 0, reg_id)
											cmd.Parameters.Append cmd.CreateParameter("pIdent", 200, 1, Len(theValue) + 1, theValue)
											cmd.Parameters.Append cmd.CreateParameter("pIdentType", 139, 1, 0, identifier_type_array(l))
											if isNull(load_id) then
												load_id = ""
											end if
											cmd.Parameters.Append cmd.CreateParameter("pload_id", 200, 1, Len(load_id) + 1, load_id) 
											cmd.Parameters.Append cmd.CreateParameter("pdatetime_stamp", 200, 1, Len(dateTimeStamp)+ 1, dateTimeStamp) 
					
											cmd.execute
											
								End Select							
							end if
						
					Next
					
					
						if err.number <> 0 then
							err_number = err.number
							err_description = err.description
							RegConn.RollbackTrans
							returnVal= DoManualRollbackSequence(dbkey,formgroup,RegConn,RootNumberVal, Sequence_id)

								'SYAN added on 1/13/2005 to fix Celera structure disappear problem
								if InStr(UCase(tableorder), "REG_NUMBERS") > 0 then  
									returnVal1 = DoManualRollbackRegNum(dbkey, formgroup, RegConn, cpdDBCounter, reg_id)
								end if
								if InStr(UCase(tableorder), "STRUCTURES") > 0 and InStr(UCase(tableorder), "TEMPORARY_STRUCTURES") <=0 then  
									returnVal2 = doManualRollbackCompd(dbkey, formgroup, RegConn, cpdDBCounter)
								end if
								'End of SYAN modification

							if Session("no_gui" & dbkey & formgroup) = True then
								if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
									DoCommit= "commit failed at " & tablename & ". transaction could not be rolled-back. See \inetpub\cfwlog.txt filefor more information. Record added to temp: " & returnval & returnval2
								else
									DoCommit= "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction rolled-back and added to temp: "  & failtrans
								end if
								logaction("commit failed at " & tablename & ":" & err_number & err_description)
								Post_String = replace(Request.Form, "user_pwd=" & request("user_pwd"),"user_pwd=XXXXX")
								logaction("full post:" & Post_String)		
								exit function
							else
								if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
									response.write  "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction could not be rolled-back: " & returnval & returnval2 & failtrans
								else
									response.write  "commit failed at " & tablename & ".  See \inetpub\cfwlog.txt file for more information. Transaction rolled-back: " & failtrans
								end if
								logaction("commit failed at " & tablename & ".   temp_compound_id: " & tempid & " error: " & err_number & err_description)
								response.end
							end if
						end if
					
			End Select
		next 'next table in the commit order
		
		'stop
		''SYAN added on 9/11/2006 to support salt stripping
		'if Application("SALT_STRIPPING") = 1 then
		'	workingMW_array=populateMW2(dbkey, formgroup, RegConn, cpdDBCounter)
		'end if
		''end of SYAN modificaiton
		
		'if transaction fails, rollback, otherwise commit.
		if failtrans <> "" then
			err_number = err.number
			err_description = err.description
			RegConn.RollbackTrans
			returnVal= DoManualRollbackSequence(dbkey,formgroup,RegConn,RootNumberVal, Sequence_id)
			
			'SYAN added on 1/13/2005 to fix Celera structure disappear problem
			if InStr(UCase(tableorder), "REG_NUMBERS") > 0 then  
				returnVal1 = DoManualRollbackRegNum(dbkey, formgroup, RegConn, cpdDBCounter, reg_id)
			end if
			if InStr(UCase(tableorder), "STRUCTURES") > 0 and InStr(UCase(tableorder), "TEMPORARY_STRUCTURES") <=0 then  
				returnVal2 = doManualRollbackCompd(dbkey, formgroup, RegConn, cpdDBCounter)
			end if
			'End of SYAN modification

			if Session("no_gui" & dbkey & formgroup) = True then
				if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
					DoCommit= "commit failed. transaction could not be rolled-back. See \inetpub\cfwlog.txt filefor more information. Record added to temp: " & returnval & returnval2
				else
					DoCommit= "commit failed. See \inetpub\cfwlog.txt filefor more information. Transaction rolled-back and added to temp: "  & failtrans
				end if
				logaction("commit failed. error: " & err_number & err_description)
				Post_String = replace(Request.Form, "user_pwd=" & request("user_pwd"),"user_pwd=XXXXX")
				logaction("full post:" & Post_String)	
				exit function
			else
				if returnVal <> 0 or returnVal1 <> 0 or returnVal2 then
					response.write  "commit failed. See \inetpub\cfwlog.txt filefor more information. Transaction could not be rolled-back: " & returnval & returnval2 & failtrans
				else
					response.write  "commit failed. See \inetpub\cfwlog.txt filefor more information. Transaction rolled-back: " & failtrans
				end if
				logaction("commit failed at temp_compound_id: " & tempid & " error: " & err_number & err_description)
				response.end
			end if
		else 'no errors

		'commit transcation
		'stop
		if Session("MarkAsDuplicateOnRegister") <> "" then
			addDuplicateEntry dbkey, formgroup,RegConn,CommitRS, Session("MarkAsDuplicateOnRegister"), cpdDBCounter
		end if
		RegConn.CommitTrans
	
		if UCase(commit_type) = "FULL_COMMIT" then
			UpdateBaseRecordCount2 dbkey, formgroup, +1
		else
			if UCase(commit_type = "BATCH_COMMIT") then
				basetable = getbasetable(dbkey, "base_form_group", "basetable")
				if UCase(basetable) = "BATCHES" then
					UpdateBaseRecordCount2 dbkey, formgroup, +1
				end if
			end if
		end if
		
		
	end if
	
	CloseRS(CommitRS)
	CloseRS(TempRS)
	
	
	
	set CommitRS = nothing
	set TempRS = nothing

	
	if not currentBatchNumber <> "" then currentBatchNumber = ""
	Session("Current_Reg_Number")=RegNumber
	DoCommit= RegNumber & ":" & currentBatchNumber & ":" & reg_id & ":" & cpdDBCounter

End Function


Sub UpdateRLSBaseTableRecordCount(dbkey, formgroup)
	Set RegConn= GetRegConn(dbkey, formgroup)
	UpdateBaseRecordCount dbkey, formgroup,  RegConn 
	'CloseConn(RegConn)
End Sub

Sub UpdateRLSTableRecordCount(dbkey, formgroup, tablename)
	Set RegConn=  GetRegConn(dbkey, formgroup)
	UpdateTableRecordCount dbkey, formgroup, "temporary_structures", RegConn
	'CloseConn(RegConn)
End Sub



'******************************************************************
'called by DoRegCommit
'remove record from temp table after commit
'******************************************************************
Sub RemoveFromTemp(ByVal dbkey,ByVal formgroup, ByVal tempid, ByRef RegConn)
		
	if bDeleteFromTemp then
		on error resume next
		if Not isObject(RegConn) then
			set RegConn = getRegConn(dbkey, formgroup)
		end if
	
		Set cmd = Server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		sql = "Delete FROM temporary_structures WHERE temp_compound_id =?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pTempid", 139, 1, 0, tempid) 
		cmd.execute
	
		if RegConn.errors.count > 0 then
			for i = 0 to RegConn.errors.count - 1
				if not inStr(UCase(RegConn.Errors.Item(i).Description), "MULTIPLE-STEP OPERATION")> 0 then
					LogAction(RegConn.errors.item(i).description)
				end if
			next
		end if
		err.Clear()
	else
		on error resume next
		if Not isObject(RegConn) then
			set RegConn = getRegConn(dbkey, formgroup)
		end if
		Set cmd = Server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		sql = "Update  temporary_structures set DUPLICATE='REGISTERED_DELETEABLE' WHERE temp_compound_id =?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pTempid", 139, 1, 0, tempid) 
		cmd.execute
		if RegConn.errors.count > 0 then
			for i = 0 to RegConn.errors.count - 1
				if not inStr(UCase(RegConn.Errors.Item(i).Description), "MULTIPLE-STEP OPERATION")> 0 then
					LogAction(RegConn.errors.item(i).description)
				end if
			next
		end if
		err.Clear()
	end if
	
	if Session("MARKEDHITSREGREVIEW_REGISTER_FORM_GROUP")<> "" then
		RemoveFromMarked dbkey,"review_register_form_group",  tempid
	end if
	if Session("MARKEDHITSREGREG_CTRBT_COMMIT_FORM_GROUP")<> "" then
		RemoveFromMarked dbkey,"reg_ctrbt_commit_form_group",  tempid
	end if
	'decrement temp by -1
	UpdateTableRecordCount2 dbkey, "temporary_structures", -1
End Sub

Sub RemoveFromMarked(ByVal dbkey, formgroup, ByVal tempid)
	'stop
	Dim Setting_Name
	Dim i
	Setting_Name = UCase("MarkedHits" & dbkey & formgroup)
	
	if CBool(Application("PROJECT_LEVEL_ROW_SECURITY")) = true then
		User_ID =  UCase(Session("storeSessionUser" & dbkey))
	else
		User_ID = getUserSettingsID(dbkey, formgroup)
	end if
	
	current_hits = Session("MarkedHits" & dbkey & formgroup) 
	on error resume next
	current_hits_array = split(current_hits, ",", -1)
	for i = 0 to Ubound(current_hits_array)
		if not CLng(current_hits_array(i)) = CLng(tempid) then
			if new_marked_hits <> "" then
				new_marked_hits = new_marked_hits  & "," & current_hits_array(i)
			else
				new_marked_hits = current_hits_array(i)
			end if
		end if
	next

	Session("MarkedHits" & dbkey & formgroup) =new_marked_hits
	updateCurrentSettings dbkey, formgroup, Setting_Name, User_ID, new_marked_hits
	
	'SYAN added on 11/16/2005 to fix CSBR-61291
	DoUnMarkHit dbkey, formgroup, tempid
	'End of SYAN modification
End Sub

Function GetTableLinkValReg(ByVal dbkey, ByVal table_name, ByVal inputval)
	the_table_array = Application(table_name & dbkey)
	the_select_links = the_table_array(kSelectLinks)
	the_new_array = split(the_select_links, ",", -1)
	Select Case inputval
		Case "0" 'source name values
			temp = split(the_new_array(0), ";", -1)
			thevalue = temp(0)
		Case "1" 'source type values
			the_source_vals = split(the_new_array(0), ";", -1)
			thevalue = the_source_vals(1)
		Case "2" 'destination name values
			 thevalue = temp(0)
		Case "3" 'destination type values
			 the_source_vals = split(the_new_array(1), ";", -1)
			thevalue = the_source_vals(1)
	End Select
	GetTableLinkValReg = thevalue
End Function


Function getNotebookVal(ByRef RegConn, ByVal notebook_number)
	
	if CBool(Application("Notebook_Lookup")) = True then			
		User_Code = getValueFromTablewConn(RegConn,"Notebooks", "Notebook_Number",notebook_number, "User_Code")
		User_Last_Name = getValueFromTablewConn(RegConn,"People", "Person_ID",User_Code, "Last_Name")
		User_First_Name = getValueFromTablewConn(RegConn,"People", "Person_ID",User_Code, "First_Name")
		User_Middle_Name = getValueFromTablewConn(RegConn,"People", "Person_ID",User_Code, "Middle_Name")
		NoteBook_name = getValueFromTablewConn(RegConn,"Notebooks", "Notebook_Number",notebook_number, "Notebook_Name")
		if CBool(Application("Show_Notebook_User")) = True then
				'SYAN modified on 2/17/2005 to fix CSBR-51849
				'NotebookVal = "#" & NoteBook_name & User_First_Name & " " &  User_Middle_Name & " " & User_Last_Name 
				NotebookVal =  NoteBook_name & "-" & User_First_Name & " " &  User_Middle_Name & " " & User_Last_Name 
		else
				NotebookVal =NoteBook_name
		end if
		getNotebookVal=NotebookVal
	else
		getNotebookval = ""
	end if

End Function
Function getIdentsAsList(byRef RS)
	if NOT (RS.BOF AND RS.EOF)then
			RS.MoveFirst
		
			Do While Not RS.EOF = True 
																						
				if theResult <> "" then
					theResult = theResult & "," & Trim(RS("Identifier"))
				else
					theResult = Trim(RS("Identifier"))
				end if

				RS.MoveNext
			loop
			result = theResult
	else
			result = ""
	end if
	getIdentsAsList=result

End Function

Function getResultTablewConn(ByRef RegConn, ByRef RS, ByRef cmd, ByVal sql, ByVal out_type, paramName, paramValue)
	
	on error resume next
	if Not isObject(RegConn) then
		set RegConn = getRegConn(dbkey, formgroup)
	end if
	If Not isObject(cmd) then
		Set cmd = Server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
	end if
	
	If Not isObject(RS) then
		Set RS = Server.CreateObject("adodb.recordset")
	end if

	cmd.CommandText = sql
	'this is always an integer 139
	cmd.Parameters.Append cmd.CreateParameter("p" & paramName,139, 1, 0, paramValue) 
	
	on error resume next
	RS.Open cmd
	cmd.Parameters.Delete "p" & paramName
	if NOT (RS.BOF AND RS.EOF)then
		RS.MoveFirst
		select case UCase(out_type)
			case "LIST"	
				result = RS.GetString(,-1, NBSPACE,"<br>",NBSPACE)
			case "STRING"
				if UBound(RS.GetRows(),2)>0 then
					RS.MoveFirst
					result = RS.GetString(,-1, NBSPACE,"",NBSPACE)
				else
					RS.MoveFirst
					result = RS.GetString(,-1, NBSPACE,"",NBSPACE)
				end if
		end select
		
		result_array = split(result, ",", -1)
		for i = 0 to UBound(result_array)
			if result_array(i).length > 0 then
				if new_result_list <> "" then
					new_result_list = new_result_list & "," & result_array(i)
				else
					new_result_list =  result_array(i)
				end if
			end if
			
		next
		result = new_result_list
	else
		result = ""
	end if
	
	RS.Close
	
	getResultTablewConn=result
End Function

'-------------------------------------------------------------------------------
' Name: buildSimpleSQLParam(table_name, table_link_field, return_fields, field_type)
' Purpose:  build a simple sql statement -no joins
' Inputs:  dbkey as string, formgroup as string, table_name: name of table as string, table_link_field: name of linking field in table as string
	'table_link_value: value of linking field as int, field_type: field_type for getting appropriate delimter as int
' Returns:	sql statement as String with ? as parameter
'-------------------------------------------------------------------------------

Function buildSimpleSQLParam(ByVal table_name, ByVal table_link_field, ByVal return_fields)
	sql = "SELECT " & return_fields &  " FROM " & table_name & " WHERE " & table_link_field & "=?"
	buildSimpleSQLParam = sql
End Function




'********************************************************************************************
'FUNCTION NAME: getValueFromTable
'PURPOSE: get a field value for given criteria - no joins
'CALLED BY: BuildRegNum and others
'INPUTS :	dbkey = the database key(dbname)
'			formgroup = the formgroup
'			table_name = the name of the table
'			table_link_field = the name of the field 
'			table_link_value - the value to the linking field
'			return_field = the field from the recordset whose value you want.
'RETURNS: return_field value
'******************************************************************


Function getValueFromTablewConn(ByRef RegConn, ByVal table_name, ByVal table_link_field, ByVal table_link_value, ByVal return_field)
		Dim theValue
		'stop
		'SYAN added the if else statement on 8/25/2004 to fix CSBR-47201
		if table_link_value <> "" then
			on error resume next
			Dim sql
			Dim RS, cmd
			'open connection table_name
			Set RS = Server.CreateObject("ADODB.Recordset")
			Set cmd = Server.CreateObject("adodb.command")
		
			fullfieldname = table_name & "." &  table_link_field
			datatype =getDataType(dbkey,  formgroup,  fullfieldname)
		
			if not isObject(RegConn) then
				Set RegConn= getRegConn(dbkey, formgroup)
			end if
		
			cmd.ActiveConnection =  RegConn
			cmd.CommandType = adCmdText
		
			sql = "select " & return_field & " from " & table_name & " where " & table_link_field & "= ?" 
			if GetFieldDelimiter(datatype) = "'" then
				'SYAN modified on 12/21/2004 to fix CSBR-49964
				if UCase(return_field) = "SEQUENCE_ID" and UCase(table_name) = "SEQUENCE" then
					pValue = Trim((table_link_value))
				'BBracke: LowerCase Prefix CSBR-77655 
				else
					if UCase(return_field) = "REG_ID" and UCase(table_name) = "REG_NUMBERS" then
						pValue = Trim((table_link_value)) 
					else
						pValue = Trim(UCase(table_link_value)) 
					end if
				end if
				'End of BBracke modification
				'End of SYAN modification
				cmd.Parameters.Append Cmd.CreateParameter("ptable_link_value", 200, 1, Len(pValue), pValue) 
			else
				cmd.Parameters.Append cmd.CreateParameter("ptable_link_value", 139, 1, 0, table_link_value) 
			end if
			cmd.CommandText = sql
			RS.Open cmd
			if Not(RS.BOF AND RS.EOF) then
				RS.MoveFirst
				theValue = RS(return_field).value
				CloseRS(RS)
			else
				theValue = ""
			end if
			'clean up
		else
			theValue = null
		end if
		
		'return field value
		getValueFromTablewConn = theValue
End Function



'********************************************************************************************
'FUNCTION NAME: getAllValuesFromTablewConn
'PURPOSE: get a field value for given criteria - no joins
'CALLED BY: BuildRegNum and others
'INPUTS :	dbkey = the database key(dbname)
'			formgroup = the formgroup
'			table_name = the name of the table
'			table_link_field = the name of the field 
'			table_link_value - the value to the linking field
'			return_field = the field from the recordset whose value you want.
'RETURNS: return_field value
'******************************************************************
Function getAllValueswConn(ByRef RegConn, ByVal table_name, ByVal table_link_field, ByVal table_link_value, ByVal return_field)
	'on error resume next
	Dim theValue, sql
	'open connection table_name
	Set CommitRS = Server.CreateObject("ADODB.Recordset")
	fullfieldname = table_name & "." &  table_link_field
	datatype =getDataType(dbkey,  formgroup,  fullfieldname)
	sql = buildSimpleSQl(table_name,table_link_field,table_link_value,datatype)
	CommitRS.Open sql, RegConn, adOpenKeyset, adLockOptimistic
	if Not(CommitRS.BOF AND CommitRS.EOF) then
		CommitRS.MoveFirst
		if theValue <> "" then
			theValue = theValue & "," & CommitRS(return_field)
		else
			thevALUE = CommitRS(return_field)
		end if
		CommitRS.MoveNext
	end if
	'clean up
	CloseRS(CommitRS)
	'return field value
	getAllValueswConn = theValue
End Function


Sub clearRegSessionVars()
	Session("mol_id")= ""
	Session("Compound_Type")= ""
	Session("Project_Name")= ""
	Session("Base64CDX")= ""
	Session("ChemNames")= ""
	Session("AltRegs")= ""
	Session("ACXNums")= ""
	Session("Salt_Name")= ""
	Session("Salt_MW")= ""
	Session("reg_id") = ""
	Session("cpdDBCounter")= ""
	Session("Reg_Number") = ""
	Session("Reg_Number_W_BATCH")
	Session("Root_Number") = ""
	Session("MWText") =""
	Session("MFText") =""
	Session("Struc_Comments_Text")=""
	Session("MW")= ""
	Session("FORMULA")=""
	Session("Product_Type")=""
	Session("RegPerson")=""
	Session("RootRegDate")=""
	Session("RegDate")=""
	Session("TXT_CMPD_FIELD_1")=""
	Session("TXT_CMPD_FIELD_2")=""
	Session("TXT_CMPD_FIELD_3")=""
	Session("TXT_CMPD_FIELD_4")=""
	Session("INT_CMPD_FIELD_1")=""
	Session("INT_CMPD_FIELD_2")=""
	Session("INT_CMPD_FIELD_3")=""
	Session("INT_CMPD_FIELD_4")=""
	Session("REAL_CMPD_FIELD_1")=""
	Session("REAL_CMPD_FIELD_2")=""
	Session("REAL_CMPD_FIELD_3")=""
	Session("REAL_CMPD_FIELD_4")=""
	Session("DATE_CMPD_FIELD_1")=""
	Session("DATE_CMPD_FIELD_2")=""
	Session("DATE_CMPD_FIELD_3")=""
	Session("DATE_CMPD_FIELD_4")=""
End Sub


Function getTableCount(tablename, strWhere, primKey)
	 if Not isObject(RegConn)  then
		Set RegConn= GetRegConn(dbkey, formgroup)
	end if

	
	Set cmd = Server.CreateObject("adodb.command")
	Set RS = Server.CreateObject("adodb.recordset")
	
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText

	
	
	if strWhere <> "" then
		sql = "Select Count(" & primKey & ") as theCount From " & tablename & " WHERE " & strWhere 
	else
		sql = "Select Count(" & primKey & ") as theCount From " & tablename 
	end if


	cmd.CommandText = sql
	
	on error resume next
	RS.Open cmd

	If Not (RS.BOF AND RS.EOF)then
		theCount = RS.Fields("theCount")
		RS.Close
	End if
	CloseRS(RS)
	'CloseConn(RegConn)
	getTableCount = theCount
End Function


Sub getRegData(byRef RegConn, byVal reg_id, byVal cpdDBcounter, ByVal displaytype)
	
	clearRegSessionVars()
	dbkey = request("dbname")
	formgroup= request("formgroup")
	
	if Not isObject(RegConn) then
		Set RegConn = getRegConn(dbkey, formgroup)
	end if
	
	on error resume next
	
	
	'set reg_id and cpddbcounter to session object
	if UCase(displaytype) = "ROOT_NUMBER" then
		
		Set cmd1 = Server.CreateObject("ADODB.COMMAND")
		cmd1.ActiveConnection =  RegConn
		cmd1.CommandType = adCmdText
		
		Set CMPD_RS =  Server.CreateObject("ADODB.RECORDSET")
		if Not cpdDBCounter <> "" then 
			Response.end
		else
			Session("Root_Number") = getValueFromTablewConn(RegConn,"Compound_Molecule", "cpd_database_counter",cpdDbCounter, "root_number")	
			Session("cpdDBCounter")=cpdDBCounter

			sql ="Select REG_ID from Reg_Numbers where cpd_internal_id =? ORDER BY REG_ID ASC"
			cmd1.CommandText = sql
			cmd1.Parameters.Append cmd1.CreateParameter("pcpdDBCounter", 139, 1, 0, cpdDBCounter)
			CMPD_RS.Open cmd1
			CMPD_RS.MoveFirst
			reg_id =RS("REG_ID")
			CMPD_RS.Close
			
			Session("RootRegDate") = getValueFromTablewConn(RegConn,"Compound_Molecule", "cpd_database_counter", cpdDbCounter, "root_reg_date")	
			bIdentifiers = false
			bSaltName=false
			bCompoundData = true
		end if
	else
		if Not reg_id <> "" then
      Response.End
      else
      Session("Root_Number") = getValueFromTablewConn(RegConn,"Compound_Molecule", "cpd_database_counter",cpdDbCounter, "root_number")
      Session("Reg_Number") = getValueFromTablewConn(RegConn,"Reg_Numbers", "reg_id", reg_id, "reg_number")
      Session("cpdDBCounter")=cpdDBCounter
      Session("reg_id") = reg_id
      bIdentifiers = true
      bSaltName=true
      bCompoundData = true
      end if

      Session("RootRegDate") = getValueFromTablewConn(RegConn,"Compound_Molecule", "cpd_database_counter", cpdDbCounter, "root_reg_date")
      Session("RegDate") = getValueFromTablewConn(RegConn,"Reg_Numbers", "reg_id", reg_id, "Registry_Date")
      'SYAN added to fix CSBR-89375
      Session("RegDate") = ConvertDateToStr(Application("DATE_FORMAT"), Session("RegDate"))
      'End of SYAN modification
      end if

      if bCompoundData = true then
      'get mol_id

      person_id = getValueFromTablewConn(RegConn,"reg_numbers", "reg_id", reg_id , "registrar_person_id")
      LastName =  getValueFromTablewConn(RegConn, "People", "Person_ID", person_id, "Last_Name")
      FirstName = getValueFromTablewConn(RegConn, "People", "Person_ID", person_id, "First_Name")
      Reg_Person = FormatDisplayName(LastName, FirstName)
      if instr(Reg_Person, "&comma;")> 0 then
			Reg_Person = replace(Reg_Person, "&comma;", ",")
		end if
		Session("RegPerson")=Reg_Person
		
		Set cmd1 = Server.CreateObject("ADODB.COMMAND")
		cmd1.ActiveConnection =  RegConn
		cmd1.CommandType = adCmdText
	
		Set RS =  Server.CreateObject("ADODB.RECORDSET")
			
		sql = "select * from compound_molecule where cpd_database_counter=?"
		cmd1.CommandText = sql
		cmd1.Parameters.Append cmd1.CreateParameter("pcpd", 139, 1, 0, cpdDBcounter) 
		
		RS.Open cmd1
		cmd1.Parameters.Delete "pcpd"
		
		Session("MWText") = RS("MW_Text")
		Session("MW_Text")=Session("MWText")
		Session("MFText") = RS("MF_Text")
		Session("MF_Text")=Session("MFText")
		Session("MW")= RS("MW2")
		Session("FORMULA")=  RS("FORMULA2")
		Session("Struc_Comments_Text")= RS("structure_comments_txt")
		Session("TXT_CMPD_FIELD_1")=RS("TXT_CMPD_FIELD_1")
		Session("TXT_CMPD_FIELD_2")=RS("TXT_CMPD_FIELD_2")
		Session("TXT_CMPD_FIELD_3")=RS("TXT_CMPD_FIELD_3")
		Session("TXT_CMPD_FIELD_4")=RS("TXT_CMPD_FIELD_4")
		
		Session("INT_CMPD_FIELD_1")=RS("INT_CMPD_FIELD_1")
		Session("INT_CMPD_FIELD_2")=RS("INT_CMPD_FIELD_2")
		Session("INT_CMPD_FIELD_3")=RS("INT_CMPD_FIELD_3")
		Session("INT_CMPD_FIELD_4")=RS("INT_CMPD_FIELD_4")
		
		Session("REAL_CMPD_FIELD_1")=RS("REAL_CMPD_FIELD_1")
		Session("REAL_CMPD_FIELD_2")=RS("REAL_CMPD_FIELD_2")
		Session("REAL_CMPD_FIELD_3")=RS("REAL_CMPD_FIELD_3")
		Session("REAL_CMPD_FIELD_4")=RS("REAL_CMPD_FIELD_4")
		
		Session("DATE_CMPD_FIELD_1")=RS("DATE_CMPD_FIELD_1")
		Session("DATE_CMPD_FIELD_2")=RS("DATE_CMPD_FIELD_2")
		Session("DATE_CMPD_FIELD_3")=RS("DATE_CMPD_FIELD_3")
		Session("DATE_CMPD_FIELD_4")=RS("DATE_CMPD_FIELD_4")
		
		'get compound type
		if not checkHideField("Product_Type") then
			Session("Product_Type")=RS("product_type")
		end if
		
		compound_type_val =RS("compound_type")
		Session("Compound_Type")= getValueFromTablewConn(RegConn, "Compound_Type", "Compound_Type", compound_type_val , "Description")
		RS.close
		'get Project Recordset
		Set cmd1 = Server.CreateObject("ADODB.COMMAND")
		cmd1.ActiveConnection =  RegConn
		cmd1.CommandType = adCmdText
		sql = "SELECT Projects.Project_Name FROM Projects,Compound_Project Where Compound_Project.CPD_Internal_ID =? AND Projects.Project_Internal_ID = Compound_Project.Project_Internal_ID"
		cmd1.CommandText = sql
		cmd1.Parameters.Append cmd1.CreateParameter("pcpdD", 139, 1, 0, cpdDBCounter) 
		RS.Open cmd1
		cmd1.Parameters.Delete "pcpdD"
		if Not(RS.BOF AND RS.EOF)then
			RS.MoveFirst
			Session("Project_Name")= RS("Project_Name")
		end if
		RS.close
		'get base64
		Set cmd1 = Server.CreateObject("ADODB.COMMAND")
		cmd1.ActiveConnection =  RegConn
		cmd1.CommandType = adCmdText
		sql = "Select Base64_CDX from structures where cpd_internal_id =?"
		cmd1.Parameters.Append cmd1.CreateParameter("pcpdDBCounter", 139, 1, 0, cpdDBCounter) 
		cmd1.CommandText = sql
			
		RS.Open cmd1
		cmd1.Parameters.Delete "pcpdDBCounter"
		if Not(RS.BOF AND RS.EOF)then
			RS.MoveFirst
			Session("Base64_CDX") = RS("Base64_CDX")
		end if
		RS.Close
	
		if UCase(Application("Batch_Level")) = "SALT" then
			Salt_Code = getValueFromTablewConn(RegConn, "Compound_Salt", "reg_internal_id", reg_id , "salt_internal_id")
			Session("Salt_Name") = getValueFromTablewConn(RegConn,"salts", "salt_code", salt_code, "Salt_Name")
			Session("Salt_MW")= getValueFromTablewConn(RegConn,"salts", "salt_code", salt_code, "Salt_MW")
		end if
	end if
	if bSalt=true then
		if UCase(Application("Batch_Level")) = "SALT" then
			Salt_Code = getValueFromTablewConn(RegConn, "Compound_Salt", "reg_internal_id", reg_id , "salt_internal_id")
			Session("Salt_Name") = getValueFromTablewConn(RegConn,"salts", "salt_code", salt_code, "Salt_Name")
		end if
	end if
	if bIdentifiers=true then
		
		
		
		Set RS =  Server.CreateObject("ADODB.RECORDSET")
		
		Set cmd = Server.CreateObject("ADODB.COMMAND")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		

		identifier_name = "chemical_name"
		sql = "Select Alt_IDS.Identifier from Alt_IDs,Identifiers where Alt_IDs.Identifier_type=Identifiers.Identifier_type AND Alt_ids.reg_internal_ID=? AND lower(Identifiers.Identifier_Descriptor)=?"
		cmd.commandtype = adCmdText
		cmd.ActiveConnection = RegConn
		sql = "Select Alt_IDS.Identifier from Alt_IDs,Identifiers where Alt_IDs.Identifier_type=Identifiers.Identifier_type AND Alt_ids.reg_internal_ID=? AND lower(Identifiers.Identifier_Descriptor)=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pRegID", 139, 1, 0, reg_ID) 
		cmd.Parameters.Append cmd.CreateParameter("pIdentTypeID", 200, 1, Len(identifier_name) + 1, CStr(identifier_name)) 
		RS.open cmd
		chemical_name = getIdentsAsList(RS)
		RS.Close

		Set cmd = Server.CreateObject("ADODB.COMMAND")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		
		identifier_name = "synonym_r"
		sql = "Select Alt_IDS.Identifier from Alt_IDs,Identifiers where Alt_IDs.Identifier_type=Identifiers.Identifier_type AND Alt_ids.reg_internal_ID=? AND lower(Identifiers.Identifier_Descriptor)=?"
		cmd.commandtype = adCmdText
		cmd.ActiveConnection = RegConn
		sql = "Select Alt_IDS.Identifier from Alt_IDs,Identifiers where Alt_IDs.Identifier_type=Identifiers.Identifier_type AND Alt_ids.reg_internal_ID=? AND lower(Identifiers.Identifier_Descriptor)=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pRegID", 139, 1, 0, reg_ID) 
		cmd.Parameters.Append cmd.CreateParameter("pIdentTypeID", 200, 1, Len(identifier_name) + 1, CStr(identifier_name)) 
		RS.open cmd
		synonym_r = getIdentsAsList(RS)
		RS.Close
		
		Set cmd = Server.CreateObject("ADODB.COMMAND")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		
		identifier_name = "chem_name_autogen"
		sql = "Select Alt_IDS.Identifier from Alt_IDs,Identifiers where Alt_IDs.Identifier_type=Identifiers.Identifier_type AND Alt_ids.reg_internal_ID=? AND lower(Identifiers.Identifier_Descriptor)=?"
		cmd.commandtype = adCmdText
		cmd.ActiveConnection = RegConn
		sql = "Select Alt_IDS.Identifier from Alt_IDs,Identifiers where Alt_IDs.Identifier_type=Identifiers.Identifier_type AND Alt_ids.reg_internal_ID=? AND lower(Identifiers.Identifier_Descriptor)=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pRegID", 139, 1, 0, reg_ID) 
		cmd.Parameters.Append cmd.CreateParameter("pIdentTypeID", 200, 1, Len(identifier_name) + 1, CStr(identifier_name)) 
		RS.open cmd
		chem_name_autogen = getIdentsAsList(RS)
		RS.Close
		
		Set cmd = Server.CreateObject("ADODB.COMMAND")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		
		identifier_name = "collaborator_id"
		sql = "Select Alt_IDS.Identifier from Alt_IDs,Identifiers where Alt_IDs.Identifier_type=Identifiers.Identifier_type AND Alt_ids.reg_internal_ID=? AND lower(Identifiers.Identifier_Descriptor)=?"
		cmd.commandtype = adCmdText
		cmd.ActiveConnection = RegConn
		sql = "Select Alt_IDS.Identifier from Alt_IDs,Identifiers where Alt_IDs.Identifier_type=Identifiers.Identifier_type AND Alt_ids.reg_internal_ID=? AND lower(Identifiers.Identifier_Descriptor)=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pRegID", 139, 1, 0, reg_ID) 
		cmd.Parameters.Append cmd.CreateParameter("pIdentTypeID", 200, 1, Len(identifier_name) + 1, CStr(identifier_name)) 
		RS.open cmd
		Collaborator_ID = getIdentsAsList(RS)
		RS.Close
		
		
		Set cmd = Server.CreateObject("ADODB.COMMAND")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		
		identifier_name = "rno_number"
		sql = "Select Alt_IDS.Identifier from Alt_IDs,Identifiers where Alt_IDs.Identifier_type=Identifiers.Identifier_type AND Alt_ids.reg_internal_ID=? AND lower(Identifiers.Identifier_Descriptor)=?"
		cmd.commandtype = adCmdText
		cmd.ActiveConnection = RegConn
		sql = "Select Alt_IDS.Identifier from Alt_IDs,Identifiers where Alt_IDs.Identifier_type=Identifiers.Identifier_type AND Alt_ids.reg_internal_ID=? AND lower(Identifiers.Identifier_Descriptor)=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pRegID", 139, 1, 0, reg_ID) 
		cmd.Parameters.Append cmd.CreateParameter("pIdentTypeID", 200, 1, Len(identifier_name) + 1, CStr(identifier_name)) 
		RS.open cmd
		RNO_Number = getIdentsAsList(RS)
		RS.Close
		
		
		Set cmd = Server.CreateObject("ADODB.COMMAND")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		
		identifier_name = "fema_gras_number"
		sql = "Select Alt_IDS.Identifier from Alt_IDs,Identifiers where Alt_IDs.Identifier_type=Identifiers.Identifier_type AND Alt_ids.reg_internal_ID=? AND lower(Identifiers.Identifier_Descriptor)=?"
		cmd.commandtype = adCmdText
		cmd.ActiveConnection = RegConn
		sql = "Select Alt_IDS.Identifier from Alt_IDs,Identifiers where Alt_IDs.Identifier_type=Identifiers.Identifier_type AND Alt_ids.reg_internal_ID=? AND lower(Identifiers.Identifier_Descriptor)=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pRegID", 139, 1, 0, reg_ID) 
		cmd.Parameters.Append cmd.CreateParameter("pIdentTypeID", 200, 1, Len(identifier_name) + 1, CStr(identifier_name)) 
		RS.open cmd
		fema_gras_number = getIdentsAsList(RS)
		RS.Close
		
		
		Set cmd = Server.CreateObject("ADODB.COMMAND")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		
		identifier_name = "cas_number"
		sql = "Select Alt_IDS.Identifier from Alt_IDs,Identifiers where Alt_IDs.Identifier_type=Identifiers.Identifier_type AND Alt_ids.reg_internal_ID=? AND lower(Identifiers.Identifier_Descriptor)=?"
		cmd.commandtype = adCmdText
		cmd.ActiveConnection = RegConn
		sql = "Select Alt_IDS.Identifier from Alt_IDs,Identifiers where Alt_IDs.Identifier_type=Identifiers.Identifier_type AND Alt_ids.reg_internal_ID=? AND lower(Identifiers.Identifier_Descriptor)=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pRegID", 139, 1, 0, reg_ID) 
		cmd.Parameters.Append cmd.CreateParameter("pIdentTypeID", 200, 1, Len(identifier_name) + 1, CStr(identifier_name)) 
		RS.open cmd
		cas_number = getIdentsAsList(RS)
		RS.Close

		Set cmd = Server.CreateObject("ADODB.COMMAND")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		
		identifier_name = "group_code"
		sql = "Select Alt_IDS.Identifier from Alt_IDs,Identifiers where Alt_IDs.Identifier_type=Identifiers.Identifier_type AND Alt_ids.reg_internal_ID=? AND lower(Identifiers.Identifier_Descriptor)=?"
		cmd.commandtype = adCmdText
		cmd.ActiveConnection = RegConn
		sql = "Select Alt_IDS.Identifier from Alt_IDs,Identifiers where Alt_IDs.Identifier_type=Identifiers.Identifier_type AND Alt_ids.reg_internal_ID=? AND lower(Identifiers.Identifier_Descriptor)=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pRegID", 139, 1, 0, reg_ID) 
		cmd.Parameters.Append cmd.CreateParameter("pIdentTypeID", 200, 1, Len(identifier_name) + 1, CStr(identifier_name)) 
		RS.open cmd
		group_code = getIdentsAsList(RS)
		RS.Close

		
		Session("ChemNames")=chemical_name
		Session("ChemNamesAutoGen")= chem_name_autogen
		Session("Synonyms")= synonym_r
		Session("Collaborator_ID") = Collaborator_ID
		Session("RNO-No")=RNO_Number
		Session("CasNums")=cas_number
		Session("FEMA-No")=fema_gras_number
		Session("GroupCode") = group_code
		
	end if
	

	
End Sub

Function GetNotebookList(ByRef RegConn)
	on error resume next
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	Set NotebookRS = Server.CreateObject("adodb.recordset")

		
	if CBool(Application("Notebook_Lookup")) = True then
		on error resume next
		
		if CBool(Application("SHOW_USER_NOTEBOOKS_ONLY")) = true then
			GetNotebookList = GetUserNotebookList(RegConn, Session("UserName" & dbkey))
			exit function
		else
			sql = "Select Notebooks.* From Notebooks Where Active = ? or Notebooks.Active = -1 order by notebook_name"
		end if
		Set cmd = Server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
				
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pActive", 139, 1, 0, 1) 
	
		on error resume next
		NotebookRS.Open cmd

		
		NotebookRS.MoveFirst
		if Not (NotebookRS.BOF AND NotebookRS.EOF)then
			if NOT UCase(Request("formmode"))="SEARCH" then
				while NotebookRS.EOF <> TRUE
					if Not CBool(NotebookRS("Active")) =false then
				
						notebook_user_code = NotebookRS("User_Code") 
						Set PeopleRS = Server.CreateObject("adodb.recordset")
						notebook_user_code = NotebookRS("User_Code") 
						sql = "SELECT People.Last_Name FROM People WHERE People.Person_ID =?"
						Set cmd = Server.CreateObject("adodb.command")
						cmd.ActiveConnection =  RegConn
						cmd.CommandType = adCmdText
				
						cmd.CommandText = sql
						cmd.Parameters.Append cmd.CreateParameter("pnotebook_user_code", 139, 1, 0, notebook_user_code) 		
						on error resume next
						PeopleRS.Open cmd
					
					
						'username = PeopleRS("First_Name") & " " & PeopleRS("Middle_Name") & " " & PeopleRS("Last_Name")
						username = PeopleRS("Last_Name")							
						PeopleRS.Close
						
						
						if NotebookIDS <> "" then
							if not isNull(NotebookRS("Notebook_Name")) then  
								Notebook_Name = replace(NotebookRS("Notebook_Name"), ",", "&comma;")
								if CBool(Application("SHOW_NOTEBOOK_USER")) = True then
									NotebookIDS = NotebookIDS & "," &  NotebookRS("Notebook_Number") & ":" &  Notebook_Name & "- " & username
								else
									NotebookIDS = NotebookIDS & "," &  NotebookRS("Notebook_Number") & ":" & Notebook_Name 
								end if
							end if
						else
							if not isNull(NotebookRS("Notebook_Name")) then  
								Notebook_Name = replace(NotebookRS("Notebook_Name"), ",", "&comma;")
								if CBool(Application("SHOW_NOTEBOOK_USER")) = True then
									NotebookIDS = NotebookRS("Notebook_Number") & ":" & Notebook_Name & "- " & username
								else
									NotebookIDS = NotebookRS("Notebook_Number") & ":" & Notebook_Name
								end if
							end if
						end if
					end if
					NotebookRS.MoveNext	
				wend	
			else
				while NotebookRS.EOF <> TRUE
					Set PeopleRS = Server.CreateObject("adodb.recordset")
					notebook_user_code = NotebookRS("User_Code") 
					sql = "SELECT People.Last_Name FROM People WHERE People.Person_ID =?"
					Set cmd = Server.CreateObject("adodb.command")
					cmd.ActiveConnection =  RegConn
					cmd.CommandType = adCmdText
					cmd.CommandText = sql
					cmd.Parameters.Append cmd.CreateParameter("pnotebook_user_code", 139, 1, 0, notebook_user_code) 		
					on error resume next
					PeopleRS.Open cmd
					
					'username = PeopleRS("First_Name") & " " & PeopleRS("Middle_Name") & " " & PeopleRS("Last_Name")
					username = PeopleRS("Last_Name")							
					PeopleRS.Close
					if NotebookIDS <> "" then
						if Not isNull(NotebookRS("Notebook_Name")) then
							Notebook_Name = replace(NotebookRS("Notebook_Name"), ",", "&comma;")
							if CBool(Application("SHOW_NOTEBOOK_USER")) = True then
								NotebookIDS = NotebookIDS & "," &  NotebookRS("Notebook_Number") & ":"  & Notebook_Name & "- " & username
							else
								NotebookIDS = NotebookIDS & "," &  NotebookRS("Notebook_Number") & ":" & Notebook_Name 
							end if
						end if
					else
						if Not isNull(NotebookRS("Notebook_Name")) then
							Notebook_Name = replace(NotebookRS("Notebook_Name"), ",", "&comma;")
							if CBool(Application("SHOW_NOTEBOOK_USER")) = True then
								NotebookIDS = NotebookRS("Notebook_Number") & ":" & Notebook_Name & "- " & username
							else
								NotebookIDS = NotebookRS("Notebook_Number") & ":" & Notebook_Name
							end if
						end if
					end if
						
					NotebookRS.MoveNext	
				wend	
			end if		
			CloseRS(NotebookRS)
		end if
		GetNotebookList=NotebookIDS
	else
		GetNotebookList=""
	end if
End Function


Function GetUserNotebookList(ByRef RegConn, ByVal UserName)

		
		Set NotebookRS = Server.CreateObject("adodb.recordset")
		Set PeopleRS = Server.CreateObject("adodb.recordset")
		if Not isObject(RegConn) then
			Set RegConn= getRegConn(dbkey, formgroup)
		end if
	


		
	Set cmd = Server.CreateObject("adodb.command")
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
				
	if CBool(Application("Notebook_Lookup")) = True then
		if Not CBool(Application("SHOW_USER_NOTEBOOKS_ONLY")) = true then
			GetUserNotebookList = GetNotebookList(RegConn)
			exit function
		else
			Set PeopleRS = Server.CreateObject("ADODB.Recordset")
			
			If Session("EditRestrictIDs" & dbkey)<> ""  then
				If Not Session("EditRestrictIDs" & dbkey)= "0" then
					
					sql = "Select distinct Notebooks.* From Notebooks, People Where (Notebooks.Active = ? or Notebooks.Active = -1)" &_
					" AND Notebooks.User_Code=People.Person_ID AND People.Person_ID IN(" & Session("EditRestrictIDs" & dbkey) & ")"
					cmd.Parameters.Append cmd.CreateParameter("pActive", 139, 1, 0, 1)
					
				else
					sql = "Select distinct Notebooks.* From Notebooks Where (Notebooks.Active = ? or Notebooks.Active = -1) order by notebook_name"
					cmd.Parameters.Append cmd.CreateParameter("pActive", 139, 1, 0, 1)
				end if
			end if
			
		end if
		
		cmd.CommandText = sql
	
		on error resume next
		NotebookRS.Open cmd
		
		NotebookRS.MoveFirst
		
		if Not (NotebookRS.BOF AND NotebookRS.EOF)then
			if NOT UCase(Request("formmode"))="SEARCH" then
				while NotebookRS.EOF <> TRUE
					if Not CBool(NotebookRS("Active")) =false then
						notebook_user_code = NotebookRS("User_Code") 
						sql = "SELECT People.Last_Name FROM People WHERE People.Person_ID = " &  notebook_user_code 
						Set cmd = Server.CreateObject("adodb.command")
						cmd.ActiveConnection =  RegConn
						cmd.CommandType = adCmdText
						cmd.CommandText = sql
						cmd.Parameters.Append cmd.CreateParameter("pnotebook_user_code", 139, 1, 0, notebook_user_code) 
						PeopleRS.Open cmd
					
						'username = PeopleRS("First_Name") & " " & PeopleRS("Middle_Name") & " " & PeopleRS("Last_Name")
						username = PeopleRS("Last_Name")	
						PeopleRS.Close
						if NotebookIDS <> "" then
							if Not isNull(NotebookRS("Notebook_Name")) then
								Notebook_Name = replace(NotebookRS("Notebook_Name"), ",", "&comma;")
								if Application("SHOW_NOTEBOOK_USER") = 1  then
							
									NotebookIDS = NotebookIDS & "," &  NotebookRS("Notebook_Number") & ":" & Notebook_Name & "- " & username
								else
									NotebookIDS = NotebookIDS & "," &  NotebookRS("Notebook_Number") & ":" & Notebook_Name
								end if
							end if
						else
							if Not isNull(NotebookRS("Notebook_Name")) then
								Notebook_Name = replace(NotebookRS("Notebook_Name"), ",", "&comma;")
								if Application("SHOW_NOTEBOOK_USER") = 1  then
									NotebookIDS = NotebookRS("Notebook_Number") & ":" &  Notebook_Name & "- " & username
								else
									NotebookIDS = NotebookRS("Notebook_Number") & ":" & Notebook_Name
								end if
							end if
						end if
					end if
				NotebookRS.MoveNext	
				wend
			else
				while NotebookRS.EOF <> TRUE
					notebook_user_code = NotebookRS("User_Code") 
					sql = "SELECT People.Last_Name FROM People WHERE People.Person_ID = " &  notebook_user_code 
					Set cmd = Server.CreateObject("adodb.command")
					cmd.ActiveConnection =  RegConn
					cmd.CommandType = adCmdText
					cmd.CommandText = sql
					cmd.Parameters.Append cmd.CreateParameter("pnotebook_user_code", 139, 1, 0, notebook_user_code) 
					PeopleRS.Open cmd
					username = PeopleRS("Last_Name")	
					PeopleRS.Close
			
					if NotebookIDS <> "" then
						if Not isNull(NotebookRS("Notebook_Name")) then
							Notebook_Name = replace(NotebookRS("Notebook_Name"), ",", "&comma;")
							if Application("SHOW_NOTEBOOK_USER") = 1  then
						
								NotebookIDS = NotebookIDS & "," &  NotebookRS("Notebook_Number") & ":" &  Notebook_Name & "-" & username
							else
								NotebookIDS = NotebookIDS & "," &  NotebookRS("Notebook_Number") & ":" & Notebook_Name
							end if
						end if
					else
						if Not isNull(NotebookRS("Notebook_Name")) then
							Notebook_Name = replace(NotebookRS("Notebook_Name"), ",", "&comma;")
							if Application("SHOW_NOTEBOOK_USER") = 1 then
								NotebookIDS = NotebookRS("Notebook_Number") & ":" &  Notebook_Name & "-" & username
							else
								NotebookIDS = NotebookRS("Notebook_Number") & ":" & Notebook_Name
							end if
						end if
					end if
					NotebookRS.MoveNext	
				wend	
			end if

			CloseRS(NotebookRS)
		end if
	end if
		GetUserNotebookList=NotebookIDS
	
End Function


Function GetAvailSaltList(ByRef RegConn, ByVal cpdDBCounter)
	Set cmd = Server.CreateObject("adodb.command")
	Set RS = Server.CreateObject("adodb.recordset")
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	if CBool(Application("SHOW_MF_WITH_SALT_NAME")) = true then
		bShowMF = true 
	else
		bShowMF = false 
	end if


	sql = "Select * From Salts Where Salt_Code NOT IN(Select salt_internal_id From Compound_Salt Where cpd_internal_id=?)  order by salt_name"
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("pcpdDBCounter", 139, 1, 0, cpdDBCounter) 

	
	on error resume next
	RS.Open cmd
	
	if isObject(RS) AND NOT (RS.EOF AND RS.BOF) then
		RS.MoveFirst
		if NOT UCase(Request("formmode"))="SEARCH" then
			while RS.EOF <> TRUE    
				if Not CBool(RS("Active")) =false then
					if not isNull(RS("Salt_Name")) then
						Salt_Name = Replace(Trim(RS("Salt_Name")), ",", "&comma;")
						if bShowMF = true then
							Salt_Name = Salt_Name & "(" &   RS("SALT_MF") & ")"
						end if 
						if SaltIDS <> "" then
							SaltIDS = SaltIDS & "," &  Trim(RS("Salt_Code")) & ":" & Salt_Name
						else
							SaltIDS = Trim(RS("Salt_Code")) & ":" & Salt_Name
						end if
					end if
				end if
				RS.MoveNext	
			wend
		else
			while RS.EOF <> TRUE
				if not isNull(RS("Salt_Name")) then
					Salt_Name = Replace(Trim(RS("Salt_Name")), ",", "&comma;") 
					if bShowMF = true then
							Salt_Name = Salt_Name & "(" &   RS("SALT_MF") & ")"
					end if  
					if SaltIDS <> "" then
						SaltIDS = SaltIDS & "," &  Trim(RS("Salt_Code")) & ":" & Salt_Name
					else
						SaltIDS = Trim(RS("Salt_Code")) & ":" & Salt_Name
					end if
				end if
				RS.MoveNext	
			wend
		end if
	end if
	CloseRS(RS)
	GetAvailSaltList=SaltIDS
End Function



Function GetSaltsList(ByRef RegConn)
		Set cmd = Server.CreateObject("adodb.command")
		Set RS = Server.CreateObject("adodb.recordset")
		if Not isObject(RegConn) then
			Set RegConn= getRegConn(dbkey, formgroup)
		end if
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		
		if CBool(Application("SHOW_MF_WITH_SALT_NAME")) = true then
			bShowMF = true 
		else
			bShowMF = false 
		end if

		ValueField = "Salt_Code"
		
		
		sql = "Select * From Salts  order by salt_name"
		cmd.CommandText = sql
		
		on error resume next
		RS.Open cmd

		if NOT (RS.EOF AND RS.BOF) then
			if NOT UCase(Request("formmode"))="SEARCH" then
				while RS.EOF <> TRUE    
					if Not CBOOL(RS("Active")) =FALSE THEN
						if not isNull(RS("Salt_Name")) then
							Salt_Name = Replace(Trim(RS("Salt_Name")), ",", "&comma;") 
							if bShowMF = true then
								Salt_Name = Salt_Name & "(" &   RS("SALT_MF") & ")"
							end if 
							if SaltIDS <> "" then
								SaltIDS = SaltIDS & "," &  Trim(RS(ValueField)) & ":" & Salt_Name
							else
								SaltIDS = Trim(RS(ValueField)) & ":" & Salt_Name
							end if
						end if
					end if
				RS.MoveNext	
				wend
			else
				while RS.EOF <> TRUE  
					if not isNull(RS("Salt_Name")) then
						Salt_Name = Replace(Trim(RS("Salt_Name")), ",", "&comma;")   
						if bShowMF = true then
							Salt_Name = Salt_Name & "(" &   RS("SALT_MF") & ")"
						end if 
						if SaltIDS <> "" then
							SaltIDS = SaltIDS & "," &  Trim(RS(ValueField))& ":" & Salt_Name
						else
							SaltIDS = Trim(RS(ValueField)) & ":" & Salt_Name
						end if
					end if
					RS.MoveNext	
				wend
			end if
			CloseRS(RS)
		else
			SaltIDS = ""
		end if
	
	GetSaltsList=SaltIDS
	
End Function


Function GetSolvatesList(ByRef RegConn)
	
	Set cmd = Server.CreateObject("adodb.command")
	Set RS = Server.CreateObject("adodb.recordset")
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	sql = "Select * from solvates order by solvate_name"
	cmd.CommandText = sql
	
	
	on error resume next
	RS.Open cmd
	IF Not (RS.EOF and RS.BOF) then
		if NOT UCase(Request("formmode"))="SEARCH" then
			while RS.EOF <> TRUE    
				if Not CBOOL(RS("Active")) =FALSE THEN
					if not isNull(RS("Solvate_Name")) then
						Solvate_Name = Replace(Trim(RS("Solvate_Name")), ",", "&comma;") 
						if SolvateIDS <> "" then
							'SYAN modified 9/27/2004 to fix CSBR-46729
							If Application("FLOAT_FORMAT") = "9" then
								SolvateIDS = SolvateIDS & "|" &  RS("Solvate_MW") & ":" & Solvate_Name
							else
								SolvateIDS = SolvateIDS & "," &  RS("Solvate_MW") & ":" & Solvate_Name
							end if
							'End of SYAN modification
						else
							SolvateIDS = RS("Solvate_MW") & ":" & Solvate_Name
						end if
					end if
				end if
			RS.MoveNext	
			wend
		else
			while RS.EOF <> TRUE    
				if not isNull(RS("Solvate_Name")) then
					Solvate_Name = Replace(Trim(RS("Solvate_Name")), ",", "&comma;") 
					if SolvateIDS <> "" then
						'SYAN modified 9/27/2004 to fix CSBR-46729
						If Application("FLOAT_FORMAT") = "9" then
							SolvateIDS = SolvateIDS & "|" &  RS("Solvate_MW") & ":" & Solvate_Name
						Else
							SolvateIDS = SolvateIDS & "," &  RS("Solvate_MW") & ":" & Solvate_Name
						End if
						'End of SYAN modification
					else
						SolvateIDS = RS("Solvate_MW") & ":" & Solvate_Name
					end if
				end if
				RS.MoveNext	
			wend
		end if
		CloseRS(RS)
	else
		SolvateIDS = ""
	end if
	GetSolvatesList=SolvateIDS
End Function

Function GetSaltsListBatch(ByRef RegConn)
	'stop
	if CBool(Application("SHOW_MF_WITH_SALT_NAME")) = true then
		bShowMF = true 
	else
		bShowMF = false 
	end if
	ValueField = "Salt_MW"
	
	Set cmd = Server.CreateObject("adodb.command")
	Set RS = Server.CreateObject("adodb.recordset")
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	sql = "Select * from Salts  order by salt_name"
	cmd.CommandText = sql
	
	on error resume next
	RS.Open cmd
	if Not (RS.BOF and RS.EOF) then	
	
		if NOT UCase(Request("formmode"))="SEARCH" then
			while RS.EOF <> TRUE    
				if not isNull(RS("Salt_Name")) then
					Salt_Name = Replace(Trim(RS("Salt_Name")), ",", "&comma;")  
					if bShowMF = true then
						Salt_Name = Salt_Name & "(" &   RS("SALT_MF") & ")"
					end if 
					if Not CBOOL(RS("Active")) =FALSE THEN
						if SaltIDS <> "" then
							'SYAN modified 9/27/2004 to fix CSBR-46729
							If Application("FLOAT_FORMAT") = "9" then
								SaltIDS = SaltIDS & "|" &  RS(ValueField) & ":" & Salt_Name
							Else
								SaltIDS = SaltIDS & "," &  RS(ValueField) & ":" & Salt_Name
							End if
							'End of SYAN modification
						else
							SaltIDS = RS(ValueField) & ":" & Salt_Name
						end if
					end if
				end if
			RS.MoveNext	
			wend
		else
			while RS.EOF <> TRUE   
				if not isNull(RS("Salt_Name")) then 
					Salt_Name = Replace(Trim(RS("Salt_Name")), ",", "&comma;")  
					if bShowMF = true then
						Salt_Name = Salt_Name & "(" &   RS("SALT_MF") & ")"
					end if
					if SaltIDS <> "" then
							'SYAN modified 9/27/2004 to fix CSBR-46729
							If Application("FLOAT_FORMAT") = "9" then
								SaltIDS = SaltIDS & "|" &  RS(ValueField) & ":" & Salt_Name
							Else
								SaltIDS = SaltIDS & "," &  RS(ValueField) & ":" & Salt_Name
							End if
							'End of SYAN modification
					else
						SaltIDS = RS(ValueField) & ":" & Salt_Name
					end if
				end if
				RS.MoveNext	
			wend
		end if
		CloseRS(RS)
	else
		SaltIDS = ""
	end if
	GetSaltsListBatch=SaltIDS
End Function

Function GetProjectsList(ByRef RegConn)

	Set cmd = Server.CreateObject("adodb.command")
	Set RS = Server.CreateObject("adodb.recordset")
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	
	if CBool(Application("PROJECT_LEVEL_ROW_SECURITY")) = True then
		ProjectIDS=GetProjectsForUserList(RegConn)
	else
		sql = "Select * from Projects  order by project_name"
		cmd.CommandText = sql
		
		RS.Open Cmd
		if Not (RS.EOF and RS.BOF) then
			if NOT UCase(Request("formmode"))="SEARCH" then
				while RS.EOF <> TRUE    
					if Not CBool(RS("Active")) =false THEN
						if not isNull(RS("Project_Name")) then 
							project_name = replace(Trim(RS("Project_Name")), ",", "&comma;")
							if ProjectIDS <> "" then
								ProjectIDS = ProjectIDS & ","  & RS("Project_Internal_ID") & ":" & project_name
							else
								ProjectIDS = RS("Project_Internal_ID") & ":" & project_name
							end if
						end if
					end if
							RS.MoveNext	
				wend
			else
				while RS.EOF <> TRUE    
					if not isNull(RS("Project_Name")) then 
						project_name = replace(Trim(RS("Project_Name")), ",", "&comma;")
						if ProjectIDS <> "" then
							ProjectIDS = ProjectIDS & ","  & RS("Project_Internal_ID") & ":" & project_name
						else
							ProjectIDS = RS("Project_Internal_ID") & ":" & project_name
						end if
					end if
					RS.MoveNext	
				wend
			end if
			CloseRS(RS)
			else
				ProjectIDS=""
			end if
	end if
	GetProjectsList=ProjectIDS
End Function 

Function IsValidUserProject(dbkey, formgroup, ByRef RegConn, project_id)
	bBuildConn = false
	bInvalidNumber=false
	on error resume next 
		myNum = CLng(project_id)
		if err.number <> 0 then
		bInvalidNumber = true
		theReturn = false
		end if
	on error goto 0
	if bInvalidNumber = false then
		 if Not isObject(RegConn)  then
			Set RegConn=GetRegConn(dbkey, formgroup)
		end if

		Set cmd = Server.CreateObject("adodb.command")
		cmd.ActiveConnection = RegConn
		cmd.CommandType = adCmdText
	
	
		Set RS = Server.CreateObject("adodb.recordset")
		
		
		sql = "select project_internal_id from projects where project_internal_id=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pProject_id", 139, 1, 0, project_id) 
		RS.Open Cmd
		
		If Not (RS.EOF AND RS.BOF) then
			theReturn = true
		else
			theReturn = false
		end if
		Set RS = Nothing
		
	end if
	IsValidUserProject = theReturn
End function

Function GetBatchProjectsList(ByRef RegConn)
	
	Set cmd = Server.CreateObject("adodb.command")
	Set RS = Server.CreateObject("adodb.recordset")
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	
	'SYAN modified on 11/17/2006 to fix CSBR-72269
	if CBool(Application("PROJECT_LEVEL_ROW_SECURITY")) = True then
		ProjectIDS=GetBatchProjectsForOwnerList(RegConn)
	else
		sql = "Select * from Batch_Projects  order by project_name"
		cmd.CommandText = sql
		RS.Open Cmd
			
		if not (RS.EOF and RS.BOF)then
	
		if NOT UCase(Request("formmode"))="SEARCH" then
			while RS.EOF <> TRUE    
				if Not CBool(RS("Active")) =false THEN
					if not isNull(RS("Project_Name")) then 
						project_name = replace(Trim(RS("Project_Name")), ",", "&comma;")
						if ProjectIDS <> "" then
							ProjectIDS = ProjectIDS & ","  & RS("Batch_Project_ID") & ":" & project_name
						else
							ProjectIDS = RS("Batch_Project_ID") & ":" & project_name
						end if
					end if
				end if
						RS.MoveNext	
			wend
		else
			while RS.EOF <> TRUE  
				if not isNull(RS("Project_Name")) then   
					project_name = replace(RS("Project_Name"), ",", "&comma;")
					if ProjectIDS <> "" then
						ProjectIDS = ProjectIDS & ","  & RS("Batch_Project_ID") & ":" & project_name
					else
						ProjectIDS = RS("Batch_Project_ID") & ":" & project_name
					end if
				end if
				RS.MoveNext	
			wend
		end if
		CloseRS(RS)
		else 
			ProjectIDS =""
		end if 
	end if
	GetBatchProjectsList=ProjectIDS
End Function 

Function GetCompoundTypeList(ByRef RegConn)
	
	' RS.Open "Select * from Compound_Type", RegConn
	Set cmd = Server.CreateObject("adodb.command")
	Set RS = Server.CreateObject("adodb.recordset")
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	
	'stop
	sql = "SELECT * FROM Compound_Type  ORDER BY COMPOUND_TYPE ASC"
	cmd.CommandText = sql
	RS.Open Cmd
	
	if Not(RS.BOF and RS.EOF)then
		RS.MoveFirst  
		if NOT UCase(Request("formmode"))="SEARCH" then
			While RS.EOF <> TRUE 
				if Not CBool(RS("Active")) =FALSE THEN
					if not isNull(RS("Description")) then   
						CompoundTypeDesciption = replace(RS("Description"), "," , "&comma;")
						if CompoundTypeIDS<> "" then
							CompoundTypeIDS= CompoundTypeIDS& "," & RS("Compound_Type") & ":" & CompoundTypeDesciption
						else
							CompoundTypeIDS= RS("Compound_Type") & ":" & CompoundTypeDesciption

						end if
					end if
				end if
				RS.MoveNext	
			wend
		else
			While RS.EOF <> TRUE 
				if not isNull(RS("Description")) then   
					CompoundTypeDesciption = replace(RS("Description"), "," , "&comma;")
					if CompoundTypeIDS<> "" then
						CompoundTypeIDS= CompoundTypeIDS& "," & RS("Compound_Type") & ":" & CompoundTypeDesciption
					else
						CompoundTypeIDS= RS("Compound_Type") & ":" & CompoundTypeDesciption
					end if
				end if
				RS.MoveNext	
			wend
		end if
	end if
	CloseRS(RS)
	GetCompoundTypeList=CompoundTypeIDS
End Function


Function GetCompoundTypeListNoStruc(ByRef RegConn)
	theID = kCmpdTypeNoStrucID
	Set cmd = Server.CreateObject("adodb.command")
	Set RS = Server.CreateObject("adodb.recordset")
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	
	sql = "SELECT * FROM Compound_Type ORDER BY Description ASC"
	cmd.CommandText = sql
	RS.Open Cmd
	
	if Not(RS.BOF and RS.EOF)then
		RS.MoveFirst
		if NOT UCase(Request("formmode"))="SEARCH" then
			While RS.EOF <> TRUE 
				if Not CBool(RS("Active")) =FALSE THEN
					if not isEmpty(RS("Compound_Type")) then
						if not CLng(RS("Compound_Type"))= CLng(theID) then
							if CompoundTypeIDS<> "" then
								CompoundTypeIDS= CompoundTypeIDS& "," & RS("Compound_Type") & ":" & RS("Description")
							else
								CompoundTypeIDS= RS("Compound_Type") & ":" & RS("Description")
							end if
						end if
					end if
				end if
				RS.MoveNext	
			wend
		else
			While RS.EOF <> TRUE 
				if not isEmpty(RS("Compound_Type")) then
					if not CLng(RS("Compound_Type"))= CLng(theID) then
						if CompoundTypeIDS<> "" then
							CompoundTypeIDS= CompoundTypeIDS& "," & RS("Compound_Type") & ":" & RS("Description")
						else
							CompoundTypeIDS= RS("Compound_Type") & ":" & RS("Description")
						end if
					end if
				end if
				RS.MoveNext	
			wend
		end if
	end if
	CloseRS(CompountTypeRS)
	GetCompoundTypeListNoStruc=CompoundTypeIDS
End Function





Function GetSiteList(ByRef RegConn)
	Set cmd = Server.CreateObject("adodb.command")
	Set RS = Server.CreateObject("adodb.recordset")
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	
	sql = "Select * from Sites ORDER BY SITE_NAME ASC"
	cmd.CommandText = sql
	RS.Open Cmd
	

	
	RS.MoveFirst
	if NOT UCase(Request("formmode"))="SEARCH" then
		while RS.EOF <> TRUE   
			if Not CBool(RS("Active")) =FALSE THEN
				if RSIDS<> "" then
					RSIDS= RSIDS& "," & RS("Site_ID")  & ":" & RS("Site_Name")
				else
					RSIDS=  RS("Site_ID") & ":" & RS("Site_Name")

				end if
			end if
			RS.MoveNext	
		wend
	else
		while RS.EOF <> TRUE   
			if RSIDS<> "" then
				RSIDS= RSIDS& "," & RS("Site_ID")  & ":" & RS("Site_Name")
			else
				RSIDS=  RS("Site_ID") & ":" & RS("Site_Name")
			end if
		RS.MoveNext	
		wend
	end if

	CloseRS(RS)
	GetSiteList=RSIDS
End Function

Function GetSelectList(InputStr)
	inputstr_array = split(inputStr, ",", -1)
	for i = 0 to uBound(inputstr_array)
		
		if output_str <> "" then
			output_str = output_str & "," & inputstr_array(i)& ":" &  inputstr_array(i)
		else
			output_str = inputstr_array(i)& ":" &  inputstr_array(i)
		end if
	next
	GetSelectList = output_str
end function
		

Function GetSequenceList(ByRef RegConn)
	Set cmd = Server.CreateObject("adodb.command")
	Set RS = Server.CreateObject("adodb.recordset")
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	
    sql = "SELECT * FROM sequence  ORDER BY PREFIX ASC"

	cmd.CommandText = sql
	RS.Open Cmd
	


	if Not (RS.EOF and RS.BOF) then
		if NOT UCase(Request("formmode"))="SEARCH" then
			while RS.EOF <> TRUE    
			if not CBool(RS("Active")) = false then
				if not isNull(RS("Prefix")) then   
					Prefix = replace(RS("Prefix"), ",", "&comma;")
					if SequenceIDS <> "" then
						SequenceIDS = SequenceIDS & "," &  RS("Sequence_ID") & ":" & Prefix
					else
						SequenceIDS = RS("Sequence_ID") & ":" & Prefix
					end if
				end if
			end if
			RS.MoveNext	
			wend
		else
			while RS.EOF <> TRUE  
				if not isNull(RS("Prefix")) then   
					Prefix = replace(RS("Prefix"), ",", "&comma;")  
					if SequenceIDS <> "" then
						SequenceIDS = SequenceIDS & "," &  RS("Sequence_ID") & ":" & Prefix
					else
						SequenceIDS = RS("Sequence_ID") & ":" & Prefix
					end if
				end if
				RS.MoveNext	
			wend
		end if
		CloseRS(RS)
	else
		SequenceIDS=""
	end if
	GetSequenceList=SequenceIDS
End Function


Function DoDeleteRegMaster (dbkey, formgroup, unique_id)
	
		formgroupflag= GetFormGroupVal(dbkey, formgroup, kFormGroupFlag)
		basetable = GetBaseTable(dbkey, formgroup, "basetable")
		 if Not isObject(RegConn)  then
			set RegConn = GetRegConn(dbkey, formgroup)
		end if

		Set RS= Server.CreateObject("ADODB.Recordset")
		if UCase(basetable) = "BATCHES" then'giv compatability
			sql = "select reg_internal_id from batches where batch_internal_id=" & unique_id
			RS.Open sql, RegConn
			If not (RS.BOF and RS.EOF) then
				reg_id = RS("reg_internal_id")
			end if
			CloseRS(RS)
		else
			reg_id = unique_id
		end if
		RegConn.BeginTrans
		isOK = DoDeleteReg(dbkey, formgroup, reg_id,RegConn)
		if isOK = false then
			RegConn.RollBackTrans
			ShowErrors = True
		else
			ShowErrors = False
			RegConn.CommitTrans
		end if
		Session("delete_count")=""
		DoDeleteRegMaster=ShowErrors
	End Function

Function getBaseID(dbkey, formgroup)
	basetable = GetBaseTable(dbkey, formgroup, "basetable")
	baseid = GetTableVal(dbkey, basetable, kPrimaryKey)
	getBaseID = baseid
End Function 

Function DoDeleteReg(dbkey, formgroup, reg_id, ByRef RegConn)
	
		if Not isObject(RegConn) then
			Set RegConn= getRegConn(dbkey, formgroup)
		end if
		
		cpdDBCounter = getValueFromTablewConn(RegConn,"reg_numbers","reg_id", reg_id, "cpd_internal_id")
		if Application("Batch_Level") = "Salt" then
			strWhere = "cpd_internal_id=" & cpdDBCounter
			theCount = getTableCount("REG_NUMBERS", strWhere, getTableVal(dbkey, "REG_NUMBERS", kPrimaryKey))
			theCount = CLng(theCount)
			if theCount = 1 then
				delete_order=Application("Delete_Compound_table_order")
			else
				delete_order=Application("Delete_Salt_table_order")
			end if
		else
			delete_order=Application("Delete_Compound_table_order")
		end if
		
		delete_order_array = Split(delete_order, ",", -1)
		for j = 0 to UBound(delete_order_array)
			table_name = delete_order_array(j)
			Select Case UCase(table_name)
				Case "ALT_IDS", "BATCHES", "COMPOUND_SALT", "REG_APPROVED","REG_QUALITY_CHECKED"
					strWhere = " reg_internal_id= " & reg_id
				Case "COMPOUND_MOLECULE"
					strWhere = " cpd_database_counter= " & cpdDBCounter
				Case "COMPOUND_PROJECT"
					strWhere = " cpd_internal_id= " & cpdDBCounter
				Case "STRUCTURES"
					strWhere = " cpd_internal_id= " & cpdDBCounter
				Case "DUPLICATES"
					'SYAN modified on 10/31/2005 to fix CSBR-55879
					deleteFromDups RegConn, dbkey, formgroup, cpdDBCounter
					'Exit Function
					'End of SYAN modification
				Case "REG_NUMBERS"
					strWhere = " reg_id= " & reg_id
			End Select
			
			if table_name <> "" then
				isOK = DoCascadeDelete(RegConn, dbkey, formgroup, reg_id,  table_name, strWhere)
			end if
		next 'table
	DoDeleteReg = isOK
End Function

Sub deleteFromDups(ByRef RegConn, dbkey, formgroup, cpdDBCounter)
	'stop
	'SYAN modified on 10/31/2005 to fix CSBR55879
	if cpdDBCounter <> "" then
		Set cmd = Server.CreateObject("adodb.command")
		on error resume next
		if Not isObject(RegConn) then
			Set RegConn= getRegConn(dbkey, formgroup)
		end if
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText

		sql = "delete from duplicates where compound_id=?"

		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pcpdDBCounter", 139, 1, 0, cpdDBCounter) 
		cmd.Execute
	
		Set cmd = Server.CreateObject("adodb.command")
		cmd.ActiveConnection = RegConn
		cmd.CommandType = adCmdText

		sql = "delete from duplicates where duplicate=?"
		cmd.CommandText = sql
		cmd.Execute
	
		if err.number <> 0 then
			logaction "deleteFromDups" & err.number & err.description
		end if
	
		on error goto 0
		err.Clear()
	end if
	'End of SYAN modification
End Sub

Sub DoUpdateTempModInfo(ByVal dbkey, ByVal formgroup, ByVal tempid)
	DBMSUser_ID = Session("CurrentUser" & dbkey)
	PersonID = getValueFromTable(dbkey, formgroup, "People", "User_ID",DBMSUser_ID,"Person_ID")
	'get basetable AND moltable values from ini file for formgroup
	temp_basetable=Application(formgroup & dbkey & "RegTempBaseTable") 'in this case return temp table
	temp_baseid=GetTableVal(dbkey, temp_basetable, kPrimaryKey)
	'create data connection AND recordset object for adding data to temporary table
	 if Not isObject(RegConn)  then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	Set TempRS = Server.CreateObject("ADODB.Recordset")
		
	Set cmd = Server.CreateObject("adodb.command")
	on error resume next
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	
	'SYAN modified on 11/30/2004 to fix CSBR-49587
	sql = "SELECT Last_Mod_Date,Last_Mod_Person_ID,Commit_Type,mol_id," &_
	"BASE64_CDX,MW2,FORMULA2,Chem_Name_Autogen,batch_project_id,project_id," &_
	"Formula_Weight,cpd_internal_id,Salt_MW,Salt_Equivalents,Solvate_MW,Solvate_Equivalents," &_
	"Percent_Active, APPROVED_BY, APPROVED_DATE, APPROVED_TIME" &_
	" FROM temporary_structures where temp_compound_id=?"
	'End of SYAN modification
	
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("pTempid", 139, 1, 0, tempid) 
	
	TempRS.LockType= 3
	TempRS.CursorType=1
	TempRS.Open cmd
	TempRS("Last_Mod_Date") = Date()
	
	'SYAN modified on 11/30/2004 to fix CSBR-49587
	TempRS("APPROVED_DATE") = Date()
	TempRS("APPROVED_TIME") = Time()
	TempRS("APPROVED_BY") = PersonID
	'End of SYAN modification
	
	if not isEmpty(PersonID) then
		TempRS("Last_Mod_Person_ID") = CLng(PersonID)
		
	end if
	
	'update MW and Formula 
	
	if UCase(TempRS("Commit_Type")) = "FULL_COMMIT" then
		base64=TempRS("BASE64_CDX")
		theChemData = getMW_and_Formula(dbkey, formgroup, "temporary_structures", TempRS("mol_id"),RegConn,base64)
		theChemDataArray = Split(theChemData, ":", -1)
		theMW = theChemDataArray(0)
		if theMW = -1 or theMW = "-1" or theMW = "0" or theMW = 0  then
			theMW = null
			
			if UCase(Application("NON_CHEMICAL_SUBMIT")) = "DISALLOW" then
				TempRS("BASE64_CDX") = ""
				base64=""
			end if
		end if
		on error resume next
		if Not isNull(theMW) then
			'SYAN modified 9/27/2004 to fix CSBR-46729
			TempRS("MW2").value = CDbl(theMW)
			'End of SYAN modification
		else
			TempRS("MW2").value =NULL
			base64 =""
		end if
		err.Clear()
		TempRS("FORMULA2")= theChemDataArray(1)
		if CBool(Application("AUTOGENERATED_CHEMICAL_NAME")) = True then
			'myPath = Application("TempFileDirectory" & dbkey) & "SessionDir\" & Session.SessionID & "\temporary_structuresStructure" & ".cdx"
		
			'chem_inputstring = request("UID." & tempid & ":" & "temporary_structures.chem_name_autogen")
			TempRS("Chem_Name_Autogen") = getAutoGeneratedName(base64," for temporary_structures.temp_compound_id:" & tempid)
		end if
		if CBool(Application("PROJECTS_NAMED_OWNER")) = true then
			batch_project_id = TempRS("batch_project_id")
			project_id = getValueFromTablewConn(RegConn, "batch_projects", "batch_project_id", batch_project_id, "owner_id")
			
			if isEmpty(project_id) or isZero(project_id) then
				project_id = "1"
			end if
			
			TempRS("project_id") = project_id
		end if
	end if
	commit_type = UCase(TempRS("Commit_Type"))
	if (commit_type = "FULL_COMMIT") or (commit_type = "BATCH_COMMIT") or (commit_type = "ADD_SALT") then
			if Not UCase(commit_type) = "FULL_COMMIT" then
					cpd_internal_id = Trim(Session("SearchData" & "Temporary_Structures.CPD_Internal_ID" & dbkey & formgroup))
					'if this is batch or add_salt you need to figure out if there really is a structure
					theMW = getValueFromTablewConn(RegConn, "compound_molecule", "cpd_database_counter",TempRS("cpd_internal_id"),"MW2")
					if Not (theMW = NULL or theMW = "" or theMW = -1) then
						theMW = CDBl(theMW)
					else
						theMW = 0
					end if
			end if
			if theMW > 0 then
				FormulaWt = DoFormulaWtCalc(dbkey, formgroup,  RegConn, theMW, TempRS("cpd_internal_id"), TempRS("Salt_MW"), TempRS("Salt_Equivalents"), TempRS("Solvate_MW"), TempRS("Solvate_Equivalents"))
				if isEmpty(FormulaWt) then
					TempRS("Formula_Weight") = Null
				else
					on error resume next
					TempRS("Formula_Weight").value = CDbl(FormulaWt)
					err.Clear()
				end if
			end if
	end if
	if  Session("DERIVED_FIElDS").Exists("PERCENT_ACTIVE") then
		if theMW > 0 then
			PercentActive = DoPercentActiveCalc(dbkey, formgroup,  RegConn, theMW, TempRS("cpd_internal_id"),FormulaWt)
		end if
		if isEmpty(PercentActive) then
			TempRS("Percent_Active") = Null
		else
			'SYAN modified on 9/27/2004 to fix CSBR-46729
			TempRS("Percent_Active") = CDbl(PercentActive)
			'End of SYAN modification
		end if
	end if
	TempRS.Update
	if err.number <> 0 then
		logaction("DoUpdateTempModInfo" & err.number & err.description)
	end if 
	
	CloseRS(TempRS)
	'CloseConn(RegConn)
End Sub


Sub DoUpdateRegModInfo(ByVal dbkey, ByVal formgroup,ByVal tablename, ByVal unique_id)
	 if Not isObject(RegConn)  then
		Set RegConn= GetRegConn(dbkey, formgroup)
	end if

	Set CommitRS = Server.CreateObject("ADODB.Recordset")
	DBMSUser_ID = Session("CurrentUser" & dbkey)
	PersonID = getValueFromTablewConn(RegConn, "People", "User_ID",DBMSUser_ID,"Person_ID")
	on error resume next

	
	Select Case UCase(tablename)
		Case "BATCHES"
			'update batch table
			Set cmd = Server.CreateObject("adodb.command")
			cmd.ActiveConnection = RegConn
			cmd.CommandType = adCmdText
			sql = "Select " & "Last_Mod_Date,Last_Mod_Person_ID" & " From Batches where batch_internal_id=?"
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("pBatchIntID", 139, 1, 0, unique_id) 
			CommitRS.LockType= 3
			CommitRS.CursorType=1
			CommitRS.Open cmd
			CommitRS("Last_Mod_Date") = Date()
			if not isEmpty(PersonID) then
				CommitRS("Last_Mod_Person_ID") = CLng(PersonID)
			end if
			CommitRS.Update
			CommitRS.Close
		Case "REG_NUMBERS", "ALT_IDS"
			cpd_id = getCPDFromRegID(dbkey, formgroup, CommitRS, RegConn, unique_ID)
			if cpd_id <> "" then
				Set cmd = Server.CreateObject("adodb.command")
				cmd.ActiveConnection = RegConn
				cmd.CommandType = adCmdText
				sql = "Select Last_Mod_Date,Last_Mod_Person_ID From Compound_Molecule where cpd_database_counter=?"
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("pcpd_id", 139, 1, 0, cpd_id) 
				CommitRS.LockType= 3
				CommitRS.CursorType=1
				CommitRS.Open cmd
				CommitRS("Last_Mod_Date") = Date()
				if not isEmpty(PersonID) then
					CommitRS("Last_Mod_Person_ID") = CLng(PersonID)
				end if
				CommitRS.Update
				CommitRS.Close
			end if
		CASE "COMPOUND_MOLECULE","STRUCTURES"
			sql = "Select Last_Mod_Date,Last_Mod_Person_ID From Compound_Molecule where cpd_database_counter=?"
			Set cmd = Server.CreateObject("adodb.command")
			cmd.ActiveConnection = RegConn
			cmd.CommandType = adCmdText
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("pcpd_id", 139, 1, 0, unique_id) 
			CommitRS.LockType= 3
			CommitRS.CursorType=1
			CommitRS.Open cmd
			CommitRS("Last_Mod_Date") = Date()
			if not isEmpty(PersonID) then
				CommitRS("Last_Mod_Person_ID") = CLng(PersonID)
			end if
			CommitRS.Update
			CommitRS.Close
			
		
		CASE "CMPD_MOL_UTILIZATIONS"
			cpd_id = getCPDFromUtilId(dbkey, formgroup, CommitRS, RegConn, unique_ID)
			sql = "SELECT Last_Mod_Date,Last_Mod_Person_ID FROM Compound_Molecule where cpd_database_counter=?"
			Set cmd = Server.CreateObject("adodb.command")
			cmd.ActiveConnection =  RegConn
			cmd.CommandType = adCmdText
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("pcpd_id", 139, 1, 0, cpd_id) 
			CommitRS.LockType= 3
			CommitRS.CursorType=1
			CommitRS.Open cmd
			
			CommitRS("Last_Mod_Date") = Date()
			
			if not isEmpty(PersonID) then
				CommitRS("Last_Mod_Person_ID") = CLng(PersonID)
			end if
			CommitRS.Update
			CommitRS.Close
		
		CASE "COMPOUND_PROJECT"
			cpd_id = getCPDFromCmpdProjId(dbkey, formgroup, CommitRS, RegConn, unique_ID)
			sql = "Select Last_Mod_Date,Last_Mod_Person_ID From Compound_Molecule where cpd_database_counter=?"
			Set cmd = Server.CreateObject("adodb.command")
			cmd.ActiveConnection =  RegConn
			cmd.CommandType = adCmdText
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("pcpd_id", 139, 1, 0, cpd_id) 
			CommitRS.LockType= 3
			CommitRS.CursorType=1
			CommitRS.Open cmd
			
			CommitRS("Last_Mod_Date") = Date()
			if not isEmpty(PersonID) then
				CommitRS("Last_Mod_Person_ID") = CLng(PersonID)
			end if
			CommitRS.Update
			CommitRS.Close
		End Select
	CloseRS(CommitRS)
	'CloseConn(RegConn)
End Sub

Function getCPDFromRegID(dbkey, formgroup, ByRef CommitRS, ByRef RegConn, reg_id)
	Set cmd = Server.CreateObject("adodb.command")
	on error resume next
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	sql = "select cpd_internal_id from reg_numbers where reg_id=?"
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("preg_id", 139, 1, 0, reg_id) 
	CommitRS.Open cmd

	if Not (CommitRS.BOF and CommitRS.EOF) then
		CommitRS.MoveFirst
		cpd = CommitRS("cpd_internal_id")
		CommitRS.Close
	else
		cpd = ""
	end if
	getCPDFromRegID=cpd
End Function

Function getCPDFromCmpdProjId(dbkey, formgroup, ByRef CommitRS, ByRef RegConn, cmpd_proj_id)
	Set cmd = Server.CreateObject("adodb.command")
	on error resume next
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	
	sql = "select cpd_internal_id from compound_project where comp_project_id=?"
	
	
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("pcmpd_proj_id", 139, 1, 0, cmpd_proj_id) 
	CommitRS.Open cmd
	
	if Not (CommitRS.BOF and CommitRS.EOF) then
		CommitRS.MoveFirst
		cpd = CommitRS("cpd_internal_id")
		CommitRS.Close
	else
		cpd = ""
	end if
	getCPDFromCmpdProjId=cpd
End Function

Function getCPDFromUtilID(dbkey, formgroup, ByRef CommitRS, ByRef RegConn, util_id)
	Set cmd = Server.CreateObject("adodb.command")
	on error resume next
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	
	sql = "select cpd_internal_id from cmpd_mol_utilizations where cmpd_mol_util_id=?"
	
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("putil_id", 139, 1, 0, util_id) 
	CommitRS.Open cmd
	
	if Not (CommitRS.BOF and CommitRS.EOF)then
		CommitRS.MoveFirst
		cpd = CommitRS("cpd_internal_id")
		CommitRS.Close
	else
		cpd = ""
	end if
	getCPDFromUtilID=cpd
	
End Function

Function getCPDFromMolID(dbkey, formgroup, ByRef CommitRS, ByRef RegConn, molid)

	Set cmd = Server.CreateObject("adodb.command")
	on error resume next
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	
	sql = "select cpd_internal_id from structures where mol_id=?"
	
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("pmolid", 139, 1, 0, molid) 
	CommitRS.Open cmd
	
	
	if Not (CommitRS.BOF and CommitRS.EOF)then
		CommitRS.MoveFirst
		cpd = CommitRS("cpd_internal_id")
		CommitRS.Close
	else
		cpd = ""
	end if
	getCPDFromMolID=cpd
	
End Function

function getIdentifierType(dbkey, formgroup, ByRef CommitRS, ByRef RegConn, identifier_name)
		
		Set cmd = Server.CreateObject("adodb.command")
		on error resume next
		if Not isObject(RegConn) then
			Set RegConn= getRegConn(dbkey, formgroup)
		end if
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
	
		sql = "SELECT identifier_type from identifiers where upper(identifier_descriptor)=?"
		
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pIdentName", 200, 1, Len(identifier_name) + 1, UCase(Trim(identifier_name))) 
		CommitRS.Open cmd
	
		if not (CommitRS.EOF and CommitRS.BOF) then
			identType = CommitRS("identifier_type")
			CommitRS.Close
		else
			identType=""
		end if
		err.Clear()
		getIdentifierType = identType
end Function 
		
	
Function DoRegUpdate(ByVal dbkey, ByVal formgroup, ByVal StrucFields, ByVal thefields, ByVal tablename, ByVal uniqueid)
	'stop
	'get basetable AND moltable values from ini file for formgroup
	'create data connection AND recordset object for adding data to temporary table
	'loop through data from form groups ado searchable fields AND commit each fields data to temp table
	if UCase(tablename) = "REG_APPROVED" then 
		bApprovedCheck = true 
		
	else
		bApprovedCheck = false
	end if
		
	if UCase(tablename) = "REG_QUALITY_CHECKED" then
		bQualityCheck = true 
	else
		bQualityCheck = false
	end if
	
	fields_array = Split(thefields, ",", -1)
	 if Not isObject(RegConn)  then
		Set RegConn= GetRegConn(dbkey, formgroup)
	end if

	Set CommitRS = Server.CreateObject("ADODB.Recordset")
		CommitRS.LockType= 3
		CommitRS.CursorType=1
		
	on error resume next
	
	if RegConn.State=0 then ' assume user has been logged out
		DoLoggedOutMsg()
	end if
	for j = 0 to UBound(fields_array)
		on error resume next
		fullfieldname = fields_array(j)
		Dim bAddNewAlt
		bAddNewAlt = false
			
		if InStr(fullfieldname, "UID")> 0 then
			test ="UID." & uniqueid & ":" &  UCase(tablename)& "."
			temp_name = split(fullfieldname, ".", -1)
			fieldname = temp_name(2)'format is UID.unqi:tablename.fieldname
		else
			if Instr(fullfieldname, "NEW.")> 0 AND UCase(tablename) = "ALT_IDS" then
				
				test = UCase(tablename)& "."
				temp_name = split(fullfieldname, ".", -1)
				fieldname = temp_name(2)'format is NEW.link_field_uniqueID|identifier_type:tablename.fieldname
				identifierType = getIdentifierType(dbkey, formgroup, CommitRS, RegConn, fieldname)
				
				
				if identifierType <> "" then
					bAddNewAlt = true
				else
					fieldname = "bypass"
				end if

					
				
			else
				test = UCase(tablename)& "."
				temp = split(fullfieldname, ":", -1)
				temp_new = split(temp(1), ".", -1)
				fieldname = temp_new(1)
			end if
		end if
		
		
		if InStr(Ucase(fullfieldname), UCase(test))> 0 then
			if bAddNewAlt = true then
				temp = Split(fullfieldname, ":", -1)
				temp2 = Split(temp(0), ".", -1)
				reg_id = temp2(1)
				newVal = Request.Form(fullfieldname)
				DateTime_Stamp = Time() &  ":" &  Date()
				
				'SYAN added 11/16/2004 to fix CSBR-49382
				Set cmd = Server.CreateObject("adodb.command")
				on error resume next
				cmd.ActiveConnection =  RegConn
				cmd.CommandType = adCmdText
				sql = "Select IDENTIFIER_TYPE From " & tablename  &   " where reg_internal_id = ? and identifier_type=?"
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("pReg_Id", 139, 1, 0, reg_id) 
				cmd.Parameters.Append cmd.CreateParameter("pIdentifierType", 139, 1, 0, identifierType) 
				Set existanceRS = Server.CreateObject("ADODB.Recordset")
				existanceRS.Open cmd

				if (existanceRS.BOF AND existanceRS.EOF) then

					Set cmd = Server.CreateObject("adodb.command")
					on error resume next
					cmd.ActiveConnection =  RegConn
					cmd.CommandType = adCmdText
				
					sql = "Insert into ALT_IDS(reg_internal_id,identifier,identifier_type,datetime_stamp)values(?,'" & replace(newval, "'", "''") & "','" & identifierType & "','" & DateTime_Stamp & "')"

					cmd.CommandText = sql
					cmd.Parameters.Append cmd.CreateParameter("pReg_Id", 139, 1, 0, reg_id) 
		
				
					cmd.Execute
				end if
				existanceRS.Close
				Set existanceRS = nothing
				'End of SYAN modification
				
			else
				
				if Not bApprovedCheck = True AND Not bQualityCheck = True AND Not bAddUtilizations then
					'newVal = ""
					'currentVal = ""
					'sql = ""
					table_unique_id = GetTableVal(dbkey, tablename, kPrimaryKey)
					datatype =getDataType(dbkey,  formgroup,  tablename & "." & table_unique_id)
					delimiter = GetFieldDelimiter(datatype)
					
					newVal = Request.Form(fullfieldname)
					
					if UCase(tablename) = "ALT_IDS" and Trim(newVal) = "" then
						Set cmd = Server.CreateObject("adodb.command")
						on error resume next
						cmd.ActiveConnection =  RegConn
						cmd.CommandType = adCmdText
						
						sql = "DELETE FROM  ALT_IDS WHERE id=?"
						cmd.CommandText = sql
						cmd.Parameters.Append cmd.CreateParameter("pID", 139, 1, 0, uniqueid) 
						cmd.Execute
						
					else ' UCase(table_name) = "ALT_IDS" and Trim(newVal) = "" then
						'on error resume next
						'see if data has changed for each submitted field, then update
					
						Set cmd = Server.CreateObject("adodb.command")
						on error resume next
						cmd.ActiveConnection =  RegConn
						cmd.CommandType = adCmdText
						sql = "Select " & fieldname & " From " & tablename  &   " where " & table_unique_id & "=?"
						cmd.CommandText = sql
						cmd.Parameters.Append cmd.CreateParameter("pUniqueID", 139, 1, 0, uniqueid) 
						CommitRS.Open cmd
					
							if not (CommitRS.BOF AND CommitRS.EOF) then
								CommitRS.MoveFirst
								currentValue =CommitRS(fieldname).Value
								CheckForADOErrors dbkey, RegConn, "Update Record Error"& "\n\n" & "Table Name: " & tablename & "\n\n" &  "Field Name: " & fieldname &  "\n\n" &"Update Value: " & Request.Form(fullfieldname) & "\n\n" & "Provider Error", "log"
								if Not isEmpty(currentValue) then
									currentValue = CStr(currentValue)
								else
									currentValue = ""
								end if
								
										
								'stop
								bUpdate = false
								if isEmpty(currentValue) then
									bUpdate = true
								Else
									if Not (currentValue = newVal) then
										bUpdate = true
									end if
								end if

								if bUpdate = true then
									if newVal = "" then newVal = null
									'SYAN modified on 9/27/2004 to fix CSBR-46729
									if (CommitRS.Fields(fieldname).Type = 5 or CommitRS.Fields(fieldname).Type = 139) then 'adDouble or adVarNumeric
										CommitRS(fieldname).Value = CDbl(newVal)
									Else
										'stop
										'SYAN added on 1/16/2006 to fix CSBR-63274
										if bUpdate = true and (UCase(fieldname) = "BASE64_CDX") and (newVal <> "VmpDRDAxMDAEAwIBAAAAAAAAAAAAAAAAAAAAAAMAEAAAAENoZW1EcmF3IDYuMC4xCAAMAAAAbXl0ZXN0LmNkeAADMgAIAP///////wAAAAAAAP//AAAAAP////8AAAAA//8AAAAA/////wAAAAD/////AAD//wEJCAAAAFkAAAAEAAIJCAAAAKcCAAAXAgIIEAAAAAAAAAAAAAAAAAAAAAAAAwgEAAAAeAAECAIAeAAFCAQAAJoVAAYIBAAAAAQABwgEAAAAAQAICAQAAAACAAkIBAAAswIACggIAAMAYAC0AAMACwgIAAQAAADwAAMADQgAAAAIeAAAAwAAAAEAAQAAAAAACwARAAAAAAALABEDZQf4BSgAAgAAAAEAAQAAAAAACwARAAEAZABkAAAAAQABAQEABwABJw8AAQABAAAAAAAAAAAAAAAAAAIAGQGQAAAAAAJAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAEAhAAAAD+/wAA/v8AAAIAAAACAAABJAAAAAIAAwDkBAUAQXJpYWwEAOQEDwBUaW1lcyBOZXcgUm9tYW4BgAEAAAAEAhAAAAD+/wAA/v8AAAIAAAACAA8IAgABABAIAgABABYIBAAAACQAGAgEAAAAJAAAAAAA") then 'only look for duplicates if there is for sure a structure
											duplicates_found = checkForPermDuplicates(dbkey, formgroup, uniqueid, newVal, RegConn)
											if duplicates_found <> "" and duplicates_found <> uniqueid then 
												'SYAN modified on 9/14/2007 to fix CSBR-72137
												Session("DuplicatesFound" & dbkey) = duplicates_found
												'getDuplicateActionPerm  dbkey, formgroup					
												
												'Session("errors_found" & dbkey & formgroup) = "Duplicate found in the system. The structure is not updated."
												Session("errors_found" & dbkey & formgroup) = "Warning: Duplicate found in the system. Duplicate information is updated."
												'PopulateDuplicatesTable uniqueid, duplicates_found

												duplicates_found = ""
												'End of SYAN modification
											end if
										else
											duplicates_found = "" 
										end if

										if Len(duplicates_found) > 0 then 
											
										else
											CommitRS(fieldname).Value = newVal
										end if
										'End of SYAN modificaiton
									end if
									'End of SYAN modification

									CommitRS.Update

									'SYAN modified on 9/14/2007 to fix CSBR-72137
									if Session("DuplicatesFound" & dbkey)<> "" then
										'stop
										populateDuplicateEntry dbkey, formgroup, RegConn, Session("DuplicatesFound" & dbkey) , uniqueid
										Session("DuplicatesFound" & dbkey)  = ""
									end if
									'End of SYAN modification

									CommitRS.Close
									
									'SYAN added on 1/16/2006 to fix CSBR-63274
									if InStr(UCase(Session("errors_found" & dbkey & formgroup)), "DUPLICATE FOUND") <=0 then
										CheckForADOErrors dbkey, RegConn, "DoUpdateRecord Update Field error" & fieldname & newVal & tablename, "log"
									end if
									'End of SYAN modificaiton
								else
									CommitRS.Close
								end if
							end if
					end if ' UCase(table_name) = "ALT_IDS" and Trim(newVal) = "" then

				else 'if Not bApprovedCheck = True AND Not bQualityCheck = True AND Not bAddUtilizations then
					if bApprovedCheck = true then
						doApprovedCheck fullfieldname, tablename,uniqueid
					end if
					if bQualityCheck = true then
						doQualityCheck fullfieldname, tablename,uniqueid
					end if
					
				end if'if Not bApprovedCheck = True AND Not bQualityCheck = True AND Not bAddUtilizations then
			end if 'if bAddNewAlt = true then
		end if 'if InStr(Ucase(fullfieldname), UCase(test))> 0 then
	Next 'field
	bStrucUpdate = false
	'update structures
	'SYAN modified on 1/18/2006 to fix CSBR-63274
	if StrucFields <> "" then
		bStrucUpdate = true
		if InStr(UCase(Session("errors_found" & dbkey & formgroup)), "DUPLICATE FOUND") <= 0 then
			isOK = DoCartridgeUpdateStructure(dbkey, formgroup, StrucFields,tablename, uniqueid,RegConn,"") 
		else 
			isOK = false
		end if 
	end if
	'End of SYAN modification
	
	'update mw and formula and formula weight if structure has been editted. update formula weight if salt or solvate field are editted
	
	if bStrucUpdate = true or instr(thefields, "SALT")>0 or instr(thefields, "SOLVATE")>0 then
		'update MW and Formula 
		err.Clear()
		Set cmd = Server.CreateObject("adodb.command")
		on error resume next
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		sql = "Select BASE64_CDX,MOL_ID From structures where cpd_internal_id=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pUniqueID", 139, 1, 0, uniqueid) 
		CommitRS.Open cmd
		
		
		
		if not (CommitRS.EOF and CommitRS.BOF) then
			mol_id=CommitRS("MOL_ID")
			base64=CommitRS("base64_cdx")
			mypath = Application("TempFileDirectory" & dbkey) & "SessionDir\" & Session.SessionID & "\compound_moleculeStructure" & ".cdx"
			chemdata=getMW_and_Formula(dbkey, formgroup, "structures", mol_id,RegConn,base64 )
			chemdata_array = split(chemdata, ":", -1)
			theMW= chemdata_array(0)
			
			if theMW = "0" or theMW=-1 or theMW = "-1" or theMW = 0 then
				theMW = 0
				if UCase(Application("NON_CHEMICAL_SUBMIT")) = "DISALLOW" then
					CommitRS("BASE64_CDX") = " "
					base64=""
				end if
				CommitRS.Update
			end if
			CommitRS.Close
		end if
		if bStrucUpdate = true then 'update mw and formula
			Set cmd = Server.CreateObject("adodb.command")
			on error resume next
			cmd.ActiveConnection =  RegConn
			cmd.CommandType = adCmdText
			sql = "Select MW2,FORMULA2 from compound_molecule where cpd_database_counter=?"
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("pUniqueID", 139, 1, 0, uniqueid) 
			CommitRS.Open cmd
		
			on error resume next
			
			if theMW = 0 or isNull(theMW) then
				CommitRS("MW2").value =null
				base64=""
			else
				on error resume next
				'SYAN modified 9/27/2004 to fix CSBR-46729
				CommitRS("MW2").value = CDbl(theMW)	
				'End of SYAN modification				
				err.clear()
			end if
			CommitRS("FORMULA2")= chemdata_array(1)
			
			CommitRS.Update
			CommitRS.Close
			if CBool(Application("AUTOGENERATED_CHEMICAL_NAME")) = True then
				Set cmd = Server.CreateObject("adodb.command")
				on error resume next
				cmd.ActiveConnection =  RegConn
				cmd.CommandType = adCmdText
				cdx_name = tablename & fieldname & "_" & uniqueid & ".cdx"
				
				regid=request("reg_id")
				myPath = Application("TempFileDirectory" & dbkey)   & cdx_name	
				sql = "select identifier,ID from alt_ids where identifier_type=6 and reg_internal_id =?"
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("pRegID", 139, 1, 0,regid)
				CommitRS.Open cmd
				
				
				autogen_name = getAutoGeneratedName(base64, " for reg_numbers.reg_id:" & regid)
				if NOT (CommitRS.eof and CommitRS.bof) then
				
					'chem_input_string = request("UID." & CommitRS("id") & ":" & "alt_ids.identifier")
					CommitRS("Identifier") = autogen_name
					CommitRS.Update
					CommitRS.Close
				else
					if autogen_name <> "" then
						'THERE CURRENTLY IS NO CHEMNAME_AUTOGEN IDENTIFIER SO YOU NEED TO ADD IT.
						Set cmd = Server.CreateObject("adodb.command")
						on error resume next
						cmd.ActiveConnection =  RegConn
						cmd.CommandType = adCmdText
						sql = "insert into alt_ids (identifier_type, reg_internal_id, identifier)values('6', ?, ?)"
						cmd.CommandText = sql
						cmd.Parameters.Append cmd.CreateParameter("pRegID", 139, 1, 0, request("reg_id")) 
						cmd.Parameters.Append cmd.CreateParameter("pidentifier", 200, 1, Len(autogen_name) + 1, autogen_name) 
						cmd.execute
					end if
				end if
			end if
			
			
			
		end if
		'stop
		'in all cases for this if update the formula wt
		Set cmd = Server.CreateObject("adodb.command")
		on error resume next
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		sql = "select SALT_NAME, SOLVATE_NAME, SALT_INTERNAL_ID, SOLVATE_ID,PERCENT_ACTIVE,FORMULA_WEIGHT,SALT_MW, SALT_EQUIVALENTS, SOLVATE_MW, SOLVATE_EQUIVALENTS from batches where cpd_internal_id =?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pUniqueid", 139, 1, 0, uniqueid) 
		CommitRS.Open cmd
		
		
		if not (CommitRS.BOF and CommitRS.EOF) then
			CommitRS.MoveFirst
			Do While Not CommitRS.EOF
					SaltMW = CommitRS("Salt_MW")
					
					SaltEquiv = CommitRS("Salt_Equivalents")
					SolvateMW = CommitRS("Solvate_MW")
					SolvateEquiv =  CommitRS("Solvate_Equivalents")
					FormulaWt = DoFormulaWtCalc(dbkey, formgroup,  RegConn, theMW, uniqueid, SaltMW,SaltEquiv , SolvateMW, SolvateEquiv)
					'DGB Ensure solvate id is properly populated
				    solvateName = CommitRS("SOLVATE_NAME").value
				    CommitRS("Solvate_ID").value = GetSolvateCodeFromSolvateName(solvateName)
					'DGB Ensure salt id is properly populated
				    saltName = CommitRS("SALT_NAME").value
				    CommitRS("Salt_internal_ID").value = GetSaltCodeFromSaltName(saltName)
					if isEmpty(FormulaWt) then
						
						CommitRS("Formula_Weight") = Null
					else
						on error resume next
						CommitRS("Formula_Weight").value = Cdbl(FormulaWt)
						err.Clear()
					end if
					'FormulaWt = ""
				
				if  Session("DERIVED_FIElDS").Exists("PERCENT_ACTIVE") then
					
					PercentActive = DoPercentActiveCalc(dbkey, formgroup,  RegConn, theMW, uniqueid,FormulaWt)
					
					if isEmpty(PercentActive) then
						CommitRS("Percent_Active") = Null
					else
						'SYAN modified on 9/27/2004 to fix CSBR-46729
						CommitRS("Percent_Active") = CDbl(PercentActive)
						'End of SYAN modification						
					end if
				end if
				
				CommitRS.Update
				
				CommitRS.MoveNext
			Loop
			
			CommitRS.Close
			'DGB also update the batch formula
			UpdateBatchFormula RegConn, uniqueid
		end if
		
	end if
	
	
	CloseRS(CommitRS)
	'CloseConn(RegConn)
			
	if err.number > 0 OR  Session("errors_found" & dbkey & formgroup)<> "" then
		success = false
	else
		success = true
	end if

	DoRegUpdate= success
End Function



Sub doQualityCheck(fullfieldname, tablename, uniqueid)
	on error resume next
	
	if Not isObject(RegConn)  then
		set RegConn=GetRegConn(dbkey, formgroup)
	end if
	theVal = request(fullfieldname)
	temp=split(theVal, ":", -1)
	flag = temp(0)
	reg_id=temp(1) 
	batchid=uniqueid
	if UCase(Application("QUALITY_CHECKED_SCOPE")) = "BATCH" then
		Select Case UCase(flag)
			Case "SET"
				Set cmd = Server.CreateObject("adodb.command")
				cmd.ActiveConnection =  RegConn
				cmd.CommandType = adCmdText
				
				sql = "Insert into REG_Quality_Checked(reg_internal_id,batch_internal_id,quality_checked)values(?,'" & batchid & "','1'" & ")"
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("preg_id", 139, 1, 0, reg_id) 
				cmd.execute
				
				
			Case "TOGGLE"
				Set cmd = Server.CreateObject("adodb.command")
				cmd.ActiveConnection =  RegConn
				cmd.CommandType = adCmdText
				sql = "DELETE from Reg_Quality_Checked WHERE REG_INTERNAL_ID =? AND Batch_Internal_id=?"
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("pbatch_id", 139, 1, 0, batchid) 
				cmd.Parameters.Append cmd.CreateParameter("preg_id", 139, 1, 0, reg_id) 
				cmd.execute
				
		end Select
	else
		Select Case UCase(flag)
			Case "SET"
				Set cmd = Server.CreateObject("adodb.command")
				cmd.ActiveConnection =  RegConn
				cmd.CommandType = adCmdText
				sql = "Insert into REG_Quality_Checked(reg_internal_id,quality_checked)values(?,'1'" & ")"
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("preg_id", 139, 1, 0, reg_id) 
				cmd.execute
				Case "TOGGLE"
				Set cmd = Server.CreateObject("adodb.command")
				cmd.ActiveConnection =  RegConn
				cmd.CommandType = adCmdText
				sql = "DELETE from Reg_Quality_Checked WHERE REG_INTERNAL_ID =? AND Batch_Internal_id IS NULL"
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("preg_id", 139, 1, 0, reg_id) 
				cmd.execute
		end Select

	end if
	if err.number <> 0 then
		logaction("doQualityCheck" & err.number & err.Description)
	end if
	'CloseConn(RegConn)
End Sub


Sub doApprovedCheck(fullfieldname, tablename, uniqueid)
	
	'on error resume next
	
	 if Not isObject(RegConn)  then
		Set RegConn= GetRegConn(dbkey, formgroup)
	end if

	
	theVal = request(fullfieldname)
	temp=split(theVal, ":", -1)
	flag = temp(0)
	reg_id=temp(1) 
	batchid=uniqueid
	if UCase(Application("APPROVED_SCOPE")) = "BATCH" then
		Select Case UCase(flag)
			Case "SET"
				Set cmd = Server.CreateObject("adodb.command")
				cmd.ActiveConnection =  RegConn
				cmd.CommandType = adCmdText
				sql = "Insert into REG_APPROVED(reg_internal_id,batch_internal_id,approved)values(?,'" & batchid & "','1'" & ")"
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("preg_id", 139, 1, 0, reg_id) 
				cmd.execute
				
			Case "TOGGLE"
				Set cmd = Server.CreateObject("adodb.command")
				cmd.ActiveConnection =  RegConn
				cmd.CommandType = adCmdText
				sql = "DELETE from REG_APPROVED WHERE REG_INTERNAL_ID = ? AND Batch_Internal_id= ?"
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("preg_id", 139, 1, 0, reg_id)
				cmd.Parameters.Append cmd.CreateParameter("pbatch_id", 139, 1, 0, batchid) 
				cmd.execute
		end Select
	else
		Select Case UCase(flag)
			Case "SET"
				Set cmd = Server.CreateObject("adodb.command")
				cmd.ActiveConnection =  RegConn
				cmd.CommandType = adCmdText
				sql = "Insert into REG_APPROVED(reg_internal_id,approved)values(?,'1'" & ")"
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("preg_id", 139, 1, 0, reg_id) 
				cmd.execute
			Case "TOGGLE"
				Set cmd = Server.CreateObject("adodb.command")
				cmd.ActiveConnection =  RegConn
				cmd.CommandType = adCmdText
				sql = "DELETE from REG_APPROVED WHERE REG_INTERNAL_ID = ? AND Batch_Internal_id IS NULL"
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("preg_id", 139, 1, 0, reg_id) 
				cmd.execute
		end Select
	end if
	'CloseConn(RegConn)
End Sub


function GetChemData(base64)
	myPath = Application("TempFileDirectory" & dbkey) & "SessionDir\" & Session.SessionID & "\chemdata.cdx"
	DecodeBase64 base64, myPath
	Set StrucObj = CreateObject("ChemFinder.Molecule")
	StrucObj.Read myPath	
	MW= StrucObj.MolWeight
	Formula= StrucObj.Formula
	StrucObj=""
	GetChemData = MW & ":" & Formula
end function


Sub CommitFromHTTPRequest(dbkey, formgroup,tablename, ByRef CommitRS,ByRef RegConn)
	dim relfields
	relfields = Session("SearchData" & "Relational" & dbkey & formgroup)
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	
	temp_array = split(relfields, ",", -1)
	for i=0 to UBound(temp_array)
			temp_array2 = split(temp_array(i), ";", -1)
			tempfieldname_array= split(temp_array2(0), ".", -1)
			tempfieldvalue = Trim(Session("SearchData" & temp_array2(0) & dbkey & formgroup))
			on error resume next
			real_full_fieldname = GetFieldCorr(dbkey, formgroup, "OtherField", temp_array2(0))	
			if err.number = 9 then 
				err.clear()	
			end if
			if real_full_fieldname <> "" then
				temp = Split(real_full_fieldname, ".", -1)
				realtablename = temp(0)
				realfieldname = temp(1)
				If UCase(realtablename) = UCase(tablename) then
					CommitRS(realfieldname).value = trim(tempfieldvalue)
					IF CBool(Application("Notebook_Lookup")) = True then
						if realfieldname="Notebook_Internal_ID" then
							Notebook_Number = tempfieldvalue
							User_Code = getValueFromTablewConn(RegConn, "notebooks", "notebook_number",Notebook_Number,"user_code")
							CommitRS("Scientist_ID") = User_Code
						end if
					end if
					'SYAN modified to fix Ben Bracke's salt loading problem
					if UCase(realfieldname) = "SALT_INTERNAL_ID" then
						if Session("SearchData" & "Temporary_Structures.Salt_Name" & dbkey & formgroup) <> "" then
							SaltName = Session("SearchData" & "Temporary_Structures.Salt_Name" & dbkey & formgroup)
							Salt_Code = GetSaltCodeFromSaltName(saltName)
						end if
	
						if Salt_Code = "" then
							Salt_Code = getValueFromTemp(dbkey, formgroup, "Salt_Code", TempTableID)
						end if
						
						CommitRS("SALT_INTERNAL_ID") = SALT_CODE
					end if
					'End of SYAN modification

					'don't continue the commit if there is an error. The transaction should be rolled back and the compound committed to the temp table.
					if err.number <> 0 then
						err_number = err.number
						err_description = err.description
						if instr(err.description, "mismatch") >0 then
							logaction(real_full_fieldname & ":" & err.number & err.Description)
							err.Raise err_number,,err_description & ":" & real_full_fieldname & " invalid type of data"
						else
							if instr(err.Description, "precision") > 0 then
								logaction(real_full_fieldname & ":" & err.number & err.Description  & " precision of data is invalid")
								err.Raise err_number,,err_description & ":" & real_full_fieldname & " precision of data is invalid"
							else
								logaction(real_full_fieldname & ":" & err.number & err.Description)
								err.Raise err_number,,err_description & ":" & real_full_fieldname
							end if
						end if
						exit sub
					end if
				end if
			end if
	next
End Sub



Sub CommitFromTempTableRS(dbkey,formgroup,tablename,ByRef CommitRS, byRef RegConn, byRef TempRS)
	on error resume next
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if

	temp_table="temporary_structures"
	TempRS.MoveFirst					
	for each Tempfield in TempRS.Fields
		tempfieldname = Tempfield.Name
		tempfieldvalue = Tempfield.Value
		tempfieldname_full = temp_table & "." & tempfieldname
		real_full_fieldname = GetFieldCorr(dbkey, formgroup, "OtherField", tempfieldname_full)		
		if real_full_fieldname <> "" then
			temp = Split(real_full_fieldname, ".", -1)
			realtablename = temp(0)
			realfieldname = temp(1)
			If UCase(realtablename) = UCase(tablename) then
				CommitRS(realfieldname) = tempfieldvalue
				if err.number <> 0 then
					logAction("error at " & real_full_fieldname)
				end if
			end if
		end if
	next 'next field in temp table
End Sub



Function doManualRollbackCompd(dbkey, formgroup, ByRef RegConn, cpdDBCounter)
	Set cmd = Server.CreateObject("adodb.command")
	 if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	on error resume next
	
	sql = "delete from structures where cpd_internal_id =?"
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("pCpd", 139, 1, 0, cpdDBCounter)
	cmd.execute
	
	
	Set cmd = Server.CreateObject("adodb.command")
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
				
	sql = "delete from compound_molecule where cpd_database_counter=?"
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("pCpd", 139, 1, 0, cpdDBCounter)
	cmd.execute

	
	doManualRollbackCompd = err.number
End Function


Function DoManualRollbackRegNum(dbkey, formgroup, ByRef RegConn, cpdDBCounter, cpd_reg_id)
	on error resume next
	Set cmd = Server.CreateObject("adodb.command")
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	
	sql = "delete from reg_numbers where cpd_internal_id =?"	
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("pCpd", 139, 1, 0, cpdDBCounter)
	cmd.execute

	DoManualRollbackRegNum= err.number 
End Function


Function DoManualRollbackSequence(dbkey, formgroup, ByRef RegConn, roll_back_num, sequence_ID)
	on error resume next
	Set cmd = Server.CreateObject("adodb.command")
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	
	sql = "UPDATE sequence SET NEXT_IN_SEQUENCE=" & roll_back_num & " where sequence_id=?"
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("pSeqID", 139, 1, 0, sequence_ID)
	cmd.execute
	DoManualRollbackSequence= err.number 
End Function

Function doApproveAll(dbkey, formgroup,theIDS)

	'stop
	
	Session("DateTime_Stamp") = Time() &  ":" &  Date()

	'check that record is within the scope of the current login user
	
		storeScriptTimeout= server.ScriptTimeout
		server.ScriptTimeout = 10000000
		'code for committing something from the temp table. the first part is the standard cows search
		'returns the reg_number and the type of commit
		'theIDS = GetIDFromRS(dbkey, formgroup, "Base_RS")
		Dim TempIDs, my_array, thecounter, total_count
		my_array = Split(theIDS, ",", -1)
		thecounter = 0
		basetable = GetBaseTable(dbkey, formgroup, "basetable")
		 if Not isObject(RegConn)  then
			Set RegConn= GetRegConn(dbkey, formgroup)
		end if

		Set RS = Server.CreateObject("ADODB.Recordset")
		Set RS2 = Server.CreateObject("ADODB.Recordset")
	
		
		total_count = UBound(my_array) + 1
		Session("count")= UBound(my_array)
		'start commit loop
			If CBool(Application("USE_ANIMATED_GIF"))=true then
				FlushImageToClient(Application("ANIMATED_GIF_PATH"))
			else
				FlushMessageToClient("Approving...")
			end if
			if not detectNS4() = true then
				InitializeProgressBar false,Session("CurrentLocation" & dbkey & formgroup)
			end if
			for thecounter = 0 to CLng(Session("count"))
			
				'on error resume next
				dateTime_stamp = Session("DateTime_Stamp")
				working_reg_id = my_array(thecounter)
				Session("current_display_num") = CInt(thecounter + 1)
				on error resume next
				if UCase(basetable) = "BATCHES" then 'base_ids are batch_internal_ids 'provide giv compatability
						'there is no Application("APPROVED_SCOPE") here as it is always Batch. This code is for Giv compatablity and is unlikely to be used elsewhere
						working_batch_id = working_reg_id 'in this case the batches table is the base and batach_internal_id is the baseid
						sql = "Select reg_internal_id from batches where batch_internal_id=?"
						set cmd = server.CreateObject("adodb.command")
						cmd.ActiveConnection =  RegConn
						cmd.CommandType = adCmdText
						cmd.CommandText = sql
						cmd.Parameters.Append cmd.CreateParameter("pBatchID", 139, 1, 0, working_batch_id)
						RS.Open cmd
						reg_id = RS("reg_internal_id")
						RS.close
						
						set cmd = server.CreateObject("adodb.command")
						cmd.ActiveConnection =  RegConn
						cmd.CommandType = adCmdText
						sql = "Select * from reg_approved where batch_internal_id =? AND reg_internal_id =?"
						cmd.CommandText = sql
						cmd.Parameters.Append cmd.CreateParameter("pBatchID", 139, 1, 0, working_batch_id)
						cmd.Parameters.Append cmd.CreateParameter("pRegID", 139, 1, 0, reg_id)
						RS.Open cmd
					
						
						Thesessionid = Session("DateTime_Stamp")
						If (RS.EOF and RS.BOF) then ' if not already approved then go ahead and approved
							sql = "Insert into REG_APPROVED(reg_internal_id,batch_internal_id,approved,DATETIME_STAMP)values(?,?,'1',?)"
							set cmd2 = server.CreateObject("adodb.command")
							cmd2.ActiveConnection =  RegConn
							cmd2.CommandType = adCmdText
							cmd2.CommandText = sql
							cmd2.Parameters.Append cmd2.CreateParameter("pRegID", 139, 1, 0, reg_id)
							cmd2.Parameters.Append cmd2.CreateParameter("pBatchID", 139, 1, 0, working_batch_id)
							cmd2.Parameters.Append cmd2.CreateParameter("pSessionID", 200, 1, Len(Thesessionid)+1, Thesessionid)
							cmd2.Execute
							
						end if
						RS.Close
						if err.number <> "" then
							errors_occured = errors_occured & "," & Session("current_display_num")	
						end if		
				else 'basetable is reg_numbers and base_ids are reg_ids
					if UCase(Application("APPROVED_SCOPE")) = "COMPOUND" then
						set cmd = server.CreateObject("adodb.command")
						cmd.ActiveConnection =  RegConn
						cmd.CommandType = adCmdText
						sql = "Select reg_internal_id from reg_approved where reg_internal_id =?"
						cmd.CommandText = sql
						cmd.Parameters.Append cmd.CreateParameter("pRegID", 139, 1, 0, working_reg_id)
						RS.Open cmd
					
						
						If (RS.EOF and RS.BOF) then ' if not already approved then go ahead and approved
							sql = "Insert into REG_APPROVED(reg_internal_id,approved,DATETIME_STAMP)values(?,'1',?)"
							set cmd2 = server.CreateObject("adodb.command")
							cmd2.ActiveConnection =  RegConn
							cmd2.CommandType = adCmdText
							cmd2.CommandText = sql
							cmd2.Parameters.Append cmd2.CreateParameter("pRegID", 139, 1, 0, working_reg_id)
							cmd2.Parameters.Append cmd2.CreateParameter("pSessionID",200, 1, Len(dateTime_stamp)+ 1, dateTime_stamp)
							cmd2.Execute
						
						end if
						RS.Close
						if err.number <> "" then
							errors_occured = errors_occured & "," & Session("current_display_num")	
						end if		
						
					else 'scope is batch
						
						sql = "Select batch_internal_id from batches where reg_internal_id=?"
						set cmd = server.CreateObject("adodb.command")
						cmd.ActiveConnection =  RegConn
						cmd.CommandType = adCmdText
						cmd.CommandText = sql
						cmd.Parameters.Append cmd.CreateParameter("pRegID", 139, 1, 0, working_reg_id)
						RS.Open cmd
					
						RS.MoveFirst
						Do While Not RS.EOF
							batchid = RS("batch_internal_id")
							sql = "Select * from reg_approved where batch_internal_id =? AND reg_internal_id =?"
							set cmd = server.CreateObject("adodb.command")
							cmd.ActiveConnection =  RegConn
							cmd.CommandType = adCmdText
							cmd.CommandText = sql
							cmd.Parameters.Append cmd.CreateParameter("pbatchId", 139, 1, 0, batchId)
							cmd.Parameters.Append cmd.CreateParameter("pRegId", 139, 1, 0, working_reg_id)
							RS2.Open cmd
							
							
							If (RS2.EOF and RS2.BOF) then ' if not already approved then go ahead and approved
								sql = "Insert into REG_APPROVED(reg_internal_id,batch_internal_id,approved,DATETIME_STAMP)values(?,?,'1',?)"
								set cmd2 = server.CreateObject("adodb.command")
								cmd2.ActiveConnection =  RegConn
								cmd2.CommandType = adCmdText
								cmd2.CommandText = sql
								cmd2.Parameters.Append cmd2.CreateParameter("pRegId", 139, 1, 0, working_reg_id)
								cmd2.Parameters.Append cmd2.CreateParameter("pbatchId", 139, 1, 0, batchId)
								cmd2.Parameters.Append cmd2.CreateParameter("pSessionID",200, 1, Len(dateTime_stamp)+ 1, dateTime_stamp)
								cmd2.Execute
								
							end if
							RS2.Close
							'SYAN added on 5/17/2005 to fix CSBR-52678
							RS.MoveNext
							'End SYAN modification
						loop
						RS.Close
						if err.number <> "" then
							errors_occured = errors_occured & "," & Session("current_display_num")	
						end if		
					end if
				end if
			if not detectNS4() = true then
				Progressbar thecounter + 1, total_count, 1
			end if
		next
		
		CloseRS(RS)
		'CloseConn(RegConn)
		server.ScriptTimeout = storeScriptTimeout
		doApproveAll = thecounter & " records approved."
end Function

'SYAN added on 12/8/2004 to fix CSBR-49587
Function doPreRegisterApprove(dbkey, formgroup, theIDs)
	Session("DateTime_Stamp") = Time() &  ":" &  Date()

	Dim idArray, i, theCount
	idArray = Split(theIDs, ",", -1)
	
	if Not isObject(RegConn) then
		set RegConn= getRegConn(dbkey, formgroup)
	end if

	DBMSUser_ID = Session("CurrentUser" & dbkey)
	PersonID = getValueFromTablewConn(RegConn, "People", "User_ID", UCase(DBMSUser_ID), "Person_ID")

	set cmd = server.CreateObject("adodb.command")
	
	theCount = UBound(idArray) + 1
	
	for i = 0 to Ubound(idArray)
	
		RegConn.BeginTrans
		
		sql = "UPDATE TEMPORARY_STRUCTURES SET APPROVED = ?, APPROVED_BY = ?, APPROVED_DATE = ?, APPROVED_TIME = ? WHERE TEMP_COMPOUND_ID = ?"
		
		cmd.ActiveConnection = RegConn
		cmd.CommandType = adCmdText
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pApproved", adInteger, adParamInput, 0, 1)
		cmd.Parameters.Append cmd.CreateParameter("pApprovedBy", adInteger, adParamInput, 0, PersonID)
		cmd.Parameters.Append cmd.CreateParameter("pApprovedDate", adDate, adParamInput, 0, Date())
		cmd.Parameters.Append cmd.CreateParameter("pApprovedTime", adVarChar, adParamInput, Len(Time()), Time())
		cmd.Parameters.Append cmd.CreateParameter("id", adInteger, adParamInput, 0, idArray(i))
		cmd.Execute
		
		cmd.Parameters.delete "pApproved"
		cmd.Parameters.delete "pApprovedBy"
		cmd.Parameters.delete "pApprovedDate"
		cmd.Parameters.delete "pApprovedTime"
		cmd.Parameters.delete "id"
		
		if err.number = 0 then
			RegConn.CommitTrans
		else
			RegConn.RollBackTrans
		end if
	next
	
	doPreRegisterApprove = theCount & " records approved."
	
end Function
'End of SYAN modification

Function DoPercentActiveCalc(dbkey, formgroup,  ByRef RegConn, theMW, cpd_internal_id,FormulaWt)
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if

	If not theMW <> "" then
		parentMW = Cstr(getParentMW(dbkey, formgroup, theMW, RegConn, cpd_internal_id))
	else
		parentMW = theMW
	end if

	if Not (isEmpty(FormulaWt) or isZero(FormulaWt)) and not (isEmpty(parentMW) or isZero(parentMW)or parentMW=0 ) then
		
		percentActive = Cdbl(parentMW)/Cdbl(FormulaWt) * 100
		
		ParentMW_SigFig = GetNumSigDigADD(ParentMW)
		FormulaWt_SigFig = GetNumSigDigADD(FormulaWt) 'number prior to multip
		
		Final_SigFig = getMin(ParentMW_SigFig,FormulaWt_SigFig,FormulaWt_SigFig)
		FinalPercentActive= FormattedNumberDec(percentActive, Final_SigFig)
	else
		FinalPercentActive = ""
	end if
	
	DoPercentActiveCalc = FinalPercentActive
end Function

Function DoFormulaWtCalc(dbkey, formgroup,  ByRef RegConn, theMW, cpd_internal_id, Salt_MW, Salt_Equiv, Solvate_MW, Solvate_Equiv)
	'stop
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	
	Set RS = Server.CreateObject("ADODB.Recordset")
	Select Case UCase(Application("FORMULA_WT_CALC"))
		Case "SALTS"
			bSalt = true
			bSolvate =false
		Case "SALTS_AND_SOLVATES"
			bSalt = true
			bSolvate =true
		Case "SOLVATE"
			bSalt = false
			bSolvate =true
		Case Else
			bSalt = false
			bSolvate = false
	End Select
	on error resume next
	if (bSalt = true or bSolvate = true) then
		parentMW = getParentMW(dbkey, formgroup, theMW, RegConn, cpd_internal_id)
		if isEmpty(Salt_MW) or isZero(Salt_MW) then Salt_MW = 0
		if isEmpty(Salt_Equiv) or isZero(Salt_Equiv) then Salt_Equiv = 0
		if isEmpty(Solvate_Equiv) or isZero(Solvate_Equiv) then Solvate_Equiv = 0
		if isEmpty(Solvate_MW) or isZero(Solvate_MW) then Solvate_MW = 0
		if not (isEmpty(parentMW) or isZero(parentMW) or parentMW = 0)then 'parentMW is populated
		
			if Cdbl(parentMW)>0 then 'parent MW is valid number
				If bSalt = true then 'get Salt portion of formula weight equation

					'Salt_MW = getSaltMW(dbkey, formgroup, RegConn, RS, Salt_code)
					if  isEmpty(Salt_MW)  then 'salt_mw is empty
						DoFormulaWtCalc = ""
						
						Exit Function
					else 'salt_mw  populated
					
						if not isEmpty(Salt_Equiv)  then 'salt_equiv populate
								
								if Cdbl(Salt_Equiv) = 0 or Cdbl(Salt_Equiv) > 0 then 'salt_equiv valid number
									SaltPortion = Cdbl(Salt_Equiv) * Cdbl(Salt_MW)
								else 'salt_equiv not a valid number
									
									DoFormulaWtCalc = ""
									Exit Function
								end if
								
						else 'salt_equivs not populated
							DoFormulaWtCalc = ""

							Exit Function
						end if 'if Not isEmpty(Salt_Equiv) then
					end if 'if  isEmpty(Salt_MW) then
				else 'bSalt is false, no salt_mw requested
					SaltPortion = 0
				end if 'If bSalt = true
	
				'Get Solvate Information
				If bSolvate = true then 'get the Solvate portion of the FormulaWt equation
					'Solvate_MW = getSolvateMW(dbkey, formgoup, RegConn, RS, Solvate_ID)

					if  isEmpty(Solvate_MW) then 'SolvateMW is empty 
						DoFormulaWtCalc = ""

						Exit Function
					else 'Solvate_MW populated okay continue
						if Not isEmpty(Solvate_Equiv)then
								if Cdbl(Solvate_Equiv) = 0 or  Cdbl(Solvate_Equiv) > 0 then
										SolvatePortion = Cdbl(Solvate_Equiv) * Cdbl(Solvate_MW)
								else 'solvate_equiv not number
									DoFormulaWtCalc = ""

									Exit Function
								end if
								
						else 'solvate_equiv missing
							DoFormulaWtCalc = ""
							Exit Function
						end if
					end if
				else 'no solvate in calculation
					DoFormulaWtCalc = ""
					Exit Function
				end if 'If bSolvate = true
			end if 'if Cdbl(parentMW)>0 then 
		end if 'if not isEmpty(parentMW)
			
		Raw_FormulaWeight = Cdbl(parentMW) + Cdbl(SaltPortion) + Cdbl(SolvatePortion)
		ParentMW_SigFig = GetNumSigDigADD(ParentMW)
		if CLng(Solvate_MW)> 0 then
			SolvateMW_SigFig = GetNumSigDigADD(Solvate_MW)
		else
			SolvateMW_SigFig = 100000 'bascially ignore the sig figures since the value was not used in the calc
		end if 'number prior to multip
		if CLng(Salt_MW)> 0 then
			SaltMW_SigFig =  GetNumSigDigADD(Salt_MW)
		else
			SaltMW_SigFig =  100000 'bascially ignore the sig figures since the value was not used in the calc
		end if
		'stop
		Final_SigFig = getMin(ParentMW_SigFig,SolvateMW_SigFig,SaltMW_SigFig)
		FinalFormula_Weight= FormattedNumberDec(Raw_FormulaWeight, Final_SigFig)
		
	
	else 'bSalt and bSolvate are false - no request 
		FinalFormula_Weight = ""
	end if 'if (bSalt= true or bSolvate = true) then
	DoFormulaWtCalc =FinalFormula_Weight

End Function 

Function getSolvateMW(dbkey, formgroup, ByRef RegConn, ByRef RS,  Solvate_ID)
	Set cmd = Server.CreateObject("adodb.command")
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	if not isEmpty(Solvate_ID) then
		if CLng(Solvate_ID) > 0 then
			sql = "Select Solvate_MW from Solvates where Solvate_ID=?"
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("pSolvate_ID", 139, 1, 0, Solvate_ID) 
			RS.Open  cmd
			
			Solvate_MW = RS("Solvate_MW")
			
			if not isEmpty(Solvate_MW) then
				if not CInt(Solvate_MW)> 0 then
					getSolvateMW = ""
					Exit Function
				end if
			else
				getSolvateMW = ""
				Exit Function
			end if
			RS.Close
		else
			getSolvateMW= ""
			Exit Function
		end if
	else
		getSolvateMW= ""
		Exit Function
	end if
	
	getSolvateMW=Solvate_MW
End Function 


Function getSaltMW(dbkey, formgroup,ByRef RegConn, ByRef RS, Salt_Code)
	Set cmd = Server.CreateObject("adodb.command")
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
			if not isEmpty(Salt_Code) then
				if CLng(Salt_Code) > 0 then
					sql = "Select Salt_MW from Salts where Salt_Code=?"
					cmd.CommandText = sql
					cmd.Parameters.Append cmd.CreateParameter("Salt_Code", 139, 1, 0, Salt_Code) 
					RS.Open  cmd
				
					RS.MoveFirst
					Salt_MW = RS("Salt_MW")
					if not isEmpty(Salt_MW) then
						if not CInt(Salt_MW)> 0 then
							getSaltMW = ""
							Exit Function
						end if
					else
						getSaltMW = ""
						Exit Function
					end if
					RS.Close
				else
					getSaltMW= ""
					Exit Function
				end if
			else
				getSaltMW= ""
				Exit Function
			end if
	
		getSaltMW = Salt_MW
End Function


Function getParentMW(dbkey, formgroup, theMW, ByRef RegConn, cpd_internal_id)
			Set RS = Server.CreateObject("ADODB.RECORDSET")
			Set cmd = Server.CreateObject("adodb.command")
			if Not isObject(RegConn) then
				Set RegConn= getRegConn(dbkey, formgroup)
			end if
			cmd.ActiveConnection =  RegConn
				cmd.CommandType = adCmdText
			if not isEmpty(theMW) then
				if CLng(theMW)>0 then
					workingMW = theMW 
				end if
			else
				if cpd_internal_id <> "" then
					

					sql ="Select MW2 from compound_molecule where cpd_database_counter=?"

					cmd.CommandText = sql
					cmd.Parameters.Append cmd.CreateParameter("pCPD", 139, 1, 0, cpd_internal_id) 
					on error resume next
					RS.Open cmd
					
					if Not (RS.BOF and RS.EOF) then
						workingMW=RS("MW2")
						
						if isEmpty(workingMW) then
							workingMW_array=populateMW(dbkey, formgroup,RegConn, cpd_internal_id)	
							workingMW = workingMW_array(0)
						end if
					end if
					RS.Close
				end if				
			
			end if
			CloseRS(RS)
		getParentMW=workingMW
End Function 

Function populateMW(dbkey, formgroup, ByRef RegConn, cpd_internal_id)
	Set cmd = Server.CreateObject("adodb.command")
	Set RS2 = Server.CreateObject("adodb.recordset")
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	sql ="Select mol_id,base64_cdx from structures where cpd_internal_id=?"
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("pCPD", 139, 1, 0, cpd_internal_id) 
	on error resume next
	RS2.Open  cmd
	
	RS2.MoveFirst
	
	theChemData = getMW_and_Formula(dbkey, formgroup, "structures", RS2("mol_id"),RegConn,RS2("base64_cdx"))
	theChemDataArray = Split(theChemData, ":", -1)
	theMW = theChemDataArray(0)
	theFormula = theChemDataArray(1)
	
	set cmd = server.CreateObject("adodb.command")
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	
	sql = "Update compound_molecule Set MW2=" & theMW & " Where cpd_database_counter=?"
	cmd.CommandText = sql
	cmd.Execute
	
	set cmd = server.CreateObject("adodb.command")
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	
	sql = "Update compound_molecule Set FORMULA2=" & theFormula & " Where cpd_database_counter=?"
	cmd.CommandText = sql
	cmd.Execute
	
	CloseRS(RS2)
	populateMW= theChemDataArray
	
End Function

Function populateMW2(dbkey, formgroup, ByRef RegConn, cpd_internal_id)
	Set cmd = Server.CreateObject("adodb.command")
	Set RS2 = Server.CreateObject("adodb.recordset")
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	sql ="Select mol_id,base64_cdx from structures where cpd_internal_id=?"
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("pCPD", 139, 1, 0, cpd_internal_id) 
	on error resume next
	RS2.Open  cmd
	
	cmd.Parameters.Delete "cCPD"
	
	RS2.MoveFirst
	
	theChemData = getMW_and_Formula(dbkey, formgroup, "structures", RS2("mol_id"),RegConn,RS2("base64_cdx"))
	theChemDataArray = Split(theChemData, ":", -1)
	theMW = theChemDataArray(0)
	theFormula = theChemDataArray(1)
	
	set cmd = server.CreateObject("adodb.command")
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	
	sql = "Update compound_molecule Set MW2=" & theMW & " Where cpd_database_counter=?"
	cmd.Parameters.Append cmd.CreateParameter("pCPD", 139, 1, 0, cpd_internal_id) 
	cmd.CommandText = sql
	cmd.Execute
	
	cmd.Parameters.Delete "cCPD"

	set cmd = server.CreateObject("adodb.command")
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	
	sql = "Update compound_molecule Set FORMULA2='" & theFormula & "' Where cpd_database_counter=?"
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("pCPD", 139, 1, 0, cpd_internal_id) 
	cmd.Execute
	
	CloseRS(RS2)
	populateMW2 = theChemDataArray
	
End Function

function getMW_and_Formula(dbkey, formgroup, tablename, mol_id,ByRef RegConn, byVal b64)
	'stop
	if UseCartridge(dbkey, formgroup) then
		Set cmd = Server.CreateObject("adodb.command")
		Set RS = Server.CreateObject("adodb.recordset")
		if Not isObject(RegConn) then
			Set RegConn= getRegConn(dbkey, formgroup)
		end if
		SetOracleSessionCursorSharingParameter RegConn, "force"
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		GET_MW_FORMULA_METHOD = Application("GET_MW_FORMULA_METHOD")
		
		Select case UCase(GET_MW_FORMULA_METHOD)
			case "STANDARD" 'use shipping cartridge functions
				sql = "SELECT CsCartridge.FORMULA(" & tablename & "." & "base64_cdx" & ",'') formula," &_
					" CsCartridge.MolWeight(" & tablename &  "." & "base64_cdx"& ") molweight" &_
					" FROM  " & tablename &_
					" WHERE MOL_ID=?"	
				bControl = false
			case "PLSQL" 'use special function written for fast access through biosar
				indexName = GetCartIndexName(RegConn, "REGDB",tablename)
				mwTableName = GetCartMWTableName(RegConn, "REGDB",indexName,tablename)
				formulaTableName = GetCartFormulaTableName(RegConn, "REGDB",indexName,tablename)
				sql = "SELECT Cscartridge.FastIndexAccess.RowIDtoMolWeight(" & tablename & ".rowid,'" & mwTableName & "')" & " as " & " molweight," &_
					"Cscartridge.FastIndexAccess.RowIDtoFormula(" & tablename & ".rowid,'" & formulaTableName & "')" & " as " & " formula" &_
					" FROM " & tablename &_
					" WHERE MOL_ID=?"
				bControl = false			
			case "JOIN" 'use direct join method - requires grants on internal cartridge index tables
				'join to cscartridge tables. tables most be granted to pubic or individual roles
				indexName = GetCartIndexName(RegConn, "REGDB",tablename)
				mwTableName = GetCartMWTableName(RegConn, "REGDB",indexName,tablename)
				mwSelectText = "round(" & mwTableName & ".MOLWEIGHT,4) as MOLWEIGHT"
				formulaTableName = GetCartFormulaTableName(RegConn, "REGDB",indexName,tablename)
				sql = "SELECT " & formulaTableName & ".Formula as formula," & "round(" & mwTableName & ".MOLWEIGHT,4) as molweight" &_
					" FROM  " & tablename  & "," & formulatTableName & "," & mwTableName &_
					" WHERE " & formulaTableName & ".RID=" & tablename  & ".ROWID" &_
					" AND " & mwTableName & ".RID=" & lookup_table_name  & ".ROWID" &_
					" AND MOL_ID=?"
				bControl = false
			case "CDCONTROL"
				'stop
				if not isObject(Session("cdAX")) then
					'Set cdAx = Server.CreateObject("ChemDrawControl8.ChemDrawCtl")
					Set cdAx =  GetCDAX
					Set Session("cdAX") = cdAx
				else
					Set cdAX = Session("cdAX")
				end if
				cdAX.DataEncoded = true   
				'b64 = replace(b64, chr(13), "")
				'b64 = replace(b64, chr(10), "")
				cdAX.Data("chemical/x-cdx") = b64
				theMW=cdAX.Objects.MolecularWeight
				theMW = FormattedNumberDec(theMW, 4)
				theFormula=cdAX.Objects.Formula
				bControl = true

		End Select
		if bControl = false then
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("pMol_ID", 139, 1, 0, MOL_ID) 
		
			on error resume next
			RS.Open cmd
			if not RS.eof then
				theMW=rs.fields("molweight")
				theFormula = rs.fields("formula")
			else
				theMW=""
				theFormula = ""
			end if
			Set RS = nothing
			RS = ""
		end if
		
		if theMW = "-1" then theMW = "0"
		theReturn = theMW & ":" & theFormula
		getMW_and_Formula = theReturn
	
	else

		sql = "SELECT FORMULA,MOLWT FROM " & tablename & " WHERE MOL_ID=" & mol_id
		Set rs = CSDODoCommand(sql, dbkey, formgroup, "0", "")
		if not rs.eof then
			theMW=rs.fields("MOLWT")
			theFormula = rs.fields("FORMULA")
		else
			theMW=""
			theFormula = ""
		end if
		Set rs = nothing
		rs = ""
		if theMW = "-1" then theMW = "0"
		theReturn = theMW & ":" & theFormula
		getMW_and_Formula = theReturn
	end if
		
End Function 


Function GetCartIndexName(byRef DataConn, schema_name, tablename)
	if Not Application("CART_MW_TABLENAME"& Trim(tablename)) <> "" then
		Dim s 
		Dim r 
		on error resume next
		Set r = Server.CreateObject("ADODB.RECORDSET")
		
		s = "SELECT INDEX_NAME FROM ALL_INDEXES WHERE TABLE_OWNER = '" & UCase(schema_name) & "' AND TABLE_NAME = '" & UCase(tablename) & "' AND ITYP_OWNER = 'CSCARTRIDGE' AND ITYP_NAME = 'MOLECULEINDEXTYPE'"
		
		Set r = DataConn.Execute(s)
		if Not (r.EOF and r.BOF) then
			theReturn =  r.Fields("INDEX_NAME").Value
			r.close
		else
			theReturn = ""
		end if
		if err.number <> 0 then
			logaction(err.number & err.Description)
		end if
		Application.Lock	
			Application("CART_INDEXNAME"& Trim(tablename))=theReturn
		Application.UnLock
	else
		theReturn= Application("CART_INDEXNAME" & Trim(tablename))
	end if
		
	GetCartIndexName = theReturn
End Function

Function GetCartMWTableName(byRef RegConn, schema_name, index_Name,tablename)
	if Not Application("CART_MW_TABLENAME"& Trim(tablename)) <> "" then
		Dim s 
		Dim r 
		on error resume next
		Set r = Server.CreateObject("ADODB.RECORDSET")
		
		s = "SELECT CSCartridge.Aux.MWTabName('" & UCase(schema_name) & "','" & UCase(index_name) & "') as table_name FROM DUAL"
		
		Set r = RegConn.Execute(s)
		if Not (r.EOF and r.BOF) then
			theReturn = r.Fields("TABLE_NAME").Value
			r.close
		else
			theReturn = ""
		end if
		
		if err.number <> 0 then
			logaction(err.number & err.Description)
		end if
		Application.Lock	
			Application("CART_MW_TABLENAME"& Trim(tablename))=theReturn
		Application.UnLock
	else
		theReturn= Application("CART_MW_TABLENAME"& Trim(tablename))
	end if
	GetCartMWTableName = theReturn
End Function

Function GetCartFormulaTableName(byRef RegConn, schema_name, index_Name,tablename)
	if Not Application("CART_FORMULA_TABLENAME"& Trim(tablename)) <> "" then
	
		Dim s 
		Dim r 
		on error resume next
		Set r = Server.CreateObject("ADODB.RECORDSET")
		
		s = "SELECT CSCartridge.Aux.FMTabName('" & schema_name & "','" & index_name & "') as table_name FROM DUAL"
		
		Set r = RegConn.Execute(s)
		if Not (r.EOF and r.BOF) then
			theReturn = r.Fields("TABLE_NAME").Value
			r.close
		else
			theReturn = ""
		end if
		if err.number <> 0 then
			logaction(err.number & err.Description)
		end if
		Application.Lock	
			Application("CART_FORMULA_TABLENAME"& Trim(tablename))=theReturn
		Application.UnLock
	else
		theReturn= Application("CART_FORMULA_TABLENAME"& Trim(tablename))
	end if
	
	GetCartFormulaTableName = theReturn
End Function

Function doUpdateBatchProject(dbkey, formgroup, batch_project_id)	
		 if Not isObject(RegConn)  then
			Set RegConn = GetRegConn(dbkey, formgroup)
		end if

	
		
		table_names = "BATCH_PROJECTS,BATCH_PROJ_UTILIZATIONS"
		StrucFields= ""
		RelFields = Request("RelationalSearchFields")
		errors_found = DoUpdateRecordMaster(dbkey, formgroup, RelFields, StrucFields, table_names)
		if errors_found = false then
					
			for i = 1 to request.form.count
				current_item =request.form.key(i)
				if inStr(current_item, "BATCH_PROJ_UTILIZATION_ID")>0 And Not inStr(current_item, "list") > 0 then
					current_item_array = split(current_item,".", -1)
					utilization_id = current_item_array(Ubound(current_item_array))
					utilization_boolean = request.form.item(i)
					if not (utilization_boolean = "" or utilization_boolean = -1) then 'this means it is unset
						set cmd = server.CreateObject("adodb.command")
						cmd.ActiveConnection =  RegConn
						cmd.CommandType = adCmdText
						sql = "INSERT into BATCH_PROJ_UTILIZATIONS (BATCH_PROJECT_ID,UTILIZATION_ID,UTILIZATION_BOOLEAN)values(?,?," & utilization_boolean & ")"							
						cmd.CommandText = sql
						cmd.Parameters.Append cmd.CreateParameter("pbatchProjID", 139, 1, 0, batch_project_id)
						cmd.Parameters.Append cmd.CreateParameter("pUtilID", 139, 1, 0, utilization_id) 
						cmd.execute
						'cmd.Parameters.delete "pbatchProjID"
						'cmd.Parameters.delete "pUtilID"
					end if 
					if  not err.number <> 0 then
						theReturn = "Project and Default Utilization Permissions Added"
					else
						theReturn ="commit to batch_projects table failed: " & err.description 
						Session("errors_found" & dbkey & formgroup) = theReturn
					end if
				else
					if  not err.number <> 0 then
						theReturn = "Project and Default Utilization Permissions Added"
					else
						theReturn ="commit to batch_projects table failed: " & err.description 
					end if
						
				end if
			next
			if  not err.number <> 0 then
				theReturn = "Project and Default Utilization Permissions Added"
			else
				theReturn ="commit to batch_projects table failed: " & err.description 
				Session("errors_found" & dbkey & formgroup) = theReturn
			end if
			'CloseConn(RegConn)
		else
			theReturn = Session("errors_found" & dbkey & formgroup)
					
		end if
		doUpdateBatchProject=theReturn
End Function

Function DoDeleteBatchProject(dbkey, formgroup, batch_project_id)
		'first check whether any batches reference this project
		 if Not isObject(RegConn)  then
			Set RegConn= GetRegConn(dbkey, formgroup)
		end if

		Set RS = Server.CreateObject("ADODB.Recordset")
		Set cmd = Server.CreateObject("adodb.command")
	
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		
		sql = "select count(batch_internal_id) as theCount from batches where batch_project_id=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pbatchProjID", 139, 1, 0, batch_project_id)
		RS.Open Cmd
		cmd.Parameters.delete "pbatchProjID"
		theCount = RS("theCount")
		if CLng(theCount) > 0 then
			theReturn = "This project is referencee by " & theCount & " batches.  Deletion failed."
			Session("errors_found" & dbkey & formgroup) = theReturn
		else
			showErrors = False
			delete_order = "Batch_Proj_Utilizations,Batch_Projects"
			table_names = 	"Batch_Proj_Utilizations,Batch_Projects"
			
			errors_occured = DoDeleteRecordMaster(dbkey, formgroup, table_names, delete_order) 'this calls doDeleteRecord as before
		
			if errors_occured = True then
				theReturn = Session("errors_found" & dbkey & formgroup)
			else
				theReturn = "Record deleted"
			end if
		end if
		DoDeleteBatchProject=theReturn
End Function

Function DoAddBatchProject(dbkey, formgroup)
		SetSessionVars dbkey, formgroup, "add_record"
		GetSearchData dbkey, formgroup
		field_names=Session("SearchData" & "Relational" & dbkey & formgroup)
		AddOrder =""
		table_names="BATCH_PROJECTS"
		field_names=Session("SearchData" & "Relational" & dbkey & formgroup)
		
		errors_found = False
		errors_found = DoAddRecordMaster(dbkey, formgroup, table_names, field_names, AddOrder)
			if errors_found = False then
				batch_project_id =Session("ADD_RECORD_NEW_ID" & dbkey & formgroup)
				 if Not isObject(RegConn)  then
					Set RegConn= GetRegConn(dbkey, formgroup)
				end if

				
				
				for i = 1 to request.form.count
					current_item =request.form.key(i)
					if inStr(current_item, "BATCH_PROJ_UTILIZATION_ID")>0 And Not inStr(current_item, "list") > 0 then
						current_item_array = split(current_item,".", -1)
						utilization_id = current_item_array(Ubound(current_item_array))
						utilization_boolean = request.form.item(i)
						if not (utilization_boolean = "" or utilization_boolean = -1) then 'this means it is unse
							set cmd = server.CreateObject("adodb.command")
							cmd.ActiveConnection =  RegConn
							cmd.CommandType = adCmdText
							sql = "INSERT into BATCH_PROJ_UTILIZATIONS (BATCH_PROJECT_ID,UTILIZATION_ID,UTILIZATION_BOOLEAN)values(?,?," & utilization_boolean & ")"							
							cmd.CommandText = sql
							cmd.Parameters.Append cmd.CreateParameter("pbatchProjID", 139, 1, 0, batch_project_id)
							cmd.Parameters.Append cmd.CreateParameter("pUtilID", 139, 1, 0, utilization_id)
							cmd.execute
							
						end if 
						if  not err.number <> 0 then
							theReturn = "Project and default utilization permissions added"
						else
							theReturn ="commit to batch_projects table failed: " & err.description 
							Session("errors_found" & dbkey & formgroup) = theReturn
						end if
					end if
				next
					if  not err.number <> 0 then
						theReturn = "Project and default utilization permissions added"
					else
						theReturn ="commit to batch_projects table failed: " & err.description 
						Session("errors_found" & dbkey & formgroup) = theReturn
					end if
				'CloseConn(RegConn)
			else
				theReturn = "commit to batch_projects table failed " & Session("errors_found" & dbkey & formgroup)
					
			end if
		DoAddBatchProject=theReturn
End Function

Function DoAddUtilization(dbkey, formgroup)
		SetSessionVars dbkey, formgroup, "add_record"
		GetSearchData dbkey, formgroup
		showErrors = False
		table_names="utilizations"
		AddType = ""
		field_names=Session("SearchData" & "Relational" & dbkey & formgroup)
		errors_found= DoAddRecordMaster(dbkey, formgroup, table_names, field_names, AddType)
		if errors_found = True then
			showErrors = True
		end if
		
		if showErrors = True and Not err.number = 9 then
			theReturn = err.number & err.description & Session("errors_found" & dbkey & formgroup)
		else
			theReturn = "Utilization permission added"
		end if
		sql = "select * from utilizations"
		Session("Base_RS" & dbkey & formgroup) = CreateRecordset("Base_RS", dbkey, formgroup, sql, maxhits, adOpenForwardOnly, adLockReadOnly)

		DoAddUtilization=theReturn
End Function

Function DoUpdateUtilization(dbkey, formgroup, utilization_id)
		table_names = "UTILIZATIONS"
		StrucFields= ""
		RelFields = Request("RelationalSearchFields")
		errors_found = DoUpdateRecordMaster(dbkey, formgroup, RelFields, StrucFields, table_names)
		if errors_found = True then
			showErrors = True
		end if
		if showErrors = True then
			theReturn = Session("errors_found" & dbkey & formgroup)
		else
			theReturn = "Utilization updated."
		end if
		DoUpdateUtilization = theReturn
End Function


Function DoDeleteUtilization(dbkey, formgroup, utilization_id)
		'first check whether any batches reference this project
		 if Not isObject(RegConn)  then
			Set RegConn= getRegConn(dbkey, formgroup)
		end if
		Set RS = Server.CreateObject("ADODB.Recordset")
		Set cmd = Server.CreateObject("adodb.command")
	
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		
		sql = "select count(utilization_id) as theCount from cmpd_mol_utilizations where utilization_id=?"

		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pUtilID", 139, 1, 0, utilization_id)
		RS.Open cmd
		theCmpdCount = RS("theCount")
		
		if CLng(theCmpdCount) > 0 then
			theReturn = "This utilization permission is referenced by " & theCmpdCount & " compound(s).  Deletion failed."
			Session("errors_found" & dbkey & formgroup) = theReturn
		else
			showErrors = False
			delete_order = "Utilizations,Batch_Proj_Utilizations,Cmpd_Mol_Utilizations"
			table_names = 	"Utilizations,Batch_Proj_Utilizations,Cmpd_Mol_Utilizations"
			errors_occured = DoDeleteRecordMaster(dbkey, formgroup, table_names, delete_order) 'this calls doDeleteRecord as before
			if errors_occured = True then
				theReturn = Session("errors_found" & dbkey & formgroup)
			else
				theReturn = "Utilization permission deleted successfully"
			end if
		end if
		CloseRS(RS)
		'CloseConn(RegConn)
		DoDeleteUtilization=theReturn
End Function

Sub doAddUtilizations (dbkey, formgroup)
			 if Not isObject(RegConn)  then
				Set RegConn= GetRegConn(dbkey, formgroup)
			end if

			
			for i = 1 to request.form.count
				current_item =request.form.key(i)
				if inStr(current_item, "CMPD_MOL_UTILIZATION_ID")>0 And Not inStr(current_item, "list") > 0 then
					current_item_array = split(current_item,".", -1)
					
					temp = current_item_array(Ubound(current_item_array))
					temp_array = split(temp, ":", -1)
					cpdDBCounter =  temp_array(1)
					utilization_id = temp_array(0) 
					utilization_boolean = request.form.item(i)
					if not (utilization_boolean = "" or utilization_boolean = -1) then 'this means it is unset
						set cmd = server.CreateObject("adodb.command")
						cmd.ActiveConnection =  RegConn
						cmd.CommandType = adCmdText
						sql = "INSERT into CMPD_MOL_UTILIZATIONS (CPD_INTERNAL_ID,UTILIZATION_ID,UTILIZATION_BOOLEAN)values(?,?," & utilization_boolean & ")"							
					
						cmd.CommandText = sql
						cmd.Parameters.Append cmd.CreateParameter("pCPD", 139, 1, 0, cpdDBCounter)
						cmd.Parameters.Append cmd.CreateParameter("pUtilID", 139, 1, 0, utilization_id)
						cmd.execute
					end if
				end if
			next
			'CloseConn(RegConn)
End Sub


Function DoUpdateRegMaster(dbkey, formgroup, RelFields, StrucFields, table_names)
		'stop
		SetSessionVars dbkey, formgroup, "update_record"
		showErrors = False
		table_name_array = split(table_names, ",", -1)
		
		count = UBound(table_name_array)
		for h=0 to CLng(count)
			table_name = table_name_array(h)	
			if Not UCase(table_name) = "CMPD_MOL_UTILIZATION_ID" then
				tables_row_ids = request(table_name & "_ROW_IDS")
				tables_row_ids_array = split(tables_row_ids, ",", -1)
					if table_name <> "" then
						count2 = UBound(tables_row_ids_array)
						for m=0 to CLng(count2)
							row_id = tables_row_ids_array(m)
							if row_id <> "" then
								'get all submitted data fields for this table and row_id
								isOK = DoRegUpdate(dbkey, formgroup, StrucFields,RelFields, table_name, row_id)
								DoUpdateRegModInfo dbkey, formgroup, table_name, row_id
								'needs to be worked in
								if isOK = False then
								showErrors = True
									
								end if
								if m = CLng(count2) then
									exit for
								end if
							end if
						next 'row_id j for table i
					end if
					if h= CLng(count) then
						exit for
					end if
				else
					DoAddUtilizations dbkey, formgroup
				end if	
			next 'table i
		
		DoUpdateRegMaster=ShowErrors
End Function

Function DoDeleteProject(dbkey, formgroup, project_id)
		 if Not isObject(RegConn)  then
			Set RegConn= GetRegConn(dbkey, formgroup)
		end if

		Set RS = Server.CreateObject("ADODB.Recordset")
		Set cmd = Server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		'check permanent tables
		sql = "select count(comp_project_id) as theCount from compound_project where PROJECT_INTERNAL_ID=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pProject_id", 139, 1, 0, project_id)
		
		RS.Open cmd
	
		
		theCountREG = RS("theCount")
		RS.Close
		
		'check temporary tables
		set cmd = server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		sql = "select count(temp_compound_id) as theCount from temporary_structures where PROJECT_ID=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pProject_id", 139, 1, 0, project_id)
		
		RS.Open cmd
	
		theCountTemp = RS("theCount")
		RS.Close
		
		totalcount = CLng(theCountReg)+ CLng(theCountTemp)
		if CLng(totalcount) > 0 then
			theReturn = "This project is referenced by " & totalcount & " record(s).  Deletion failed."
			Session("errors_found" & dbkey & formgroup) = theReturn
		else
			showErrors = False
			delete_order = ""
			table_names = 	"Projects"
			
			errors_occured = DoDeleteRecordMaster(dbkey, formgroup, table_names, delete_order) 'this calls doDeleteRecord as before
		
			if errors_occured = True then
				theReturn = Session("errors_found" & dbkey & formgroup)
			else
				theReturn = "Record deleted"
			end if
		end if
		DoDeleteProject=theReturn
End Function

Function DoDeleteNotebook(dbkey, formgroup, notebook_id)
		 if Not isObject(RegConn)  then
			Set RegConn= getRegConn(dbkey, formgroup)
		end if
		Set RS = Server.CreateObject("ADODB.Recordset")
		Set cmd = Server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		
		'check permanent tables
		sql = "select count(batch_internal_id) as theCount from batches where NOTEBOOK_INTERNAL_ID=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pnotebook_id", 139, 1, 0, notebook_id)
		
		RS.Open cmd
		theCountREG = RS("theCount")
		RS.Close
		
		'check temporary tables
		set cmd = server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		sql = "select count(temp_compound_id) as theCount from temporary_structures where NOTEBOOK_NUMBER=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pnotebook_id", 139, 1, 0, notebook_id)
		
		RS.Open cmd
		
		theCountTemp = RS("theCount")
		RS.Close
		
		totalcount = CLng(theCountReg)+ CLng(theCountTemp)
		if CLng(totalcount) > 0 then
			theReturn = "This notebook is referenced by " & totalcount & " record(s).  Deletion failed."
			Session("errors_found" & dbkey & formgroup) = theReturn
		else
			showErrors = False
			delete_order = ""
			table_names = 	"Notebooks"
			
			errors_occured = DoDeleteRecordMaster(dbkey, formgroup, table_names, delete_order) 'this calls doDeleteRecord as before
		
			if errors_occured = True then
				theReturn = Session("errors_found" & dbkey & formgroup)
			else
				theReturn = "Record deleted"
			end if
		end if
		DoDeleteNotebook=theReturn
End Function

Function DoDeleteSalt(dbkey, formgroup, salt_id)
		bOverrideDelete = false
		Session("errors_found" & dbkey & formgroup)=""
		if salt_id = "1" then
			theReturn = "Salt Code 1  is used internally and cannot be deleted."
			Session("errors_found" & dbkey & formgroup)=theReturn
		else
			
			 if Not isObject(RegConn)  then
				Set RegConn= GetRegConn(dbkey, formgroup)
			end if

			Set RS = Server.CreateObject("ADODB.Recordset")
			Set cmd = Server.CreateObject("adodb.command")
			cmd.ActiveConnection =  RegConn
			cmd.CommandType = adCmdText
			
			if UCase(Application("BATCH_LEVEL"))= "SALT" then
				
				'check permanent tables
				set cmd = server.CreateObject("adodb.command")
				cmd.ActiveConnection =  RegConn
				cmd.CommandType = adCmdText
				sql = "select count(COMPOUND_SALT_ID) as theCount from compound_salt where SALT_INTERNAL_ID=?"
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("psalt_id", 139, 1, 0, salt_id)
		
				RS.Open cmd
				
				
				theCountREG1 = RS("theCount")
				RS.Close
				
				'check temporary tables
				set cmd = server.CreateObject("adodb.command")
				cmd.ActiveConnection =  RegConn
				cmd.CommandType = adCmdText
				sql = "select count(temp_compound_id) as theCount from temporary_structures where SALT_CODE=?"
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("psalt_id", 139, 1, 0, salt_id)
		
				RS.Open cmd
				theCountTemp = RS("theCount")
				RS.Close
			
				totalcount = CLng(theCountReg1) + CLng(theCountReg2)+ CLng(theCountTemp)
				if CLng(totalcount) > 0 then
					bOverrideDelete = true
				end if
			
			end if
			
			if bOverrideDelete = true then
				theReturn = "This salt is referenced by " & totalcount & " record(s).  Deletion failed."
				Session("errors_found" & dbkey & formgroup) = theReturn
			else
				showErrors = False
				delete_order = ""
				table_names = 	"Salts"
				
				errors_occured = DoDeleteRecordMaster(dbkey, formgroup, table_names, delete_order) 'this calls doDeleteRecord as before
				
				if errors_occured = True then
					theReturn = Session("errors_found" & dbkey & formgroup)
				else
					theReturn = "Record deleted"
				end if
			end if
		end if
		DoDeleteSalt=theReturn
End Function

Function DoDeleteSolvate(dbkey, formgroup, solvate_id)
		 if Not isObject(RegConn)  then
			Set RegConn= GetRegConn(dbkey, formgroup)
		end if

		Set RS = Server.CreateObject("ADODB.Recordset")
		Set cmd = Server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		
		'check permanent tables
		sql = "select count(batch_internal_id) as theCount from batches where SOLVATE_ID=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("psolvate_id", 139, 1, 0,solvate_id)
		
		RS.Open cmd
		cmd.Parameters.Delete "psolvate_id"
		theCountREG = RS("theCount")
		RS.Close
		
		'check temporary tables
		set cmd = server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		sql = "select count(temp_compound_id) as theCount from temporary_structures where SOLVATE_ID=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("psolvate_id", 139, 1, 0, solvate_id)
		
		RS.Open cmd
		cmd.Parameters.Delete "psolvate_id"
		theCountTemp = RS("theCount")
		RS.Close
		
		totalcount = CLng(theCountReg)+ CLng(theCountTemp)
	
		if CLng(totalcount) > 0 then
			theReturn = "This solvate is referenced by " & totalcount & " record(s).  Deletion failed."
			Session("errors_found" & dbkey & formgroup) = theReturn
		else
			showErrors = False
			delete_order = ""
			table_names = 	"Solvates"
			
			errors_occured = DoDeleteRecordMaster(dbkey, formgroup, table_names, delete_order) 'this calls doDeleteRecord as before
		
			if errors_occured = True then
				theReturn = Session("errors_found" & dbkey & formgroup)
			else
				theReturn = "Record deleted"
			end if
		end if
		DoDeleteSolvate=theReturn
End Function


Function DoDeleteCompoundType(dbkey, formgroup, compound_type_id)
		 if Not isObject(RegConn)  then
			Set RegConn= getRegConn(dbkey, formgroup)
		end if
		Set RS = Server.CreateObject("ADODB.Recordset")
		Set cmd = Server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		
		'check permanent tables
		sql = "select count(cpd_database_counter) as theCount from compound_molecule where Compound_type=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pCompound_type", 139, 1, 0, compound_type_id)
		
		RS.Open cmd
		cmd.Parameters.Delete "pCompound_type"
		
		theCountREG = RS("theCount")
		RS.Close
		
		'check temporary tables
		set cmd = server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		sql = "select count(temp_compound_id) as theCount from temporary_structures where Compound_type=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pCompound_type", 139, 1, 0, compound_type_id)
		
		RS.Open cmd
		cmd.Parameters.Delete "pCompound_type"
		
		theCountTemp = RS("theCount")
		RS.Close
		
		totalcount = CLng(theCountReg) + CLng(theCountTemp)
		if CLng(totalcount) > 0 then
			theReturn = "This structure comment is referenced by " & totalcount & " record(s).  Deletion failed."
			Session("errors_found" & dbkey & formgroup) = theReturn
		else
			showErrors = False
			delete_order = ""
			table_names = 	"Compound_Type"
			
			errors_occured = DoDeleteRecordMaster(dbkey, formgroup, table_names, delete_order) 'this calls doDeleteRecord as before
		
			if errors_occured = True then
				theReturn = Session("errors_found" & dbkey & formgroup)
			else
				theReturn = "Record deleted"
			end if
		end if
		DoDeleteCompoundType=theReturn
End Function

Function DoDeleteSite(dbkey, formgroup, site_id)
		 if Not isObject(RegConn)  then
			Set RegConn= GetRegConn(dbkey, formgroup)
		end if

		Set RS = Server.CreateObject("ADODB.Recordset")
		Set cmd = Server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		
		'check peoples tables
		sql = "select count(person_id) as theCount from people where site_id=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("psite_id", 139, 1, 0, site_id)
		
		RS.Open cmd
		
		
		theCount= RS("theCount")
		RS.Close
		
		if CLng(theCount) > 0 then
			theReturn = "This site is referenced by " & theCount & " record(s).  Deletion failed."
			Session("errors_found" & dbkey & formgroup) = theReturn
		else
			showErrors = False
			delete_order = ""
			table_names = 	"Sites"
			
			errors_occured = DoDeleteRecordMaster(dbkey, formgroup, table_names, delete_order) 'this calls doDeleteRecord as before
		
			if errors_occured = True then
				theReturn = Session("errors_found" & dbkey & formgroup)
			else
				theReturn = "Record deleted"
			end if
		end if
		DoDeleteSite=theReturn
End Function


Function DoDeleteSequence(dbkey, formgroup, sequence_id)
		 if Not isObject(RegConn)  then
			Set RegConn= GetRegConn(dbkey, formgroup)
		end if

		Set RS = Server.CreateObject("ADODB.Recordset")
		Set cmd = Server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		
		'check permanent tables
		sql = "select count(cpd_database_counter) as theCount from compound_molecule where SEQUENCE_INTERNAL_ID=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("psequence_id", 139, 1, 0, sequence_id)
		RS.Open cmd
		
		
		theCountREG = RS("theCount")
		RS.Close
		
		'check temporary tables
		set cmd = server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		sql = "select count(temp_compound_id) as theCount from temporary_structures where SEQUENCE_ID=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("psequence_id", 139, 1, 0, sequence_id)
		RS.Open cmd
	
		
		theCountTemp = RS("theCount")
		
		totalcount = CLng(theCountReg) + CLng(theCountTemp)
		if CLng(totalcount) > 0 then
			theReturn = "This sequence is referenced by " & totalcount & " record(s).  Deletion failed."
			Session("errors_found" & dbkey & formgroup) = theReturn
		else
			showErrors = False
			delete_order = ""
			table_names = 	"Sequence"
			
			errors_occured = DoDeleteRecordMaster(dbkey, formgroup, table_names, delete_order) 'this calls doDeleteRecord as before
		
			if errors_occured = True then
				theReturn = Session("errors_found" & dbkey & formgroup)
			else
				theReturn = "Record deleted"
			end if
		end if
		DoDeleteSequence=theReturn
End Function

Function DoDeletePerson(dbkey, formgroup, person_id)
		'first check whether any batches reference this project
		theReturn = "not fully implemented"
		
		DoDeletePerson = theReturn
End Function


function getMin(numString1, numString2, numString3)
	on error resume next
	
	'SYAN modified on 5/26/2005 to fix Celera overflow error	
	'if CInt(numString2) > CInt(numString1) then
	if CLng(numString2) > CInt(numString1) then
		testNumFinal = numString1
	else
		testNumFinal = numString2
	end if
	'if CInt(numString3) > CInt(testNumFinal) then
	if CLng(numString3) > CInt(testNumFinal) then
		testNumFinal = testNumFinal
	else
		testNumFinal = CInt(numString3)
	end if
	
	getMin = testNumFinal
	
end function

'get the minium number of several numbers. Ou

Function GetNumSigDigADD(r) 
    ' return the number of significant digits that are in the specified string to the right of the decimal
    ' where the string is guaranteed to represent a positive number.
    Dim result 
    Dim i 
    'first split the string 
    'SYAN modified on 9/27/2004 to fix CSBR-46729
    if Application("FLOAT_FORMAT") = "9" then
		if inStr(r, ",")>0 then
			myNum = split(r, ",", -1)
			s = myNum(1)
			if s = "" then
				result = 0
			else
				result = Len(s)
			end if
		else
			result = 0
		end if
	else
		if inStr(r, ".")>0 then
			myNum = split(r, ".", -1)
			s = myNum(1)
			if s = "" then
				result = 0
			else
				result = Len(s)
			end if
		else
			result = 0
		end if
	end if
	'End of SYAN modification
    GetNumSigDigADD = result
End Function

Function GetNumSigDig(s) 
    ' return the number of significant digits that are in the specified string to the right of the decimal
    ' where the string is guaranteed to represent a positive number.
    Dim result 
    Dim i 
    'first split the string 
    myNum = split(s, ".", -1)
    result = 0
    For i = 1 To Len(s)
        If (IsNumeric(Mid(s, i, 1))) Then
            result = result + 1
        End If
    Next 
    GetNumSigDig = result
End Function

Function FormattedNumberDec(d, SigDecimals)
    ' format the number 'd' so that it has sigdig signficant digits.
  
    'SYAN modified on 9/27/2004 to fix CSBR-46729
    if Application("FLOAT_FORMAT") = "9" then
		if inStr(d, ",")>0 then
			NumArray = split(d, ",", -1)
			on error resume next
			NumberPart = NumArray(0)
			if err.number <> 0 then
				NumberPart = ""
			end if
			on error goto 0
			on error resume next 
			Temp_DecimalPart = NumArray(1)
			if err.number <> 0 then
				FormattedNumberDec = NumberPart 
			else
				theDecLength = Len(Temp_DecimalPart)
				lengthDif = CInt(theDecLength) - CInt(SigDecimals)
				Final_RightPart = Left(Temp_DecimalPart,CInt(theDecLength-lengthDif))
				if Final_RightPart <> "" then
					FormattedNumberDec = NumberPart & "," & Final_RightPart
				else
					FormattedNumberDec = NumberPart
				end if
			end if
		else
			FormattedNumberDec = d
		end if
	else
		if inStr(d, ".")>0 then
			NumArray = split(d, ".", -1)
			on error resume next
			NumberPart = NumArray(0)
			if err.number <> 0 then
				NumberPart = ""
			end if
			on error goto 0
			on error resume next 
			Temp_DecimalPart = NumArray(1)
			if err.number <> 0 then
				FormattedNumberDec = NumberPart 
			else
				theDecLength = Len(Temp_DecimalPart)
				lengthDif = CInt(theDecLength) - CInt(SigDecimals)
				Final_RightPart = Left(Temp_DecimalPart,CInt(theDecLength-lengthDif))
				if Final_RightPart <> "" then
					FormattedNumberDec = NumberPart & "." & Final_RightPart
				else
					FormattedNumberDec = NumberPart
				end if
			end if
		else
			FormattedNumberDec = d
		end if
	end if
	'End of SYAN modification
End Function


Function doDeleteBatch(dbkey, formgroup, batch_id)
	'stop
	'SYAN added on 11/18/2005 to fix CSBR-61357
	Dim LastBatchNumberRS
	Set LastBatchNumberRS = Server.CreateObject("ADODB.RECORDSET")
	
	Dim MaxBatchNumberRS
	Set MaxBatchNumberRS = Server.CreateObject("ADODB.RECORDSET")

	Dim bUpdateLastBatchNumber, regInternalID
	bUpdateLastBatchNumber = false
	'End of SYAN modification
	
	if Not isObject(RegConn)  then
	   Set RegConn= GetRegConn(dbkey, formgroup)
	end if

	Set cmd = Server.CreateObject("adodb.command")
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
		
	RegConn.BeginTrans
	theResult = doDeleteAnalytics(RegConn,dbkey, formgroup, batch_id)
		
	'SYAN added on 11/18/2005 to fix CSBR-61357
	sql = "SELECT REG_NUMBERS.LAST_BATCH_NUMBER, BATCHES.BATCH_NUMBER, BATCHES.REG_INTERNAL_ID FROM REG_NUMBERS, BATCHES WHERE REG_NUMBERS.REG_ID = BATCHES.REG_INTERNAL_ID AND BATCH_INTERNAL_ID = ?"
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("pbatch_id", 139, 1, 0, batch_id)
	LastBatchNumberRS.Open cmd
	cmd.Parameters.delete "pbatch_id"
			
	if not (LastBatchNumberRS.EOF and LastBatchNumberRS.BOF) then
		if CLng(LastBatchNumberRS("LAST_BATCH_NUMBER").value) = CLng(LastBatchNumberRS("BATCH_NUMBER").value) then
			bUpdateLastBatchNumber = true
			regInternalID = LastBatchNumberRS("REG_INTERNAL_ID").value
		end if
	end if
	'End of SYAN modification
	
	if not instr(theResult,"error")>0 then
		sql = "Delete FROM Batches Where Batch_Internal_ID =?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pbatch_id", 139, 1, 0, batch_id)
		cmd.execute
		cmd.Parameters.delete "pbatch_id"
		
		if err.number <> 0 then
			RegConn.RollBackTrans
			theReturn = err.number & err.description
			Session("errors_found" & dbkey & formgroup) = theReturn
		else
			RegConn.CommitTrans
			
			'SYAN added on 11/18/2005 to fix CSBR-61357
			sql = "SELECT MAX(BATCH_NUMBER) as MaxBatchNumber FROM BATCHES WHERE REG_INTERNAL_ID = ?"
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("p_reg_internal_id", 139, 1, 0, regInternalID)
			MaxBatchNumberRS.Open cmd
			cmd.Parameters.delete "p_reg_internal_id"

			if not (MaxBatchNumberRS.EOF and MaxBatchNumberRS.BOF) then
				on error resume next
				maxBatchNumber = CLng(MaxBatchNumberRS("MaxBatchNumber").Value)
				if IsNumeric(maxBatchNumber) = false or IsEmpty(maxBatchNumber) then
					maxBatchNumber = 0
				else
					maxBatchNumber =  CLng(MaxBatchNumberRS("MaxBatchNumber").Value)
				end if
				sql = "UPDATE REG_NUMBERS SET LAST_BATCH_NUMBER = ? WHERE REG_ID = ?"
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("pMaxBatchNumber", 139, 1, 0, maxBatchNumber)
				cmd.Parameters.Append cmd.CreateParameter("pRegID", 139, 1, 0, regInternalID)
				on error resume next
				cmd.Execute
				cmd.Parameters.delete "p_reg_internal_id"
			end if
				
			'End of SYAN modification
			
			theReturn =  "Batch and associated analtyics data successfully deleted"
		end if	
	else
		RegConn.RollBackTrans
		theReturn =  Session("errors_found" & dbkey & formgroup)
	end if

	doDeleteBatch = theReturn
End Function

Function doDeleteAnalyticsMaster(dbkey,formgroup, batch_id)
		 if Not isObject(RegConn)  then
			Set RegConn= GetRegConn(dbkey, formgroup)
		end if

		RegConn.BeginTrans
		theResult = doDeleteAnalytics(RegConn,dbkey, formgroup, batch_id)
		if instr(theResult, "error")> 0 then
			RegConn.RollBackTrans
			theReturn = "analtyics not deleted. errors occured: " & err.number & err.Description
			Session("errors_found" & dbkey & formgroup) = theReturn
		else
			RegConn.CommitTrans
			theReturn= "analtyics successfully deleted"
		end if
		doDeleteAnalyticsMaster = theReturn
End Function

Function doDeleteAnalytics(ByRef RegConn, dbkey, formgroup,batch_id)
		Set RS = Server.CreateObject("ADODB.Recordset")
		
		Set cmd = Server.CreateObject("adodb.command")
		if Not isObject(RegConn) then
			Set RegConn= getRegConn(dbkey, formgroup)
		end if
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
	
		sql = "Select experiment_id from experiments where experiment_batch_id =?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pbatch_id", 139, 1, 0, batch_id)
		RS.Open cmd
		
		
		If Not (RS.BOF and RS.EOF) then
			RS.MoveFirst
			Do While Not RS.EOF
				experiment_id = RS("experiment_id")
				theResult = DoDeleteExperiment(RegConn, dbkey, formgroup,experiment_id)
				if instr(theResult,"error")> 0  then
					doDeleteAnalytics="analytics not deleted due to the following errors: " & err.number & err.description
					exit function
				end if
			RS.MoveNext
			Loop
		end if
		
		'check for errors and rollback if necessary
		if err.number <> 0 then
			
			message = "analytics not deleted due to the following errors: " & err.number & err.description
		else
			
			message = "analytics has been deleted"
		end if
		
		DoDeleteAnalytics=message
End Function

Function DoDeleteExperimentMaster(dbkey,formgroup, experiment_id)
		 if Not isObject(RegConn)  then
			Set RegConn=GetRegConn(dbkey, formgroup)
		end if

		
		RegConn.BeginTrans
		theResult = DoDeleteExperiment(RegConn,dbkey, formgroup, experiment_id)
		if instr(theResult, "error")> 0 then
			RegConn.RollBackTrans
			theReturn = "experiment not deleted. errors occured: " & err.number & err.Description
			Session("errors_found" & dbkey & formgroup) = theReturn
		else
			RegConn.CommitTrans
			theReturn= "experiment successfully deleted"
		end if
		DoDeleteExperimentMaster = theReturn
End Function

Function DoDeleteExperiment(ByRef RegConn, dbkey, formgroup,experiment_id)
		
	
		if Not isObject(RegConn) then
			Set RegConn= getRegConn(dbkey, formgroup)
		end if

		
			
		'delete experiments from mixreg_results table
		set cmd = server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		sql = "Delete from results where result_experiment_id=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pexperiment_id", 139, 1, 0, experiment_id)
		cmd.execute
		
		
		'delete references experiments from mixreg_pars table
		set cmd = server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		sql = "Delete from parameters where parameter_experiment_id=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pexperiment_id", 139, 1, 0, experiment_id)
		cmd.execute
		
		'delete  experiments from mixreg_experiments table
		set cmd = server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		sql = "Delete from experiments where experiment_id=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pexperiment_id", 139, 1, 0, experiment_id)
		cmd.execute
	
		
		'check for errors and rollback if necessary
		if err.number <> 0 then
			message = "experiment not deleted due to the following errors: " & err.number & err.description
		else
			message = "experiment has been deleted"
		end if
		
		DoDeleteExperiment=message
End Function

Function doUpdateAnalytics(dbkey, formgroup,batch_id)
	'stop
	showErrors = False
	RelFields = Request("RelationalSearchFields")
	StrucFields = ""		
	errors_found = DoUpdateRecordMaster(dbkey, formgroup, RelFields, StrucFields, table_names)
	if not errors_found=true then
	
		theReturn = "Update completed"
	else
		theReturn = "Errors occured. Update failed" & " Errors: " & err.number & err.description
	end if

	doUpdateAnalytics = theReturnMessage
End Function

Function getDupList(dbkey, formgroup, dupList, byRef RegConn)
if  isEmpty(dupList) OR  isNull(dupList) then
	getDupList=""
	exit function
else
	
	if trim(duplist)= "REGISTERED_DELETEABLE" then
		theresult=" " & dupList
	else
		Set RS = Server.CreateObject("ADODB.RECORDSET")
		
		if Not isObject(RegConn) then
			Set RegConn= getRegConn(dbkey, formgroup)
		end if

		temp = split(dupList, ",", -1)
		bRegNum = false
		bRootNum = false
		Dim i
		for i = 0 to Ubound(temp)
			temp2 = split(temp(i), ":", -1)
			
			duptype = temp2(0)
			dupid = temp2(1)
			Dim SaltsList
			if UCase(duptype) = "ADD_SALT" then
				set cmd = server.CreateObject("adodb.command")
				cmd.ActiveConnection =  RegConn
				cmd.CommandType = adCmdText
				sql = "select distinct root_number from reg_numbers where cpd_internal_id =?"
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("pdupid", 139, 1, 0, dupid)
				RS.Open cmd
			
				If not (RS.BOF and RS.EOF) then
					bRootNum = true
					RS.MoveFirst
					if SaltsList <> "" then
						SaltsList = SaltsList & "," & RS("Root_Number")
					else
						SaltsList =  RS("Root_Number")
					end if
				end if
			end if
			Dim BatchList
			if UCase(duptype) = "BATCH_COMMIT" then
				on error resume next
				set cmd = server.CreateObject("adodb.command")
				cmd.ActiveConnection =  RegConn
				cmd.CommandType = adCmdText
				sql = "select reg_number  from reg_numbers where reg_id =?"
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("pdupid", 139, 1, 0, dupid)
				RS.Open cmd
				
				If not (RS.BOF and RS.EOF) then
					bRegNum = true
					RS.MoveFirst
					if BatchList <> "" then
						BatchList = BatchList & "," & RS("reg_number")
					else
						BatchList =  RS("reg_number")
					end if
				end if
				RS.Close
			end if
		next
		Dim theresult
		if bRegNum and bRootNum  then
			theresult = " Known Duplicates: " & BatchList & "," & "Known Duplicates: " & SaltsList
		end if
		if bRegNum and Not bRootNum then
			theresult = " Known Duplicates: " & BatchList 
		end if
		if Not bRegNum and  bRootNum then
			theresult = " Known Duplicates: " & SaltsList 
		end if
	end if
end if
getDupList = theresult
End Function



Function getPersonDisplayName(dbkey, formgroup, person_id, ByRef RegConn)
	on error resume next
	if Not isObject(RegConn) then
		Set RegConn = getRegConn(dbkey, formgroup)
	end if
	LastName =  getValueFromTablewConn(RegConn, "People", "Person_ID", person_id, "Last_Name")
	FirstName = getValueFromTablewConn(RegConn, "People", "Person_ID", person_id, "First_Name")
	displayName = FormatDisplayName(LastName, FirstName)
	if not isNull(displayName) then
		displayName = replace(displayName, "&comma;", ",")
	end if
	getPersonDisplayName = displayName
End Function

Function FormatDisplayName(LastName, FirstName)
		if FirstName <> "" then
			'SYAN modified on 4/27/2007 to fix CSBR-74825
			'theResult = LastName & "&comma; " & Left(FirstName,1) & "."  
			theResult = LastName & "&comma; " & FirstName  
			'End of SYAN modification
		else
			theResult = LastName 
		end if
		FormatDisplayName= theResult
End Function

'People List DropDown

Function GetPeopleList(ByRef RegConn)
	Set PeopleRS = Server.CreateObject("ADODB.Recordset")
	Set cmd = Server.CreateObject("adodb.command")
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	
	sql="Select person_id,active,last_name,first_name from People where person_id >?  order by last_name"
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("pperson_id", 139, 1, 0, 1)
	PeopleRS.Open cmd
	
	PeopleRS.MoveFirst
	'PeopleRSIDS = "0:unspecified"
	if NOT UCase(Request("formmode"))="SEARCH" then
		while PeopleRS.EOF <> TRUE    
			if Not CBool(PeopleRS("Active")) =FALSE  THEN
				LastName = PeopleRS("last_name")
				FirstName = PeopleRS("first_name")
				theName = FormatDisplayName(LastName, FirstName)
				
				'response.write theName & "<br>"


				if PeopleRSIDS<> "" then
					PeopleRSIDS= PeopleRSIDS& "," & PeopleRS("person_id") & ":" &  theName
				else
					PeopleRSIDS=  PeopleRS("person_id") & ":" & theName

				end if
			end if
				PeopleRS.MoveNext	
		wend
		'Response.end
	else
		while PeopleRS.EOF <> TRUE    
			LastName = PeopleRS("last_name")
			FirstName = PeopleRS("first_name")
			theName = FormatDisplayName(LastName, FirstName)
			
				if PeopleRSIDS<> "" then
					PeopleRSIDS= PeopleRSIDS& "," & PeopleRS("person_id") & ":"  & theName
				else
					PeopleRSIDS=  PeopleRS("person_id") & ":"  & theName
				end if
			
			PeopleRS.MoveNext	
		wend
	end if
	PeopleRSIDS = "0:unspecified" & "," & PeopleRSIDS
	CloseRS(PeopleRS)
	GetPeopleList=PeopleRSIDS
End Function





Function DoRegisterAll(dbkey, formgroup,duplicate_action, sortby,sortdirection)
			
			'stop
			storeScriptTimeout= server.ScriptTimeout
			server.ScriptTimeout = 10000000
			
			If CBool(Application("USE_ANIMATED_GIF"))=true then
				FlushImageToClient(Application("ANIMATED_GIF_PATH"))
			else
				FlushMessageToClient("Registering...")
			end if
			if DetectNS = true then
				Response.Write " "
			end if
			if not detectNS4() = true then
				InitializeProgressBar false,Session("CurrentLocation" & dbkey & formgroup)
			end if
			'code for committing something from the temp table. the first part is the standard cows search
			'returns the reg_number and the type of commit
			Dim  my_array, thecounter, total_count
			 if Not isObject(RegConn)  then
				Set RegConn= GetRegConn(dbkey, formgroup)
			end if

			Set RS = Server.CreateObject("ADODB.Recordset")
			Set cmd = Server.CreateObject("adodb.command")
			cmd.ActiveConnection =  RegConn
			cmd.CommandType = adCmdText
			
			SetOracleSessionCursorSharingParameter RegConn, "force"
			
			Session("ContentsField" & dbkey & formgroup)=""
			csdo_select = "IN(select regdb.csdohitlist.ID from regdb.csdohitlist where regdb.csdohitlist.hitlistid =?)"
			if Not sortdirection <> "" then
				sortdirection = "ASC"
			end if
			If Not UCase(sortby) = "TEMP_COMPOUND_ID" then
				sql = "SELECT temp_compound_id, " & sortby & " FROM temporary_structures where rowid  " & csdo_select & " ORDER BY " & sortby & " " &  sortdirection
			else
				sql = "SELECT temp_compound_id FROM temporary_structures where rowid " & csdo_select & " ORDER BY Temp_compound_id "& " " &  sortdirection
			end if
			
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("phitlistId", 139, 1, 0, Session("hitlistid" & dbkey & formgroup) )
			RS.Open cmd
			cmd.Parameters.Delete "phitlistId"
			
			
			total_count = Session("hitlistrecordcount" & dbkey & formgroup)
			
			SetSessionVars dbkey, formgroup, "register"
			If Not (RS.EOF AND RS.BOF) then
				
				Session("count")= total_count
				'Set myConnection = CSDOGetCSDOConnection(dbkey, formgroup)
				thecounter=0
				'start commit loop
				For i = 1 to total_count
					on error resume next
					working_id = RS("TEMP_COMPOUND_ID")
					if err.number = 3021 then exit for
					commit_result = DoRegCommit(dbkey, formgroup, "batch_mode",working_id ,duplicate_action, "", RegConn)
					if inStr(UCase(commit_result), "DUPLICATE")> 0 or inStr(UCase(commit_result), "ERROR")> 0 or inStr(UCase(commit_result), "UNAPPROVED")> 0 then
						Session("DupTrackingStr" & dbkey) = Session("DupTrackingStr" & dbkey) & ";" & commit_result
					else
						Session("RegTrackingStr" & dbkey) = Session("RegTrackingStr" & dbkey) & ";" & commit_result
					end if
					if not detectNS4() = true then
						Progressbar thecounter + 1, total_count, 1
					end if
					RS.MoveNext
					thecounter=thecounter+1
				next
				CloseRS(RS)
				'CloseConn(RegConn)
			end if
			server.ScriptTimeout = storeScriptTimeout
	DoRegisterAll=thecounter & " records processed."
End Function





function getAutoGeneratedName(b64, identifier)

		if Not b64<> ""then
			getAutoGeneratedName=""
			exit function
		end if
		on error resume next
		err.Clear()
		theName=ConvertBase64CDXtoName(b64)
		if Not theName <> "" then
				logaction("unable to generate name" & identifier)
		end if
		if err.number <> 0 then
			logaction("Error Autogenerating Chemical Name" & err.number & err.Description)
		end if
		
		getAutoGeneratedName = theName
end function

		
		
	

Function setDisplayType(theKeyName_str)
	on error resume next
	if inStr(theKeyName_str, ".")> 0 then
		theKeyNameTemp = split(theKeyName_str, ".", -1)
		theKeyName = UCase(theKeyNameTemp(1))
	else
		theKeyName=theKeyName_str
	end if
	formmode = request("formmode")
	theValue = Session("DISPLAY_TYPES").ITEM(UCase(theKeyName))
	theValueArray = Split(theValue, ";", -1)
		Select Case UCase(formmode)
			Case "SEARCH"
				theReturn = theValueArray(0)
			Case "EDIT", "LIST"
				theReturn = theValueArray(1)
			Case Else
				theReturn = theValueArray(0)
		End Select
		if err.number <> 0 then
			Response.write "error in DisplayFields section of cfserver.ini for " & theKeyName
			err.Clear()
		end if
		setDisplayType = theReturn
End function

Function getDefaultValue(theKeyName_str)
	if theKeyName_str<> "" then
		display_settings = setDisplayTypeOverride("search", theKeyName_str)
		if inStr(display_settings, "!") then
			temp = split(display_settings, "!", -1)
			default_value = temp(UBound(temp))
		else
			default_value = ""
		end if
	else
		default_value=""
	end if
		getDefaultValue = default_value
end Function

Function setDisplayTypeOverride(formmode,theKeyName_str)
	on error resume next
	if inStr(theKeyName_str, ".")> 0 then
		theKeyNameTemp = split(theKeyName_str, ".", -1)
		theKeyName = UCase(theKeyNameTemp(1))
	else
		theKeyName=theKeyName_str
	end if
	theValue = Session("DISPLAY_TYPES").ITEM(UCase(theKeyName))
	theValueArray = Split(theValue, ";", -1)
		Select Case UCase(formmode)
			Case "SEARCH"
				theReturn = theValueArray(0)
			Case "EDIT", "LIST"
				theReturn = theValueArray(1)
			Case Else
				theReturn = theValueArray(0)
		End Select
		if err.number <> 0 then
			Response.write "error in DisplayFields section of cfserver.ini for " & theKeyName
			err.Clear()
		end if
		setDisplayTypeOverride = theReturn
End function

Function setBackGroundDisplay(columntype, theKeyName_str)
	on error resume next
	if inStr(theKeyName_str, ".")> 0 then
		theKeyNameTemp = split(theKeyName_str, ".", -1)
		theKeyName = UCase(theKeyNameTemp(1))
	else
		theKeyName=theKeyName_str
	end if
	'formmode = request("formmode")
	theValue = Session("DISPLAY_TYPES").ITEM(UCase(theKeyName))
	if Instr(UCase(theValue),"CHECKBOX")>0 then
		setBackGroundDisplay = ""
	else
		if  UCasE(columntype) = "C1" then
			setBackGroundDisplay=td_bgcolor_c1
		else
			setBackGroundDisplay=td_bgcolor_c2
		end if
	end if
	
End function

Function getLabelName(theKeyName_str)
	if inStr(theKeyName_str, ".")> 0 then
		theKeyNameTemp = split(theKeyName_str, ".", -1)
		theKeyName = UCase(theKeyNameTemp(1))
	else
		theKeyName=theKeyName_str
	end if
	myVar = Session("FIELD_LABELS").ITEM(UCase(theKeyName))
	getLabelName=myVar
End Function

Function checkHideField(theKeyName_str)
	if inStr(theKeyName_str, ".")> 0 then
		theKeyNameTemp = split(theKeyName_str, ".", -1)
		theKeyName = UCase(theKeyNameTemp(1))
	else
		theKeyName=UCase(theKeyName_str)
	end if
	
	formmode = UCase(Request("formmode"))
	if Session("GUI_FIELDS_TO_HIDE").Exists(theKeyName) then
	
			checkHideField = True
	else
		
		If (inStr(UCASE(formmode), "ADD_") >0 or inStr(UCASE(formmode), "EDIT_") >0 ) AND  Session("DERIVED_FIELDS").Exists(UCase(theKeyName)) then
			checkHideField = True
		else
			checkHideField = False
		end if
	end if
	
End Function

Function checkHideField_Ignore_Derived(theKeyName_str)
	
	if inStr(theKeyName_str, ".")> 0 then
		theKeyNameTemp = split(theKeyName_str, ".", -1)
		theKeyName = UCase(theKeyNameTemp(1))
	else
		theKeyName=UCase(theKeyName_str)
	end if
	
	formmode = UCase(Request("formmode"))
	if Session("GUI_FIELDS_TO_HIDE").Exists(theKeyName) then
		checkHideField_Ignore_Derived = True
	else
		checkHideField_Ignore_Derived = False
	end if
	
End Function

Function isDerived(theKeyName_str, output_string)
	
	if inStr(theKeyName_str, ".")> 0 then
		theKeyNameTemp = split(theKeyName_str, ".", -1)
		theKeyName = UCase(theKeyNameTemp(1))
	else
		theKeyName=UCase(theKeyName_str)
	end if
	formmode = UCase(Request("formmode"))
	if Session("DERIVED_FIElDS").Exists(theKeyName) AND formmode = "EDIT_RECORD" then
		final_output_string = "raw_no_edit"
	else
		final_output_string = output_string
	end if
	isDerived = final_output_string
end Function

Function rePostQuery(querystring, user_id, user_pwd)
	
	Dim Connection,HttpRequest
	Dim HostName,StatusCode,Target,Referrer,Data,FormHeaders
	Dim HTTP_QUERY_STATUS_CODE,HTTP_QUERY_STATUS_TEXT
	Dim httpResponse
	HostName = Request.ServerVariables("Server_Name")
	'CSBR# 139459
	'Purpose: To append portnumber to the hostname, if a non-standard port number is used.
	Dim portNumber	
	portNumber = Request.ServerVariables("SERVER_PORT")
    if portNumber <> "80" then
	    HostName = HostName & ":" & portNumber 
	end if
	'End of change

	on error resume next
	RequestType = 1 ' 0 means GET, 1 means POST
	HTTP_QUERY_STATUS_CODE = 19
	HTTP_QUERY_STATUS_TEXT = 20
	
	theArray = split(querystring, "?", -1)
	Target = theArray(0)
	Referrer = "CambridgeSoft CSHTTP"
	Data = theArray(1)
	if user_id <> "" then
		Data = Data & "&user_id=" & user_id & "&user_pwd=" & user_pwd
	end if 
	
	FormHeaders = "Content-Type: application/x-www-form-urlencoded"
	set Connection = Server.CreateObject("CSHttp.Connection")
	Connection.Open (HostName)
	set HttpRequest = Connection.Requests.Add(RequestType, Target, Referrer, Data, FormHeaders)
	HttpRequest.Send
	StatusCode = httpRequest.Info(HTTP_QUERY_STATUS_CODE, 0)+""
	If StatusCode <> "200" then
		httpResponse = httpRequest.Info(HTTP_QUERY_STATUS_TEXT, 0)
	Else
		httpResponse = httpRequest.Response
	End If
	if inStr(httpResponse, "invalid username or password")>0 then
		Response.Write httpResponse
		Response.end
    end if
    rePostQuery = httpResponse
End Function


'PEOPLE_PROJECT Functions

Function GetPeopleBoundProjectList(ByRef RegConn, project_id)
	Set PeopleRS = Server.CreateObject("ADODB.Recordset")
	Set cmd = Server.CreateObject("adodb.command")
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn

	

	cmd.CommandType = adCmdText
	
	sql="Select last_name, first_name, userid, person_id, user_id from People,People_Project where people.person_id = people_project.person_id and people_project.project_id=?  order by last_name"
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("pproject_id", 139, 1, 0, project_id)
	PeopleRS.Open cmd
	
	PeopleRS.MoveFirst
	if NOT UCase(Request("formmode"))="SEARCH" then
		while PeopleRS.EOF <> TRUE    
			if Not CBool(PeopleRS("Active")) =FALSE THEN
				LastName = PeopleRS("last_name")
				FirstName = PeopleRS("first_name")
				theName = FormatDisplayName(LastName, FirstName)
				if PeopleRSIDS<> "" then
					PeopleRSIDS= PeopleRSIDS& "," & PeopleRS("person_id") & ":" &  theName
				else
					PeopleRSIDS=  PeopleRS("person_id") & ":" & theName

				end if
			end if
				PeopleRS.MoveNext	
		wend
	else
		while PeopleRS.EOF <> TRUE    
			LastName = PeopleRS("last_name")
			FirstName = PeopleRS("first_name")
			theName = FormatDisplayName(LastName, FirstName)
			if PeopleRSIDS<> "" then
				PeopleRSIDS= PeopleRSIDS& "," & PeopleRS("person_id") & ":"  & theName
			else
				PeopleRSIDS=  PeopleRS("person_id") & ":"  & theName
			end if
			PeopleRS.MoveNext	
		wend
	end if
	CloseRS(PeopleRS)
	GetPeopleBoundProjectList=PeopleRSIDS
End Function

Function GetProjectsForUserList(ByRef RegConn)

	Set ProjectRS = Server.CreateObject("ADODB.Recordset")
	Set cmd = Server.CreateObject("adodb.command")
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn

	cmd.CommandType = adCmdText
	
	DBMSUser_ID = UCase(Session("CurrentUser" & dbkey))
	on error resume next
	sql = "Select projects.Project_Internal_ID, projects.Project_Name, projects.Active from projects, people,people_project where projects.project_internal_id=people_project.project_id " &_
			" AND people.person_id=people_project.person_id " &_
			" AND Upper(people.user_id)=? order by project_name"
	
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("pUser_id", 200, 1, Len(DBMSUSER_ID) + 1, UCase(Trim(DBMSUser_ID)))
	ProjectRS.Open cmd
	
	
	if err.number <> 0 then
		response.Write err.number & err.Description & sql
	end if
	
	if Not (ProjectRS.BOF and ProjectRS.EOF) then
		ProjectRS.MoveFirst	
		if NOT UCase(Request("formmode"))="SEARCH" then
			while ProjectRS.EOF <> TRUE   
				
				if Not CBool(ProjectRS("Active")) =false THEN
					if not isNull(ProjectRS("Project_Name")) then   
						project_name = replace(ProjectRS("Project_Name"), ",", "&comma;")
						if ProjectIDS <> "" then
							ProjectIDS = ProjectIDS & ","  & ProjectRS("Project_Internal_ID") & ":" & project_name
						else
							ProjectIDS = ProjectRS("Project_Internal_ID") & ":" & project_name
						end if
					end if
				end if
						ProjectRS.MoveNext	
			wend
			
		else
			while ProjectRS.EOF <> TRUE  
				if not isNull(ProjectRS("Project_Name")) then    
					project_name = replace(ProjectRS("Project_Name"), ",", "&comma;")
					if ProjectIDS <> "" then
						ProjectIDS = ProjectIDS & ","  & ProjectRS("Project_Internal_ID") & ":" & project_name
					else
						ProjectIDS = ProjectRS("Project_Internal_ID") & ":" & project_name
					end if
				end if
				ProjectRS.MoveNext	
			wend
		end if
		else
			ProjectIDS = ""
		end if
	CloseRS(ProjectRS)
	
	
	GetProjectsForUserList=ProjectIDS
End Function 

'SYAN modified on 11/17/2006 to fix CSBR-72269
Function GetBatchProjectsForOwnerList(ByRef RegConn)
	'stop
	Set ProjectRS = Server.CreateObject("ADODB.Recordset")
	Set cmd = Server.CreateObject("adodb.command")
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn

	cmd.CommandType = adCmdText
	
	DBMSUser_ID = UCase(Session("CurrentUser" & dbkey))
	on error resume next
	'SYAN modified on 5/9/2007 to fix csbr-77778
	sql = "select distinct Batch_Projects.batch_project_id, Batch_Projects.Project_Name, Batch_Projects.Owner_id, Batch_Projects.Active from batch_projects, projects where batch_projects.owner_id is null or batch_projects.owner_id = projects.project_internal_id order by project_name"
	'End of SYAN modification
	
	cmd.CommandText = sql
	ProjectRS.Open cmd
	
	
	if err.number <> 0 then
		response.Write err.number & err.Description & sql
	end if
	
	if Not (ProjectRS.BOF and ProjectRS.EOF) then
		ProjectRS.MoveFirst	
		if NOT UCase(Request("formmode"))="SEARCH" then
			while ProjectRS.EOF <> TRUE   
				
				if Not CBool(ProjectRS("Active")) =false THEN
					if not isNull(ProjectRS("Project_Name")) then   
						project_name = replace(ProjectRS("Project_Name"), ",", "&comma;")
						if ProjectIDS <> "" then
							ProjectIDS = ProjectIDS & ","  & ProjectRS("batch_project_id") & ":" & project_name
						else
							ProjectIDS = ProjectRS("batch_project_id") & ":" & project_name
						end if
					end if
				end if
						ProjectRS.MoveNext	
			wend
			
		else
			while ProjectRS.EOF <> TRUE  
				if not isNull(ProjectRS("Project_Name")) then    
					project_name = replace(ProjectRS("Project_Name"), ",", "&comma;")
					if ProjectIDS <> "" then
						ProjectIDS = ProjectIDS & ","  & ProjectRS("batch_project_id") & ":" & project_name
					else
						ProjectIDS = ProjectRS("batch_project_id") & ":" & project_name
					end if
				end if
				ProjectRS.MoveNext	
			wend
		end if
		else
			ProjectIDS = ""
		end if
	CloseRS(ProjectRS)
	
	
	GetBatchProjectsForOwnerList=ProjectIDS
End Function 
'End of SYAN modification

Function GetCurrentProjectUsers(dbkey, formgroup, byRef RegConn, return_field1, return_field2, return_field3, return_field4, orderby, project_id)
	'stop
	Set RS = Server.CreateObject("adodb.recordset")
	Set cmd = Server.CreateObject("adodb.command")
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	cmd.ActiveConnection =  RegConn

	cmd.CommandType = adCmdText
	
	sql ="SELECT people.* from people,people_project " &_
		" WHERE people.person_id=people_project.person_id " &_
		" AND people_project.project_id=?" &_
		" ORDER BY " & orderby
		
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("pproject_id", 139, 1, 0, project_id)
	RS.Open cmd
	
	isOK = checkErrors(RegConn)
	if isOK <> "" then
		Response.Write isOK
		current_project_user_list = ""
	else
		'SYAN modified on 10/20/2005 to fix CSBR-58112
		'current_project_user_list = GetLookupList(RS,return_field1, return_field2)
		
		if not (RS.BOF and RS.EOF) then
			RS.MoveFirst
			Do While Not RS.EOF
				if current_project_user_list <> "" then
				 	current_project_user_list = current_project_user_list & "," & RS.fields(return_field1) & ":" & RS.fields(return_field2) & ":" & RS.fields(return_field3) & ":" & RS.fields(return_field4)
				else
					current_project_user_list = RS.fields(return_field1) & ":" & RS.fields(return_field2) & ":" & RS.fields(return_field3) & ":" & RS.fields(return_field4)
				end if
				RS.MoveNext
			loop
		end if
		'End of SYAN modification
	end if
	GetCurrentProjectUsers = current_project_user_list

	CloseRS(RS)
End Function


Function ListAllUsersOrdered(dbkey, formgroup, RegConn, priv_table, return_field1, return_field2, return_field3, return_field4, order_by)
	'stop
	on error resume next
	 if Not isObject(RegConn)  then
		call GetRegConn(dbkey,formgroup)
	end if
	Set RS = Server.CreateObject("adodb.recordset")
	Set cmd = Server.CreateObject("adodb.command")
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	
	sql="Select * from People where person_id >? and active = ?"  &_
			" Order by " & order_by
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("pPersonID", 139, 1, 0, 0)
	cmd.Parameters.Append cmd.CreateParameter("pActive", 139, 1, 0, 1)
	RS.Open cmd
	
	isOK = checkErrors(RegConn)
	if isOK <> "" then
		Response.Write isOK
		theUserList = ""
	else
		
		'SYAN modified on 10/20/2005 to fix CSBR-58112
		'current_project_user_list = GetLookupList(RS,return_field1, return_field2)
		
		if not (RS.BOF and RS.EOF) then
			RS.MoveFirst
			Do While Not RS.EOF
				if theUserList <> "" then
				 	theUserList = theUserList & "," & RS.fields(return_field1) & ":" & RS.fields(return_field2) & ":" & RS.fields(return_field3) & ":" & RS.fields(return_field4)
				else
					theUserList = RS.fields(return_field1) & ":" & RS.fields(return_field2) & ":" & RS.fields(return_field3) & ":" & RS.fields(return_field4)
				end if
				RS.MoveNext
			loop
		end if
		'End of SYAN modification
		
	end if
	ListAllUsersOrdered = theUserList
	CloseRS(RS)
End Function


Function getPersonUserListSQL(ByRef RegConn, dbkey, formgroup, priv_table, order_by)
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	
		'privTableRolesSQL= "SELECT distinct role_name from security_roles"
		'privTableRolesSQL = getPrivTableRoleSQL(dbkey, formgroup, priv_table)
		'sql = "Select People.* from people, dba_role_privs " &_
			'" WHERE dba_role_privs.grantee=people.user_id " &_
			''" AND dba_role_privs.granted_role IN(" & privTableRolesSQL & ")" &_
			'" Order by " & order_by
			
		sql = "Select * from People where person_id >0 and active = 1"  &_
			" Order by " & order_by
	getPersonUserListSQL = sql
	
end function

Function doUpdatePeopleProject(dbkey, formgroup, project_id, people_project_users_list)	
				Session("storeSessionUser" & dbkey) = Session("UserName" & dbkey)
				Session("storeSessionPWD" & dbkey) = Session("UserID" & dbkey)
				Session("UserName" & dbkey) = Application("REG_USERNAME")
				Session("UserID" & dbkey) =  Application("REG_PWD")

				table_names = "PROJECTS"
				StrucFields= ""
				RelFields = Request("RelationalSearchFields")
				errors_found = DoUpdateRecordMaster(dbkey, formgroup, RelFields, StrucFields, table_names)
				Session("UserName" & dbkey) = Session("storeSessionUser" & dbkey)
				Session("UserID" & dbkey) = Session("storeSessionPWD" & dbkey)
				if errors_found = false then
					Session("storeSessionUser" & dbkey) = Session("UserName" & dbkey)
					Session("storeSessionPWD" & dbkey) = Session("UserID" & dbkey)
					Session("UserName" & dbkey) = Application("REG_USERNAME")
					Session("UserID" & dbkey) =  Application("REG_PWD")
					
					 if Not isObject(RegConn)  then
						set RegConn= GetRegConn(dbkey,formgroup)
					end if
					Set cmd = Server.CreateObject("adodb.command")
					cmd.ActiveConnection =  RegConn
					cmd.CommandType = adCmdText
					
					Session("UserName" & dbkey) = Session("storeSessionUser" & dbkey)
					Session("UserID" & dbkey) = Session("storeSessionPWD" & dbkey)
					RegConn.BeginTrans
					sql = "DELETE FROM PEOPLE_PROJECT WHERE PROJECT_ID=?"
					
					cmd.CommandText = sql
					cmd.Parameters.Append cmd.CreateParameter("pProject_id", 139, 1, 0,project_id)
					
					cmd.execute
					cmd.Parameters.Delete "pProject_id"
					
					
					
					temp_array = Split(people_project_users_list, ",", -1)
					for i = 0 to UBound(temp_array)
						temp_array2 = split(temp_array(i), ":", -1)
						person_id = temp_array2(0)
						'insert into people project
						set cmd = server.CreateObject("adodb.command")
						cmd.ActiveConnection =  RegConn
						cmd.CommandType = adCmdText
						sql = "INSERT INTO PEOPLE_PROJECT(PROJECT_ID, PERSON_ID)VALUES(?,?)"
						cmd.CommandText = sql
						cmd.Parameters.Append cmd.CreateParameter("pProject_id", 139, 1, 0,project_id)
						cmd.Parameters.Append cmd.CreateParameter("pPerson_id", 139, 1, 0,person_id)
						cmd.execute
						cmd.Parameters.Delete "pProject_id"
						cmd.Parameters.Delete "pPerson_id"
					next
					
					if  not err.number <> 0 then
						RegConn.CommitTrans
						theReturn = "Project and Users Added"
					else
						RegConn.RollBackTrans
						theReturn ="commit to people_project table failed: " & err.description 
						Session("errors_found" & dbkey & formgroup) = theReturn
					end if
					'CloseConn(RegConn)
				else
					theReturn = Session("errors_found" & dbkey & formgroup)
					
				end if
				
				doUpdatePeopleProject=theReturn
End Function

Function DoDeletePeopleProject(dbkey, formgroup, project_id)
		Session("storeSessionUser" & dbkey) = Session("UserName" & dbkey)
		Session("storeSessionPWD" & dbkey) = Session("UserID" & dbkey)
		Session("UserName" & dbkey) = Application("REG_USERNAME")
		Session("UserID" & dbkey) =  Application("REG_PWD")
		'first check whether any batches reference this project
		
		if Not isObject(RegConn)  then
			set RegConn= GetRegConn(dbkey,formgroup)
		end if
		Set RS = Server.CreateObject("ADODB.Recordset")
		Set cmd = Server.CreateObject("adodb.command")
		 if Not isObject(RegConn)  then
			Call getRegConn(dbkey, formgroup)
		end if
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
					
		Session("UserName" & dbkey) = Session("storeSessionUser" & dbkey)
		Session("UserID" & dbkey) = Session("storeSessionPWD" & dbkey)
		
		sql = "select count(cpd_internal_id) as theCount from compound_project where project_internal_id=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pProject_id", 139, 1, 0,project_id)
		RS.Open cmd
		cmd.Parameters.Delete "pProject_id"
		
		theCount = RS("theCount")
		
		if CLng(theCount) > 0 then
			theReturn = "This project is referenced by " & theCount & " compounds.  Deletion failed."
			Session("errors_found" & dbkey & formgroup) = theReturn
		else
			showErrors = False
			delete_order = "People_Project,Projects"
			table_names = 	"People_Project,Projects"
			
			errors_occured = DoDeleteRecordMaster(dbkey, formgroup, table_names, delete_order) 'this calls doDeleteRecord as before
		
			if errors_occured = True then
				theReturn = Session("errors_found" & dbkey & formgroup)
			else
				theReturn = "Record deleted"
			end if
		end if
		
		DoDeletePeopleProject=theReturn
End Function

Function DoAddPeopleProject(dbkey, formgroup,people_project_users_list)
		SetSessionVars dbkey, formgroup, "add_record"
		GetSearchData dbkey, formgroup
		field_names=Session("SearchData" & "Relational" & dbkey & formgroup)
		AddOrder =""
		table_names="PRoJECTS"
		field_names=Session("SearchData" & "Relational" & dbkey & formgroup)
		Session("storeSessionUser" & dbkey) = Session("UserName" & dbkey)
		Session("storeSessionPWD" & dbkey) = Session("UserID" & dbkey)
		Session("UserName" & dbkey) = Application("REG_USERNAME")
		Session("UserID" & dbkey) =  Application("REG_PWD")
		errors_found = False
		errors_found = DoAddRecordMaster(dbkey, formgroup, table_names, field_names, AddOrder)
		Session("UserName" & dbkey) = Session("storeSessionUser" & dbkey)
		Session("UserID" & dbkey) = Session("storeSessionPWD" & dbkey)
			if errors_found = False then
				Session("storeSessionUser" & dbkey) = Session("UserName" & dbkey)
				Session("storeSessionPWD" & dbkey) = Session("UserID" & dbkey)
				Session("UserName" & dbkey) = Application("REG_USERNAME")
				Session("UserID" & dbkey) =  Application("REG_PWD")
				if Not isObject(RegConn)  then
					set RegConn= GetRegConn(dbkey,formgroup)
				end if
				Set cmd = Server.CreateObject("adodb.command")
				cmd.ActiveConnection =  RegConn
				cmd.CommandType = adCmdText
				Session("UserName" & dbkey) = Session("storeSessionUser" & dbkey)
				Session("UserID" & dbkey) = Session("storeSessionPWD" & dbkey)
				RegConn.BeginTrans
				project_id =Session("ADD_RECORD_NEW_ID" & dbkey & formgroup)
				temp_array = Split(people_project_users_list, ",", -1)
					for i = 0 to UBound(temp_array)
						temp_array2 = split(temp_array(i), ":", -1)
						person_id = temp_array2(0)
						'insert into people project
						set cmd = server.CreateObject("adodb.command")
						cmd.ActiveConnection =  RegConn
						cmd.CommandType = adCmdText
						sql = "INSERT INTO PEOPLE_PROJECT(PROJECT_ID, PERSON_ID)VALUES(?,?)"
						cmd.CommandText = sql
						cmd.Parameters.Append cmd.CreateParameter("pProject_id", 139, 1, 0,project_id)
						cmd.Parameters.Append cmd.CreateParameter("pPerson_id", 139, 1, 0,person_id)
						cmd.execute
						cmd.Parameters.Delete "pProject_id"
						cmd.Parameters.Delete "pPerson_id"
					next
					
					if  not err.number <> 0 then
						RegConn.CommitTrans
						theReturn = "Project and assoicated users Added"
					else
						RegConn.RollBackTrans
						theReturn ="commit to batch_projects table failed: " & err.description 
						Session("errors_found" & dbkey & formgroup) = theReturn
					end if
					'CloseConn(RegConn)
			else
				theReturn = "commit to people_project table failed " & Session("errors_found" & dbkey & formgroup)
					
			end if
			
		DoAddPeopleProject=theReturn
End Function

Sub addDuplicateEntry(dbkey, formgroup, ByRef RegConn,ByRef CommitRS, dups_mol_ids,  cpd_internal_id)
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	LoadID=Session("Load_ID")
	if  isNull(LoadID) then
		LoadID = ""
	end if
	theSessionID= Session("DateTime_Stamp")
	
	if instr(dups_mol_ids, ",")> 0 then
		temp_array = split(dups_mol_ids, ",", -1)
		for i = 0 to UBound(temp_array)
			on error resume next
			cpd_id_dup=getCPDFromMolID(dbkey, formgroup, CommitRS, RegConn, temp_array(i))
			sql = "Select compound_id from duplicates where compound_id='" & cpd_internal_id & " AND duplicate=" & cpd_id_dup
			set cmd = server.CreateObject("adodb.command")
			cmd.ActiveConnection =  RegConn
			cmd.CommandType = adCmdText
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("pcpd_id", 139, 1, 0,cpd_internal_id)
			cmd.Parameters.Append cmd.CreateParameter("pcpd_id_dup", 139, 1, 0,cpd_id_dup)
			CommitRS.Open cmd
			
			
			if (CommitRS.EOF and CommitRS.BOF) then
				sql = "INSERT INTO Duplicates(compound_id, duplicate, load_id, datetime_stamp)values(?,?,?,?)"
				set cmd = server.CreateObject("adodb.command")
				cmd.ActiveConnection =  RegConn
				cmd.CommandType = adCmdText
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("pcpd_id", 139, 1, 0,cpd_internal_id)
				cmd.Parameters.Append cmd.CreateParameter("pcpd_id_dup", 139, 1, 0,cpd_id_dup)
				cmd.Parameters.Append cmd.CreateParameter("ploadID", 200, 1, Len(loadid) + 1,loadid)
				cmd.Parameters.Append cmd.CreateParameter("psessionID", 200, 1, Len(theSessionID) + 1,theSessionID)
				cmd.execute
			
			end if
			CommitRS.close
			'add reverse entry as well
			sql = "Select compound_id from duplicates where compound_id='" & cpd_id_dup & " AND duplicate=" & cpd_internal_id
			set cmd = server.CreateObject("adodb.command")
			cmd.ActiveConnection =  RegConn
			cmd.CommandType = adCmdText
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("pcpd_id_dup", 139, 1, 0,cpd_id_dup)
			cmd.Parameters.Append cmd.CreateParameter("pcpd_id", 139, 1, 0,cpd_internal_id)
			CommitRS.Open cmd
			
			LoadID=Session("Load_ID")
			if  isNull(LoadID) then
				LoadID = ""
			end if
			if (CommitRS.EOF and CommitRS.BOF) then
				sql = "INSERT INTO Duplicates(compound_id, duplicate, load_id, datetime_stamp)values(?,?,?,?)"
				set cmd = server.CreateObject("adodb.command")
				cmd.ActiveConnection =  RegConn
				cmd.CommandType = adCmdText
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("pcpd_id_dup", 139, 1, 0,cpd_id_dup)
				cmd.Parameters.Append cmd.CreateParameter("pcpd_id", 139, 1, 0,cpd_internal_id)
				cmd.Parameters.Append cmd.CreateParameter("ploadID", 200, 1, Len(loadid) + 1,loadid)
				cmd.Parameters.Append cmd.CreateParameter("psessionID", 200, 1, Len(theSessionID) + 1,theSessionID)
				cmd.execute
				
			end if
			CommitRS.close
			if err.number <> 0 then
				logaction(err.number & err.Description)
			end if
		next
	else
		LoadID=Session("Load_ID")
		if  isNull(LoadID) then
			LoadID = ""
		end if
		cpd_id_dup=getCPDFromMolID(dbkey, formgroup, CommitRS, RegConn, dups_mol_ids)
		on error resume next
		set cmd = server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		sql = "Select compound_id from duplicates where compound_id=? AND duplicate=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pcpd_id", 139, 1, 0,cpd_internal_id)
		cmd.Parameters.Append cmd.CreateParameter("pcpd_id_dup", 139, 1, 0,cpd_id_dup)
		CommitRS.Open cmd
		
		if (CommitRS.EOF and CommitRS.BOF) then
			sql = "INSERT INTO Duplicates(compound_id, duplicate, load_id, datetime_stamp)values(?,?,?,?)"
			set cmd = server.CreateObject("adodb.command")
			cmd.ActiveConnection =  RegConn
			cmd.CommandType = adCmdText
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("pcpd_id", 139, 1, 0,cpd_internal_id)
			cmd.Parameters.Append cmd.CreateParameter("pcpd_id_dup", 139, 1, 0,cpd_id_dup)
			cmd.Parameters.Append cmd.CreateParameter("ploadID", 200, 1, Len(loadid) + 1,loadid)
			cmd.Parameters.Append cmd.CreateParameter("psessionID", 200, 1, Len(theSessionID) + 1,theSessionID)
			cmd.execute
		
		end if
		CommitRS.close
		LoadID=Session("Load_ID")
		if  isNull(LoadID) then
			LoadID = ""
		end if
		'add reverse entry as well
		set cmd = server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		sql = "Select compound_id from duplicates where compound_id=? AND duplicate=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pcpd_id_dup", 139, 1, 0,cpd_id_dup)
		cmd.Parameters.Append cmd.CreateParameter("pcpd_id", 139, 1, 0,cpd_internal_id)
		CommitRS.Open cmd
		
		
		if (CommitRS.EOF and CommitRS.BOF) then
			sql = "INSERT INTO Duplicates(compound_id, duplicate, load_id, datetime_stamp)values(?,?,?,?)"
			set cmd = server.CreateObject("adodb.command")
			cmd.ActiveConnection =  RegConn
			cmd.CommandType = adCmdText
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("pcpd_id_dup", 139, 1, 0,cpd_id_dup)
			cmd.Parameters.Append cmd.CreateParameter("pcpd_id", 139, 1, 0,cpd_internal_id)
			cmd.Parameters.Append cmd.CreateParameter("ploadID", 200, 1, Len(loadid) + 1,loadid)
			cmd.Parameters.Append cmd.CreateParameter("psessionID", 200, 1, Len(theSessionID) + 1,theSessionID)
			cmd.execute
			
		end if
		CommitRS.close
		if err.number <> 0 then
			logaction(err.number & err.Description)
		end if
	end if
End Sub


Sub AddCmpdProject(dbkey, formgroup, bTEMPTABLE, ByRef RegConn,ByRef TempRS, cpdDBCounter)
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	load_id = Session("load_id")
	theSessionID= Session("DateTime_Stamp")
	on error resume next
		if bTEMPTABLE = false then
			if CBool(Application("PROJECTS_NAMED_OWNER")) = true then
				batch_project_id = Session("SearchData" & "TEMPORARY_STRUCTURES.BATCH_PROJECT_ID" & dbkey & formgroup)
				project_id = getValueFromTablewConn(RegConn, "batch_projects", "batch_project_id", batch_project_id, "owner_id")
				if isEmpty(project_id) or isZero(project_id) then
					project_id = "1"
				end if
			else
				project_id = Session("SearchData" & "temporary_structures.project_id" & dbkey & formgroup)
			end if

		else					
			project_id = TempRS("PROJECT_ID")
		end if
		
		if isEmpty(project_id) then 
			project_id = "1"
		end if
		LoadID=Session("Load_ID")
		if  isNull(LoadID) then
			LoadID = ""
		end if
		Set cmd = Server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		sql = "INSERT INTO Compound_project (CPD_INTERNAL_ID, PROJECT_INTERNAL_ID,LOAD_ID,DATETIME_STAMP)values(?,?,?,?)"
		cmd.Parameters.Append cmd.CreateParameter("pcpdDBCounter", 139, 1, 0,cpdDBCounter)
		cmd.Parameters.Append cmd.CreateParameter("pproject_id", 139, 1, 0,project_id)
		cmd.Parameters.Append cmd.CreateParameter("ploadID", 200, 1, Len(loadid) + 1,loadid)
		cmd.Parameters.Append cmd.CreateParameter("psessionID", 200, 1, Len(theSessionID) + 1,theSessionID)
		cmd.commandtext=sql
		cmd.execute
		cmd.Parameters.Delete "pcpdDBCounter"
		cmd.Parameters.Delete "pproject_id"
		cmd.Parameters.Delete "ploadID"
		cmd.Parameters.Delete "psessionID"
		
		
		if err.number <> 0 then
			failtrans = failtrans & "," & tablename & ":" & err.number & " " &  err.description
		end if
		err.clear()

End Sub

Sub RequeryDBRebuildRS(dbkey, formgroup, sql, table_name, maxhits, byRef DataConn)
	if not isObject(dataconn) then
		Set DataConn = GetNewConnection(dbkey, formgroup, "base_connection")
	end if
	Session("Base_RS" & dbkey & formgroup)= ""
	Session("SearchData" & "SearchStrategy" & dbkey & formgroup) = "rel"
	Session("SearchData" & "RelPortion" & dbkey & formgroup)=sql
	
	'clear this so if a refine is done, it will indicate that is is the first and that the base values should be stored.
	Session("Refine" & dbkey & formgroup)=""
	Session("SearchDomain" & dbkey & formgroup) = 0
	'this makes sure you reuse hit lists instead of generating a new one after each search
	Session("hitlistID" & dbkey & formgroup) = Session("BaseRShitlistID" & dbkey & formgroup) 
	basetable = table_name
	if basetable <> "" then
		baseid = GetTableVal(dbkey, basetable, kPrimaryKey)
		Session("ContentsField" & dbkey & formgroup)=basetable & "." & baseid
	else
		Session("ContentsField" & dbkey & formgroup)=""
	end if
	if maxhits= "" then maxhits = 1000000
	on error resume next
	Set rs = CSDODoCommand(sql, dbkey, formgroup, maxhits, dataconn)
	if not (rs.bof and rs.eof) then
		rsArray = rs.getRows(-1)
		Session("Base_RS" & dbkey & formgroup)= rsArray
		if Maxhits <> "" then
			UpdateArray dbkey, formgroup, Session("GetNextCount" & dbkey & formgroup)
		end if
	end if
End Sub



Function ModifyFieldResponse(post_input_string)

	dim post_input_string_2
	dim final_post_request
	post_input_string_2 = RemoveHiddenFields(post_input_string)
	final_post_request = addDisplayNames(post_input_string_2)
	ModifyFieldResponse = final_post_request
End function

Function RemoveHiddenFields(post_input_string)
	dim theReturnList
	'remove MW and FORMULA since they are virtual fields
	post_input_string = Replace(post_input_string, ",MW,", ",")  
	post_input_string = Replace(post_input_string, ",FORMULA,", ",")
	'SYAN modified on 12/5/2005 to fix CSBR-61296
	'post_input_string = Replace(post_input_string, ";ENTRY_PERSON_ID;", ",")
	'post_input_string = Replace(post_input_string, ";LAST_MOD_PERSON_ID;", ",")
	'post_input_string = Replace(post_input_string, ";LAST_MOD_DATE;", ",")
	'End of SYAN modification
	temp_array = split(post_input_string, ";", -1)
	for i = 0 to UBound(temp_array)
		test_value = temp_array(i)
		if test_value <> "" then
			if Not checkHideField_ChemLoader(test_value) then
				if theReturnList <> "" then
					theReturnList = theReturnList & ";" & test_value
				else
					theReturnList =  test_value
				end if
			end if
		end if
	Next
	RemoveHiddenFields = theReturnList
end function

Function addDisplayNames(post_input_string)
	dim theReturnList
	temp_array = split(post_input_string, ";", -1)
	for i = 0 to UBound(temp_array)
		test_value = temp_array(i)
		if test_value <> "" then
			display_name = getLabelName(test_value)
			if not display_name <> "" then
				display_name = test_value
			end if
			display_name= replace(UCase(display_name), "<SUP>", "")
			display_name= replace(display_name, "</SUP>", "")
			if inStr (UCase(display_name), "EQUIVALENTS") > 0 then
				if inStr(test_value, "SALT") then
					display_name = display_name & " (SALT)"
				else
					display_name = display_name & " (SOLVATE)"
				end if
			end if
			if UCase(test_value) = "STRUCTURE_COMMENTS_TXT" AND CBool(Application("COMPOUND_TYPES_USED")) = true then
					display_name =  display_name & " (text)"
			end if
			if UCase(Trim(test_value)) = "COMPOUND_TYPE"  AND CBool(Application("STRUCTURE_COMMENTS_TEXT")) = true then
					display_name = display_name & " (compound_type)"
			end if
			if theReturnList <> "" then
				theReturnList = theReturnList & ";" & display_name & ":" & test_value
			else
				theReturnList = display_name & ":" & test_value
			end if
		end if
	Next
	addDisplayNames = theReturnList
End Function

Function checkHideField_ChemLoader(theKeyName_str)
	Dim theReturn
	theReturn = false
	if inStr(theKeyName_str, ".")> 0 then
		theKeyNameTemp = split(theKeyName_str, ".", -1)
		theKeyName = UCase(theKeyNameTemp(1))
	else
		theKeyName=UCase(theKeyName_str)
	end if
	if Session("GUI_FIELDS_TO_HIDE").Exists(theKeyName) then
			theReturn = True
	else
		
		If Session("DERIVED_FIELDS").Exists(theKeyName) then
			theReturn = True
		end if
	end if
	if UCase(theKeyName) = "NOTEBOOK_INTERNAL_ID" AND CBool(Application("NOTEBOOK_LOOKUP")) = false then
		theReturn = True
	end if
	if UCase(theKeyName) = "NOTEBOOK_NUMBER" AND CBool(Application("NOTEBOOK_LOOKUP")) = false then
		theReturn = True
	end if
	if UCase(theKeyName) = "NOTEBOOK_TEXT" AND CBool(Application("NOTEBOOK_LOOKUP")) = true then
		theReturn = True
	end if
	if UCase(display_name) = "COMPOUND_TYPE" AND CBool(Application("COMPOUND_TYPES_USED")) = False then
			theReturn = True
	end if
	if UCase(display_name) = "STRUCTURE_COMMENTS_TXT" AND CBool(Application("STRUCTURE_COMMENTS_TEXT")) = false then
			theReturn = True
	end if
	
	
	
	
	checkHideField_ChemLoader=theReturn
	
End Function

Function getTempTableFieldNames(dbkey, formgroup)
	'stop
	If Not Application("TempTableDisplayFields") <> "" then
		
		StoreUser = Session("UserName" & dbkey)
		StorePWD = Session("UserID" & dbkey)
		Session("UserName" & dbkey) = Application("REG_USERNAME")
		Session("UserID" & dbkey) = Application("REG_PWD")	
		
		
		set Reg_Conn= GetRegConn(dbkey,formgroup)
		
		Session("UserName" & dbkey) =StoreUser
		Session("UserID" & dbkey) = StorePWD
		Set myRS = Server.CreateObject("ADODB.RECORDSET")
		Set cmd = Server.CreateObject("adodb.command")
		cmd.ActiveConnection =  Reg_Conn
		cmd.CommandType = adCmdText
		table_name = "TEMPORARY_STRUCTURES"
		sql= "SELECT COLUMN_NAME FROM USER_TAB_COLUMNS WHERE TABLE_NAME=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pTableName", 200, 1, Len(table_name) + 1,table_name ) 
	    myRS.Open cmd
		
		If Not (myRS.BOF and myRS.EOF) then
			Session("records_found" & dbkey & formgroup)=1
		else
			Session("records_found" & dbkey & formgroup)=0
		end if
		if  Session("records_found" & dbkey & formgroup)>0 then
			on error resume next
			Do while not myrs.EOF
				if theVal <> "" and not myrs.bof then
					theVal = theVal & ";"
				end if
				
				Set myfields = myrs.fields
				return_props = "value"
				for k = 0 to myfields.count - 1
					if theVal <> "" and not k= 0then
						theVal = theVal & ","
					end if
					return_props_array = split(return_props, ",", -1)
					for l=0 to UBound(return_props_array)
						test_property = Trim(return_props_array(l))
						newval=property_val(myfields.item(k),test_property) 
						if theVal <> ""  then
							if Not (UCase(newval) = "BASE64_CDX") AND Not(UCase(newval) = "TEMP_COMPOUND_ID")then
								if l = 0 then
									theVal= theVal & newval
								else
									theVal = theVal & ";" & newval
								end if
							end if
						else
							theVal = newval
						end if
						
					next
				next
			myrs.movenext
			loop
			Set myrs = Nothing
			myrs = ""
			the_result = theVal
			CloseRS(MyRS)
			Reg_Conn.Close
			'stop
			return_result = ModifyFieldResponse(the_result)
			
			Application.Lock
				Application("TempTableDisplayFields")="TEMP_COMPOUND_ID:TEMP_COMPOUND_ID" & ";" & return_result
			Application.UnLock
		end if

	end if
	
	getTempTableFieldNames= Application("TempTableDisplayFields")
End Function 

function property_val(ByRef thefield, byval input_str)
	dim returnvalue
	properties_allowed = "NAME,SIZE,VALUE,ACTUALSIZE,DEFINEDSIZE,TYPE,ATTRIBUTES,ORIGINALVALUE,DATAFORMAT,UNDERLYINGVALUE"
	property_allowed_array= split(properties_allowed, ",", -1)
		for i = 0 to UBound(property_allowed_array)
			if UCase(input_str) = UCase(property_allowed_array(i)) then
				Select Case UCase(input_str)
				Case "NAME"
					returnvalue = thefield.NAME
				Case "SIZE","ACTUALSIZE"
					returnvalue = thefield.ACTUALSIZE
				Case "TYPE"
					returnvalue = thefield.TYPE
				Case "VALUE"
					returnvalue = thefield.VALUE
				Case "ATTRIBUTES"
					returnvalue = thefield.ATTRIBUTES
				Case "ORIGINALVALUE"
					returnvalue = thefield.ORIGINALVALUE
				Case "DATAFORMAT"
					returnvalue = thefield.ORIGINALVALUE
				Case "UNDERLYINGVALUE"
					returnvalue = thefield.UNDERLYINGVALUE
				Case "DEFINEDSIZE"
					returnvalue = thefield.DEFINEDSIZE
				End Select
				exit for
			end if
		next
	property_val = returnvalue
end function


Sub doRemoveRequired(dbkey, formgorup, remove_required)
	required_fields = GetFormGroupVal(dbkey, formgroup, kRequiredFields) & ","
	required_fields = required_fields & ","
	required_fields = replace(remove_required, tempid & "," ,  "")
	required_fields = left(required_fields, 1, len(required_fields)-1)%>
	<script language = "javascript">
		required_fields = "<%=new_required_fields%>"
	</script>
	<%
End Sub

Function GetRegConn(dbkey, formgroup)
	if Not dbkey <> "" then
		dbkey = "reg"
	end if
	if not formgroup <> "" then
		formgroup= request("formgroup")
	end if 
	'DGB reuse connection for no_gui calls
	if isObject(Session("PersitentRegConn")) then Set RegConn = Session("PersitentRegConn") 
	if not isObject(RegConn)then
		Set RegConn = GetNewConnection(dbkey, formgroup, "base_connection")
	else
		'this is for RLS support. user context is switched for doing some registration routines
		if not instr(lcase(RegConn.connectionstring), "user id=" & lcase(Session("username" & dbkey)))>0 then
			Set RegConn = GetNewConnection(dbkey, formgroup, "base_connection")
			Session("PersitentRegConn") = ""
		end if
	end if
	if NOT IsObject(Session("PersitentRegConn")) AND bPersistRegConn then Set Session("PersitentRegConn") = RegConn
	Set GetRegConn =  RegConn
End Function
' Parses the nuemrical part of a legacy reg number
' Supports numbers with either prefix, suffix or both as
' long as both delimeters are the same
Function ParseSequence(str, del)
	'SYAN modified on 11/29/2004 to fix Fujitsu problem
	If IsNull(str) = false then
		Dim fd
		Dim sd
		Dim sq
    
		fd = InStr(1, str, del) ' fd is first (prefix) delimeter
		sd = InStr(fd + 1, str, del) ' sd is second (suffix) delimeter
    
		If fd = 0 Then ' no delimeters
		    sq = str
		ElseIf sd = 0 Then 'ningle delimenter
		    If fd > 4 Then  ' there is a suffix
		        sq = Left(str, fd - 1)
		    Else
		        sq = Right(str, Len(str) - fd) ' there is a prefix
		    End If
		Else
		    sq = Mid(str, fd + 1, sd - fd - 1) ' both prefix and suffix present
		End If
		If Not IsNumeric(sq) Then sq = 0
	else
		sq = 0
	end if
	'End of SYAN modification
    ParseSequence = CLng(sq)
End Function

function getListButtonCode(fieldname)
	Dim theReturn
	
	theReturn = "<script language=""javascript"">"
	theReturn = theReturn & "getOpenFileButton('" & fieldname & "')"
	theReturn = theReturn & "</script>"
	getListButtonCode = theReturn
End function
function getFirstBatchID(ByRef DataConn, reg_id)
	'determine compound owner -first batch
	Set RS = server.CreateObject("adodb.recordset")
	Set cmd = server.CreateObject("adodb.command")
	cmd.ActiveConnection =  DataConn
	cmd.CommandType = adCmdText
	sql = "Select Batch_Internal_ID From Batches where reg_internal_id=? Order by Batch_Number asc"
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("pRegID", 5, 1, 0, reg_id) 
	on error resume next
	RS.Open cmd
	RS.MoveFirst
	if Not ( RS.BOF and  RS.EOF) then
		firstBatchID= RS("Batch_Internal_ID")
		RS.Close
	end if
	Set  RS = Nothing

	getFirstBatchID = firstBatchID
end function

Function getApprovedFlag(ByRef DataConn, byVal reg_id, ByVal batch_id)
	
	Set ApprovedRS = server.CreateObject("adodb.recordset")
	Set cmd = server.CreateObject("adodb.command")
	cmd.ActiveConnection =  DataConn
	cmd.CommandType = adCmdText
	
	if UCase(Application("Approved_Scope")) = "BATCH" then
		sql = "Select Approved from Reg_Approved Where reg_internal_id =? AND Batch_Internal_ID=?"
		cmd.Parameters.Append cmd.CreateParameter("pRegID", 5, 1, 0, reg_id) 
		cmd.Parameters.Append cmd.CreateParameter("pbatch_id", 5, 1, 0, batch_id) 
	else
		sql = "Select Approved from Reg_Approved Where reg_internal_id =? AND Batch_Internal_ID IS NULL"
		cmd.Parameters.Append cmd.CreateParameter("pRegID", 5, 1, 0, reg_id) 
	end if
	cmd.CommandText = sql
	ApprovedRS.Open cmd
	if Not (ApprovedRS.BOF AND ApprovedRS.EOF) then
		theResult = True
		ApprovedRS.Close
	else
		theResult = False
	
	end if
	Set ApprovedRS = Nothing
	
	getApprovedFlag=theResult
	
end function

' DGB RegTunning
' Alternative functions that avoids querying the DB for increment/decrement record counts.
Sub UpdateTableRecordCount2(ByVal dbkey, ByVal tablename, ByVal increment)
	if increment = 1 then increment = +1
		if CBool(Application("Use_Session_Record_Counts")) then
			oldvalue = Session(tablename & "RecordCount" & dbkey) 
			if oldvalue = "" then
				newvalue = 1
			else
				newvalue = CLng(oldvalue) + cLng(increment)
			end if
			Session(tablename & "RecordCount" & dbkey) = newvalue
		else
			oldvalue = Application(tablename & "RecordCount" & dbkey)
			if oldvalue = "" then
				newvalue = 1
			else
				newvalue = CLng(oldvalue) + cLng(increment)
			end if
			Application.Lock
				Application(tablename & "RecordCount" & dbkey) = newvalue
			Application.UnLock
		end if 
end sub

Sub UpdateBaseRecordCount2(dbkey, formgroup, ByVal increment)

		basetable = getbasetable(dbkey, "base_form_group", "basetable")
		if UCase(basetable) = "BATCHES" then
			table = "BATCHES"
		else
			table = "REG_NUMBERS"
		end if
		if increment = 1 then increment = +1

		if CBool(Application("Use_Session_Record_Counts")) = true then
			oldvalue = Session(table & "RecordCount" & "REG") 
			if oldvalue = "" then
				newvalue = 1
			else
				newvalue = CLng(oldvalue) + cLng(increment)
			end if
			Session(table & "RecordCount" & "REG") = newvalue
		else
			oldvalue = Application(table & "RecordCount" & "REG")
			if oldvalue = "" then
				newvalue = 1
			else
				newvalue = CLng(oldvalue) + cLng(increment)
			end if
			Application.Lock
					Application(table & "RecordCount" & "REG") = newvalue
			Application.UnLock
		end if
end sub

'SYAN added on 10/19/2004 to avoid null to be CDbl-ed, which will throw error
Function ConvertToDbl(d)
	Dim returnVal
	If IsNull(d) = false then
		returnVal = CDbl(d)
	Else
		returnVal = d
	End if
	
	ConvertToDbl = returnVal
End Function
'End of SYAN modification

'SYAN added on 10/19/2004 to fix CSBR-46772
Function DeleteMarkedTemp(dbkey, formgroup)
	'stop
	Dim returnVal
	
	if Not isObject(RegConn) then
		Set RegConn = GetRegConn(dbkey, formgroup)
	end if
	
	MarkedHitsArray = Split(Session("MarkedHits" & dbkey & formgroup), ",")
	
	for i = 0 to UBound(MarkedHitsArray)
		RemoveFromTemp dbkey, formgroup, MarkedHitsArray(i), RegConn
	next
	
	if err.number <> 0 then
		returnVal = err.number & err.Description
	else 
		returnVal = true
	end if
	DeleteMarkedTemp = returnVal
End Function

Function DeleteMarkedPerm(dbkey, formgroup)
	'stop
	Dim returnVal
	
	if Not isObject(RegConn) then
		Set RegConn = GetRegConn(dbkey, formgroup)
	end if
	
	MarkedHitsArray = Split(Session("MarkedHits" & dbkey & formgroup), ",")
	
	for i = 0 to UBound(MarkedHitsArray)
		DoDeleteRegMaster dbkey, formgroup, MarkedHitsArray(i)
		
		if Session("MarkedHits" & dbkey & formgroup) <> "" then
			RemoveFromMarked dbkey ,formgroup,  MarkedHitsArray(i)
		end if
	next
	

	if err.number <> 0 then
		returnVal = err.number & err.Description
	else 
		returnVal = true
	end if
	DeleteMarkedPerm = returnVal
End Function


'End of SYAN modification

'SYAN added on 11/29/2004 to fix CSBR-49587
Function getTempApprovedFlag(ByRef DataConn, byVal temp_compound_id)
	Set ApprovedFlagRS = server.CreateObject("adodb.recordset")
	Set cmd = server.CreateObject("adodb.command")
	cmd.ActiveConnection =  DataConn
	cmd.CommandType = adCmdText
	
	sql = "Select Approved from Temporary_structures Where TEMP_COMPOUND_ID =?"
	cmd.Parameters.Append cmd.CreateParameter("pTempCompoundID", 5, 1, 0, temp_compound_id) 

	cmd.CommandText = sql
	ApprovedFlagRS.Open cmd
	
	if Not (ApprovedFlagRS.BOF AND ApprovedFlagRS.EOF) then
		ApprovedFlagRS.MoveFirst
		if IsNull(ApprovedFlagRS(0)) then
			retVal = False
		else
			retVal = CBool(ApprovedFlagRS(0))
		End if
	else
		retVal = False
	end if
	
	ApprovedFlagRS.Close
	Set ApprovedFlagRS = Nothing
	
	getTempApprovedFlag = retVal
	
end function
'End of SYAN modificaiton

'SYAN added on 1/18/2006 to fix CSBR-63274
Function checkForPermDuplicates(dbkey, formgroup, uID, base64Str, RegConn)
	Dim retVal
	
	if Not isObject(RegConn) then
		set RegConn= getRegConn(dbkey, formgroup)
	end if
	
	on error resume next
	
	Session("ContentsField" & dbkey & formgroup) = ""
	DupStr=DoCartridgeDuplicateSearch(dbkey, formgroup, "STRUCTURES.BASE64_CDX", Base64Str,  RegConn, "CPD_INTERNAL_ID")
	
	if DupStr <> "" then
    retVal = DupStr
    else
    retVal = ""
    end if

    checkForPermDuplicates = retVal
    End function

    Sub FillSaltSolvateInTemp(byval temp_id, byval salt_id, byval solvate_id)
    'stop
    Set sRS = Server.CreateObject("adodb.recordset")
    Set tRS = Server.CreateObject("adodb.recordset")
    Set cmd3 = Server.CreateObject("adodb.command")
    cmd3.ActiveConnection =  RegConn
    cmd3.CommandType = adCmdText
    sql = "select * from salts where salt_code = ?"
    cmd3.CommandText = sql
    cmd3.Parameters.Append cmd3.CreateParameter("psaltID", 139, 1, 0, salt_id)
    sRS.LockType=3
    sRS.CursorType=1
    sRS.Open cmd3

    cmd3.Parameters.Delete "psaltID"

    Set solRS = Server.CreateObject("adodb.recordset")
    Set cmd4 = Server.CreateObject("adodb.command")
    cmd4.ActiveConnection =  RegConn
    cmd4.CommandType = adCmdText
    sql = "select * from solvates where solvate_id = ?"
    cmd4.CommandText = sql
    cmd4.Parameters.Append cmd4.CreateParameter("psolvateID", 139, 1, 0, solvate_id)
    solRS.LockType=3
    solRS.CursorType=1
    solRS.Open cmd4

    cmd4.Parameters.Delete "psolvateID"
    'stop


    sql = "select batch_formula, formula2, mw2, formula_weight, salt_code, salt_name, salt_mw, salt_mf, salt_equivalents, solvate_id, solvate_name, solvate_mw, solvate_mf, solvate_equivalents from temporary_structures where temp_compound_id = ?"
    Set cmd5 = Server.CreateObject("adodb.command")
    cmd5.ActiveConnection =  RegConn
    cmd5.CommandType = adCmdText
    cmd5.Parameters.Append cmd5.CreateParameter("ptempID", 139, 1, 0, temp_id)
    cmd5.CommandText = sql
    tRS.LockType=3
    tRS.CursorType=1
    tRS.Open cmd5

    if not (tRS.BOF and tRS.EOF) then
    batch_formula = tRS("formula2")
    else
    batch_formula = ""
    end if
    
    'stop
    if batch_formula = "" or IsNull(batch_formula) then
    sql = "select compound_molecule.formula2 from compound_molecule, temporary_structures where compound_molecule.cpd_database_counter = temporary_structures.cpd_internal_id and temporary_structures.temp_compound_id = ?"
    Set cmd6 = Server.CreateObject("adodb.command")
    cmd6.ActiveConnection =  RegConn
    cmd6.CommandType = adCmdText
    cmd6.Parameters.Append cmd5.CreateParameter("ptempID", 139, 1, 0, temp_id)
    cmd6.CommandText = sql
    Set bRS = Server.CreateObject("adodb.recordset")
    bRS.LockType=3
    bRS.CursorType=1
    bRS.Open cmd6
    if not (bRS.BOF and bRS.EOF) then
      batch_formula = bRS("formula2")
    else
      batch_formula = ""
    end if
    end if

    if not (sRS.BOF and sRS.EOF) then

    tRS("salt_code") = sRS("SALT_CODE")
    tRS("salt_name") = sRS("SALT_NAME")
    tRS("salt_mw") = sRS("SALT_MW")
    tRS("salt_mf") = sRS("SALT_MF")

    salt_code = CInt(sRS("SALT_CODE"))
    salt_equivalents = tRS("SALT_EQUIVALENTS")
    salt_mf = sRS("SALT_MF")
    salt_mw = sRS("SALT_MW")

    if salt_code = 1 then
    salt = ""
    else
    if Cint(salt_equivalents) = 1 or Cint(salt_equivalents) = 0 then
    salt = salt_mf
    else
    salt = salt_equivalents & salt_mf
			end if
		end if
						
		if not (solRS.BOF and solRS.EOF) then

			tRS("solvate_id") = solRS("SOLVATE_ID")
			tRS("solvate_name") = solRS("SOLVATE_NAME")
			tRS("solvate_mw") = solRS("SOLVATE_MW")
			tRS("solvate_mf") = solRS("SOLVATE_MF")

			solvate_id = CInt(solRS("SOLVATE_ID"))
			solvate_equivalents = tRS("SOLVATE_EQUIVALENTS")
			solvate_mf = solRS("SOLVATE_MF")
			solvate_mw = solRS("SOLVATE_MW")
			
			if solvate_ID = 1 then
				solvate = ""
			else
				if Cint(solvate_equivalents) = 1 or Cint(solvate_equivalents) = 0 then
					solvate = solvate_mf
				else
					solvate = solvate_equivalents & solvate_mf
				end if
			end if
				

			if salt <> "" then
				batch_formula = batch_formula & "." & salt
        else
        batch_formula = batch_formula
        end if

        if solvate <> "" then
				batch_formula = batch_formula & "." & solvate
        end if

        tRS("batch_formula") = batch_formula
        end if
        'stop
        FormulaWt = DoFormulaWtCalc(dbkey, formgroup,  RegConn, tRS("mw2"), temp_id, salt_mw, salt_equivalents, solvate_mw, solvate_equivalents)
        tRS("formula_weight") = FormulaWt
        tRS.Update

        end if
        tRS.Close
        sRS.Close
        solRS.Close
        set sRS = nothing
        set tRS = nothing
        set bRS = nothing
        set cmd3 = nothing
        set cmd4 = nothing
        set cmd5 = nothing
        set cmd6 = nothing
        End Sub


        Sub ProcessMolecule(byref base64string, byref splitted, byref status, byref logEntry)
        'stop
        Set scriptFile = fso.OpenTextFile(Application("MOLECULE_PROCESS_SCRIPT"), 1) 'ForReading

        dim in_vars(0)
        dim in_vals(0)
        'dim out_vars(0)
        dim out_vars(2)

        script = scriptFile.ReadAll
        if script <> "" then
		in_vars(0) = "base64"
		in_vals(0) = base64string
		
		out_vars(0) = "out_m"
		out_vars(1) = "fragments"
		out_vars(2) = "logstring"
		'
		'out_vars(0) = "mainMol"
		'out_vars(1) = "salt"
							
		'stop
		'f = Application("soapClient").BatchExecute(script, in_vars, in_vals, out_vars, out_vals, errors)
		on error resume next
		version = Application("soapClient").Version
		

		if err.number = "424" then
			Set Application("soapClient") = CreateObject("MSSOAP.SoapClient30")
			Application("soapClient").ClientProperty("ServerHTTPRequest") = True
			On Error Resume Next
			Call Application("soapClient").MSSoapInit(Application("SERVER_TYPE") & "localhost/PyEngine/Service.asmx?wsdl")
		end if 
		
		'stop
		f = Application("soapClient").SingleExecute(script, in_vars, in_vals, out_vars, out_vals, error)
		
		'response.write "error: " & error
		'response.write "out_vals: " & out_vals
		'response.end 

		if CBool(f) = true then
			if instr(out_vals, "|||||") then								
				structureAndLog = Split(out_vals, "|||||")
				base64string = structureAndLog(0)
				splitted = structureAndLog(1)
				status = status & " " & structureAndLog(2)
				logEntry = logEntry & " " & structureAndLog(3)
			end if
		elseif error <> "" then
			status = status & " " & "PROCESS FAILED"
		end if
		'f = Application("soapClient").Execute("r=12+99", "r", retval, error)

		'base64string = out_vals
		base64string = replace(base64string, chr(13), "")
		base64string = replace(base64string, chr(10), "")
		
		trace "b64:" & base64string & "<BR>", 10
		trace "splited:" & splitted & "<BR>",10
		trace "status:" & status & "<BR>",10
			
	end if
	
End Sub

Function ApplyChemScriptRules(byref base64, byref tRS, byref salt_id, byref Salt_Equivalents, byref saltBase64, byref solvate_id, byref Solvate_Equivalents, byref solvateBase64 )
	'stop
						
	base64string_original = base64
	base64 = replace(base64, chr(13), "")
	base64 = replace(base64, chr(10), "")

	if Application("MOLECULE_PROCESS") = 1 and Application("MOLECULE_PROCESS_SCRIPT") <> "" then
	
		
		splitted = ""
		status = ""
		logEntry = ""
		ProcessMolecule base64, splitted, status, logEntry
		


	end if
							
	mainBase64 = base64
	mainFragLog = splitted
	'stop
		
							
	mainFragArr = Split(splitted, ",")
						
	if UBound(mainFragArr) > 1 then			
		'mainBase64 = mainFragArr(0)
		'mainBase64 = replace(mainBase64, "\r\n", "")
		'mainBase64 = Right(mainBase64, len(mainBase64) - 2) 'Get rid of leading ['
										
		'base64string = mainBase64
									
									
		saltArr = mainFragArr(1)
		saltInfoArr = Split(saltArr, "$$$$")
										
		Salt_Equivalents = right(saltInfoArr(0), len(saltInfoArr(0)) - 2)
										
		saltBase64 = saltInfoArr(1)
		saltBase64 = replace(saltBase64, "\r\n", "")
		trace "saltB64:" & saltBase64, 10						
		Salt_Equivalents = CInt(Salt_Equivalents)
		trace "saltEq:" & Salt_Equivalents, 10
		if Salt_Equivalents = 0 then
			salt_id = "1" 
		else
			salt_id = DoCartridgeDuplicateSearch(dbkey, "base_ctrbt_form_group", "REGDB.SALTS.BASE64_CDX", saltBase64, RegConn, "SALT_CODE")
		end if
		trace "saltid:" & salt_id, 10		
		saltStrippingStatus = ""
								
		if salt_id = "" then
			saltStrippingStatus = "warning"
			message = "There are un-recoganized salts in the structure need to be entered into salts table."
		end if
										
		solvateArr = mainFragArr(2)
		solvateInfoArr = Split(solvateArr, "$$$$")
										
		Solvate_Equivalents = right(solvateInfoArr(0), len(solvateInfoArr(0)) - 2)
		
							
		solvateBase64 = solvateInfoArr(1)
		solvateBase64 = replace(solvateBase64, "\r\n", "")
		trace "SolvateB64:" & solvateBase64, 10
		Solvate_Equivalents = CInt(Solvate_Equivalents)
		trace "solvageEq:" & Solvate_Equivalents, 10
		if Solvate_Equivalents = 0 then
			solvate_id = "1"
		else					
			solvate_id = DoCartridgeDuplicateSearch(dbkey, "base_ctrbt_form_group", "REGDB.SOLVATES.BASE64_CDX", solvateBase64, RegConn, "SOLVATE_ID")
		end if	
		trace "solvate:" & solvate_id, 10				
		if solvate_id = "" then
			saltStrippingStatus = "warning"
									
			if message <> "" then
				message = "There are un-recoganized salts and solvates in the structure need to be entered into salts and solvates table."
			else
				message = "There are un-recoganized solvates in the structure need to be entered into solvates table."
			end if
		end if
												
		'if saltStrippingLog <> "" then
		'	logEntry = saltStrippingLog
		'end if
		
		'stop
		if (salt_id = "1" and solvate_id = "1") then
			saltStrippingStatus = "STRIPPED = N/A"
		end if								
											
		if saltStrippingStatus = "warning" then
			mainBase64 = base64string_original
			saltBase64 = ""
			Salt_Equivalents = ""
			salt_id = "1"
			solvateBase64 = ""
			Solvate_Equivalents = ""
			solvate_id = "1"
			saltStrippingStatus = "STRIPPED = FAILED"
			'This is turned off for CARA, but might need to be turned back on for general release
			'showmessagedialog(message)
		elseif saltBase64 <> "" or solvateBase64 <> "" then
			saltStrippingStatus = "STRIPPED = SUCCEEDED"
		end if
			
		base64 = mainBase64
		status = status & " | " & saltStrippingStatus
	end if
	


		if salt_id = "1" or salt_id = "" then
		saltName = Session("SearchData" & "Temporary_Structures.Salt_Name" & dbkey & formgroup)
		salt_id = GetSaltCodeFromSaltName(saltName)

		salt_Equivalents = Session("SearchData" & "Temporary_Structures.Salt_Equivalents" & dbkey & formgroup)

		saltBase64 = ""
		if salt_id = "" then
			salt_id = "1"
		end if
	end if
	
	'response.write "salt_id then:" & salt_id
	'response.end

	if solvate_id = "1" or solvate_id = "" then	
		solvateName = Session("SearchData" & "Temporary_Structures.Solvate_Name" & dbkey & formgroup)
		solvate_id = GetSolvateCodeFromSolvateName(solvateName)		
		
		Solvate_Equivalents = Session("SearchData" & "Temporary_Structures.Solvate_Equivalents" & dbkey & formgroup)

		solvateBase64 = ""
		if solvate_id = "" then
			solvate_id = "1"
		end if
	end if
	
	status = Replace(status, "|||", "|")
	
	'stop
	
	if Left(status, 2) = " |" then
		status = Right(status, len(status) - 2)
	end if
	
								
	tRS("base64_cdx") = mainBase64

	tRS("base64_cdx_original") = base64string_original
	tRS("status") = status
	tRS("log") = logEntry
						
	if InStr(status, "STRIPPED = SUCCEEDED") > 0 then
		tRS("stripping_succeeded") = 1
		tRS("stripping_failed") = 0
	else
		tRS("stripping_succeeded") = 0
		tRS("stripping_failed") = 1
	end if
	
End Function

Function ReApplyChemScriptRules(dbkey, formgroup)
	
	if Not isObject(RegConn) then
		Set RegConn = GetRegConn(dbkey, formgroup)
	end if

	MarkedHitsArray = Split(Session("MarkedHits" & dbkey & formgroup), ",")
	
	
	for i = 0 to UBound(MarkedHitsArray)
		'stop

		ReApplyChemScriptRulesSingle dbkey, formgroup, CInt(MarkedHitsArray(i))
				
	next
	
	Set tmpRS = Nothing
	Set cmd = Nothing

End function

Function ReApplyChemScriptRulesSingle(dbkey, formgroup, tempID)
	
	if Not isObject(RegConn) then
		Set RegConn = GetRegConn(dbkey, formgroup)
	end if

	
	Set tmpRS = Server.CreateObject("adodb.recordset")
	Set cmd = Server.CreateObject("adodb.command")
	cmd.ActiveConnection =  RegConn
	cmd.CommandType = adCmdText
	

	'LJB 5/6 add error trapping here since very often we are finding that the errors output later on are not relevant to errors occureing at the insert step
	if err.number <> 0 then
		logaction("Error occured on selecting newly inserted record from Temporary_structures" & err.number & err.description)
	end if
	
	tmpRS.LockType=3
	tmpRS.CursorType=1
	
	'stop

	sql = "Select * from temporary_structures where temp_compound_id =?"
	cmd.CommandText = sql
	
	cmd.Parameters.Append cmd.CreateParameter("pTempCompoundID", 5, 1, 0, CInt(tempID)) 
	
	tmpRS.Open cmd
		
	if not (tmpRS.EOF and tmpRS.BOF) then
		salt_id = ""
		Salt_Equivalents = ""
		saltBase64 = ""
			
		solvate_id = ""
		Solvate_Equivalents= ""
		solvateBase64 = ""
								
		ApplyChemScriptRules tmpRS("base64_cdx_original"), tmpRS, salt_id, Salt_Equivalents, saltBase64, solvate_id, Solvate_Equivalents, solvateBase64
		
		if Salt_Equivalents <> "" then
			tmpRS("Salt_Equivalents") = CDbl(Salt_Equivalents)
		end if
			
		if Solvate_Equivalents <> "" then
			tmpRS("Solvate_Equivalents") = CDbl(Solvate_Equivalents)
		end if
			
		tmpRS.Update
		tmpRS.Close
			
		if salt_id = "" then salt_id = 1
		if solvate_id = "" then solvate_id = 1
			
		FillSaltSolvateInTemp CInt(tempID), salt_id, solvate_id

		if Session("MarkedHits" & dbkey & formgroup) <> "" then
			RemoveFromMarked dbkey ,formgroup,  tempID
		end if
		
		cmd.Parameters.Delete "pTempCompoundID"
		
	end if
	
	Set tmpRS = Nothing
	Set cmd = Nothing

End function

'DGB added on 8/20/2007 to fix invalid solvate id values
Function GetSolvateCodeFromSolvateName(sName)
	'stop
	Dim retVal
	
	if Not isObject(RegConn)  then
		Set RegConn = GetRegConn(dbkey, formgroup)
	end if
	
	Set SCodeRS = Server.CreateObject("ADODB.Recordset")
	
	sql = "select solvate_id from solvates where Upper(solvate_name) = '" & UCase(sName) & "'"

	on error resume next
	SCodeRS.Open sql, RegConn
	
	if NOT (SCodeRS.EOF AND SCodeRS.BOF) then
		SCodeRS.MoveFirst
		retVal = SCodeRS("SOLVATE_ID")
	Else
		retVal = DefaultCode
	End if
	
	CloseRS(SCodeRS)
	
	GetSolvateCodeFromSolvateName = retVal	
End Function
'End of DGB modification

'SYAN added on 10/24/2007 to fix CSBR-72137
'This function is basically identical to addDuplicateEntry except it does not look cpd_internal_id by mol_id
'Also changed not to use CommitRS since it is by other code all over the place
Sub populateDuplicateEntry(dbkey, formgroup, ByRef RegConn, dup_cpd_internal_ids,  cpd_internal_id)
	if Not isObject(RegConn) then
		Set RegConn= getRegConn(dbkey, formgroup)
	end if
	LoadID=Session("Load_ID")
	if  isNull(LoadID) then
		LoadID = ""
	end if
	theSessionID= Session("DateTime_Stamp")
	
	Set dupRS = Server.CreateObject("ADODB.Recordset")

	if instr(dup_cpd_internal_ids, ",")> 0 then
		temp_array = split(dup_cpd_internal_ids, ",", -1)
		for i = 0 to UBound(temp_array)
			on error resume next
			cpd_id_dup=temp_array(i)
			sql = "Select compound_id from duplicates where compound_id='" & cpd_internal_id & " AND duplicate=" & cpd_id_dup
			set cmd = server.CreateObject("adodb.command")
			cmd.ActiveConnection =  RegConn
			cmd.CommandType = adCmdText
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("pcpd_id", 139, 1, 0,cpd_internal_id)
			cmd.Parameters.Append cmd.CreateParameter("pcpd_id_dup", 139, 1, 0,cpd_id_dup)
			dupRS.Open cmd
			
			
			if (dupRS.EOF and dupRS.BOF) then
				sql = "INSERT INTO Duplicates(compound_id, duplicate, load_id, datetime_stamp)values(?,?,?,?)"
				set cmd = server.CreateObject("adodb.command")
				cmd.ActiveConnection =  RegConn
				cmd.CommandType = adCmdText
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("pcpd_id", 139, 1, 0,cpd_internal_id)
				cmd.Parameters.Append cmd.CreateParameter("pcpd_id_dup", 139, 1, 0,cpd_id_dup)
				cmd.Parameters.Append cmd.CreateParameter("ploadID", 200, 1, Len(loadid) + 1,loadid)
				cmd.Parameters.Append cmd.CreateParameter("psessionID", 200, 1, Len(theSessionID) + 1,theSessionID)
				cmd.execute

			
			end if
			dupRS.close
			
			'add reverse entry as well
			sql = "Select compound_id from duplicates where compound_id='" & cpd_id_dup & " AND duplicate=" & cpd_internal_id
			set cmd = server.CreateObject("adodb.command")
			cmd.ActiveConnection =  RegConn
			cmd.CommandType = adCmdText
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("pcpd_id_dup", 139, 1, 0,cpd_id_dup)
			cmd.Parameters.Append cmd.CreateParameter("pcpd_id", 139, 1, 0,cpd_internal_id)
			dupRS.Open cmd
			
			LoadID=Session("Load_ID")
			if  isNull(LoadID) then
				LoadID = ""
			end if
			if (dupRS.EOF and dupRS.BOF) then
				sql = "INSERT INTO Duplicates(compound_id, duplicate, load_id, datetime_stamp)values(?,?,?,?)"
				set cmd = server.CreateObject("adodb.command")
				cmd.ActiveConnection =  RegConn
				cmd.CommandType = adCmdText
				cmd.CommandText = sql
				cmd.Parameters.Append cmd.CreateParameter("pcpd_id_dup", 139, 1, 0,cpd_id_dup)
				cmd.Parameters.Append cmd.CreateParameter("pcpd_id", 139, 1, 0,cpd_internal_id)
				cmd.Parameters.Append cmd.CreateParameter("ploadID", 200, 1, Len(loadid) + 1,loadid)
				cmd.Parameters.Append cmd.CreateParameter("psessionID", 200, 1, Len(theSessionID) + 1,theSessionID)
				cmd.execute
				
			end if
			if err.number <> 0 then
				logaction(err.number & err.Description)
			end if
		next
		dupRS.close
else
		LoadID=Session("Load_ID")
		if  isNull(LoadID) then
			LoadID = ""
		end if
		cpd_id_dup=dup_cpd_internal_ids
		on error resume next
		set cmd = server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		sql = "Select compound_id from duplicates where compound_id=? AND duplicate=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pcpd_id", 139, 1, 0,cpd_internal_id)
		cmd.Parameters.Append cmd.CreateParameter("pcpd_id_dup", 139, 1, 0,cpd_id_dup)
		dupRS.Open cmd
		
		if (dupRS.EOF and dupRS.BOF) then
			sql = "INSERT INTO Duplicates(compound_id, duplicate, load_id, datetime_stamp)values(?,?,?,?)"
			set cmd = server.CreateObject("adodb.command")
			cmd.ActiveConnection =  RegConn
			cmd.CommandType = adCmdText
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("pcpd_id", 139, 1, 0,cpd_internal_id)
			cmd.Parameters.Append cmd.CreateParameter("pcpd_id_dup", 139, 1, 0,cpd_id_dup)
			cmd.Parameters.Append cmd.CreateParameter("ploadID", 200, 1, Len(loadid) + 1,loadid)
			cmd.Parameters.Append cmd.CreateParameter("psessionID", 200, 1, Len(theSessionID) + 1,theSessionID)
			cmd.execute
		
		end if
		dupRS.close
		LoadID=Session("Load_ID")
		if  isNull(LoadID) then
			LoadID = ""
		end if
		'add reverse entry as well
		set cmd = server.CreateObject("adodb.command")
		cmd.ActiveConnection =  RegConn
		cmd.CommandType = adCmdText
		sql = "Select compound_id from duplicates where compound_id=? AND duplicate=?"
		cmd.CommandText = sql
		cmd.Parameters.Append cmd.CreateParameter("pcpd_id_dup", 139, 1, 0,cpd_id_dup)
		cmd.Parameters.Append cmd.CreateParameter("pcpd_id", 139, 1, 0,cpd_internal_id)
		dupRS.Open cmd
		
		
		if (dupRS.EOF and dupRS.BOF) then
			sql = "INSERT INTO Duplicates(compound_id, duplicate, load_id, datetime_stamp)values(?,?,?,?)"
			set cmd = server.CreateObject("adodb.command")
			cmd.ActiveConnection =  RegConn
			cmd.CommandType = adCmdText
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("pcpd_id_dup", 139, 1, 0,cpd_id_dup)
			cmd.Parameters.Append cmd.CreateParameter("pcpd_id", 139, 1, 0,cpd_internal_id)
			cmd.Parameters.Append cmd.CreateParameter("ploadID", 200, 1, Len(loadid) + 1,loadid)
			cmd.Parameters.Append cmd.CreateParameter("psessionID", 200, 1, Len(theSessionID) + 1,theSessionID)
			cmd.execute
			
		end if
		dupRS.close
		if err.number <> 0 then
			logaction(err.number & err.Description)
		end if
	end if
End Sub
'End of SYAN modification
Sub UpdateBatchFormula(RegConn, batchId)
'stop
        Dim BatchFormulaDelimeter
        
	'TODO:  Bring out this settings to the cfserver.ini file
        BatchFormulaDelimeter = " "   
        
        set BFcmd = Server.CreateObject("adodb.command")
		BFcmd.ActiveConnection = RegConn
		BFcmd.CommandType = adCmdText
	    BFcmd.CommandText = "update batches t set t.batch_formula = (select " &_
                            "c.formula2|| " &_
                            "case   when ((b.salt_internal_id is null) OR (b.salt_internal_id = " & DefaultCode & ")) then '' " &_
                            "       else " &_ 
                            "           case    when (b.salt_equivalents = 0) then '' " &_
                            "                   when (b.salt_equivalents <>1) then '" & BatchFormulaDelimeter & "' ||b.salt_equivalents||'(' " &_
                            "                   else '" & BatchFormulaDelimeter & "' end|| " &_
                            "           case when (b.salt_equivalents > 0) then (select salt_mf from salts where salt_code= b.salt_internal_id) else '' end|| " &_
                            "           case    when (b.salt_equivalents <>1) " &_ 
                            "                   then ')' " &_ 
                            "                   else '' " &_
                            "                   end " &_
                            "end || " &_                     
                            "case   when ((b.solvate_id is null) OR (b.solvate_id = " & DefaultCode & ") ) then '' " &_
                            "       else " &_ 
                            "           case when (b.solvate_equivalents = 0) then ''" &_  
                            "                when (b.solvate_equivalents <>1) then '" & BatchFormulaDelimeter & "' ||b.solvate_equivalents||'(' " &_ 
                            "                else '" & BatchFormulaDelimeter & "' " &_ 
                            "       end ||" &_                     
                            "       case when (b.solvate_equivalents > 0) then (select solvate_mf from solvates where solvate_id= b.solvate_id) else '' end|| " &_
                            "       case  when (b.solvate_equivalents <>1) " &_ 
                            "       then ')' " &_
                            "       else '' " &_ 
                            "       end " &_            
                            "end " &_  
                            "as BatchFormula " &_            
                            "from batches b, compound_molecule c " &_
                            "where c.cpd_database_counter = b.reg_internal_id " &_
                            "and b.batch_internal_id = t.batch_internal_id)" &_
                            "where t.reg_internal_id = ?"

	    BFcmd.Parameters.Append BFcmd.CreateParameter("BatchID", 139 , 1, 0, batchId) 
		on error resume next
		BFcmd.Execute
		if err then
		    response.Write "error while executing UpdateBatchFormula :" & err.Description
		    err.Clear
		    response.end
		end if	
end sub

'SYAN added on 2/3/2008 to fix CSBR-90280
Sub FillBatchSaltInfo(salt_internal_id, CommitRS)
	
	if Not isObject(RegConn)  then
		Set RegConn = GetRegConn(dbkey, formgroup)
	end if
	
	Set SaltInfoRS = Server.CreateObject("ADODB.Recordset")
	
	sql = "select * from salts where salt_code = '" & salt_internal_id & "'"
	on error resume next
	SaltInfoRS.Open sql, RegConn
	
	if NOT (SaltInfoRS.EOF AND SaltInfoRS.BOF) then
		SaltInfoRS.MoveFirst
    CommitRS("SALT_NAME") = SaltInfoRS("SALT_NAME")
    CommitRS("SALT_MW") = SaltInfoRS("SALT_MW")
	End if
	
	CloseRS(SaltInfoRS)
	
End Sub
%>
