<%'Copyright 1998-2001 CambridgeSoft Corporation All Rights Reserved%>
<%
	
	Response.Write "<STYLE type=""text/css"">"
	Response.Write "TD {font-family: verdana, arial, ariel; font-size: 10pt;}"
	Response.Write "TH {font-family: verdana, arial, ariel; font-size: 10pt;font-weight:bold;}"
	Response.Write "BODY {font-family: verdana, arial, ariel; font-size: 10pt;}"
	Response.Write "A {font-family: verdana, arial, ariel; font-size: 10pt;}"
	Response.Write "</STYLE>"



'PURPOSE OF FILE: To add custom vbscript functions to an application
'     All form files generated by the wizard have a #INCLUDE for this file. Add
' the #INCLUDE to form files that you might add to the application.


'#####
' Checking application variable values.
'#####

Function ThisAppIsIntegratedWith( ByRef sOtherApp )
	sIntegratedApps = UCase( Application( "IntegratedWith" ) )
	if ( 0 < InStr( sIntegratedApps, UCase( sOtherApp ) ) ) then
		ThisAppIsIntegratedWith = true
	else
		ThisAppIsIntegratedWith = false
	end if
end Function

Function StandardizeHTML(sInput)
	sInput = replace(sInput,"<sub><sub><sub>","<sub>")
	sInput = replace(sInput,"</sub></sub></sub>","</sub>")
	sInput = replace(sInput,"<sub><sub>","<sub>")
	sInput = replace(sInput,"</sub></sub>","</sub>")
	
	StandardizeHTML =sInput
end function

'#####
' Supplement to structure searching.
'#####

Function DoDupsSearch( dbkey, formgroup )
	Dim ADOmolstr, compound_moltable, compound_basetable, compound_table_baseid, Base64Str
	compound_moltable = "D3_PARENTS"

	'get the base64str for this records
	Base64Str = Request.Form( "D3_PARENTS.Structure" )
	if Base64Str <> "" then
		on error resume next
		sPath = Application("TempFileDirectory" & dbkey) & "SessionDir\" & Session.SessionID & "\compound_moleculeStructure" & ".cdx"

		'decode base64 str
		DecodeBase64 Base64Str, sPath

		sql = "SELECT MOL_ID FROM "  &_
			compound_moltable & " WHERE " & _
			"EXACTSTRUCT(STRUCTURE, " & _
			"STRUCT('" & sPath & "')) > 0"
		set rs = CSDODoCommand(sql, dbkey, formgroup, "0", Conn)
		if inStr(UCase(err.source), "MOLSERVER")>0 then
			ADOmolstr = "PARSING_ERROR"
		else
			err.clear()
			if not (rs.BOF and rs.EOF) then
				do while not rs.EOF
					If ADOMolStr = "" then
						ADOMolStr = rs.Fields("MOL_ID")
					else	
						ADOMolStr = ADOMolStr & "," & rs.Fields("MOL_ID")
					end if
					rs.MoveNext
				loop
				CloseRS(rs)
			else
				ADOmolstr = ""
			end if
		end if
	else
		ADOmolstr = ""
	end if
	DoDupsSearch = ADOmolstr
End function


'#####
' Adding an argument to a URL to indicate where it was assembled.  Useful for debugging.
'#####

Function URLWithMadeInArgument( ByRef sURL_Input, ByRef sNewTag )
	Dim  sArgument
	Dim  sURL_Output
	Dim  sOldTag
	Dim  sRight
	Dim  iMadeIn
	Dim  iOldTag
	Dim  iNextArg

	' Define the argument, so we can change it in just one place.
	sArgument = "MadeIn="

	' Is the argument already in the query string?
	iMadeIn = inStr( sURL_Input, sArgument )
	if iMadeIn <= 0 then
		' The argument is not already in the URL.
		if inStr( sURL_Input, "?" ) <= 0 then
			' There is no query string in the URL yet.  Start with the "made in" string.
			sURL_Output = sURL_Input & "?" & sArgument & sNewTag
		else
			' There is already a query string in the URL.  Tack the "made in" string on.
			sURL_Output = sURL_Input & "&" & sArgument & sNewTag
		end if
	else
		' There is a "made in" string in the query string.  Replace the old tag with the new one.

		iOldTag = iMadeIn + Len( sArgument ) + 1  ' Argument + "="
		' Get the URL starting at the old value.
		sRight = Right( sURL_Input, iOldTag )

		' Extract the old tag from that string we just got.
		iNextArg = inStr( sRight, "&" )
		if iNextArg <= 0 then
			' There is nothing else _but_ the old tag in that string.
			sOldTag = sRight
		else
			' There is an argument in the query string after the old tag.  Extract the old tag.
			sOldTag = Left( sRight, iNextArg )
		end if

		' Replace the old "made in" argument and tag with the new one.  (Include the argument in
		' the replacement to avoid trouble when the tag is the same as something else in the URL.)
		sURL_Output = Replace( sURL_Input, ( sArgument & sOldTag ), ( sArgument & sNewTag ) )
	end if

	' Test the function.
	'ShowMessageInAlertDialog( "MadeIn, input: '" & sURL_Input & "'" )
	'ShowMessageInAlertDialog( "MadeIn, output: '" & sURL_Output & "'" )
	'URLWithMadeInArgument = sURL_Input

	URLWithMadeInArgument = sURL_Output
end Function


'#####
' Generating text lists for use in the COWS function ShowLookUpList().
'#####

Function GetDegCondsList( ByRef connDB )
	Set rsDegConds = Server.CreateObject( "ADODB.Recordset" )
	sSQL = "select * from D3_CONDS order by DEG_COND_TEXT"
	rsDegConds.Open sSQL, connDB

	rsDegConds.MoveFirst
	while not rsDegConds.EOF
		sCurrentItem = rsDegConds( "DEG_COND_KEY" ) & ":" & rsDegConds( "DEG_COND_TEXT" )
		if "" <> sItemsList then
			sItemsList = sItemsList & "," & sCurrentItem
		else
			sItemsList = sCurrentItem
		end if
		rsDegConds.MoveNext
	wend

	CloseRS( rsDegConds )
	GetDegCondsList = sItemsList
End Function

Function GetStatusList( ByRef connDB )
	Set rsStatusList = Server.CreateObject( "ADODB.Recordset" )
	sSQL = "select * from D3_STATUSES order by STATUS_KEY"
	rsStatusList.Open sSQL, connDB

	rsStatusList.MoveFirst
	while not rsStatusList.EOF
		sCurrentItem = rsStatusList( "STATUS_KEY" ) & ":" & rsStatusList( "STATUS_TEXT" )
		if "" <> sItemsList then
			sItemsList = sItemsList & "," & sCurrentItem
		else
			sItemsList = sCurrentItem
		end if
		rsStatusList.MoveNext
	wend

	CloseRS( rsStatusList )
	GetStatusList = sItemsList
End Function

Function GetSaltsListForDropDownBox( ByRef connDB )
	Set rsSalts = Server.CreateObject( "ADODB.Recordset" )

	sSQL = "Select * from D3_SALTS order by SALT_CODE"
	rsSalts.Open sSQL, connDB

	rsSalts.MoveFirst
	while not rsSalts.EOF
		sCurrentItem = rsSalts( "SALT_CODE" ) & ":" & rsSalts( "SALT_CODE" ) & " - " & rsSalts( "SALT_NAME" )
		if "" <> sItemsList then
			sItemsList = sItemsList & "," & sCurrentItem
		else
			sItemsList = sCurrentItem
		end if
		rsSalts.MoveNext
	wend

	CloseRS( rsSalts )
	GetSaltsListForDropDownBox = sItemsList
End Function


'#####
' Converting a list of salt codes to a list of salt names.
'#####

Function GetSaltNameListFromSaltCodeList( ByRef sCodesList )
	' Clear the names list.
	sNamesList = ""

	if "" <> sCodesList then
		' There are salts in the list.

		' Split the code list into individual code strings.
		asCodes = Split( sCodesList, ",", -1 )

		' Open a connection to the database and create a recordset for the individual salts.
		Set connBase = GetNewConnection( dbkey, formgroup, "base_connection" )

		for each sCode in asCodes
			sCode = Trim( sCode )
			sSQL = "Select * from D3_SALTS where SALT_CODE = '" & sCode & "'"
			Set rsSalt = Server.CreateObject( "ADODB.Recordset" )
			rsSalt.Open sSQL, connBase
			if "" <> sNamesList then
				' There are names on the list already.  Tack the new one onto the end.
				sNamesList = sNamesList & ", " & rsSalt.Fields( "SALT_NAME" )
			else
				' This is the first name found.  Start the names list.
				sNamesList = rsSalt( "SALT_NAME" )
			end if

			rsSalt.Close
		next  ' each sCode in asCodes

		' Close the database connection.
		connBase.Close
	end if

	GetSaltNameListFromSaltCodeList = sNamesList
End Function


'#####
' Determining whether there are records which refer to a particular record.
'#####

Function ConditionHasExperiments( ByVal keyCondition, ByRef connDB )
	' Make a record set for the experiments which are for the input condition.
	Dim	rsCondExpts
	Set rsCondExpts = Server.CreateObject( "ADODB.Recordset" )
	sSQL = "select * from D3_EXPTS where DEG_COND_FK = " & keyCondition
	rsCondExpts.Open sSQL, connDB
	if not rsCondExpts.BOF and not rsCondExpts.EOF then
		' There are records.
		ConditionHasExperiments = true
	else
		ConditionHasExperiments = false
	end if
	' Close the recordset.
	rsCondExpts.Close
end Function

'#####
' Determining whether there are records which refer to a particular record.
'#####

Function FunctionalGroupHasDegradants( ByVal keyFGroup, ByRef connDB )
	' Make a record set for the experiments which are for the input condition.
	Dim	rsFGroupDegs
	Set rsFGroupDegs = Server.CreateObject( "ADODB.Recordset" )
	'are there records in the join table?
	sSQL = "select * from D3_DegsFGroup, D3_Degs where D3_DegsFGroup.Deg_Cmpd_ID = D3_Degs.Deg_Cmpd_Key and D3_DegsFGroup.Deg_FGroup_ID = " & keyFGroup
	rsFGroupDegs.Open sSQL, connDB
	if not rsFGroupDegs.BOF and not rsFGroupDegs.EOF then
		' There are records.
		FunctionalGroupHasDegradants = true
	else
		FunctionalGroupHasDegradants = false
	end if
	' Close the recordset.
	rsFGroupDegs.Close
end Function

'#####
' Get Functional Groups
'#####

Function GetCurrentFunctionalGroups(dbkey, formgroup, byRef Conn, return_field1, return_field2, orderby, Deg_Cmpd_ID)
	Set RS = Server.CreateObject("adodb.recordset")
	Set cmd = Server.CreateObject("adodb.command")
	
	cmd.ActiveConnection =  Conn

	cmd.CommandType = adCmdText
	
	sql ="SELECT D3_FGROUPS.* from D3_FGROUPS,D3_DEGSFGROUP  " &_
		" WHERE D3_FGROUPS.Deg_FGroup_Key=D3_DEGSFGROUP.Deg_FGroup_ID " &_
		" AND D3_DEGSFGROUP.Deg_Cmpd_ID=?" &_
		" ORDER BY " & orderby
		
	cmd.CommandText = sql
	cmd.Parameters.Append cmd.CreateParameter("Deg_Cmpd_ID", 139, 1, 0, Deg_Cmpd_ID)
	RS.Open cmd
	
	
	if RS.EOF or RS.BOF then
		current_deg_fgroup_list = ""
	else
		current_deg_fgroup_list = GetLookupList(RS,return_field1, return_field2)
	end if
	GetCurrentFunctionalGroups = current_deg_fgroup_list

	CloseRS(RS)
End Function



'#####
' List FGroups
'#####
Function ListAllFGroupsOrdered(dbkey, formgroup, byRef Conn, return_field1, return_field2, order_by)
	on error resume next
	
	Set RS = Server.CreateObject("adodb.recordset")
	Set cmd = Server.CreateObject("adodb.command")
	cmd.ActiveConnection =  Conn
	cmd.CommandType = adCmdText
	
	sql="Select * from D3_FGroups Order by " & order_by
	cmd.CommandText = sql
	RS.Open cmd
	
	
	if rs.eof or rs.bof then
		theFGroupList = ""
	else
		
		theFGroupList = GetLookupList(RS,return_field1, return_field2)
		
	end if
	ListAllFGroupsOrdered = theFGroupList
	CloseRS(RS)
End Function


'#####
' Save FGroups
'#####
Function DoAddDegFGroup(dbkey, formgroup, byRef conn, deg_fgroups_list, iDeg_Cmpd_ID)
	on error resume next
	'first remove everything in the table for this deg
	'Delete the experiment.
	
	
	sSQL = "Delete from D3_DegsFgroup where Deg_Cmpd_ID = " & iDeg_Cmpd_ID
	conn.Execute sSQL

	'The following is for Oracle databases.
	conn.Execute "commit"
	
	if deg_fgroups_list <> "" then
		temp_array = Split(deg_fgroups_list, ",", -1)
		for i = 0 to UBound(temp_array)
			temp_array2 = split(temp_array(i), ":", -1)
			iDeg_FGroup_ID = temp_array2(0)
			'insert into D3_DegsFgroup
			set cmd = server.CreateObject("adodb.command")
			cmd.ActiveConnection =  conn
			cmd.CommandType = adCmdText
			sql = "INSERT INTO D3_DegsFgroup(Deg_Cmpd_ID, Deg_FGroup_ID)VALUES(?,?)"
			cmd.CommandText = sql
			cmd.Parameters.Append cmd.CreateParameter("pDeg_Cmpd_ID", 139, 1, 0,iDeg_Cmpd_ID)
			cmd.Parameters.Append cmd.CreateParameter("pDeg_FGroup_ID", 139, 1, 0,iDeg_FGroup_ID)
			cmd.execute
			cmd.Parameters.Delete "pDeg_Cmpd_ID"
			cmd.Parameters.Delete "pDeg_FGroup_ID"
		next
		'The following is for Oracle databases.
		conn.Execute "commit"
	end if
		
	if not err.number <> 0 then
		DoAddDegFGroup = true
	else
		DoAddDegFGroup = false
	end if		
End Function


'#####
' Update MW difference for Degradant
'#####
Function DoUpdateMWDifference(dbkey, formgroup, byRef conn, iDeg_CMPD_ID)
	'Calculate MW difference if there is no r-group in the parent and degradant
	DoUpdateMWDifference = 0
				
	'calculate change in MW if no MW value provided.
	sSQL= "select D3_base64.* from D3_base64, D3_DEGS, D3_EXPTS, D3_PARENTS "&_
	"where D3_DEGS.DEG_CMPD_KEY=" & iDeg_CMPD_ID &" and "&_
	"		D3_DEGS.DEG_EXPT_FK = D3_EXPTS.EXPT_KEY and D3_EXPTS.PARENT_CMPD_FK = D3_PARENTS.PARENT_CMPD_KEY "&_
	"		and D3_PARENTS.MOL_ID = D3_base64.mol_id"
				
				
				
	Set rsStructure = Server.CreateObject( "ADODB.Recordset" )
	rsStructure.Open sSQL, DataConn
				
	sParentMW = getShowCFWChemResult( dbkey, formgroup, "MolWeight", "D3_BASE64.MolWeight", rsStructure( "MOL_ID" ), "raw", "1", "17" )
	sParentMW = replace(sParentMW,"&nbsp;","")
	'sParentMW = MyFormatNumber( sMW, 4 )
	
	' Get the molecular formula.
	sParentFormula = getShowCFWChemResult( dbkey, formgroup, "Formula", "D3_BASE64.BASE64_CDX", rsStructure( "MOL_ID" ), "raw", "1", "17" )
	rsStructure.Close
				
	sSQL= "select D3_base64.* from D3_base64, D3_DEGS "&_
	"where D3_DEGS.DEG_CMPD_KEY=" & iDeg_CMPD_ID &" and "&_
	" D3_DEGS.Mol_ID = D3_base64.mol_id"
	rsStructure.Open sSQL, DataConn
				
	sDegradantMW = getShowCFWChemResult( dbkey, formgroup, "MolWeight", "D3_BASE64.MolWeight", rsStructure( "MOL_ID" ), "raw", "1", "17" )
	sDegradantMW = replace(sDegradantMW,"&nbsp;","")
	
	' Get the molecular formula.
	sDegradantFormula = getShowCFWChemResult( dbkey, formgroup, "Formula", "D3_BASE64.BASE64_CDX", rsStructure( "MOL_ID" ), "raw", "1", "17" )
	if hasRgroup(sParentFormula) = false and hasRGroup(sDegradantFormula) = false then
		'if there is no r group in the parent or degradant, get the weight difference.
		iMWChange = sDegradantMW - sParentMW
		if iMWChange <> "" then
			sSQL = "Update D3_DEGS set MW_AMT_CHG = " & iMWChange  & " where DEG_CMPD_KEY = " & iDeg_CMPD_ID 
			DataConn.Execute sSQL
			DoUpdateMWDifference = iMWChange
		end if
	end if
	rsStructure.Close
	
end function
'#####
' Deleting data objects: parent, experiment, degradant, mechanism, document link.
'#####

Sub DeleteParent( ByVal keyParent, ByRef connDB )
	if "" = keyParent then
		' Odd.  There is no parent key.  Just leave.
		exit Sub
	end if

	' There is a parent key.  Delete the experiments of the parent.
	DeleteExperimentsOfParent keyParent, connDB

	' Delete the document links of the parent.
	'DeleteDocumentLinksOfParent keyParent, connDB

	' Get the specified parent.
	Dim	rsParent
	Set rsParent = Server.CreateObject( "ADODB.Recordset" )
	sSQL = "Select * from D3_PARENTS where PARENT_CMPD_KEY = " & keyParent
	rsParent.Open sSQL, connDB

	' Delete the base64 record for the structure of the degradant.
	if not rsParent.BOF and not rsParent.EOF then
		molidParent = rsParent.Fields( "MOL_ID" )
		if "" <> molidParent then
			' There is a mol ID.  Delete the corresponding base64 entry.
			sSQL = "Delete from D3_BASE64 where MOL_ID = " & molidParent
			connDB.Execute sSQL

			' The following is for Oracle databases.
			connDB.Execute "commit"
		end if
	end if

	' Close the record set for the degradant.
	rsParent.Close

	' Delete the parent.
	sSQL = "Delete from D3_PARENTS where PARENT_CMPD_KEY = " & keyParent
	connDB.Execute sSQL

	' The following is for Oracle databases.
	connDB.Execute "commit"
End Sub

Sub DeleteExperimentsOfParent( ByVal keyParent, ByRef connDB )
	if "" = keyParent then
		' Odd.  There is no parent key.  Just leave.
		exit Sub
	end if

	' Get the set of experiments which point to the specified parent.
	Dim	rsExperiments
	Set rsExperiments = Server.CreateObject( "ADODB.Recordset" )
	sSQL = "Select * from D3_EXPTS where PARENT_CMPD_FK = " & keyParent
	rsExperiments.Open sSQL, connDB

	while not rsExperiments.EOF
		' Get the primary key for the experiment.
		keyExpt = rsExperiments.Fields( "EXPT_KEY" )

		' Get the next experiment: can't do this _after_ deleting the experiment.
		rsExperiments.MoveNext

		' Delete the (now) previous experiment.
		DeleteExperiment keyExpt, connDB
	wend

	' Close the set of experiments.
	rsExperiments.Close
End Sub

Sub DeleteExperiment( ByVal keyExpt, ByRef connDB )
	if "" = keyExpt then
		' Odd.  There is no experiment key.  Just leave.
		exit Sub
	end if

	' First, delete the degradants of the experiment.
	DeleteDegradantsOfExperiment keyExpt, connDB

	' Delete the experiment.
	sSQL = "Delete from D3_EXPTS where EXPT_KEY = " & keyExpt
	connDB.Execute sSQL

	' The following is for Oracle databases.
	connDB.Execute "commit"
End Sub

Sub DeleteDegradantsOfExperiment( ByVal keyExpt, ByRef connDB )
	if "" = keyExpt then
		' Odd.  There is no experiment key.  Just leave.
		exit Sub
	end if

	' Get the set of degradants which point to the specified experiment.
	Dim	rsDegradants
	Set rsDegradants = Server.CreateObject( "ADODB.Recordset" )
	sSQL = "Select * from D3_DEGS where DEG_EXPT_FK = " & keyExpt
	rsDegradants.Open sSQL, connDB

	while not rsDegradants.EOF
		' Get the primary key for the degradant.
		keyDegCmpd = rsDegradants.Fields( "DEG_CMPD_KEY" )

		' Get the next degradant: can't do this _after_ deleting the degradant.
		rsDegradants.MoveNext

		' Delete the (now) previous degradant.
		DeleteDegradant keyDegCmpd, connDB
	wend

	' Close the set of degradants.
	rsDegradants.Close
End Sub

Sub DeleteDegradant( ByVal keyDegCmpd, ByRef connDB )
	if "" = keyDegCmpd then
		' Odd.  There is no degradant key.  Just leave.
		exit Sub
	end if

	' First, delete the mechanism(s) of the degradant.
	DeleteMechanismsOfDegradant keyDegCmpd, connDB

	' Get the specified degradant.
	Dim	rsDegradant
	Set rsDegradant = Server.CreateObject( "ADODB.Recordset" )
	sSQL = "Select * from D3_DEGS where DEG_CMPD_KEY = " & keyDegCmpd
	rsDegradant.Open sSQL, connDB

	' Delete the base64 record for the structure of the degradant.
	if not rsDegradant.BOF and not rsDegradant.EOF then
		molidDegradant = rsDegradant.Fields( "MOL_ID" )
		if "" <> molidDegradant then
			' There _is_ a degradant mol ID.  Delete the corresponding base64 item.
			sSQL = "Delete from D3_BASE64 where MOL_ID = " & molidDegradant
			connDB.Execute sSQL

			' The following is for Oracle databases.
			connDB.Execute "commit"
		end if
	end if

	' Close the record set for the degradant.
	rsDegradant.Close

	' Delete the degradant.
	sSQL = "Delete from D3_DEGS where DEG_CMPD_KEY = " & keyDegCmpd
	connDB.Execute sSQL

	' The following is for Oracle databases.
	connDB.Execute "commit"
End Sub

Sub DeleteMechanismsOfDegradant( ByVal keyDegCmpd, ByRef connDB )
	if "" = keyDegCmpd then
		' Odd.  There is no degradant key.  Just leave.
		exit Sub
	end if

	' Get the set of mechanisms which point to the specified degradant.  There should
	' be just one such mechanism, but to parallel DeleteDegradantsOfExperiment() &
	' DeleteExperimentsOfParent() and to be on the safe side, let's prepare for more than one.
	Dim	rsMechanisms
	Set rsMechanisms = Server.CreateObject( "ADODB.Recordset" )
	sSQL = "Select * from D3_MECHS where DEG_CMPD_FK = " & keyDegCmpd
	rsMechanisms.Open sSQL, connDB

	' Delete the mechanism(s).
	while not rsMechanisms.EOF
		' Get the primary key for the mechanism.
		keyMech = rsMechanisms.Fields( "MECH_KEY" )

		' Get the next mechanism: can't do this _after_ deleting the mechanism.
		rsMechanisms.MoveNext

		' Delete the (now) previous mechanism.
		DeleteMechanism keyMech, connDB
	wend

	' The following is for Oracle databases.
	connDB.Execute "commit"
End Sub

Sub DeleteMechanism( ByVal keyMech, ByRef connDB )
	if "" = keyMech then
		' Odd.  There is no mechanism key.  Just leave.
		exit Sub
	end if

	' Get the specified mechanism.
	Dim	rsMechanism
	Set rsMechanism = Server.CreateObject( "ADODB.Recordset" )
	sSQL = "Select * from D3_MECHS where MECH_KEY = " & keyMech
	rsMechanism.Open sSQL, connDB

	' Delete the base64 record for the structure of the mechanism.
	if not rsMechanism.BOF and not rsMechanism.EOF then
		molidMechanism = rsMechanism.Fields( "MOL_ID" )
		if "" <> molidMechanism then
			' There _is_ a mechanism mol ID.  Delete the corresponding base64 item.
			sSQL = "Delete from D3_BASE64 where MOL_ID = " & molidMechanism
			connDB.Execute sSQL

			' The following is for Oracle databases.
			connDB.Execute "commit"
		end if
	end if

	' Close the recordset for the mechanism.
	rsMechanism.Close

	' Delete the mechanism.
	sSQL = "Delete from D3_MECHS where MECH_KEY = " & keyMech
	connDB.Execute sSQL

	' The following is for Oracle databases.
	connDB.Execute "commit"
End Sub

Sub DeleteCondition( ByVal keyCond, ByRef connDB )
	if "" = keyCond then
		' Odd.  There is no condition key.  Just leave.
		exit Sub
	end if

	' Delete the condition.
	sSQL = "Delete from D3_CONDS where DEG_COND_KEY = " & keyCond
	connDB.Execute sSQL

	' The following is for Oracle databases.
	connDB.Execute "commit"
End Sub

Sub DeleteFunctionalGroup( ByVal keyFGroup, ByRef connDB )
	if "" = keyFGroup then
		' Odd.  There is no functional group key.  Just leave.
		exit Sub
	end if

	' Delete the functional group.
	sSQL = "Delete from D3_FGROUPS where Deg_FGroup_Key = " & keyFGroup
	connDB.Execute sSQL

	' The following is for Oracle databases.
	connDB.Execute "commit"
End Sub

Sub DeleteDocumentLinksOfParent( ByVal keyParent, ByRef connDB )
	if "" = keyParent then
		' Odd.  There is no parent key.  Just leave.
		exit Sub
	end if

	' Get the set of document links which point to the specified parent.
	Dim	rsDocumentLinks
	Set rsDocumentLinks = Server.CreateObject( "ADODB.Recordset" )
	sSQL = "SELECT * FROM D3_DocMgr_Links WHERE Parent_Cmpd_Key = " & keyParent
	rsDocumentLinks.Open sSQL, connDB

	while not rsDocumentLinks.EOF
		' Get the primary key for the document link.
		keyDocLink = rsDocumentLinks.Fields( "Link_Key" )

		' Get the next document link: can't do this _after_ deleting the document link.
		rsDocumentLinks.MoveNext

		' Delete the (now) previous document link.
		DeleteDocumentLink keyDocLink, connDB
	wend

	' Close the set of document links.
	rsDocumentLinks.Close
End Sub

Sub DeleteDocumentLink( ByVal keyDocLink, ByRef connDB )
	if "" = keyDocLink then
		' Odd.  There is no document link key.  Just leave.
		exit Sub
	end if

	' Delete the document link.
	sSQL = "Delete from D3_DOCMGR_LINKS where LINK_KEY = " & keyDocLink
	connDB.Execute sSQL

	' The following is for Oracle databases.
	connDB.Execute "commit"
End Sub

'#####
' Getting the molecular weight and formula from CDX data.
' CAP, 2002-09-19: these routines are no longer used, since COWS 7.1.151 SP1 doesn't need to
'     write CDX data to files.
'#####

'Sub  GetMolWeightFromCDX( ByVal  molID, ByRef  mwOutput )
'	' Get molecular weight from the base64 data.
'	sPath = Application( "TempFileDirectory" & dbkey ) & "D3_BASE64BASE64_CDX_" & rsBase64.Fields( "MOL_ID" ) & ".cdx"
'	Set molParent = CreateObject( "ChemFinder.Molecule" )
'	molParent.Read sPath
'	mwOutput = molParent.MolWeight
'	Set molParent = Nothing
'	molParent = ""
'	molParent.Close
'end Sub

'Sub  GetFormulaFromCDX( ByVal  molID, ByRef  formulaOutput )
'	' Get formula from the base64 data.
'	sPath = Application( "TempFileDirectory" & dbkey ) & "D3_BASE64BASE64_CDX_" & rsBase64.Fields( "MOL_ID" ) & ".cdx"
'	Set molParent = CreateObject( "ChemFinder.Molecule" )
'	molParent.Read sPath
'	formulaOutput = molParent.Formula
'	Set molParent = Nothing
'	molParent = ""
'	molParent.Close
'end Sub


'#####
' Counting records in a table.
'#####

Function  NumberOfRecords( connDB, table, refinement )
	' 'refinement' can be something like, "WHERE MOL_ID = 1534".  For the total number of
	' records in the table, it should be, "".

	sql = "SELECT COUNT(*) FROM " & table & refinement
	'Response.Write( "<br>NumberOfRecords: sql = '" & sql & "'" )
	Set rsCount = connDB.Execute( sql )
	if 0 < err.number then
		' Bah, an error.  Set the count to zero.
		nRecord = 0
		'Response.Write( "<br>NumberOfRecords: an error came up" )
	else
		if ( rsCount.BOF AND rsCount.EOF ) then
			' There are no records, so the count is zero.
			nRecord = 0
			'Response.Write( "<br>NumberOfRecords: no records???" )
		else
'			rsCount.MoveFirst  ' CAP: doesn't seem to work if you do a MoveFirst.  Odd...
			nRecord = rsCount.Fields( 0 )
			'Response.Write( "<br>NumberOfRecords: " & nRecord & " records" )
		end if
	End if

	rsCount.Close
	Set rsCount = Nothing

	NumberOfRecords = nRecord
	'Response.Write( "<br>NumberOfRecords: NumberOfRecords = '" & NumberOfRecords & "'" )
End Function


'#####
' Giving messages through dialogs.
'#####

Sub  ShowMessageInAlertDialog( ByRef  sMessage )
	' For those times when I haven't got search_func_vbs.asp...
%>
	<script language="javascript">
		var sAlert = "<%=sMessage%>"
		alert( sAlert )
	</script>
<%
end Sub


'#####
' String functions.
'#####

Function MyFormatNumber( ByRef sInput, ByVal nDecimalPlaces )
	iDecimal = inStr( sInput, "." )
	if ( 0 < iDecimal ) then
		sFormatted = Left( sInput, ( iDecimal + 2 ) )
	else
		' No decimal point here, so no formatting to do.
		sFormatted = sInput
	end if
	MyFormatNumber = sFormatted
End Function

Function  CleanString_ProtectApostrophes( sToClean )
	sCleaned = Replace( sToClean, "'", "''" )

	CleanString_ProtectApostrophes = sCleaned
End Function


'#####
' Getting info about documents and their links to parent compounds.
'#####

Sub FillRecordsetWithDocumentLinksToParent( ByRef connD3, ByRef rsDocLinks, ByVal Parent_Cmpd_Key )
	' Fill the record set for the document links.
	sQuery = "SELECT * FROM D3_DocMgr_Links WHERE Parent_Cmpd_Key = " & Parent_Cmpd_Key
	rsDocLinks.Open sQuery, connD3
	'Response.Write( "<br>sQuery = '" & sQuery & "'<br>" )
End Sub

Function GetLinkTextForDocument( ByRef connDocMgr, ByRef rsDocInfo, ByVal DocID )
	' I tried putting the opening and closing of rsDocInfo inside this function, so it would
	' not need to have a recordset passed in to it.  Found that didn't work, though.  No time
	' to pursue the idea, unfortunately.

	' Get things from the current document which we can use to identify that document.
	' We _must_ specify the attributes rather than just use "*", because one of them is a
	' BLOB-type item and seems to screw up the SELECT.
	sQuery = "SELECT DocName, Title FROM DocMgr_Documents WHERE DocID = " & DocID
	rsDocInfo.Open sQuery, connDocMgr

	' Assemble the text to use for the link.
'	sLinkText = rsDocInfo.Fields( "TITLE" ) & " (" & rsDocInfo.Fields( "DOCNAME" ) & ")"
	sLinkText = rsDocInfo.Fields( "DOCNAME" )

	GetLinkTextForDocument = sLinkText
End Function

Function GetListForShowLookUpList_AllDocuments()
	Dim connDocMgr
	Dim	rsDocs

	' Connect to the DocManager database.
	MakeNewConnectionToDocManagerDB connDocMgr

	' Get the recordset of documents.
	Set rsDocs = Server.CreateObject( "ADODB.Recordset" )
	sSQL = "SELECT DOCID FROM DocMgr_Documents ORDER BY TITLE, DOCNAME, DOCID"
	rsDocs.Open sSQL, connDocMgr

	' Make a recordset for information on a document.
	Dim	rsDocInfo
	Set rsDocInfo = Server.CreateObject( "ADODB.Recordset" )

	' Step through the documents, adding each to the list of items.
	rsDocs.MoveFirst
	sItemsList = ""
	while not rsDocs.EOF
		sCurrentItem = rsDocs( "DOCID" ) & ":" & GetLinkTextForDocument( connDocMgr, rsDocInfo, rsDocs( "DOCID" ) )

		if 2 < Len( sItemsList ) then
			sItemsList = sItemsList & "," & sCurrentItem
		else
			sItemsList = sCurrentItem
		end if

		rsDocInfo.Close

		rsDocs.MoveNext
	wend

	GetListForShowLookUpList_AllDocuments = sItemsList

	CloseRS( rsDocInfo )
	CloseRS( rsDocs )
	CloseConn( connDocMgr )
End Function

Sub MakeDocumentLinkDropDown()
	Dim connDocMgr
	Dim	rsDocs

	' Connect to the DocManager database.
	MakeNewConnectionToDocManagerDB connDocMgr

	' Get the recordset of documents.
	Set rsDocs = Server.CreateObject( "ADODB.Recordset" )
	sSQL = "SELECT DOCID FROM DocMgr_Documents ORDER BY TITLE, DOCNAME, DOCID"
	rsDocs.Open sSQL, connDocMgr

	' Make a recordset for information on a document.
	Dim	rsDocInfo
	Set rsDocInfo = Server.CreateObject( "ADODB.Recordset" )

	' Write the beginning of the drop-down box item.
%>
<select  name="D3_DOCMGR_LINKS.DocIDlist" onChange="updateSelectedValue(this.form,this)" size ="1">
	<option>-- Document --</option>
<%

	' Step through the documents and make an "option" line for each.
	rsDocs.MoveFirst
	while not rsDocs.EOF
		Response.Write( "<!-- DOCID = '" & rsDocs( "DOCID" ) & "' -->" )
%>	<option value="<%=rsDocs( "DOCID" )%>"><%=GetLinkTextForDocument( connDocMgr, rsDocInfo, rsDocs( "DOCID" ) )%></option>
<%
		rsDocInfo.Close

		rsDocs.MoveNext
	wend

	' Write the end of the drop-down box item.
%></select><input type="hidden" name="D3_DOCMGR_LINKS.DocID" value="" >
<%

	CloseRS( rsDocInfo )
	CloseRS( rsDocs )
	CloseConn( connDocMgr )
End Sub

'#####
' Determins if formula has an r group
'#####

function hasRGroup(sFormula)
	Set oRegEx = New RegExp
	With oRegEx
		.Pattern = "R[^a-z]"
		.IgnoreCase = false
		.Global = True
	End With
	if oRegEx.Test(sFormula) then
		'the R is not followed by a little letter
		hasRGroup = true
	else
		hasRGroup = false
	end if
	Set oRegEx = nothing
end function
							
'#####
' Utilities for the D3-DocManager-DLIMS integration.
'#####

Sub MakeNewConnectionToDocManagerDB( ByRef connDocMgr )
	' Make a connection to the D3 database.
	Set connDocMgr = Server.CreateObject( "ADODB.Connection" )

	' For now, ...
	'sConn = "DSN=docmgr_oracle;UID=doc_submitter;PWD=doc_submitter"	

	sConn = "DSN=docmgr_oracle;UID=" & Session( "UserName" & dbkey )
	sConn = sConn & ";PWD=" & Session( "UserID" & dbkey )

	connDocMgr.Open( sConn )
End Sub

Sub MakeNewConnectionToD3DB( ByRef connD3 )
	' Make a connection to the D3 database.
	Set connD3 = Server.CreateObject( "ADODB.Connection" )

	' For now, ...
	'sConn = "DSN=D3;UID=doc_submitter;PWD=doc_submitter"	

	sConn = "DSN=D3;UID=" & Session( "UserName" & dbkey )
	sConn = sConn & ";PWD=" & Session( "UserID" & dbkey )

	connD3.Open( sConn )
End Sub

'#####
' Get status name
'#####

function getStatusText (byVal sStatusKey, ByRef connD3)
	Set rsStatus = Server.CreateObject( "ADODB.Recordset" )
	sSQL = "Select STATUS_TEXT from D3_STATUSES where STATUS_KEY =" & sStatusKey
	
	rsStatus.Open sSQL, connD3
	if not rsStatus.eof then
		getStatusText = rsStatus("STATUS_TEXT")
	else
		getStatusText = 2000
	end if
	rsStatus.Close
end function

'#####
' Determin if the user has edit privilages on this specific record.
'#####

function IsRecordEditable (byVal sTable, byVal sKeyColumn, byVal recId, ByRef connD3)
	IsRecordEditable = false
	if Session( "dd_Edit_Records" & dbkey ) then
	'can they edit at all?
	
		Set rsRecordStatus = Server.CreateObject( "ADODB.Recordset" )
		sSQL = "Select STATUS from " & sTable & " where " & sKeyColumn &  "=" & recId
		rsRecordStatus.Open sSQL, connD3
	
		if not rsRecordStatus.eof then
			sStatus = rsRecordStatus("STATUS")
			if sStatus <> "20001" then ' if not in the approved state
				IsRecordEditable = true
			else
				' it is in the approved state, do i have permission to approve things, 
				' if so, then let me edit it
				if Session( "DD_APPROVE_RECORDS" & dbkey ) then 
					IsRecordEditable = true
				else
					IsRecordEditable = false
				end if
			end if
		else
			IsRecordEditable = true
		end if
		rsRecordStatus.Close
	else
		IsRecordEditable = false
	end if
end function

'#####
' Create Status Email
'#####
function SendStatusMail (byval sNewStatus , byVal sFormGroup_LowerCase )
	sTo = ""
	sKey = Session( "PrimaryKey" & dbkey )
	if sKey <> "" then
		Select Case UCase( sNewStatus )
			Case "20000"
			'needs review
				if sFormGroup_LowerCase ="base_form_group" then
					sSubject = "Submitted compound needs review"
					sContent = "The compound you have submitted has had its status changed to ""Needs Review""."
				else
					sSubject = "Submitted experiment needs review"
					sContent = "The experiment you have submitted has had its status changed to ""Needs Review""."
				end if
				'new additions are sent to the admin email. so if they change it to new, they will get an email, not the submitter
				'therefor they should always change the status to rejected if they want to send an email
				'if they dont want to send an email, they change to this state.
				'eventaully records in this state will be hidden from searches done by the general public
				sTo = Application("D3_EMAIL")
			Case "20001"
			'approved
				if sFormGroup_LowerCase ="base_form_group" then
					sSubject = "Submitted compound has been approved"
					sContent = "The compound you have submitted has been approved."
				else
					sSubject = "Submitted experiment has been approved"
					sContent = "The experiment you have submitted has been approved."
				end if
			
			Case "20002"
			'rejected
				if sFormGroup_LowerCase ="base_form_group" then
					sSubject = "Submitted compound has been rejected"
					sContent = "The compound you have submitted has been rejected."
				else
					sSubject = "Submitted experiment has been rejected"
					sContent = "The experiment you have submitted has been rejected."
				end if
		end select
			
		'get the email of the person this is going to
		' Open a connection to the database and create a recordset for the individual salts.
		Set connEmailBase = GetNewConnection( dbkey, formgroup, "base_connection" )
		if sFormGroup_LowerCase ="base_form_group" or sFormGroup_LowerCase ="addparent_form_group" then
			sSQL = "Select SUBMITTED_BY from D3_PARENTS dd where dd.PARENT_CMPD_KEY = " & Session( "PrimaryKey" & dbkey )
		else
			sSQL = "Select SUBMITTED_BY from D3_EXPTS dd where  dd.EXPT_KEY = " & Session( "PrimaryKey" & dbkey )
		end if
	
		Set rsEmail = Server.CreateObject( "ADODB.Recordset" )
		rsEmail.Open sSQL, connEmailBase
		if not rsEmail.EOF then
			UserName = rsEmail("SUBMITTED_BY")
		end if
		rsEmail.Close

		if UserName <> "" and sTo = "" then
			' Get User info
			'Set Cmd = GetCommand(connBase, "{CALL " &  "CS_SECURITY.MANAGE_USERS.GETUSER(?)}", 1)	
			
			ConnStr = "FILE NAME=" & Application("CS_SECURITY_UDL_PATH") & ";User ID=" & Session("UserName" & dbkey) & ";Password=" & Session("UserID" & dbkey)
			'Response.Write "ConnString=" & ConnStr
			'Response.End
			Set ConnSecurity = Server.CreateObject("ADODB.Connection")
			ConnSecurity.Open ConnStr
			
			Set Cmd = Server.CreateObject("ADODB.Command")
			Cmd.ActiveConnection = ConnSecurity
			Cmd.CommandType = 1
			Cmd.CommandText = "{CALL " &  "CS_SECURITY.MANAGE_USERS.GETUSER(?)}"
			Cmd.Parameters.Append Cmd.CreateParameter("PUSERNAME",200, 1, 30, UserName)
			Cmd.Properties ("PLSQLRSet") = TRUE  
			Set rsEmail = Cmd.Execute
			Cmd.Properties ("PLSQLRSet") = FALSE
			sTo = rsEmail("Email")
			rsEmail.Close
			ConnSecurity.Close
		end if
	
	
		connEmailBase.Close
			
		sFrom = Application("D3_EMAIL")
	
		if sSubject <> "" and sContent <> "" and sTo <> "" and sFrom <> "" then
			SendStatusMail = SendMail ( sTo,  sFrom,  sSubject,  sContent)
		else
			SendStatusMail = false
		end if
	else
		SendStatusMail = false
	end if
end function

'#####
' Send Email
'#####
function SendMail (byVal sTo, byVal sFrom, byVal sSubject, byVal sContent)
	bSendMail = true
	Set myMail=CreateObject("CDO.Message")
	
	if sTo <> "" and IsEmailValid(sTo) = true then
		myMail.To= sTo
	else
		bSendMail = false
	end if
	
	if sFrom <> "" and IsEmailValid(sFrom) = true then
		myMail.From= sFrom
	else
		bSendMail = false
	end if
	
	if sSubject <> ""  then
		myMail.Subject= sSubject
	else
		bSendMail = false
	end if
	
	if sContent <> ""  then
		myMail.TextBody = sContent
	else
		bSendMail = false
	end if
	
	if bSendMail then
		myMail.Send
	end if
	SendMail = bSendMail
end function


'#####
' Validate Email
'#####

Function IsEmailValid(strEmail)
 
    Dim strArray
    Dim strItem
    Dim blnIsItValid
 
    ' assume the email address is correct 
    blnIsItValid = True
   
    ' split the email address in two parts: name@domain.ext
    strArray = Split(strEmail, "@")
 
    ' if there are more or less than two parts 
    If UBound(strArray) <> 1 Then
        blnIsItValid = False
        IsEmailValid = blnIsItValid
        Exit Function
    End If
 
    ' check each part
    For Each strItem In strArray
        ' no part can be void
        If Len(strItem) <= 0 Then
            blnIsItValid = False
            IsEmailValid = blnIsItValid
            Exit Function
        End If
       
        ' check each character of the part
        ' only following "abcdefghijklmnopqrstuvwxyz_-."
        ' characters and the ten digits are allowed
        For i = 1 To Len(strItem)
               c = LCase(Mid(strItem, i, 1))
               ' if there is an illegal character in the part
               If InStr("abcdefghijklmnopqrstuvwxyz_-.", c) <= 0 And Not IsNumeric(c) Then
                   blnIsItValid = False
                   IsEmailValid = blnIsItValid
                   Exit Function
               End If
        Next
  
      ' the first and the last character in the part cannot be . (dot)
        If Left(strItem, 1) = "." Or Right(strItem, 1) = "." Then
           blnIsItValid = False
           IsEmailValid = blnIsItValid
           Exit Function
        End If
    Next
 
    ' the second part (domain.ext) must contain a . (dot)
    If InStr(strArray(1), ".") <= 0 Then
        blnIsItValid = False
        IsEmailValid = blnIsItValid
        Exit Function
    End If
 
    ' check the length oh the extension 
    i = Len(strArray(1)) - InStrRev(strArray(1), ".")
    ' the length of the extension can be only 2, 3, or 4
    ' to cover the new "info" extension
    If i <> 2 And i <> 3 And i <> 4 Then
        blnIsItValid = False
        IsEmailValid = blnIsItValid
        Exit Function
    End If

    ' after . (dot) cannot follow a . (dot)
    If InStr(strEmail, "..") > 0 Then
        blnIsItValid = False
        IsEmailValid = blnIsItValid
        Exit Function
    End If
 
    ' finally it's OK 
    IsEmailValid = blnIsItValid
   
 End Function
%>