<%' Copyright 1998-2002, CambridgeSoft Corp., All Rights Reserved
'DO NOT EDIT THIS FILE

'-------------------------------------------------------------------------------
' Purpose: 'Nested SD File export
' Assumes:
' Inputs:
'-------------------------------------------------------------------------------

Function exportSDFile(ByVal dbkey, ByVal formgroup, ByVal fieldstoexport_input, ByVal ExportType, ByVal MaxExportNumber, ByVal bStrucDataOut)
	hitlistid = Session("HitListID" & dbkey & formgroup)
	test = Application("ALLOW_SORT_ALL_FIELDS")
	test2= Session("order_by" & dbkey & formgroup)
	fieldstoexport=TrimItemsInString(dbkey, formgroup, fieldstoexport_input)
	subFormsString = getTablesString(dbkey, formgroup, fieldstoexport)
	orig_fieldstoexport = fieldstoexport
	'LJB 5/1/2002 clear variable that is used to add fields from the order by clause to the select statement. They are necessary for the select
	'but should not be output to the sdf file
	Session("FieldsToHideFromDisplay")=""
	Session("FieldsToHideFromDisplayNested")=""
	basetable = GetBaseTable(dbkey, formgroup, "basetable")
	SQLSyntax = GetTableVal(dbkey, basetable,kSQLSyntax)
	formmode = request("formmode")
	'LJB 5/1/2002 Get list of field from sort statements that need to be added to the base table select clause
	if Session("allOuterSorts") <> "" then
		'Session("order_by" & dbkey & formgroup)=""
		basetableSort = GetLastWidgetBaseTableSort(basetable)
		'make sure the sort by field is in the field list
		
		fieldsToAddTemp= AddFieldToSelectList(basetableSort,fieldstoexport)
		if fieldsToAddTemp <> "" then
			if fieldstoexport <> "" then
				fieldstoexport  = fieldstoexport & ","&  fieldsToAddTemp
			else
				fieldstoexport  =fieldsToAddTemp
			end if
		end if
		order_by =" ORDER BY " & basetableSort
	else
		if Session("order_by" & dbkey & formgroup) <> "" then
			order_by_temp=" ORDER BY " & Session("order_by" & dbkey & formgroup)
			if Session("sort_direction" & dbkey & formgroup) <> "" then
				sort_direction = Session("sort_direction" & dbkey & formgroup)
			end if
			order_by =order_by_temp & " " & sort_direction
		end if 
	end if
	
	Select case UCase(ExportType)
		Case "VIEW"
			Session("error" & dbkey & formgroup)= False
			true_basetable = GetBaseTable(dbkey, formgroup, "basetable")
			basetable = true_basetable
			true_baseid = GetTableVal(dbkey, basetable, kPrimaryKey)
			ViewInfo = GetFormGroupVal(dbkey, formgroup,kSDFileFields)
			ViewInfoArray = Split(ViewInfo,";", -1)
			ViewInfoArray2 = Split(ViewInfoArray(0), ":", -1)
			view_basetable = ViewInfoArray2(1)
			view_baseid =  true_baseid
			StrucUniqueID = "MOL_ID"
			if maxexportNumber <> "" then
				maxhits = maxexportNumber
			else
				maxhits = ""
			end if
			set DataConn = GetNewConnection(dbkey, formgroup, "base_connection")
			if Not StrucUniqueID = "NULL" then
				fieldstoexport_final = checkForMolid(dbkey, formgroup, fieldstoexport,basetable & "." & "mol_id")
			else
				fieldstoexport_final =fieldstoexport
			end if
			strGetFields = replace(fieldstoexport_final, view_basetable, UCase(true_basetable))
			dim hitlistid
			
			param_sql = BuildSelectStatement(dbkey, formgroup, true_basetable, "",strGetFields,maxhits)
		
			param_sql=replace(param_sql, UCase(true_basetable), view_basetable)
		
			'creates sql where hitlistid is the parameter
			if MaxHits <> "" then
				param_sql=AddLookups(dbkey,formgroup,param_sql, StrucUniqueID,"NESTED")
				param_sql = AddParamCSDOHitListToSelect_WithMAX(dbkey, formgroup, param_sql,"?","?" )
				param_sql = replace(param_sql, ",,", ",") & order_by

				If CBool(Application("ALLOW_SORT_ALL_FIELDS"))= true and Session("order_by" & dbkey & formgroup) <> "" then
					param_sql= removeDistinct(dbkey, formgroup, param_sql)
				end if
				param_sql=RemoveLookupKeywords(param_sql)
				Set BaseTablecmd = Server.CreateObject("ADODB.Command")
				BaseTablecmd.CommandText = param_sql
				BaseTablecmd.CommandType = adCmdText
				
				
				BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("hitlistid", 5, 1,0,Session("HitListID" & dbkey & formgroup))
				BaseTablecmd.ActiveConnection = DataConn 
				
			else
		
				param_sql=AddLookups(dbkey,formgroup,param_sql,StrucUniqueID,"NESTED")
				param_sql = AddParamCSDOHitListToSelect(dbkey, formgroup, param_sql,"?")
				param_sql = replace(param_sql, ",,", ",") & order_by

				If CBool(Application("ALLOW_SORT_ALL_FIELDS"))= true and Session("order_by" & dbkey & formgroup) <> "" then
					param_sql= removeDistinct(dbkey, formgroup, param_sql)
				end if
				param_sql=RemoveLookupKeywords(param_sql)
				Set BaseTablecmd = Server.CreateObject("ADODB.Command")
				BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("hitlistid", 5, 1,0,Session("HitListID" & dbkey & formgroup))
				
				BaseTablecmd.CommandText = param_sql
				BaseTablecmd.CommandType = adCmdText
				BaseTablecmd.ActiveConnection = DataConn 
				
			end if
		
		Case Else 'Tables
			Session("error" & dbkey & formgroup)= False
			
			if UCase(formgroup) = "REG_CTRBT_COMMIT_FORM_GROUP" or UCase(formgroup)="REVIEW_REGISTER_FORM_GROUP" then
				hitlistID= Session("HitListID" & dbkey & formgroup)
				formgroup =  "REG_CTRBT_FORM_GROUP"
				Session("HitListID" & dbkey & formgroup) = hitlistID
			end if
			basetable = GetBaseTable(dbkey, formgroup, "basetable")
			
			baseid = GetTableVal(dbkey, basetable, kPrimaryKey)
			
			StrucUniqueID = GetTableVal(dbkey, basetable,kStrucFieldID)
			
			
			if maxexportNumber <> "" then
				maxhits = maxexportNumber
			else
				maxhits = ""
			end if
			set DataConn = GetNewConnection(dbkey, formgroup, "base_connection")
			tempFields = getTableExportFields(basetable, fieldstoexport)
			
			if Not StrucUniqueID = "NULL" then
				fieldstoexport_final = checkForMolid(dbkey, formgroup, tempFields,basetable & "." & StrucUniqueID )
			else
			fieldstoexport_final =tempFields
			end if
		
			if not Instr(UCase(fieldstoexport_final), UCase(basetable) & "." & UCase(baseid) )> 0  AND not Instr(UCase(fieldstoexport_final), "[" & UCase(basetable) & "].[" & UCase(baseid)  & "]")> 0  then
				strGetFields = basetable & "." & baseid & "," & fieldstoexport_final
			else
				strGetFields = fieldstoexport_final
			end if
			'LJB don't send subforms when creating select statment when XML Widget sorting is being used
			If CBool(Application("ALLOW_SORT_ALL_FIELDS"))= true and Session("order_by" & dbkey & formgroup) <> "" then
				param_sql = BuildSelectStatement(dbkey, formgroup, basetable, Session("strWhereSubforms" & dbkey & formgroup),strGetFields,"")
			else
				param_sql = BuildSelectStatement(dbkey, formgroup, basetable,"",strGetFields,"")
			end if
			param_sql = FinalizeSQl(dbkey, formgroup, param_sql, basetable)
			
			
			'creates sql where hitlistid is the parameter
			if MaxHits <> "" then
				basetable = getBaseTable(dbkey, formgroup, "basetable")
				SQLSyntax = getTableVal(dbkey, basetable, kSQLSyntax)
				param_sql=AddLookups(dbkey,formgroup,param_sql,StrucUniqueID,"NESTED")
				if UCase(SQLSyntax) = "ORACLE" then
					param_sql = AddParamCSDOHitListToSelect_WithMAX(dbkey, formgroup, param_sql,"?","?" )
				else
					param_sql = AddParamCSDOHitListToSelect_WithMAX(dbkey, formgroup, param_sql,"?",maxhits )
				end if
				param_sql = replace(param_sql, ",,", ",") & order_by

				If CBool(Application("ALLOW_SORT_ALL_FIELDS"))= true and Session("order_by" & dbkey & formgroup) <> "" then
					param_sql= removeDistinct(dbkey, formgroup, param_sql)
				end if
				param_sql=RemoveLookupKeywords(param_sql)
				Set BaseTablecmd = Server.CreateObject("ADODB.Command")
				BaseTablecmd.CommandText = param_sql
				BaseTablecmd.CommandType = adCmdText
				
				if UCase(SQLSyntax) = "ORACLE" then
					BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("hitlistid", 5, 1,0,Session("HitListID" & dbkey & formgroup))
					BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("max", 5, 1,0,MaxHits)
				else
					BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("hitlistid", 5, 1,0,Session("HitListID" & dbkey & formgroup))
				end if

				BaseTablecmd.ActiveConnection = DataConn 
				
			else
				
				param_sql=AddLookups(dbkey,formgroup,param_sql,StrucUniqueID,"NESTED")
				param_sql = AddParamCSDOHitListToSelect(dbkey, formgroup, param_sql,"?")
				param_sql = replace(param_sql, ",,", ",") & order_by
				If CBool(Application("ALLOW_SORT_ALL_FIELDS"))= true and Session("order_by" & dbkey & formgroup) <> "" then
					param_sql= removeDistinct(dbkey, formgroup, param_sql)
				end if
				param_sql=RemoveLookupKeywords(param_sql)
				Set BaseTablecmd = Server.CreateObject("ADODB.Command")
				BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("hitlistid", 5, 1,0,Session("HitListID" & dbkey & formgroup))
				BaseTablecmd.CommandText = param_sql
				BaseTablecmd.CommandType = adCmdText
				BaseTablecmd.ActiveConnection = DataConn 
				
			end if
	End Select
	on error resume next

	Set RS = Server.CreateObject("ADODB.RECORDSET")
	RS.CursorType = 3
	RS.Open BaseTableCmd
	Trace "DoNestedExport HITLISTID:" & Session("HitListID" & dbkey & formgroup) & ":SQL= " & param_sql, 20
	recordcount = GetRecordCount(dbkey, formgroup, rs)

	
	if maxexportNumber<> "" then
		FlushMessageToClient("export is limited to a maximum of " & maxexportNumber & " records.")
		FlushMessageToClient("exporting " & recordcount & " records...")
	else
		FlushMessageToClient("exporting " & recordcount & " records...")
	end if
	
	if err.number <> 0 or Not recordcount <> "" then
		Session("fEmptyRecordset" & dbkey & formgroup) = True
		FlushMessageToClient("The recordset was not succesfully created: <br>" & param_sql)
		FlushMessageToClient("Error : <br>" &  err.number & err.description)
		Response.end
	else
			molfilepath = Application("TempFileDirectory" & dbkey) & "Sessiondir\" & Session.sessionid & "\"
			molfilepathhttp =Application("TempFileDirectoryHTTP" & dbkey) & "Sessiondir/" & Session.sessionid & "/"
	
			sdfilename=  GetTimeStamp()
	
			Set fs = Server.CreateObject("Scripting.FileSystemObject")
			Set a = fs.CreateTextFile(molfilepath & sdfilename & ".sdf")  
			storeTimeout = server.ScriptTimeout
			server.ScriptTimeout = 10000000
			
			If not (RS.EOF and RS.BOF) = true then
				if Not UseCartridge(dbkey, formgroup) then
					Set myConnection = CSDOGetCSDOConnection(dbkey, formgroup)
				end if
				RS.MoveFirst
				counter = 1
				
				if Not detectNS4() = true then
					InitializeProgressBar true, ""
				end if
			
				'DGB this block used to be inside the loop.  
				'I pulled it out since it has no depency in loop variable l
				Tablename = GetBaseTable(dbkey, formgroup, "moltable")
				if Not UCase(ExportType) = "VIEW" then
						if UseCartridge(dbkey, formgroup) then
							on error resume next
							strucFields = getFormGroupVal(dbkey, formgroup, kStructureFields)
							temp_fields_array = split(strucFields, ",", -1)
							for p = 0 to Ubound(temp_fields_array)
								temp_fields2= split(temp_fields_array(p), ".", -1)
								
								if UBound(temp_fields2) = 2 then
									struc_table_name = temp_fields2(0) & "." & temp_fields2(1)
									'struc_table_name = GetTableVal(dbkey, struc_table_name, kTableRealName)
									struc_fieldname = temp_fields2(2)
								else
									struc_table_name = temp_fields2(0)
									'struc_table_name = GetTableVal(dbkey, struc_table_name, kTableRealName)
									struc_fieldname = temp_fields2(1)
								end if
								currentTable = UCase(Trim(Tablename))
								theStrucTable = UCase( Trim(struc_table_name))
								if (theStrucTable =currentTable) or (currentTable = Ucase(basetable)) then
									if struc_fields <> "" then
										struc_fields = struc_fields & "," & struc_fieldname
									else
										struc_fields = struc_fieldname
									end if
								end if
							next
							Structure_Fieldname = "Structure"
						else
							Structure_Fieldname = "Structure"
						end if
					else
						if UseCartridge(dbkey, formgroup) then
						
							on error resume next
							strucFields = getFormGroupVal(dbkey, formgroup, kStructureFields)
							temp_fields_array = split(strucFields, ",", -1)
							for p = 0 to Ubound(temp_fields_array)
								temp_fields2= split(temp_fields_array(p), ".", -1)
								
								if UBound(temp_fields2) = 2 then
									struc_table_name = temp_fields2(0) & "." & temp_fields2(1)
									struc_fieldname = temp_fields2(2)
								else
									struc_table_name = temp_fields2(0)
									struc_fieldname = temp_fields2(1)
								end if
								
								if  UCase(ExportType) = "VIEW" then
									TableName = view_basetable
								end if
							
								currentTable = UCase(Trim(Tablename))
								theStrucTable = UCase( Trim(struc_table_name))
								if (theStrucTable =currentTable) or (currentTable = Ucase(basetable)) then
									if struc_fields <> "" then
										struc_fields = struc_fields & "," & struc_fieldname
									else
										struc_fields = struc_fieldname
									end if
								end if
							next
							Structure_Fieldname = "View_Structure"
						else
							Structure_Fieldname = "View_Structure"
						end if
					end if
				' DGB end of block pulled from loop
	
				For l = 1 to recordcount
				
					if Not detectNS4() = true then
						FlushMessageToClient(" ")
					end if
					
					UniqueID = RS(StrucUniqueID)
					baseid_value = RS(Baseid)
				
					if (Not UniqueID = "") AND (Not isEmpty(UniqueID)) then
						if Not UCase(ExportType) = "VIEW" then
							UniqueID = RS(StrucUniqueID)
						else
							basetable = view_basetable
							UniqueID = RS(StrucUniqueID)
						end if
					end if
					if bStrucDataOut = true then 'output structure mw and formula
						if (Not UniqueID = "") AND (Not isEmpty(UniqueID)) then
							If CLng(UniqueID) > 0 then
								myTime = Timer()
								Fieldname = Structure_Fieldname
								' return molweight
								'check to see if there is a structure
								if UseCartridge(dbkey, formgroup) then
									
									mw_table_name = struc_table_name
									CSDOGetChemData dbkey, formgroup, mw_table_name, Fieldname, UniqueID, "MOLWEIGHT", DataConn
								else ' Use CSDO to produce sdout.mol
								
									mw_table_name = TableName
									struc_table_name = mw_table_name
									CSDOGetChemData dbkey, formgroup, mw_table_name, Fieldname, UniqueID, "sdout.mol", myConnection
								end if
								If Not Session("MW" & dbkey & formgroup & struc_table_name & Fieldname & UniqueID)="" then
									if UseCartridge(dbkey, formgroup) then
										CSDOGetChemData dbkey, formgroup, struc_table_name, Fieldname, UniqueID, "FORMULA", DataConn
									
										fields_array = split(struc_fields, ",", -1)
										for q = 0 to UBound(fields_array)
											Session("molfile" & dbkey & formgroup) =""
											
											CSDOGetChemData dbkey, formgroup, struc_table_name,fields_array(q), UniqueID, "get_molfile", DataConn
											a.WriteLine Session("molfile" & dbkey & formgroup) 
										next
									else ' Used CSDO read sdout.mol
										myDir = molfilepath & "sdout.mol"
										Set b = fs.OpenTextFile(myDir)
										do while b.AtEndOfStream <> True
											myvar = b.ReadLine
											a.WriteLine myvar
										loop
										b.close
									end if
								end if
								'no need to output this
								'a.WriteLine ">  <" & StrucUniqueID & "> " & "(" & counter & ")"
								'a.WriteLine UniqueID
								
								a.WriteLine " "
								fieldvalue = Session("MW" & dbkey & formgroup & struc_table_name & Fieldname & UniqueID)
								output_fieldname = "MolWeight"
								a.WriteLine ">  <" & output_fieldname & "> " & "(" & counter & ")"
								WriteSdfDataField a, fieldvalue
								
								output_fieldname = "Formula"
								fieldvalue = Session("Formula" & dbkey & formgroup & struc_table_name & Fieldname & UniqueID)
								a.WriteLine ">  <" & output_fieldname & "> " & "(" & counter & ")"
								WriteSdfDataField a, fieldvalue
								
							end if
						end if
					end if
						
					on error resume next
				
					Dim i
					
					For i = 0 to RS.Fields.Count-1
						fieldname = ""
						fieldname = RS.Fields.Item(i).Name
						display_fieldName = ""
						
						if Not UCase(fieldname) = UCase(StrucUniqueID) then
							'LJB 5/1/2004 check to see if current field was added only because it is in the order by clause. it should not be displayed.
							if Not HideFieldFromDisplay(basetable & "." & fieldname) then
								if UCase(fieldname) = UCase(Baseid) AND CheckOrigRequest(basetable & "." & baseid,fieldstoexport ) then
										
										'LJB 3/2005 get display names from export specific dictionary created in export_hits_dialog.asp
										display_fieldName = getDisplayNamesForSDExport(basetable & "." & fieldname)
										display_fieldName = replace(display_fieldName, "<sup>", "")
										display_fieldName = replace(display_fieldName, "</sup>", "")
										display_fieldName = replace(display_fieldName, "<sub>", "")
										display_fieldName = replace(display_fieldName, "</sub>", "")
										display_fieldName = replace(display_fieldName, "<", "")
										display_fieldName = replace(display_fieldName, ">", "")
										if not display_fieldName <> "" then
											display_fieldName =fieldname
										end if
										fieldvalue = RS.Fields.Item(i).Value
										a.WriteLine ">  <" & display_fieldName & "> " & "(" & counter & ")"
										WriteSdfDataField a, fieldvalue
										
								else
										'display_fieldName = getLabelNameFromDict(dbkey, formgroup, formmode,basetable & "." & fieldname)
										'LJB 3/2005 get display names from export specific dictionary created in export_hits_dialog.asp
										display_fieldName = getDisplayNamesForSDExport(basetable & "." & fieldname)
										display_fieldName = replace(display_fieldName, "<sup>", "")
										display_fieldName = replace(display_fieldName, "</sup>", "")
										display_fieldName = replace(display_fieldName, "<sub>", "")
										display_fieldName = replace(display_fieldName, "</sub>", "")
										display_fieldName = replace(display_fieldName, "<", "")
										display_fieldName = replace(display_fieldName, ">", "")
										if not display_fieldName <> "" then
											display_fieldName =fieldname
										end if
										fieldvalue = RS.Fields.Item(i).Value
										a.WriteLine ">  <" & display_fieldName & "> " & "(" & counter & ")"
										WriteSdfDataField a, fieldvalue
										
								end if
							end if
						end if
					Next 'i
					
					subFormsString_array = split(subFormsString, ",", -1)
					Set RSp = Server.CreateObject("ADODB.RECORDSET")
					RSp.CursorType=3
					Set SubTablecmd = Server.CreateObject("ADODB.Command")
					Intertables=""
			
					for j = 0 to UBound(subFormsString_array)
						Set RSp = Server.CreateObject("ADODB.RECORDSET")
						RSp.CursorType=3
						Set SubTablecmd = Server.CreateObject("ADODB.Command")
						InterTables=GetTableVal(dbkey, subFormsString_array(j), kInterTables) & "," & subFormsString_array(j)
						tempFields = getTableExportFields(subFormsString_array(j), fieldstoexport)
						order_by =""
						Session("FieldsToHideFromDisplayNested")=""
						strGetFields = tempFields
					
						'LJB 5/1/2005 add support for XML Widget sorting
						if Session("allInnerSorts") <> "" then
							
							tempFields =modifySQl(tempFields)
							childTableSort = GetLastWidgetChildTableSort(subFormsString_array(j))
							'add sort by for child table
							'make sure the sort by field is in the field list
							
							fieldsToAddTemp= AddFieldToSelectListNested(childTableSort,tempFields)
							if fieldsToAddTemp <> "" then
								if strGetFields <> "" then
									strGetFields  = strGetFields & "," & fieldsToAddTemp
								else
									strGetFields  =fieldsToAddTemp
								end if
							end if
							if order_by <> "" then
								order_by = order_by & "," & childTableSort
							else
								order_by = childTableSort
							end if
						end if
						
						
						SubTablecmd.ActiveConnection = DataConn 
						SubTablecmd.CommandType = adCmdText
						strGetFields =modifySQl(strGetFields)
						
						SubFormParamSQL=GetDisplaySQL(dbkey, formgroup, strGetFields,basetable,InterTables,"?","SQL_COWS")
					
						SubFormParamSQL=AddLookups(dbkey,formgroup,SubFormParamSQL, "","FLAT")
						SubFormParamSQL=RemoveLookupKeywords(SubFormParamSQL)
						'add order by clause to support XML Widget sorting
					
						SubTablecmd.parameters.append SubTablecmd.CreateParameter("baseID", 5, 1,0,baseid_value)

						if Session("add_childtable_criteria" & dbkey & formgroup) = "LIMIT" then
							SubFormParamSQL = AddChildTableCriteria( dbkey, formgroup, subFormsString_array(j), SubFormParamSQL)
							SubFormParamSQL = modifySql(SubFormParamSQL)
						end if
						if Session("allInnerSorts") <> "" and order_by <> "" then
							SubFormParamSQL=SubFormParamSQL & " ORDER BY " & order_by
						end if
						'DGB fix ACX Size problem
						SubFormParamSQL = replace(SubFormParamSQL,"Package.Size","Package.""SIZE""")
						SubTablecmd.CommandText = SubFormParamSQL
						RSp.Open SubTablecmd
						
						
						SubTablecmd.Parameters.Delete "baseID"
						tablename_val = getTableNameFromDict(dbkey, formgroup,formmode, subFormsString_array(j))
						
						if not tablename_val <> "" then
							tablename_val = subFormsString_array(j)
						end if
						a.WriteLine ">  <" & tablename_val & "> " & "(" & counter & ")"
						theValue = ""
						fieldvalues=""
						fieldnames = ""
						fieldname_value=""
						
						If Not (RSp.BOF AND RSp.EOF) then
							rsprecordcount = GetRecordCount(dbkey, formgroup, rsp)
							RSp.MoveFirst
							For f = 0 to Rsp.Fields.Count-1
								fieldname_value = RSp.Fields.Item(f).Name
								'5/1/2004 check to see if current field was added only because it is in the order by clause. it should not be displayed.
								hideField = ""
								if Not HideFieldFromDisplayNested(subFormsString_array(j) & "." & fieldname_value) then
									'LJB 3/2005 get display names from export specific dictionary created in export_hits_dialog.asp
									
									display_fieldName = getDisplayNamesForSDExport(subFormsString_array(j) & "." & fieldname_value)
									display_fieldName = replace(display_fieldName, "<sup>", "")
									display_fieldName = replace(display_fieldName, "</sup>", "")
									display_fieldName = replace(display_fieldName, "<sub>", "")
									display_fieldName = replace(display_fieldName, "</sub>", "")
									display_fieldName = replace(display_fieldName, "<", "")
									display_fieldName = replace(display_fieldName, ">", "")
									if not display_fieldname <> "" then
										display_fieldname = fieldname_value
									end if
									if fieldnames <> "" then
										fieldnames = fieldnames & " -- " & display_fieldname
									 else
										fieldnames =  display_fieldname
									 end if
								 end if
							Next
							fieldnames = fieldnames & CHr(13)
							
							
							for n = 0 to rsprecordcount-1
							
								For k = 0 to Rsp.Fields.Count-1
									theName = RSp.Fields.Item(k).Name
									if Not HideFieldFromDisplayNested(subFormsString_array(j) & "." & theName) then
										theValue = RSp.Fields.Item(k).Value
									
										if theValue = "" or isNull(theValue) then
											theValue = "  "
										end if
										if k = 0 then
											if fieldvalues <> "" then
												fieldvalues = fieldvalues &  theValue
											else
												fieldvalues =  theValue
											end if
										else
											if fieldvalues <> "" then
												
												fieldvalues = fieldvalues & " -- " & theValue
											else
												fieldvalues =  theValue
											end if
										end if
									end if 
								next
								if Trim(fieldvalues) <> "" then
									fieldvalues = fieldvalues & CHr(13)
								end if
								
								Rsp.MoveNext
							next
								if rsprecordcount>1 then
									a.WriteLine fieldnames & fieldvalues  & " -- " & CHr(13)
								else
									a.WriteLine fieldnames & fieldvalues  
								end if
							
						
							Rsp.Close
						else
						'LJB 3/2005 if child table has no data, there needs to be new line or ChemDraw for Excel misaligns data 
						a.WriteLine " "
						end if
					next
					a.WriteLine " "
					a.WriteLine " "
					a.WriteLine "$$$$"
					RS.MoveNext
				
					if Not detectNS4() = true then
						 Progressbar counter, recordcount,5
					end if
					counter = counter + 1
					if err.number <> 0 then
						'response.write err.number
					end if
				next 'j
				
			
			Set myConnection = Nothing	
			a.close
			RS.Close
			server.ScriptTimeout = storeTimeout
		end if
		
	end if
	
	Set RS= Nothing
	exportSDFile = molfilepathhttp & sdfilename & ".sdf"
End Function

'-------------------------------------------------------------------------------
' Purpose: 'Flat SD File export
' Assumes:
' Inputs:
'-------------------------------------------------------------------------------
Function DoSDFileExport(ByVal dbkey, ByVal formgroup, ByVal fieldstoexport_input, ByVal ExportType, ByVal MaxExportNumber,ByVal bStrucDataOut)
	fieldstoexport=TrimItemsInString(dbkey, formgroup, fieldstoexport_input)
	subFormsString = getTablesString(dbkey, formgroup, fieldstoexport)
	
	'LJB 5/1/2002 clear variable that is used to add fields from the order by clause to the select statement. They are necessary for the select
	'but should not be output to the sdf file
	Session("FieldsToHideFromDisplay")=""
	basetable = GetBaseTable(dbkey, formgroup, "basetable")
	SQLSyntax = GetTableVal(dbkey, basetable,kSQLSyntax)
	
	'LJB 5/1/2002 Get list of field from sort statements that need to be added to the select clause
	if Session("allOuterSorts") <> "" or Session("order_by" & dbkey & formgroup) <> "" then
		if Session("allOuterSorts") <> "" then
			basetableSort = GetLastWidgetBaseTableSort(basetable)
			'make sure the sort by field is in the field list
			fieldsToAddTemp= AddFieldToSelectList(basetableSort,fieldstoexport)
			if fieldsToAddTemp <> "" then
				if fieldstoexport <> "" then
					fieldstoexport  = fieldstoexport & ","&  fieldsToAddTemp
				else
					fieldstoexport  =fieldsToAddTemp
				end if
			end if
			order_by =" ORDER BY " & basetableSort
		else
		
			if Session("order_by" & dbkey & formgroup) <> "" then
				fieldsToAddTemp= AddFieldToSelectList(Session("order_by" & dbkey & formgroup) ,fieldstoexport)
				if fieldsToAddTemp <> "" then
					if fieldstoexport <> "" then
						fieldstoexport  = fieldstoexport & ","&  fieldsToAddTemp
					else
						fieldstoexport  =fieldsToAddTemp
					end if
				end if
			end if
			
		end if
	end if
	
	if subFormsString <> "" then
		temp = split(subFormsString, ",", -1)
		for m = 0 to UBound(temp)
				
				if Session("allInnerSorts") <> "" then
					childTableSort = GetLastWidgetChildTableSort(temp(m))
					'make sure the sort by field is in the field list
					fieldsToAddTemp= AddFieldToSelectList(childTableSort,fieldstoexport)
					if fieldsToAddTemp <> "" then
						if fieldstoexport <> "" then
							fieldstoexport  = fieldstoexport & "," & fieldsToAddTemp
						else
							fieldstoexport  =fieldsToAddTemp
						end if
					end if
					if order_by <> "" then
						order_by = order_by & "," & childTableSort
					else
						order_by = childTableSort
					end if
				end if
		next
	end if
		
	
	
	
	
	if Session("add_childtable_criteria" & dbkey & formgroup) = "LIMIT" then
		test_array = Split(Session("strWhereSubforms" & dbkey & formgroup), ",", -1)
		for i = 0 to UBound(test_array)
			bItemFound = instr(UCase(subFormsString), UCase(test_array(i)))>0
			if bItemFound = false then
				if subFormsString <> "" then
					subFormsString = subFormsString & "," & test_array(i)
				else
					subFormsString = test_array(i)
				end if
			end if
		next
	end if
	
	if Session("order_by" & dbkey & formgroup) <> "" then
		temp = replace(Session("order_by" & dbkey & formgroup), "ASC", "")
		temp = replace(temp, "DESC", "")
		test_array2 = split(temp, ",", -1)
		dim x
			for x = 0 to UBound(test_array2)
				temp2 = split(test_array2(x), ".", -1)
				if UBound(temp2) = 2 then
					test = temp2(0) & "." & temp2(1)
				else
					test = temp2(0) 
				end if
				if not UCase(test) = UCase(basetable) then
					bItemFound = instr(UCase(subFormsString), UCase(test))>0 
					if bItemFound = false then
						if subFormsString <> "" then
							subFormsString = subFormsString & "," & test
						else
							subFormsString =test
						end if
					end if
				end if
			next
	
	end if
	
	if UseCartridge(dbkey, formgroup) then
		IDColName = "ROWID"
	else
		IDColName = "ID"
	end if

	if Session("order_by" & dbkey & formgroup) <> "" then
		'support XML Widget Sorting
		if Not Session("allOuterSorts")<> "" then
		
			order_by_temp=" ORDER BY " & Session("order_by" & dbkey & formgroup) 
			if Session("sort_direction" & dbkey & formgroup) <> "" then
				sort_direction = Session("sort_direction" & dbkey & formgroup)
			end if
			order_by =order_by_temp & " " & sort_direction
		end if
	else
		
		if UCase(SQLSyntax) = "ORACLE" then
			if Not Session("allOuterSorts")<> "" then
				order_by = " ORDER BY " & "csdohitlist." & IDcolName
				if fieldstoexport <> "" then
					fieldstoexport = fieldstoexport & "," & "csdohitlist." & IDcolName 
				else
					fieldstoexport = "csdohitlist." & IDcolName
				end if
			end if
		else
			order_by = ""
		end if
	end if
	set DataConn = GetNewConnection(dbkey, formgroup, "base_connection")
	Select case UCase(ExportType)
		Case "VIEW"
			Session("error" & dbkey & formgroup)= False
			true_basetable = GetBaseTable(dbkey, formgroup, "basetable")
			basetable = true_basetable
			true_baseid = GetTableVal(dbkey, basetable, kPrimaryKey)
			ViewInfo = GetFormGroupVal(dbkey, formgroup,kSDFileFields)
			ViewInfoArray = Split(ViewInfo,";", -1)
			ViewInfoArray2 = Split(ViewInfoArray(0), ":", -1)
			view_basetable = ViewInfoArray2(1)
			view_baseid =  true_baseid
			StrucUniqueID = "MOL_ID"
			if maxexportNumber <> "" then
				maxhits = maxexportNumber
			else
				maxhits = ""
			end if
		
			fieldstoexport_final = checkForMolid(dbkey, formgroup, fieldstoexport,basetable & "." & "mol_id")
			strGetFields = replace(fieldstoexport_final, view_basetable, UCase(true_basetable))
			
			'strGetFields = true_basetable & ".*"
			baseSQL = BuildSelectStatement(dbkey, formgroup, true_basetable, "",strGetFields,maxhits)
			sql = AddCSDOHitListToSelect(dbkey, formgroup, baseSQL)
			
			sql = RemoveDistinct(dbkey, fromgroup, sql)
			sql=replace(sql, UCase(true_basetable), view_basetable)
			sql = FinalizeSQl(dbkey, formgroup, sql, basetable)
			if maxhits <> "" then
				sql = SetMaxHitsSQL(dbkey, formgroup, sql,basetable, maxhits)
			end if
		Case Else
			Session("error" & dbkey & formgroup)= False
			basetable = GetBaseTable(dbkey, formgroup, "basetable")
			StrucUniqueID = GetTableVal(dbkey, basetable,kStrucFieldID)
			if maxexportNumber <> "" then
				maxhits = maxexportNumber
			else
				maxhits = ""
			end if
			
			if Not StrucUniqueID = "NULL" then
				fieldstoexport_final = checkForMolid(dbkey, formgroup, fieldstoexport,basetable & "." & StrucUniqueID )
			else
				fieldstoexport_final=fieldstoexport
			end if
		
			SQLSyntax = GetTableVal(dbkey, basetable,kSQLSyntax)
			strGetFields = fieldstoexport_final
			orig_strGetFields = strGetFields
			
			strGetFields_temp = alias_all_names(SQLSyntax,strGetFields)
			strGetFields = strGetFields_temp(0)
			strGetFields_aliasOnly = strGetFields_temp(1)
		
			'strGetFields = BuildAllStrFields(dbkey, formgroup,  subFormsString) & "," & basetable & ".*"
			param_sql = BuildSelectStatement(dbkey, formgroup, basetable, subFormsString,strGetFields,"")
			'creates sql where hitlistid is the parameter
			if MaxHits <> "" then
				basetable = getBaseTable(dbkey, formgroup, "basetable")
				SQLSyntax = getTableVal(dbkey, basetable, kSQLSyntax)
				param_sql=AddLookups(dbkey,formgroup,param_sql,StrucUniqueID,"FLAT")
				if UCase(SQLSyntax) = "ORACLE" then
					param_sql = AddParamCSDOHitListToSelect_WithMAX(dbkey, formgroup, param_sql,"?","?" )
				else
					param_sql = AddParamCSDOHitListToSelect_WithMAX(dbkey, formgroup, param_sql,"?",maxhits)
				end if
				param_sql = replace(param_sql, ",,", ",") & order_by
				If CBool(Application("ALLOW_SORT_ALL_FIELDS"))= true and Session("order_by" & dbkey & formgroup) <> "" then
					basetable = GetBaseTable(dbkey, formgroup, "basetable")
					test_str = Session("order_by" & dbkey & formgroup)
						
					test_array1 = split(test_str, ".", -1)
					if Ubound(test_array1) = 2 then
						table_name = test_array1(0) & "." &  test_array1(1)
					else
						table_name = test_array1(0)
					end if
						
					if UCase(Trim(basetable))= UCase(Trim(table_name)) then
						bRemoveDistinct = false
					else
						bRemoveDistinct = True
					end if
					if bRemoveDistinct = true then
						param_sql= removeDistinct(dbkey, formgroup, FullSelect)
					end if
				end if
				param_sql=RemoveLookupKeywords(param_sql)
				param_sql=FinalizeSQl(dbkey, formgroup, param_sql, basetable)
				Set BaseTablecmd = Server.CreateObject("ADODB.Command")
				BaseTablecmd.ActiveConnection = DataConn
				BaseTablecmd.CommandType = adCmdText
			
				
				if UCase(SQLSyntax) = "ORACLE" then
					BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("hitlistid", 5, 1,0,Session("HitListID" & dbkey & formgroup))
					BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("max", 5, 1,0,MaxHits)
				else
					BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("hitlistid", 5, 1,0,Session("HitListID" & dbkey & formgroup))
				end if
				
				
				
			else
			
				param_sql=AddLookups(dbkey,formgroup,param_sql,StrucUniqueID,"FLAT")
				param_sql = AddParamCSDOHitListToSelect(dbkey, formgroup, param_sql,"?")
				if Not Session("add_childtable_criteria" & dbkey & formgroup) = "LIMIT" then				
					param_sql = replace(param_sql, ",,", ",") & order_by
				end if
				If CBool(Application("ALLOW_SORT_ALL_FIELDS"))= true and Session("order_by" & dbkey & formgroup) <> "" then
					basetable = GetBaseTable(dbkey, formgroup, "basetable")
					test_str = Session("order_by" & dbkey & formgroup)
						
					test_array1 = split(test_str, ".", -1)
					if Ubound(test_array1) = 2 then
						table_name = test_array1(0) & "." &  test_array1(1)
					else
						table_name = test_array1(0)
					end if
						
					if UCase(Trim(basetable))= UCase(Trim(table_name)) then
						bRemoveDistinct = false
					else
						bRemoveDistinct = True
					end if
					if bRemoveDistinct = true then
						param_sql= removeDistinct(dbkey, formgroup, FullSelect)
					end if
				end if
				param_sql=FinalizeSQl(dbkey, formgroup, param_sql, basetable)
				param_sql=RemoveLookupKeywords(param_sql)
				Set BaseTablecmd = Server.CreateObject("ADODB.Command")
				BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("hitlistid", 5, 1,0,Session("HitListID" & dbkey & formgroup))
				
				
				BaseTablecmd.CommandType = adCmdText
				BaseTablecmd.ActiveConnection = DataConn 
				
			end if
			'sql = RemoveDistinct(dbkey, fromgroup, sql)
			'sql = FinalizeSQl(dbkey, formgroup, sql, basetable)
			'if maxhits <> "" then
				'sql = SetMaxHitsSQL(dbkey, formgroup, sql, basetable, maxhits)
			'end if
			
	End Select
	
	if Session("add_childtable_criteria" & dbkey & formgroup) = "LIMIT" then
		if subFormsString<> "" then
			temp = split(subFormsString, ",", -1)
			for m = 0 to UBound(temp)
					param_sql = AddChildTableCriteria( dbkey, formgroup, temp(m), param_sql)
					param_sql = modifySql(param_sql)
			next
		
				'sql= sql & " AND " & Session("SearchData" & "FullStrWhere" & dbkey & formgroup)
				'sql = modifySql(sql)
		end if
		param_sql = replace(param_sql, ",,", ",") & order_by
	end if
	'add outer join syntax for each subtable
	if subFormsString <> "" then
	'support child table supports done with XML widget
			

		temp = split(subFormsString, ",", -1)
		for m = 0 to UBound(temp)
				tablejoin = getTableVal(dbkey, temp(m), kselectjoin)
				
				if not instr(tablejoin, "(+)")> 0 then
					if instr(tablejoin, "|") > 0 then
						temp_split = split(tablejoin, "|", -1)
						for n =0 to UBound(temp_split)
							temp_split2 = split(temp_split(n), "=", -1)
							outer_join = temp_split2(0) & "(+)" &   "=" &  temp_split2(1)
							param_sql = replace(param_sql, temp_split(n),outer_join)
						next
					else
						temp2 = split(tablejoin, "=", -1)
						outer_join = temp2(0) & "(+)" &   "=" &  temp2(1)
						param_sql = replace(param_sql, tablejoin,outer_join)
					end if
				end if
				
				
		next
	end if
	
	
	
	param_sql = replace(param_sql, ",,", ",")

	if Not inStr(param_sql, "ORDER BY") > 0   then
		if Trim(order_by) <> "" then
			if not inStr(UCase(order_by), "ORDER BY")>0 then
				order_by = " ORDER BY " & order_by
			end if
			param_sql = param_sql & order_by
		end if
		
		
	end if

	if order_by <> "" then
		if Not (UCase(Trim(order_by)) = "ORDER BY CSDOHITLIST.ROWID" or UCase(Trim(order_by)) = "CSDOHITLIST.ROWID")then
			param_sql = aliasOrderBy(SQLSyntax, param_sql)
		end if
	end if

	
	rsname = "SD_File"
	on error resume next
	'DGB Fixed ACX Oracle problem with Size field
	param_sql = replace(param_sql, "Package.Size","Package.""SIZE""")	
	BaseTablecmd.CommandText = param_sql
	Set RS = Server.CreateObject("ADODB.RECORDSET")
	RS.CursorType = 3
	RS.Open BaseTableCmd
	Trace "DoFlatFileExport HITLISTID:" & Session("HitListID" & dbkey & formgroup) & ":SQL= " & param_sql, 20
	'Response.Write param_sql & session("hitlistid" & dbkey & formgroup)
	'Response.end
	recordcount = getRecordcount(dbkey, formgroup, RS)

	if maxexportNumber<> "" then
		FlushMessageToClient("export is limited to a maximum of " & maxexportNumber & " records.")
		FlushMessageToClient("exporting " & recordcount & " records...")
	else
		FlushMessageToClient("exporting " & recordcount & " records...")
	end if
	'FlushMessageToClient("exporting " & recordcount & " records")

	if err.number <> 0 or Not recordcount <> "" then
		Session("fEmptyRecordset" & dbkey & formgroup) = True
		FlushMessageToClient("The recordset was not succesfully created: <br>" & sql)
		FlushMessageToClient("Error : <br>" &  err.description)
		Response.end
	else
			molfilepath = Application("TempFileDirectory" & dbkey) & "Sessiondir\" & Session.sessionid & "\"
			molfilepathhttp =Application("TempFileDirectoryHTTP" & dbkey) & "Sessiondir/" & Session.sessionid & "/"
	
			sdfilename=  GetTimeStamp()

			'Set Fields = Session("SD_File" & dbkey & formgroup).Fields
			Set fs = Server.CreateObject("Scripting.FileSystemObject")
			Set a = fs.CreateTextFile(molfilepath & sdfilename & ".sdf")  
			storeTimeout = server.ScriptTimeout
			server.ScriptTimeout = 10000000
			If not (RS.EOF and RS.BOF) = true then
				if Not UseCartridge(dbkey, formgroup) then
					Set myConnection = CSDOGetCSDOConnection(dbkey, formgroup)
				end if
				RS.MoveFirst
				counter = 1
				'DisplayProcessingCount "OpenWindow", counter-1 
				'DGB added struc_fields
			
				Tablename = GetBaseTable(dbkey, formgroup, "moltable")
				if Not UCase(ExportType) = "VIEW" then
						if UseCartridge(dbkey, formgroup) then
							on error resume next
							strucFields = getFormGroupVal(dbkey, formgroup, kStructureFields)
							temp_fields_array = split(strucFields, ",", -1)
							for p = 0 to Ubound(temp_fields_array)
								temp_fields2= split(temp_fields_array(p), ".", -1)
								
								if UBound(temp_fields2) = 2 then
									struc_table_name = temp_fields2(0) & "." & temp_fields2(1)
									struc_fieldname = temp_fields2(2)
								else
									struc_table_name = temp_fields2(0)
									struc_fieldname = temp_fields2(1)
								end if
								currentTable = UCase(Trim(Tablename))
								theStrucTable = UCase( Trim(struc_table_name))
								if (theStrucTable =currentTable) or (currentTable = Ucase(basetable)) then
									if struc_fields <> "" then
										struc_fields = struc_fields & "," & struc_fieldname
									else
										struc_fields = struc_fieldname
									end if
								end if
							next
							Fieldname = "Structure"
						else
							Fieldname = "Structure"
						end if
					else
						if UseCartridge(dbkey, formgroup) then
							on error resume next
							strucFields = getFormGroupVal(dbkey, formgroup, kStructureFields)
							temp_fields_array = split(strucFields, ",", -1)
							for p = 0 to Ubound(temp_fields_array)
								temp_fields2= split(temp_fields_array(p), ".", -1)
								
								if UBound(temp_fields2) = 2 then
									struc_table_name = temp_fields2(0) & "." & temp_fields2(1)
									struc_fieldname = temp_fields2(2)
								else
									struc_table_name = temp_fields2(0)
									struc_fieldname = temp_fields2(1)
								end if
								
								if  UCase(ExportType) = "VIEW" then
									TableName = view_basetable
								end if
							
								currentTable = UCase(Trim(Tablename))
								theStrucTable = UCase( Trim(struc_table_name))
								if (theStrucTable =currentTable) or (currentTable = Ucase(basetable)) then
									if struc_fields <> "" then
										struc_fields = struc_fields & "," & struc_fieldname
									else
										struc_fields = struc_fieldname
									end if
								end if
							next
							Fieldname = "View_Structure"
						else
							Fieldname = "View_Structure"
						end if
						
					end if
				'DGB added struc_fields
		
				InitializeProgressBar true, ""
				Tablename = GetBaseTable(dbkey, formgroup, "moltable")
				StrucUniqueID= replace(tablename & "." & StrucUniqueID, ".", "_")
				'since all fields are aliased this field must be converted to the alias name so it can be retrieved
				
				StrucUniqueID=makeAliasCompat(SQLSyntax,StrucUniqueID)
				Do While Not RS.EOF
				
					FlushMessageToClient(" ")
					
					if Not UCase(ExportType) = "VIEW" then
						Fieldname = "Structure"
					else
						Fieldname = "View_Structure"
					end if
					
					if UseCartridge(dbkey, formgroup) then
						UniqueID = RS(StrucUniqueID)
					else
						UniqueID = RS(StrucUniqueID)
					end if
					if (Not UniqueID = "") AND (Not isEmpty(UniqueID)) then
						if Not UCase(ExportType) = "VIEW" then
							UniqueID = RS(StrucUniqueID)
						else
							UniqueID = RS(StrucUniqueID)
						end if
					end if
					if bStrucDataOut = true then 'output structure mw and formula
						if (Not UniqueID = "") AND (Not isEmpty(UniqueID)) then
							If CLng(UniqueID) > 0 then
								
								myTime = Timer()
								if UseCartridge(dbkey, formgroup) then
								
									mw_table_name = struc_table_name
									CSDOGetChemData dbkey, formgroup, mw_table_name, Fieldname, UniqueID, "MOLWEIGHT", DataConn
								else
									mw_table_name = TableName
									struc_table_name = mw_table_name
									CSDOGetChemData dbkey, formgroup, TableName, Fieldname, UniqueID, "sdout.mol", myConnection
								end if
								If Not Session("MW" & dbkey & formgroup & mw_table_name & Fieldname & UniqueID)="" then
									if UseCartridge(dbkey, formgroup) then
										CSDOGetChemData dbkey, formgroup, struc_table_name, Fieldname, UniqueID, "FORMULA", DataConn
										
										fields_array = split(struc_fields, ",", -1)
										for q = 0 to UBound(fields_array)
											Session("molfile" & dbkey & formgroup) =""
											
											CSDOGetChemData dbkey, formgroup, struc_table_name,fields_array(q), UniqueID, "get_molfile", DataConn
											a.WriteLine Session("molfile" & dbkey & formgroup) 
										next
									else
									
										myDir = molfilepath & "sdout.mol"
										Set b = fs.OpenTextFile(myDir)
										do while b.AtEndOfStream <> True
											myvar = b.ReadLine
											a.WriteLine myvar
										loop
										b.close
									end if
								end if
								'fs.DeleteFile myDir, True
								
								'no need to output this
								'a.WriteLine ">  <" & StrucUniqueID & "> " & "(" & counter & ")"
								'a.WriteLine UniqueID
								
								
								a.WriteLine " "
								fieldvalue = Session("MW" & dbkey & formgroup & struc_table_name & Fieldname & UniqueID)
								output_fieldname = "MolWeight"
								a.WriteLine ">  <" & output_fieldname & "> " & "(" & counter & ")"
								WriteSdfDataField a, fieldvalue
								
								output_fieldname = "Formula"
								fieldvalue = Session("Formula" & dbkey & formgroup & struc_table_name & Fieldname & UniqueID)
								a.WriteLine ">  <" & output_fieldname & "> " & "(" & counter & ")"
								WriteSdfDataField a, fieldvalue
							
							end if
						end if
					end if
					on error resume next
					Dim i
				
					fields_to_show = split(strGetFields_aliasOnly, ",", -1)
					fields_to_show_orig = split(orig_strGetFields, ",", -1)
				
					for i = 0 to UBound(fields_to_show)
						if Not (UCase(fields_to_show_orig(i))= "CSDOHITLIST." & Ucase(IDcolName)) and not (UCase(fields_to_show(i))=  UCase(StrucUniqueID)) then
						fieldname = fields_to_show(i)
					
						'LJB 5/1/2004 check to see if current field was added only because it is in the order by clause. it should not be displayed.
						if Not HideFieldFromDisplay(fields_to_show_orig(i)) then

							'LJB 3/2005 get display names from export specific dictionary created in export_hits_dialog.asp
							display_fieldName = getDisplayNamesForSDExport(fields_to_show_orig(i))
							display_fieldName = replace(display_fieldName, "<sup>", "")
							display_fieldName = replace(display_fieldName, "</sup>", "")
							display_fieldName = replace(display_fieldName, "<sub>", "")
							display_fieldName = replace(display_fieldName, "</sub>", "")
							display_fieldName = replace(display_fieldName, "<", "")
							display_fieldName = replace(display_fieldName, ">", "")
							if not display_fieldName <> "" then
								display_fieldName =fieldname
							end if
						
							fieldvalue = RS(fieldname)
						
							err.Clear()
							a.WriteLine ">  <" & display_fieldName & "> " & "(" & counter & ")"
							WriteSdfDataField a, fieldvalue
								
							end if
						end if
					Next 'i

					a.WriteLine "$$$$"
					RS.MoveNext
					
					'DisplayProcessingCount "UpdateWindow", counter-1
					Progressbar counter, recordcount,5
					counter = counter + 1
					if err.number <> 0 then
						'response.write err.number
					end if
				loop 'j
			'DisplayProcessingCount "CloseWindow", ""
			Set myConnection = Nothing	
			a.close
			RS.Close
			server.ScriptTimeout = storeTimeout
		end if
		
	end if
	Set RS= Nothing
	DoSDFileExport = molfilepathhttp & sdfilename & ".sdf"
End Function

Function AddLookups(dbkey, formgroup, paramSQL,strucid,export_type)
	if Session("bypass_ini" & dbkey & formgroup) = true then
		Select_Names = Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup)
	else
	
		if Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup) <> "" then
			if Not Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup)="NULL" then
				Select_Names = Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup)
			end if
		else
			Select_Names = GetLookupNameSelect(dbkey, formgroup)
		end if
	end if
	if Select_Names <> "" and Not Select_Names = "NULL" then
		temp = split(paramSQL, "FROM", -1)
		Working_from_where = " FROM " & temp(1)
		
		temp2 = split(temp(0), "SELECT",  -1)
		if inStr(temp2(1), "DISTINCTROW") then
			working_select = " SELECT DISTINCTROW " 
			working_fields = replace(temp2(1), "DISTINCTROW ", "")
		else
			if inStr(temp2(1), "DISTINCT") then
				working_select = "SELECT DISTINCT " 
				working_fields = replace(temp2(1), "DISTINCT ", "")
			else
				working_select = " SELECT "
				working_fields = temp2(1)
			end if
		end if
		
		Select_Names = replace(Select_Names, "||','||", "CS_CONCAT")
		working_fields_array= split(working_fields, ",", -1)
		working_lookup_fields = split(Select_Names, "|", -1)

		for i = 0 to UBound(working_fields_array)
			if UCase(export_type) = "FLAT" then
				field_name = working_fields_array(i)
				if instr(field_name, " as ")> 0 then
					temp1 = split(field_name, " as ", -1)
					field_name = trim(temp1(1))
				else 
						if instr(trim(field_name), " ")> 0 then
							temp1 = split(trim(field_name), " ", -1)
							field_name = trim(temp1(1))
						end if
				end if
			else
				field_name = working_fields_array(i)
			end if
		bItemFound =false
			for j = 0 to UBound(working_lookup_fields)
				if Instr(working_lookup_fields(j), "::")> 0 then
					working_lookup_fields_array = split(working_lookup_fields(j), "::", -1)
					if UCase(export_type) = "FLAT" then
							test_field = working_lookup_fields_array(0)
							test_field = replace(test_field, ".", "_")
							test_length = len(test_field)
							if CInt(test_length)> 27 then
								trim_length =  CInt(test_length) - 27
								test_field = right(test_field, CInt(test_length)-CInt(trim_length))
							end if
					else
						test_field = working_lookup_fields_array(0)
					end if
					select_value = working_lookup_fields_array(1)
					select_value = replace(select_value, "SELECT ", " LOOKUP_S ")
					select_value = replace(select_value, " FROM ", " LOOKUP_F ")
					select_value = replace(select_value, " WHERE ", " LOOKUP_W ")
					
				else
					if UCase(export_type) = "FLAT" then
							test_field = working_lookup_fields(j)
							test_field = replace(test_field, ".", "_")
							test_length = len(test_field)
							if CInt(test_length)> 27 then
								trim_length =  CInt(test_length) - 27
								test_field = right(test_field, CInt(test_length)-CInt(trim_length))
							end if
					else
						test_field = working_lookup_fields(j)
					end if
				end if
					if strucid <> "" then
						if Not Instr(UCase(Trim(field_name)),UCase(strucid))>0 then
							if UCase(export_type) = "FLAT" then
								working_field_test =working_fields_array(i)
								if instr(working_field_test, " as ")> 0 then
									temp1 = split(working_field_test, " as ", -1)
									working_field_test = trim(temp1(1))
								else 
										if instr(trim(working_field_test), " ")> 0 then
											temp1 = split(trim(working_field_test), " ", -1)
											working_field_test = trim(temp1(1))
										end if
								end if
							else
								working_field_test =working_fields_array(i)
							end if
							if  UCase(Trim(working_field_test))= UCase(Trim(test_field)) AND select_value <> "" then
								if Not UCase(export_type) = "FLAT" then
									
									temp_final=split(working_fields_array(i), ".", -1)
								end if
								
								if UCase(export_type) = "FLAT" then
									field_name_as =working_field_test
									
								else
									field_name_as = temp_final(UBound(temp_final))
								end if
								if return_fields <> "" then
									return_fields = return_fields & "," & "(" & select_value & ")" & " as " & field_name_as
								else
									return_fields = "(" & select_value & ")" & " as " & field_name_as
								end if
								bItemFound = true
							end if
						end if
					else
						
							if (UCase(Trim(field_name)) = UCase(Trim(test_field))) AND select_value <> "" then
								if UCase(export_type) = "FLAT" then
									working_field_test =working_fields_array(i)
									if instr(working_field_test, " as ")> 0 then
										temp1 = split(working_field_test, " as ", -1)
										working_field_test = trim(temp1(1))
									else 
											if instr(trim(working_field_test), " ")> 0 then
												temp1 = split(trim(working_field_test), " ", -1)
												working_field_test = trim(temp1(1))
											end if
									end if
								else
									temp_final=split(working_fields_array(i), ".", -1)
								end if
								if UCase(export_type) = "FLAT" then
									field_name_as = working_field_test
								else
									field_name_as = temp_final(UBound(temp_final))
								end if
								if return_fields <> "" then
									return_fields = return_fields & "," & "(" & select_value & ")" & " as " & field_name_as
								else
									return_fields = "(" & select_value & ")" & " as " & field_name_as
								end if
								bItemFound = true
							end if
						
					end if
			next 'j
			if bItemFound = false then
				if return_fields <> "" then
					return_fields = return_fields & "," & working_fields_array(i)
				else
					return_fields =working_fields_array(i)
				end if
			end if
		next 'i
		'protect keywords
		
		theReturn  = working_select & return_fields & working_from_where
		
	else	
		theReturn = paramSQL
	end if
	
	AddLookups = theReturn	
End Function

Function GetLookupNameSelect(dbkey, formgroup)
		LookupNames = GetINIValue( "optional", formgroup, "SDFILE_LOOKUP_FIELDS", "web_app", dbkey)
		if Instr(UCase(LookupNames), "ADD_LINES")>0 then
			LookupNames=AppendToSDFileStr(formgroup, dbkey, LookupNames,"SDFILE_LOOKUP_FIELDS" )
		end if
		Application.Lock
		Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup)=LookupNames
		if (Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup)="INIEmpty" or Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup) = "NULL" or Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup) = "") then
			Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup)="NULL"
		end if
		Application.UnLock
		GetLookupNameSelect=Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup)
End function

Function AppendToSDFileStr(ByVal section_name,ByVal currentDB, ByVal inputStr,ByVal key_name)
	Dim finalStr, NewEntry,AppendedStr,tempArray,tempArray2,theCount,lineIdent,tempINIEntry,NumAdditional
	
	StrSeparator = "|"
	ItemSeparator = "::"
	
	tempArray = Split(inputStr, StrSeparator, -1)
	theCount = UBound(tempArray)
	lineIdent = tempArray(theCount)
	newArray = Split(lineIdent, ItemSeparator, -1)
	NumAdditional = newArray(1)
	if Not NumAdditional <> "" then 
		NumAdditional = 0
		finalStr = Replace(inputStr, StrSeparator & lineIdent, " ")
	end if
	if NumAdditional > 0 then

		For i = 1 to NumAdditional
			NewEntry =GetINIValue("optional",  UCase(section_name), UCase(key_name) & i, "web_app", currentDB)
			if AppendedStr <> "" then
				AppendedStr = AppendedStr & StrSeparator & NewEntry
			Else
				AppendedStr = NewEntry
			End if
		Next 'i
	finalStr = Replace(inputStr, lineIdent, AppendedStr)
	End if
	
	AppendToSDFileStr = finalStr

End Function

Function RemoveLookupKeywords(sql)

	theReturn = replace(sql, " LOOKUP_S ", " SELECT ")
	theReturn = replace(theReturn, " LOOKUP_F ", " FROM ")
	theReturn = replace(theReturn, " LOOKUP_W ", " WHERE ")
	theReturn = replace(theReturn, "CS_CONCAT", "||','||")

RemoveLookupKeywords = theReturn
End Function

Function alias_all_names(syntax,inputstr)

	temp = split(inputstr, ",", -1)
	
	if syntax = "ORACLE" then
		for i = 0 to UBound(temp)
			alias_name = replace(temp(i), ".", "_")
			test_length = len(alias_name)
			if CInt(test_length)> 27 then
				trim_length_try=27
				trim_length =  CInt(test_length) - trim_length_try
				alias_name = right(alias_name, CInt(test_length)-CInt(trim_length))
				Do Until Not (left(alias_name,1) = Chr(95))
					trim_length =  CInt(test_length) - trim_length_try
					alias_name = right(alias_name, CInt(test_length)-CInt(trim_length))
					trim_length_try = trim_length_try - 1
				loop
				'DJP test if 27the char is a num if so then use "a" if not then use what is there
				leftChar = left(alias_name,1)
				if instr("0123456789",leftChar)>0 then
					alias_name = "a" & right(alias_name,len(alias_name)-1)
				end if
			end if
			if new_list <> "" then
			
				new_list = new_list & "," &  temp(i) & " " & alias_name 
				alias_only = alias_only & "," & alias_name 
			else
				new_list=temp(i) & " " & alias_name 
				alias_only =alias_name 
			end if
		next
	
	else
		for i = 0 to UBound(temp)
			alias_name = replace(temp(i), ".", "_")
			test_length = len(alias_name)
			if CInt(test_length)> 27 then
				trim_length_try=27
				trim_length =  CInt(test_length) - trim_length_try
				alias_name = right(alias_name, CInt(test_length)-CInt(trim_length))
				Do Until Not (left(alias_name,1) = Chr(95))
					trim_length =  CInt(test_length) - trim_length_try
					alias_name = right(alias_name, CInt(test_length)-CInt(trim_length))
					trim_length_try = trim_length_try - 1
				loop
			end if
			if new_list <> "" then
				new_list = new_list & "," & temp(i) & " as " & alias_name 
				alias_only = alias_only & "," & alias_name 
			else
				new_list=temp(i) & " as " & alias_name 
				alias_only = alias_name 
			end if
		next
	
	end if
	final_list = new_list & "|||" & alias_only
	
	alias_all_names = split(final_list, "|||", -1)
End function


Function makeAliasCompat(syntax,alias_name)
	test_length = len(alias_name)
	if CInt(test_length)> 27 then
		trim_length_try=27
		trim_length =  CInt(test_length) - trim_length_try
		alias_name = right(alias_name, CInt(test_length)-CInt(trim_length))
		Do Until Not (left(alias_name,1) = Chr(95))
			trim_length =  CInt(test_length) - trim_length_try
			alias_name = right(alias_name, CInt(test_length)-CInt(trim_length))
			trim_length_try = trim_length_try - 1
		loop
		if UCase(syntax) = "ORACLE" then
			'DJP test if 27the char is a num if so then use "a" if not then use what is there
			leftChar = left(alias_name,1)
			if instr("0123456789",leftChar)>0 then
				alias_name = "a" & right(alias_name,len(alias_name)-1)
			end if
		end if
	end if
	makeAliasCompat = alias_name
End Function

'LJB 3/2005 function for getting display names for fields. This dictionary is created in the export_hits_dialog.asp file prior to export
function getDisplayNamesForSDExport(fieldname)
	if session("export_hits_display_names_DICT").Exists(UCase(fieldname)) then
		displayName = session("export_hits_display_names_DICT").Item(UCase(fieldname))
	else
		displayName = fieldname
	end if
	getDisplayNamesForSDExport= displayName
end function

'DGB to fix CSBR-50143
' When structures are edited in ChemReg the base64_cdx saved in the
' database contains a linebrake every 65 characters.  Ocasionally, 
' a line brake coincides with the end of the base64_cdx string. This causes a
' problem while exporting the base64_cdx field to an sdf because
' the sdf spec does not allow for two consecutive linebrakes at
' the end of a data field.  
' To avoid this problem, the line brake at the end of the field is
' now only added if the data does not already contain a line brake at the end.
'
' f is a reference to the text file, val is the value of the data field.
' DGB added fix from Mitch to avoid probelm with blank fields.
Sub WriteSdfDataField(byref f, val)
	if val <> "" then
		f.writeline val
	else
		f.write vbcrlf
		f.write vbcrlf
	end if
 	if NOT ((asc(right(val,2)) = 13) AND (asc(right(val,1))= 10)) then f.writeline ""
End sub



'LJB 5/1/2005 Function to get the fields in the sort list for a child table when the XML widget is used to sort
function GetLastWidgetChildTableSort(childTableName)'
	dim theReturn
	theReturn=""
	hitlistid = Session("HitListID" & "biosar_browser" & "1189")
	if Session("allInnerSorts") <> "" then
		temp = split(Session("allInnerSorts"), "|", -1) 
		'loop backwards since we are interested in the most recent sort
		for i = 0 to UBound(temp)
			temp2 = split(temp(i), ".", -1)
			test = Trim(replace(childTableName, ".", "_"))& "_RS"
			if Trim(UCase(temp2(0))) = test then
				theReturn = childTableName & "." & temp2(1) ' return the fieldname and the sort direction
				exit for
			end if
		next
	end if
	GetLastWidgetChildTableSort=theReturn
end function

'LJB 4/30/2005 break off order by clause and alias all names. This was causing sorting to break
Function aliasOrderBy(SQLSyntax, param_sql)
	'if SQLSyntax = "ORACLE" then
		temp_param = split(param_sql, "ORDER BY", -1)
		param_sql = temp_param(0)
		order_by = temp_param(1)
			temp_order_by = split(order_by, ",", -1)
			'stop
			for k = 0 to UBound(temp_order_by)
				sortByField=temp_order_by(k)
				if Trim(sortByField)<> "" then
					if instr(UCase(temp_order_by(k)), "DESC") > 0 then
							storeDirection = " DESC"
							
							sortByField=replace(sortByField, " asc", " ASC")
							sortByField=replace(sortByField, " Asc", " ASC")
							sortByField=replace(sortByField, " desc", " DESC")
							sortByField=replace(sortByField, " Desc", " DESC")
							fieldNameTemp =split(sortByField, " DESC", -1)
							fieldName = Trim(fieldNameTemp(0))
					else
							if instr(UCase(temp_order_by(k)), "ASC") > 0 then
								storeDirection = " ASC"
								sortByField=replace(sortByField, " asc", " ASC")
								sortByField=replace(sortByField, " Asc", " ASC")
								sortByField=replace(sortByField, " desc", " DESC")
								sortByField=replace(sortByField, " Desc", " DESC")
								fieldNameTemp =split(sortByField, " ASC", -1)
								fieldName = Trim(fieldNameTemp(0))
							else
								storeDirection = " " 
								fieldName=sortByField
							end if
					end if
					
					newAliasedFieldName = alias_all_names(SQLSyntax,fieldName)
				
					
					finalAliasedName = newAliasedFieldName(1)
				
				
					if new_order_by <> "" then
						new_order_by = new_order_by & "," & finalAliasedName  & storeDirection
					else
						new_order_by = finalAliasedName  & storeDirection
					end if
				end if
			next
	
			aliasOrderBy = param_sql & " ORDER BY " & new_order_by
		'else
			'aliasOrderBy = param_sql
		'end if
end function

'LJB 5/1/2005 Function to get the fields in the sort list fo the base table when the XML widget is used to sort
function GetLastWidgetBaseTableSort(basetable)
	dim theReturn
	theReturn = ""
	if Session("allOuterSorts") <> "" then
		temp = split(Session("allOuterSorts"), "|", -1)
		'return the last sort
		theReturn = basetable & "." & temp(UBound(temp))
	end if
	GetLastWidgetBaseTableSort=theReturn
End Function

'LJB 5/1/2005 function to add fields from the order by clause to the select list. Also keeps a running list of fields
'added so they will be hidden when the sdf file is written
function AddFieldToSelectList(sortByField,fieldList)
	temp = split(fieldList, ",", -1)
	sortByField=replace(sortByField, " asc", " ASC")
	sortByField=replace(sortByField, " Asc", " ASC")
	sortByField=replace(sortByField, " desc", " DESC")
	sortByField=replace(sortByField, " Desc", " DESC")
	if instr(UCase(sortByField), "ASC") > 0 then
		fieldNameTemp =split(sortByField, " ASC", -1)
		fieldName = Trim(fieldNameTemp(0))
	else
		if instr(UCase(sortByField), "DESC") > 0 then
			fieldNameTemp =split(sortByField, " DESC", -1)
			fieldName = Trim(fieldNameTemp(0))
		else
			fieldName = Trim(sortByField)
		end if 
	end if 
	itemFound = false
	for i = 0 to UBound(temp)
		if UCase(temp(i)) = UCase(fieldName) then
			itemFound = true
			exit for
		end if
	next
	
	
	if itemFound = true then
		AddFieldToSelectList = ""
	else
		AddFieldToSelectList = fieldName
		'keep a list of added fields so they will not be displayed in the sdfile.
		if Session("FieldsToHideFromDisplay") <> "" then
			Session("FieldsToHideFromDisplay") = Session("FieldsToHideFromDisplay") & "," & fieldName
		else
			Session("FieldsToHideFromDisplay") = fieldName
		end if
	end if
	
End function
'LJB 5/1/2005 function to add fields from the order by clause to the select list for Nested export of child tables. Also keeps a running list of fields
'added so they will be hidden when the sdf file is written
function AddFieldToSelectListNested(sortByField,fieldList)
	temp = split(fieldList, ",", -1)
	sortByField=replace(sortByField, " asc", " ASC")
	sortByField=replace(sortByField, " Asc", " ASC")
	sortByField=replace(sortByField, " desc", " DESC")
	sortByField=replace(sortByField, " Desc", " DESC")
	if instr(UCase(sortByField), "ASC") > 0 then
		fieldNameTemp =split(sortByField, " ASC", -1)
		fieldName = Trim(fieldNameTemp(0))
	else
		if instr(UCase(sortByField), "DESC") > 0 then
			fieldNameTemp =split(sortByField, " DESC", -1)
			fieldName = Trim(fieldNameTemp(0))
		end if
	end if 
	itemFound = false
	for i = 0 to UBound(temp)
		if UCase(temp(i)) = UCase(fieldName) then
			itemFound = true
			exit for
		end if
	next
	
	
	if itemFound = true then
		AddFieldToSelectListNested = ""
	else
		AddFieldToSelectListNested = fieldName
		'keep a list of added fields so they will not be displayed in the sdfile.
		if Session("FieldsToHideFromDisplayNested") <> "" then
			Session("FieldsToHideFromDisplayNested") = Session("FieldsToHideFromDisplayNested") & "," & fieldName
		else
			Session("FieldsToHideFromDisplayNested") = fieldName
		end if
	end if
	
End function

'LJB 5/1/2005 function to determine if a field should be hidden form the sdf output because it was added only because it was in the order by clause.
Function HideFieldFromDisplay(testField)
	dim hideField
	hideField = false
	if Session("FieldsToHideFromDisplay") <> "" then
		temp = split(Session("FieldsToHideFromDisplay"), ",", -1)
		for i = 0 to Ubound(temp)
			if UCase(temp(i)) = UCase(testField) then
				hideField = true
				exit for
			end if
		next
	end if
	HideFieldFromDisplay = hideField
End Function

'LJB 5/1/2005 function to determine if a field should be hidden form the sdf output for nested child table fields because it was added only because it was in the order by clause.
Function HideFieldFromDisplayNested(testField)
	dim hideField
	hideField = false
	if Session("FieldsToHideFromDisplayNested") <> "" then
		temp = split(Session("FieldsToHideFromDisplayNested"), ",", -1)
		for i = 0 to Ubound(temp)
			if UCase(temp(i)) = UCase(testField) then
				hideField = true
				exit for
			end if
		next
	end if
	HideFieldFromDisplayNested = hideField
End Function
%>