<%' Copyright 1999-2003 CambridgeSoft Corporation. All rights reserved
'DO NOT EDIT THIS FILE%>

<% 'ljb change to make compatible with cows
Const kfieldInteger = 1
Const kfieldDouble = 2
Const kfieldNumericRange = 10
Const kfieldText = 0
Const kfieldMemo = 7
Const kfieldCAS = 25
Const kfieldDate = 8
Const kfieldDate2 = 9 

Const SQUOTE = "'"
Const DQUOTE = """"


Const PERCENT = "%"
Const STAR = "*"
Const OPAREN = "("
Const CPAREN = ")"

Function IsNumericField(ByVal fieldType ) 

    IsNumericField = (fieldType = kfieldInteger Or fieldType = kfieldDouble Or fieldType = kfieldNumericRange)

End Function

'sqlText = ParseDataQuery("10 or 20", "MP", 2)
'Response.Write sqlText

Sub NormalizeCAS(cas )

    cas = LTrim(cas)
    cas = RTrim(cas)
    
    If Len(cas) > 2 Then
        If left(cas, 1) = "[" And Right(cas, 1) = "]" Then
            cas = Mid(cas, 2, Len(cas) - 2)
        End If
    End If
    
    cas = LTrim(cas)
    cas = RTrim(cas)
    
    If IsNumeric(cas) And Len(cas) >= 5 Then
        cas = Mid(cas, 1, Len(cas) - 3) & "-" & Mid(cas, Len(cas) - 2, 2) & "-" & Right(cas, 1)
    End If

End Sub

 Sub Command1_Click()
    MakeSQL
End Sub

Function ParseDataQuery(ByVal query, ByVal fieldName, ByVal fieldType,ByVal dbkey, ByVal formgroup) 
   
    ParseDataQuery = ""
    basetable = GetBaseTable(dbkey, formgroup, "basetable")
	SQLSyntax = GetTableVal(dbkey, basetable,kSQLSyntax) 
    ' if first char is backslash, the rest is straight SQL
    'response.write Mid(query, 1, 1) = chr(92)
    If (Len(query) > 0 And Mid(query, 1, 1) =  chr(92)) Then
       ParseDataQuery = Mid(query, 2)
       If NOT SQLSyntax = "ACCESS" then
			ParseDataQuery= replace(ParseDataQuery, DQUOTE, SQUOTE)
			ParseDataQuery=  replace(ParseDataQuery, SQUOTE & SQUOTE, SQUOTE)
       end if
      
        Exit Function
    End If

    ' Handle the lone case of just "*" or "%"
    Dim q 
    q = query
    q = LTrim(q)
    q = RTrim(q)
    If (Len(q) = 1 And (Mid(q, 1, 1) = STAR Or Mid(q, 1, 1) = PERCENT)) Then
        ParseDataQuery = fieldName & " LIKE '" & STAR & "'"
        Exit Function
    End If

    ' if field is numeric, handle ranges like "99" or "100-101"
    Dim lo 
    Dim hi 
    Dim tmp 
    tmp = query
    
    fieldType = CInt(fieldtype)
    If fieldType = kfieldInteger Or fieldType = kfieldDouble Then
		if ((inStr(tmp, "<")> 0) or (inStr(tmp, ">")> 0) AND fieldType = kfieldDouble) then
			ParseDataQuery = fieldName & tmp
			exit function
		end if
	
        ' if string has op ("< 10"), ignore err and parse below
        If ParseNumericRange(tmp, fieldType, lo, hi) Then
			
            ParseDataQuery = fieldName
            If lo = hi Then
                ParseDataQuery = ParseDataQuery & " = "
                ParseDataQuery = ParseDataQuery & lo
            Else
                ParseDataQuery = ParseDataQuery & " BETWEEN "
                ParseDataQuery = ParseDataQuery & lo
                ParseDataQuery = ParseDataQuery & " AND "
                ParseDataQuery = ParseDataQuery & hi
            End If
            Exit Function
		end if
    End If
    
    ' if date, expect <date> - <date>
    If fieldType = kfieldDate or fieldType = kfieldDate2 Then
        Dim drange 
        drange = OutputDateRange(query, fieldName,fieldtype, sqlSyntax)
        If Len(drange) > 1 Then
            ParseDataQuery = drange
            Exit Function
        End If
    End If
    
    ' otherwise parse the thing for <qry>[<op><qry>]
    ' such as "molname = benzene or toluene"
    Dim p 
    Dim nChars 
    Dim dblQuote 
    Dim m_out 

    p = 1
    
    Dim m_between 
    m_between = False
    
    Dim m_op 
    Dim m_qrySubterm 
    
while true
    ' determine operator
    Dim m_needPercent 
    m_needPercent = False

    While p < Len(query) And Mid(query, p, 1) = " "
        p = p + 1
    Wend

    If IsOperator(query, p, nChars, m_between) Then
        m_op = Mid(query, p, nChars)
        p = p + nChars
    ' new 8/01!  if starts with NOT, change to NOT LIKE
    ElseIf IsNotOp(query, p, nChars) Then
        m_op = "NOT LIKE"
        m_needPercent = True
        p = p + nChars
    Else
        m_op = AssignOperator(query, p, fieldType, m_between, m_needPercent, Len(m_out) <> 0)
    End If
    
    ' parse the rest as a single date and output the results
    If fieldType = kfieldDate or fieldType = kfieldDate2 Then
        If IsDate(Mid(query, p)) Then
            ParseDataQuery = fieldName & " " & m_op & " " & Mid(query, p)
            Exit Function
        End If
    End If

    ' output all text up to next joiner

	if UCase(SQlSyntax) = "ACCESS" then
		StartQuote query, p, fieldType, dblQuote
	else
		StartQuote query, p, fieldType, SQUOTE
	end if
    Dim doLoop 
    doLoop = True
    While (doLoop)
        If p > Len(query) Then
            EndSubterm m_out, m_qrySubterm, fieldName, fieldType, m_op, m_between, m_needPercent
            ParseDataQuery = m_out
            Exit Function

        ElseIf dblQuote And Mid(query, p, 1) <> DQUOTE Then
            m_qrySubterm = m_qrySubterm & Mid(query, p, 1)
            p = p + 1

        ElseIf IsJoiner(query, p, nChars) Then
            EndSubterm m_out, m_qrySubterm, fieldName, fieldType, m_op, m_between, m_needPercent
            If (nChars >= 3 And Mid(query, p + nChars - 3, 3) = "NOT") Then  ' Handles 'not' and 'and not'
                m_out = m_out & " AND NOT "
            Else
                m_out = m_out & " "
                m_out = m_out & Mid(query, p, nChars)
                m_out = m_out & " "
            End If
            p = p + nChars
            doLoop = False
        
        ElseIf Mid(query, p, 1) = STAR Or Mid(query, p, 1) = PERCENT Then
            m_qrySubterm = m_qrySubterm & STAR
            p = p + 1

        ElseIf Mid(query, p, 1) = SQUOTE Then
            m_qrySubterm = m_qrySubterm & SQUOTE
            p = p + 1
            If (Mid(query, p, 1) <> SQUOTE) Then
                m_qrySubterm = m_qrySubterm & SQUOTE
            End If
            If p > Len(query) Then      ' HACK!  EndQuote will remove this quote, so add another
                m_qrySubterm = m_qrySubterm & SQUOTE
            End If

        Else
            m_qrySubterm = m_qrySubterm & Mid(query, p, 1)
            p = p + 1
        End If
    Wend
wend

    ParseDataQuery = ""

End Function

 Function IsJoiner(ByVal query , p , nChars ) 
    
    nChars = 0
    If Len(query) >= p + 5 And UCase(Mid(query, p, 5)) = " AND " Then
        nChars = 3
        p = p + 1
    ElseIf Len(query) >= p + 4 And UCase(Mid(query, p, 4)) = " OR " Then
        nChars = 2
        p = p + 1
    ElseIf Len(query) >= p + 5 And UCase(Mid(query, p, 5)) = " NOT " Then
        nChars = 3
        p = p + 1
    ElseIf Len(query) >= p + 9 And UCase(Mid(query, p, 9)) = " AND NOT " Then
        nChars = 7
        p = p + 1
    End If
    
    IsJoiner = (nChars > 0)

End Function

 Sub OutputRange(m_out , _
                        ByVal fieldName , _
                        ByVal m_op , _
                        ByVal m_qrySubterm , _
                        ByVal m_needPercent , _
                        ByVal lo , _
                        ByVal hi )
    
    ' a range query should hit if it's between the values in the hi and lo fields,
    ' or, if the hi and lo fields are both empty, if it matches the main field exactly

    m_out = m_out & OPAREN ' parens to enclose entire term
    m_out = m_out & OPAREN ' parens to enclose range search


    ' man, this would be a lot easier if we wanted to ignore the operators...

    If m_op = "" Or Mid(m_op, 1, 1) <> ">" Then
        m_out = m_out & fieldName & "Lo"
        If Len(m_op) >= 3 And Mid(m_op, 1, 3) = "NOT" Then
            m_out = m_out & " > "
        ElseIf m_op = "<" Then
            m_out = m_out & " < "
        Else
            m_out = m_out & " <= "
        End If
        m_out = m_out & hi
        
        If m_op = "" Or Mid(m_op, 1, 1) <> "<" Then
            If Len(m_op) <= 3 Or Mid(m_op, 1, 3) <> "NOT" Then
                m_out = m_out & " AND "
            Else
                m_out = m_out & " OR "
            End If
        End If
    End If

    If m_op = "" Or Mid(m_op, 1, 1) <> "<" Then
        m_out = m_out & fieldName & "Hi"
        If Len(m_op) >= 3 And Mid(m_op, 1, 3) = "NOT" Then
            m_out = m_out & " < "
        ElseIf m_op = ">" Then
            m_out = m_out & " > "
        Else
            m_out = m_out & " >= "
        End If
        m_out = m_out & lo
    End If

    m_out = m_out & CPAREN  ' end of range search

    m_out = m_out & " OR "

    m_out = m_out & OPAREN  ' start of exact search

    m_out = m_out & fieldName & "Lo" & " IS NULL"
    m_out = m_out & " AND "
    m_out = m_out & fieldName & "Hi" & " IS NULL"
    m_out = m_out & " AND "

    OutputMemo m_out, fieldName, m_op, m_qrySubterm, m_needPercent

    m_out = m_out & CPAREN  ' end of exact search
    m_out = m_out & CPAREN  ' end of entire term

End Sub

 Sub OutputMemo(m_out , ByVal fieldName , ByVal m_op , ByVal m_qrySubterm , m_needPercent )

    ' for memo fields, we do a full-word search
    ' unfortunately, sql doesn't have a good way to *do* a full-word search, so we have to do a three-way compare
    ' fortunately, we get to ignore the operators entirely
    
    m_needPercent = False

    m_qrySubterm = RTrim(m_qrySubterm)

    ' remove quote if there
    Dim n 
    n = Len(m_qrySubterm)
    If n >= 1 Then
        Dim c 
        c = Right(m_qrySubterm, 1)
        If c = DQUOTE Or c = SQUOTE Then
            m_qrySubterm = Mid(m_qrySubterm, 1, n - 1)
        End If
    End If

    m_out = m_out & OPAREN  ' parens to enclose entire term

    ' entire field ends with this word?
    m_out = m_out & fieldName
    m_out = m_out & " LIKE "

    m_out = m_out & SQUOTE

    If Mid(m_qrySubterm, 1, 1) <> STAR Then
        m_out = m_out & "*[!a-z]"
    End If
    m_out = m_out & m_qrySubterm

    EndQuote m_out, kfieldMemo, m_needPercent

    m_out = m_out & " OR "

    ' entire field starts with this word?
    m_out = m_out & fieldName
    m_out = m_out & " LIKE "

    m_out = m_out & SQUOTE

    m_out = m_out & m_qrySubterm
    If Right(m_qrySubterm, 1) <> STAR Then
        m_out = m_out & "[!a-z]*"
    End If

    EndQuote m_out, kfieldMemo, m_needPercent

    If left(m_qrySubterm, 1) <> STAR And Right(m_qrySubterm, 1) <> STAR Then
        m_out = m_out & " OR "

        ' field contains this whole word anywhere within?
        m_out = m_out & fieldName
        m_out = m_out & " LIKE "

        m_out = m_out & SQUOTE

        m_out = m_out & "*[!a-z]"
        m_out = m_out & m_qrySubterm
        m_out = m_out & "[!a-z]*"

        EndQuote m_out, kfieldMemo, m_needPercent
    End If

    m_out = m_out & CPAREN  ' end of entire term

End Sub

 Sub EndSubterm(m_out , _
                        m_qrySubterm , _
                        ByVal fieldName , _
                        ByVal fieldType , _
                        m_op , _
                        ByVal m_between , _
                        m_needPercent )
    
    Dim isValidRange 
    Dim lo 
    Dim hi 
    
    Dim tmp 
    tmp = m_qrySubterm
    isValidRange = ParseNumericRange(tmp, fieldType, lo, hi)

    If isValidRange And fieldType = kfieldNumericRange Then
        OutputRange m_out, fieldName, m_op, m_qrySubterm, m_needPercent, lo, hi
    ElseIf fieldType = kfieldMemo Or fieldType = kfieldNumericRange Then
        OutputMemo m_out, fieldName, m_op, m_qrySubterm, m_needPercent
    Else ' a regular field
        If fieldType = kfieldDouble And IsNumeric(m_qrySubterm) And isValidRange And m_between = False Then
            m_out = m_out & fieldName
            If lo = hi Then
                m_out = m_out & " = "
                m_out = m_out & lo
            Else
                m_out = m_out & " BETWEEN "
                m_out = m_out & lo
                m_out = m_out & " AND "
                m_out = m_out & hi
            End If
        Else
                        If fieldType = kfieldCAS Then
                                If InStr(m_qrySubterm, STAR) = 0 And m_op = "LIKE" Then
                                        m_op = "="
                                        m_needPercent = False
                                End If
                                NormalizeCAS m_qrySubterm
                        End If
        
            If m_between = False Then
                m_out = m_out & fieldName
                m_out = m_out & " "
                m_out = m_out & m_op
                m_out = m_out & " "
            End If
    
            If IsNumericField(fieldType) = False Then
                m_out = m_out & SQUOTE
            End If
    
            m_out = m_out & m_qrySubterm
        End If

        EndQuote m_out, fieldType, m_needPercent
    End If

    m_qrySubterm = ""
    m_op = ""

End Sub

 Sub EndQuote(m_out , ByVal fieldType , ByVal m_needPercent )
    
    If IsNumericField(fieldType) Then
        Exit Sub
    End If

    ' find last non-blank char of output
    RTrim (m_out)
    
    ' remove quote if there
    Dim n 
    n = Len(m_out)
    If (n < 1) Then
        Exit Sub
    End If
    
    Dim c 
    c = Right(m_out, 1)
    If c = DQUOTE Or c = SQUOTE Then
        n = n - 1
        m_out = left(m_out, n)
    End If

    ' append percent if needed, then quote
    If m_needPercent And Right(m_out, 1) <> STAR Then
        m_out = m_out & STAR
    End If

    m_out = m_out & SQUOTE

End Sub

 Sub StartQuote(ByVal query , p , ByVal fieldType , hasDoubleQuote )
    
    hasDoubleQuote = False
    If IsNumericField(fieldType) Then
        Exit Sub
    End If

    ' skip blanks and any quote the user provided
    While Mid(query, p, 1) = " "
        p = p + 1
    Wend
    
    If Mid(query, p, 1) = SQUOTE Then
        p = p + 1
    ElseIf Mid(query, p, 1) = DQUOTE Then
        hasDoubleQuote = True
        p = p + 1
    End If
    
End Sub

 Function IsNotOp(ByVal query , ByVal p , nChars ) 

    nChars = 0
    If Mid(query, p, 4) = "NOT " Then
        nChars = 3
    End If
    
    IsNotOp = (nChars > 0)

End Function

 Function AssignOperator(ByVal query , ByVal p , ByVal fieldType , between , needPercent , ByVal firstTime ) 

    If firstTime And (InStr(Mid(query, p), "-") Or InStr(Mid(query, p), "to")) Then
        AssignOperator = "BETWEEN"
        between = True
    ElseIf firstTime = False And between Then
        AssignOperator = ""        ' need no operator if previous was "between'
    ElseIf IsNumericField(fieldType) Or fieldType = kfieldDate or fieldType = kfieldDate2 Then
        AssignOperator = "="
    Else
        AssignOperator = "LIKE"
        needPercent = True
    End If

End Function

 Function IsOperator(ByVal query , p , nChars , between ) 

    If p + 1 > Len(query) Then
        IsOperator = False
        Exit Function
    End If
    
    nChars = 0
    If Mid(query, p, 1) = "=" Then
        nChars = 1
    ElseIf p + 2 <= Len(query) And Mid(query, p, 1) = "<" And Mid(query, p + 1, 1) = "=" Then
        nChars = 2
    ElseIf p + 2 <= Len(query) And Mid(query, p, 1) = ">" And Mid(query, p + 1, 1) = "=" Then
        nChars = 2
    ElseIf p + 2 <= Len(query) And Mid(query, p, 1) = "<" And Mid(query, p + 1, 1) = ">" Then
        nChars = 2
    ElseIf Mid(query, p, 1) = "<" Then
        nChars = 1
    ElseIf Mid(query, p, 1) = ">" Then
        nChars = 1
    ElseIf p + 5 <= Len(query) And Mid(query, p, 5) = "LIKE " Then
        nChars = 4
    ElseIf p + 8 <= Len(query) And Mid(query, p, 5) = "BETWEEN " Then
        nChars = 7
        between = True
    End If
    
    
    IsOperator = (nChars > 0)

End Function

Function OutputDateRange(ByRef query , ByRef fieldName, ByRef fieldType, ByVal SQLSyntax) 
    Dim begin 
    Dim left 
    Dim token 
    Dim dt1 
    Dim dt2 
    
    begin = query
    left = query
    
    Dim i 
    Dim toStrLen 
    i = InStr(query, "-")
    If i Then
        toStrLen = 1
    Else
        i = InStr(query, "to")
        If i Then
            toStrLen = 2
        End If
    End If
    
    If i Then
        dt1 = Mid(query, 1, i - 1)
        dt1 = RTrim(dt1)
        dt2 = Mid(query, i + toStrLen)
        If IsDate(dt1) And IsDate(dt2) Then
            OutputDateRange = fieldName
            If dt1 = dt2 Then
				if Not UCase(SQLSyntax) = "ORACLE" then
					OutputDateRange = OutputDateRange & " = " & dt1
                else
					if fieldtype = kfieldDate then
						OutputDateRange = OutputDateRange & " = " & "TO_DATE('" & UCase(dt1) & "'," & "'MM,DD,YYYY')"'
					else 
						if fieldtype = kfieldDate2 then
							OutputDateRange = OutputDateRange & " = " & "TO_DATE('" & UCase(dt1) & "'," & "'DD,MM,YYYY')"
						end if
					end if
                end if
            Else	
          		OutputDateRange = OutputDateRange & " BETWEEN "
				if Not UCase(SQLSyntax) = "ORACLE" then
						If cdate(dt1) < cdate(dt2) Then
							OutputDateRange = OutputDateRange & dt1 & " AND " & dt2
						Else
							OutputDateRange = OutputDateRange & dt2 & " AND " & dt1
						End If
					
				else
					if fieldtype = kfieldDate then
						If cdate(dt1) < cdate(dt2) Then
							OutputDateRange = OutputDateRange & " TO_DATE('" & UCase(dt1) & "'," & "'MM,DD,YYYY')" & " AND " & "TO_DATE('" & UCase(dt2) & "'," & "'MM,DD,YYYY')"
						Else
							OutputDateRange = OutputDateRange & " TO_DATE('" & UCase(dt2) & "'," & "'MM,DD,YYYY')" & " AND " & "TO_DATE('" & UCase(dt1) & "'," & "'MM,DD,YYYY')"
						End If
					else
						if fieldtype = kfieldDate2 then
							If cdate(dt1) < cdate(dt2) Then
							OutputDateRange = OutputDateRange & " TO_DATE('" & UCase(dt1) & "'," & "'DD,MM,YYYY')" & " AND " & "TO_DATE('" & UCase(dt2) & "'," & "'DD,MM,YYYY')"
						Else
							OutputDateRange = OutputDateRange & " TO_DATE('" & UCase(dt2) & "'," & "'DD,MM,YYYY')" & " AND " & "TO_DATE('" & UCase(dt1) & "'," & "'DD,MM,YYYY')"
						End If
						end if
					end if
				
				
				end if
            End If
            
            Exit Function
        End If
    End If
    
    OutputDateRange = ""
End Function

Function ReplaceSubstring(s , a , b ) 

    While InStr(s, a) > 0
    
        Dim i 
        i = InStr(s, a)
        
        Dim bef, aft 
        bef = ""
        aft = ""
        If i > 1 Then bef = Mid(s, 1, i - 1)
        If i + Len(a) <= Len(s) Then aft = Mid(s, i + Len(a))
        
        s = bef & b & aft
    
    Wend
    
    ReplaceSubstring = s

End Function

 Function ReadANum(ByVal s , i ) 

Dim startVal 
startVal = i

ReplaceSubstring s, ",", ""

If i <= Len(s) Then

    If Mid(s, i, 1) = "-" Or Mid(s, i, 1) = "+" Then
        i = i + 1
    End If
    
    While i <= Len(s) And IsNumeric(Mid(s, i, 1))
        i = i + 1
    Wend
    
    If i <= Len(s) And Mid(s, i, 1) = "." Then
        i = i + 1
        
        While i <= Len(s) And IsNumeric(Mid(s, i, 1))
            i = i + 1
        Wend
    End If
        
End If

ReadANum = Mid(s, startVal, i - startVal)

End Function


Function ParseNumericRange(ByVal s , ByVal fieldType , lo , hi ) 

Dim i 
i = 1

Dim loStr, hiStr 
loStr = ReadANum(s, i)

While i <= Len(s) And Mid(s, i, 1) = " "
    i = i + 1
Wend

Dim isPlusMinus 
isPlusMinus = False

If i <= Len(s) And Mid(s, i, 1) = "-" Then
    i = i + 1
ElseIf i <= Len(s) And (Mid(s, i, 2) = "to" Or Mid(s, i, 2) = "To") Then
    i = i + 2
ElseIf i <= Len(s) And Mid(s, i, 1) = "±" Then
    i = i + 1
    isPlusMinus = True
End If

While i <= Len(s) And Mid(s, i, 1) = " "
    i = i + 1
Wend

If i > Len(s) And loStr = "" Then
    ' didn't find anything
Else
    If i > Len(s) Then
        If fieldType = kfieldInteger Then
            hiStr = ""
        Else
            Dim delta 
            delta = 0.499999
            Dim dotpos 
            dotpos = InStr(loStr, ".")
            If dotpos > 0 Then
                While dotpos < Len(loStr)
                    delta = delta / 10
                    dotpos = dotpos + 1
                Wend
            End If
            
            hiStr = delta
            isPlusMinus = True
        End If
    Else
        hiStr = ReadANum(s, i)
    End If
    
    If i <= Len(s) Then
        ' not a parsable range
    ElseIf hiStr = "" Then
        hiStr = loStr
        hi = trim(hiStr)
        lo = trim(loStr)
        ParseNumericRange = True
    Else
        hi = CDbl(trim(hiStr))
        lo = CDbl(trim(loStr))
        if hi = "" then hi = 0
        if lo = "" then lo = 0
       
        If isPlusMinus Then
            Dim temp 
            temp = lo
            lo = temp - hi
            hi = temp + hi
            hiStr = hi
            loStr = lo
        ElseIf (cdbl(hi) < cdbl(lo)) Then
            Dim tempStr 
            tempStr = hiStr
            hiStr = loStr
            loStr = tempStr
            hi = hiStr
            lo = loStr
        End If
        ParseNumericRange = True
    End If
End If

End Function


 Sub searchTerm_KeyUp(KeyCode , Shift )

    If KeyCode = 13 Then    ' a return key
        MakeSQL
    End If
    
End Sub





%>
