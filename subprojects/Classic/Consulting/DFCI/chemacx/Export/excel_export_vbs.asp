<%' Copyright 1998-2002, CambridgeSoft Corp., All Rights Reserved
'DO NOT EDIT THIS FILE

'output XML at different stages to applicaiton's cfwtemp directory
Dim outputDebug
outputDebug = false


'-------------------------------------------------------------------------------
' Purpose: 'Nested Excel File export
' Assumes:
' Inputs:
'-------------------------------------------------------------------------------

Function ExportNestedExcel(ByVal dbkey, ByVal formgroup, ByVal fieldstoexport_input, ByVal ExportType, ByVal MaxExportNumber, ByVal bStrucDataOut)
	
	fieldstoexport=TrimItemsInString(dbkey, formgroup, fieldstoexport_input)
	subFormsString = getTablesString(dbkey, formgroup, fieldstoexport)
	
	basetable = GetBaseTable(dbkey, formgroup, "basetable")
	SQLSyntax = GetTableVal(dbkey, basetable,kSQLSyntax)
	strGetFields = fieldstoexport 
	orig_strGetFields = strGetFields

    Set cmd = CreateObject("ADODB.Command")
	Set shapeConn = getShapeConn()
	cmd.ActiveConnection =  shapeConn
	'build shaped recordset with sql hardcoded for a specific to application
    set RS = getAppShapeStatement(cmd,maxexportnumber)
  	recordcount = getRecordcount(dbkey, formgroup, RS)

	if maxexportNumber<> "" then
		FlushMessageToClient("export is limited to a maximum of " & maxexportNumber & " records.")
		FlushMessageToClient("exporting " & recordcount & " records...")
	else
		FlushMessageToClient("exporting " & recordcount & " records...")
	end if
	'FlushMessageToClient("exporting " & recordcount & " records")

	if err.number <> 0 or Not recordcount <> "" then
		Session("fEmptyRecordset" & dbkey & formgroup) = True
		FlushMessageToClient("The recordset was not succesfully created: <br>" & sql)
		FlushMessageToClient("Error : <br>" &  err.description)
		Response.end
    Else
		If not (RS.EOF and RS.BOF) = true then
				
				InitializeProgressBar true, ""
				Set fso = Server.CreateObject("Scripting.FileSystemObject")
				Set oData = Server.CreateObject("MSXML2.FreeThreadedDOMDocument.4.0")
				oData.validateOnParse=true
				oData.async=false
				
				'save as xml
				RS.Save oData, 1
				RS.Close
			
				if outputDebug = true then
					oData.save(server.MapPath("/CFWTemp/" & Application("Appkey")  & "/" & dbkey & "temp/sessiondir/" & session.sessionid & "/InputRS.xml"))
				end if	
				
				oData.setProperty "SelectionLanguage","XPath"
				oData.setProperty "SelectionNamespaces","xmlns:s='uuid:BDC6E3F0-6DA3-11d1-A2A3-00AA00C14882' xmlns:dt='uuid:C2F41010-65B3-11d1-A29F-00AA00C14882' xmlns:rs='urn:schemas-microsoft-com:rowset'"
				
				'first we will go through and set the field to those from the export templates
				set dataNodeList = oData.getElementsByTagName("s:ElementType")
				Set dataNode = dataNodeList.Item(0) ' this basically selects ROW.
				tempName = dataNode.getAttribute("name")
				'this should be "row" 
					on error resume next
					Dim i
					basetable = GetBaseTable(dbkey, formgroup, "basetable")
					fields_to_show = split(strGetFields, ",", -1)
				
					for i = 0 to UBound(fields_to_show)
						fieldname = fields_to_show(i)
						fieldname_temp = split(fieldname, ".", -1)
						if Ubound(fieldname_temp) = 2 then
							fieldname_only = fieldname_temp(2)
							tablename = fieldname_temp(0) & "." & fieldname_temp(1)
						else
							fieldname_only = fieldname_temp(1)
							tablename = fieldname_temp(0) 
						end if
						'first do basetable fields
							if Trim(UCase(tablename)) = UCase(basetable) then
								'LJB 5/1/2004 check to see if current field was added only because it is in the order by clause. it should not be displayed.
								if Not HideFieldFromDisplay(fields_to_show(i)) then
									
									'LJB 3/2005 get display names from export specific dictionary created in export_hits_dialog.asp
									display_fieldName = getDisplayNamesForSDExport(fieldname)
									display_fieldName = replace(display_fieldName, "<sup>", "")
									display_fieldName = replace(display_fieldName, "</sup>", "")
									display_fieldName = replace(display_fieldName, "<sub>", "")
									display_fieldName = replace(display_fieldName, "</sub>", "")
									display_fieldName = replace(display_fieldName, "<", "")
									display_fieldName = replace(display_fieldName, ">", "")
									if not display_fieldName <> "" then
										display_fieldName =fieldname
									end if
									
									xpath_query="//s:ElementType[@name='" & tempName & "']/s:AttributeType[@name='" & UCase(fieldname_only) & "']"
									set dataNode2 = oData.selectSingleNode(xpath_query)
									Set newAtt = oData.createAttribute("rs:name")	
									newAtt.value = display_fieldName
									dataNode2.setAttributeNode(newAtt)	
									dataNode2.setAttribute("name") = UCase(fieldname_only)
									err.Clear()
										
									end if
								end if
					Next 'i
					'now do this for structure, mw and formula
					xpath_query="//s:ElementType[@name='" & tempName & "']/s:AttributeType[@name='STRUCTURE']"
					set dataNode2 = oData.selectSingleNode(xpath_query)
					Set newAtt = oData.createAttribute("rs:name")	
					newAtt.value = "Structure"
					dataNode2.setAttributeNode(newAtt)	
					dataNode2.setAttribute("name") = "STRUCTURE"
					
					xpath_query="//s:ElementType[@name='" & tempName & "']/s:AttributeType[@name='BASE64_CDX']"
					set dataNode2 = oData.selectSingleNode(xpath_query)
					Set newAtt = oData.createAttribute("rs:name")	
					newAtt.value = "Structure"
					dataNode2.setAttributeNode(newAtt)	
					dataNode2.setAttribute("name") = "BASE64_CDX"
					
					xpath_query="//s:ElementType[@name='" & tempName & "']/s:AttributeType[@name='MOLWEIGHT']"
					set dataNode2 = oData.selectSingleNode(xpath_query)
					Set newAtt = oData.createAttribute("rs:name")	
					newAtt.value = "MolWeight"
					dataNode2.setAttributeNode(newAtt)	
					dataNode2.setAttribute("name") = "MOLWEIGHT"
					
					xpath_query="//s:ElementType[@name='" & tempName & "']/s:AttributeType[@name='FORMULA']"
					set dataNode2 = oData.selectSingleNode(xpath_query)
					Set newAtt = oData.createAttribute("rs:name")	
					newAtt.value = "Formula"
					dataNode2.setAttributeNode(newAtt)	
					dataNode2.setAttribute("name") = "FORMULA"
					
					
					'next go through each subform
					
					
					subFormsString_temp = split(subFormsString, ",", -1)
					for i = 0 to UBound(subFormsString_temp)
					
						subform = UCase(subFormsString_temp(i)) & "_RS"
						
						for j = 0 to UBound(fields_to_show)
							fieldname = fields_to_show(j)
							fieldname_temp = split(fieldname, ".", -1)
							if Ubound(fieldname_temp) = 2 then
								fieldname_only = fieldname_temp(2)
								tablename = fieldname_temp(0) & "." & fieldname_temp(1)
							else
								fieldname_only = fieldname_temp(1)
								tablename = fieldname_temp(0) 
							end if
							
							'first do basetable fields
								if Trim(UCase(tablename)) = UCase(subFormsString_temp(i)) then
									'LJB 5/1/2004 check to see if current field was added only because it is in the order by clause. it should not be displayed.
									if Not HideFieldFromDisplay(fields_to_show(i)) then
										
										'LJB 3/2005 get display names from export specific dictionary created in export_hits_dialog.asp
										display_fieldName = getDisplayNamesForSDExport(fieldname)
										display_fieldName = replace(display_fieldName, "<sup>", "")
										display_fieldName = replace(display_fieldName, "</sup>", "")
										display_fieldName = replace(display_fieldName, "<sub>", "")
										display_fieldName = replace(display_fieldName, "</sub>", "")
										display_fieldName = replace(display_fieldName, "<", "")
										display_fieldName = replace(display_fieldName, ">", "")
										if not display_fieldName <> "" then
											display_fieldName =fieldname
										end if
										
										xpath_query="//s:ElementType[@rs:ReshapeName='" & subform & "']/s:AttributeType[@name='" & UCase(fieldname_only) & "']"
										set dataNode2 = oData.selectSingleNode(xpath_query)
										Set newAtt = oData.createAttribute("rs:name")	
										newAtt.value = display_fieldName
										dataNode2.setAttributeNode(newAtt)	
										dataNode2.setAttribute("name") = UCase(fieldname_only)
										err.Clear()
											
										end if
									end if
							Next 'i
						
					next
					
					
					'xpath_query="//s:ElementType[@name='Chapter1']"
					'set dataNode2 = oData.selectSingleNode(xpath_query)
					'reshapeName = dataNode2.getAttribute("rs:ReshapeName")	
					'dataNode2.setAttribute("name") = reshapeName
					
					finaldoc = "/CFWTemp/" & Application("Appkey")  & "/" & dbkey & "temp/sessiondir/" & session.sessionid & "/TempTransformRS.xml"
					oData.save(server.MapPath(finaldoc))
					Set oXSL = Server.CreateObject("MSXML2.FreeThreadedDOMDocument.4.0")
					Set oFinalData = Server.CreateObject("MSXML2.FreeThreadedDOMDocument.4.0")
					XSLpath = "/" & Application("Appkey")  & "/export/convert_nested.xsl"
					oXSL.load(Server.MapPath(XSLpath))
					oFinalData.load(Server.MapPath(finaldoc))
					'create object for transform
					 bname = currentLogin & fso.GetBaseName(fso.GetTempName)
					'put the transform into a variable and write it to a file. 
					'If you put this in an object and save it as XML you end up loosing the &#10; which are key to the child table data rows delineation.
					'I can't find any other way to do this.
 
					Dim myvar
					myvar = oFinalData.transformNode(oXSL)
					on error resume next
					xmlName = "/CFWTemp/" & Application("Appkey")  & "/" & dbkey & "temp/sessiondir/" & session.sessionid & "/" & bname & ".xml"
					Set fs = Server.CreateObject("Scripting.FileSystemObject")
					Set a = fs.OpenTextFile(server.MapPath(xmlName), 8, True, -1)  
					a.Write myvar
					a.close
					xlsName = "/CFWTemp/" & Application("Appkey")  & "/" & dbkey & "temp/sessiondir/" & session.sessionid & "/" & bname & ".xls"
	
  
					'now let's open this in Excel
					dim ExcelApp, ExcelWB, oSheet, oCell, foundCell
					set ExcelApp = Server.createobject("Excel.Application")
					ExcelApp.visible = True

					set ExcelWB = ExcelApp.Workbooks.Open( Server.MapPath(xmlName))

					Set oSheet = ExcelWB.ActiveSheet

					ExcelWB.SaveAs Server.MapPath(xlsName), FileFormat=xlNormal

					ExcelWB.Close
					ExcelApp.quit

					'DisplayProcessingCount "UpdateWindow", counter-1
					Progressbar counter, recordcount,5
					counter = counter + 1
					if err.number <> 0 then
						'response.write err.number
					end if
				
			'DisplayProcessingCount "CloseWindow", ""
			
			
			server.ScriptTimeout = storeTimeout
		end if
		
	end if

	
   
    
    
 	exportNestedExcel = xlsName
End Function


'-------------------------------------------------------------------------------
' Purpose: 'Flat SD File export
' Assumes:
' Inputs:
'-------------------------------------------------------------------------------
Function exportFlatExcel(ByVal dbkey, ByVal formgroup, ByVal fieldstoexport_input, ByVal ExportType, ByVal MaxExportNumber,ByVal bStrucDataOut)
	fieldstoexport=TrimItemsInString(dbkey, formgroup, fieldstoexport_input)
	subFormsString = getTablesString(dbkey, formgroup, fieldstoexport)
	
	'LJB 5/1/2002 clear variable that is used to add fields from the order by clause to the select statement. They are necessary for the select
	'but should not be output to the sdf file
	Session("FieldsToHideFromDisplay")=""
	basetable = GetBaseTable(dbkey, formgroup, "basetable")
	SQLSyntax = GetTableVal(dbkey, basetable,kSQLSyntax)
	
	'LJB 5/1/2002 Get list of field from sort statements that need to be added to the select clause
	if Session("allOuterSorts") <> "" or Session("order_by" & dbkey & formgroup) <> "" then
		if Session("allOuterSorts") <> "" then
			basetableSort = GetLastWidgetBaseTableSort(basetable)
			'make sure the sort by field is in the field list
			fieldsToAddTemp= AddFieldToSelectList(basetableSort,fieldstoexport)
			if fieldsToAddTemp <> "" then
				if fieldstoexport <> "" then
					fieldstoexport  = fieldstoexport & ","&  fieldsToAddTemp
				else
					fieldstoexport  =fieldsToAddTemp
				end if
			end if
			order_by =" ORDER BY " & basetableSort
		else
		
			if Session("order_by" & dbkey & formgroup) <> "" then
				fieldsToAddTemp= AddFieldToSelectList(Session("order_by" & dbkey & formgroup) ,fieldstoexport)
				if fieldsToAddTemp <> "" then
					if fieldstoexport <> "" then
						fieldstoexport  = fieldstoexport & ","&  fieldsToAddTemp
					else
						fieldstoexport  =fieldsToAddTemp
					end if
				end if
			end if
			
		end if
	end if
	
	if subFormsString <> "" then
		temp = split(subFormsString, ",", -1)
		for m = 0 to UBound(temp)
				
				if Session("allInnerSorts") <> "" then
					childTableSort = GetLastWidgetChildTableSort(temp(m))
					'make sure the sort by field is in the field list
					fieldsToAddTemp= AddFieldToSelectList(childTableSort,fieldstoexport)
					if fieldsToAddTemp <> "" then
						if fieldstoexport <> "" then
							fieldstoexport  = fieldstoexport & "," & fieldsToAddTemp
						else
							fieldstoexport  =fieldsToAddTemp
						end if
					end if
					if order_by <> "" then
						order_by = order_by & "," & childTableSort
					else
						order_by = childTableSort
					end if
				end if
		next
	end if
		
	
	
	
	
	if Session("add_childtable_criteria" & dbkey & formgroup) = "LIMIT" then
		test_array = Split(Session("strWhereSubforms" & dbkey & formgroup), ",", -1)
		for i = 0 to UBound(test_array)
			bItemFound = instr(UCase(subFormsString), UCase(test_array(i)))>0
			if bItemFound = false then
				if subFormsString <> "" then
					subFormsString = subFormsString & "," & test_array(i)
				else
					subFormsString = test_array(i)
				end if
			end if
		next
	end if
	
	if Session("order_by" & dbkey & formgroup) <> "" then
		temp = replace(Session("order_by" & dbkey & formgroup), "ASC", "")
		temp = replace(temp, "DESC", "")
		test_array2 = split(temp, ",", -1)
		dim x
			for x = 0 to UBound(test_array2)
				temp2 = split(test_array2(x), ".", -1)
				if UBound(temp2) = 2 then
					test = temp2(0) & "." & temp2(1)
				else
					test = temp2(0) 
				end if
				if not UCase(test) = UCase(basetable) then
					bItemFound = instr(UCase(subFormsString), UCase(test))>0 
					if bItemFound = false then
						if subFormsString <> "" then
							subFormsString = subFormsString & "," & test
						else
							subFormsString =test
						end if
					end if
				end if
			next
	
	end if
	
	if UseCartridge(dbkey, formgroup) then
		IDColName = "ROWID"
	else
		IDColName = "ID"
	end if

	if Session("order_by" & dbkey & formgroup) <> "" then
		'support XML Widget Sorting
		if Not Session("allOuterSorts")<> "" then
		
			order_by_temp=" ORDER BY " & Session("order_by" & dbkey & formgroup) 
			if Session("sort_direction" & dbkey & formgroup) <> "" then
				sort_direction = Session("sort_direction" & dbkey & formgroup)
			end if
			order_by =order_by_temp & " " & sort_direction
		end if
	else
		
		if UCase(SQLSyntax) = "ORACLE" then
			if Not Session("allOuterSorts")<> "" then
				order_by = " ORDER BY " & "csdohitlist." & IDcolName
				if fieldstoexport <> "" then
					fieldstoexport = fieldstoexport & "," & "csdohitlist." & IDcolName 
				else
					fieldstoexport = "csdohitlist." & IDcolName
				end if
			end if
		else
			order_by = ""
		end if
	end if
	set DataConn = GetNewConnection(dbkey, formgroup, "base_connection")
	Select case UCase(ExportType)
		Case "VIEW"
			Session("error" & dbkey & formgroup)= False
			true_basetable = GetBaseTable(dbkey, formgroup, "basetable")
			basetable = true_basetable
			true_baseid = GetTableVal(dbkey, basetable, kPrimaryKey)
			ViewInfo = GetFormGroupVal(dbkey, formgroup,kSDFileFields)
			ViewInfoArray = Split(ViewInfo,";", -1)
			ViewInfoArray2 = Split(ViewInfoArray(0), ":", -1)
			view_basetable = ViewInfoArray2(1)
			view_baseid =  true_baseid
			StrucUniqueID = "MOL_ID"
			if maxexportNumber <> "" then
				maxhits = maxexportNumber
			else
				maxhits = ""
			end if
		
			fieldstoexport_final = checkForMolid(dbkey, formgroup, fieldstoexport,basetable & "." & "mol_id")
			strGetFields = replace(fieldstoexport_final, view_basetable, UCase(true_basetable))
			
			'strGetFields = true_basetable & ".*"
			baseSQL = BuildSelectStatement(dbkey, formgroup, true_basetable, "",strGetFields,maxhits)
			sql = AddCSDOHitListToSelect(dbkey, formgroup, baseSQL)
			
			sql = RemoveDistinct(dbkey, fromgroup, sql)
			sql=replace(sql, UCase(true_basetable), view_basetable)
			sql = FinalizeSQl(dbkey, formgroup, sql, basetable)
			if maxhits <> "" then
				sql = SetMaxHitsSQL(dbkey, formgroup, sql,basetable, maxhits)
			end if
		Case Else
			Session("error" & dbkey & formgroup)= False
			basetable = GetBaseTable(dbkey, formgroup, "basetable")
			StrucUniqueID = GetTableVal(dbkey, basetable,kStrucFieldID)
			if maxexportNumber <> "" then
				maxhits = maxexportNumber
			else
				maxhits = ""
			end if
			
			if Not StrucUniqueID = "NULL" then
				fieldstoexport_final = checkForMolid(dbkey, formgroup, fieldstoexport,basetable & "." & StrucUniqueID )
			else
				fieldstoexport_final=fieldstoexport
			end if
		
			SQLSyntax = GetTableVal(dbkey, basetable,kSQLSyntax)
			strGetFields = fieldstoexport_final 
			orig_strGetFields = strGetFields
			
			strGetFields_temp = alias_all_names(SQLSyntax,strGetFields)
			strGetFields = strGetFields_temp(0)
			strGetFields_aliasOnly = strGetFields_temp(1)
		
			'strGetFields = BuildAllStrFields(dbkey, formgroup,  subFormsString) & "," & basetable & ".*"
			param_sql = BuildSelectStatement(dbkey, formgroup, basetable, subFormsString,strGetFields,"")
			
			'add structure specific sql
			if UseCartridge(dbkey, formgroup) then
						on error resume next
						strucFields = getFormGroupVal(dbkey, formgroup, kStructureFields)
						temp_fields_array = split(strucFields, ",", -1)
							
							temp_fields2= split(temp_fields_array(0), ".", -1)
								
							if UBound(temp_fields2) = 2 then
								struc_table_name = temp_fields2(0) & "." & temp_fields2(1)
								'struc_table_name = GetTableVal(dbkey, struc_table_name, kTableRealName)
								struc_fieldname = temp_fields2(2)
							else
								struc_table_name = temp_fields2(0)
								'struc_table_name = GetTableVal(dbkey, struc_table_name, kTableRealName)
								struc_fieldname = temp_fields2(1)
							end if
								
							theStrucTable = UCase( Trim(struc_table_name))
								
							
						'lets assume there is only one field for now
						if UCase(Trim(struc_fieldname)) = "STRUCTURE" then
							struc_fieldname = "BASE64_CDX"
						end if
						full_struc_field_name = theStrucTable & "." & struc_fieldname
						param_sql = replace(param_sql,"SELECT ", "SELECT " & full_struc_field_name & " STRUCTURE, CsCartridge.MolWeight(" & full_struc_field_name & ")  MOLWEIGHT, CsCartridge.Formula(" & full_struc_field_name & ",'SORTABLE=YES') FORMULA,")
			end if
			'creates sql where hitlistid is the parameter
			if MaxHits <> "" then
				basetable = getBaseTable(dbkey, formgroup, "basetable")
				SQLSyntax = getTableVal(dbkey, basetable, kSQLSyntax)
				param_sql=AddLookups(dbkey,formgroup,param_sql,StrucUniqueID,"FLAT")
				if UCase(SQLSyntax) = "ORACLE" then
					param_sql = AddParamCSDOHitListToSelect_WithMAX(dbkey, formgroup, param_sql,"?","?" )
				else
					param_sql = AddParamCSDOHitListToSelect_WithMAX(dbkey, formgroup, param_sql,"?",maxhits)
				end if
				param_sql = replace(param_sql, ",,", ",") & order_by
				If CBool(Application("ALLOW_SORT_ALL_FIELDS"))= true and Session("order_by" & dbkey & formgroup) <> "" then
					basetable = GetBaseTable(dbkey, formgroup, "basetable")
					test_str = Session("order_by" & dbkey & formgroup)
						
					test_array1 = split(test_str, ".", -1)
					if Ubound(test_array1) = 2 then
						table_name = test_array1(0) & "." &  test_array1(1)
					else
						table_name = test_array1(0)
					end if
						
					if UCase(Trim(basetable))= UCase(Trim(table_name)) then
						bRemoveDistinct = false
					else
						bRemoveDistinct = True
					end if
					if bRemoveDistinct = true then
						param_sql= removeDistinct(dbkey, formgroup, FullSelect)
					end if
				end if
				param_sql=RemoveLookupKeywords(param_sql)
				param_sql=FinalizeSQl(dbkey, formgroup, param_sql, basetable)
				Set BaseTablecmd = Server.CreateObject("ADODB.Command")
				BaseTablecmd.ActiveConnection = DataConn
				BaseTablecmd.CommandType = adCmdText
			
				
				if UCase(SQLSyntax) = "ORACLE" then
					BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("hitlistid", 5, 1,0,Session("HitListID" & dbkey & formgroup))
					BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("max", 5, 1,0,MaxHits)
				else
					BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("hitlistid", 5, 1,0,Session("HitListID" & dbkey & formgroup))
				end if
				
				
				
			else
			
				param_sql=AddLookups(dbkey,formgroup,param_sql,StrucUniqueID,"FLAT")
				param_sql = AddParamCSDOHitListToSelect(dbkey, formgroup, param_sql,"?")
				if Not Session("add_childtable_criteria" & dbkey & formgroup) = "LIMIT" then				
					param_sql = replace(param_sql, ",,", ",") & order_by
				end if
				If CBool(Application("ALLOW_SORT_ALL_FIELDS"))= true and Session("order_by" & dbkey & formgroup) <> "" then
					basetable = GetBaseTable(dbkey, formgroup, "basetable")
					test_str = Session("order_by" & dbkey & formgroup)
						
					test_array1 = split(test_str, ".", -1)
					if Ubound(test_array1) = 2 then
						table_name = test_array1(0) & "." &  test_array1(1)
					else
						table_name = test_array1(0)
					end if
						
					if UCase(Trim(basetable))= UCase(Trim(table_name)) then
						bRemoveDistinct = false
					else
						bRemoveDistinct = True
					end if
					if bRemoveDistinct = true then
						param_sql= removeDistinct(dbkey, formgroup, FullSelect)
					end if
				end if
				param_sql=FinalizeSQl(dbkey, formgroup, param_sql, basetable)
				param_sql=RemoveLookupKeywords(param_sql)
				Set BaseTablecmd = Server.CreateObject("ADODB.Command")
				BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("hitlistid", 5, 1,0,Session("HitListID" & dbkey & formgroup))
				
			
				BaseTablecmd.CommandType = adCmdText
				BaseTablecmd.ActiveConnection = DataConn 
				
			end if
			'sql = RemoveDistinct(dbkey, fromgroup, sql)
			'sql = FinalizeSQl(dbkey, formgroup, sql, basetable)
			'if maxhits <> "" then
				'sql = SetMaxHitsSQL(dbkey, formgroup, sql, basetable, maxhits)
			'end if
			
	End Select
	
	if Session("add_childtable_criteria" & dbkey & formgroup) = "LIMIT" then
		if subFormsString<> "" then
			temp = split(subFormsString, ",", -1)
			for m = 0 to UBound(temp)
					param_sql = AddChildTableCriteria( dbkey, formgroup, temp(m), param_sql)
					param_sql = modifySql(param_sql)
			next
		
				'sql= sql & " AND " & Session("SearchData" & "FullStrWhere" & dbkey & formgroup)
				'sql = modifySql(sql)
		end if
		param_sql = replace(param_sql, ",,", ",") & order_by
	end if
	'add outer join syntax for each subtable
	if subFormsString <> "" then
	'support child table supports done with XML widget
			

		temp = split(subFormsString, ",", -1)
		for m = 0 to UBound(temp)
				tablejoin = getTableVal(dbkey, temp(m), kselectjoin)
				
				if not instr(tablejoin, "(+)")> 0 then
					if instr(tablejoin, "|") > 0 then
						temp_split = split(tablejoin, "|", -1)
						for n =0 to UBound(temp_split)
							temp_split2 = split(temp_split(n), "=", -1)
							outer_join = temp_split2(0) & "(+)" &   "=" &  temp_split2(1)
							param_sql = replace(param_sql, temp_split(n),outer_join)
						next
					else
						temp2 = split(tablejoin, "=", -1)
						outer_join = temp2(0) & "(+)" &   "=" &  temp2(1)
						param_sql = replace(param_sql, tablejoin,outer_join)
					end if
				end if
				
				
		next
	end if
	
	
	
	param_sql = replace(param_sql, ",,", ",")

	if Not inStr(param_sql, "ORDER BY") > 0   then
		if Trim(order_by) <> "" then
			if not inStr(UCase(order_by), "ORDER BY")>0 then
				order_by = " ORDER BY " & order_by
			end if
			param_sql = param_sql & order_by
		end if
		
		
	end if

	if order_by <> "" then
		if Not (UCase(Trim(order_by)) = "ORDER BY CSDOHITLIST.ROWID" or UCase(Trim(order_by)) = "CSDOHITLIST.ROWID")then
			param_sql = aliasOrderBy(SQLSyntax, param_sql)
		end if
	end if

	
	rsname = "SD_File"
	on error resume next
	'DGB Fixed ACX Oracle problem with Size field
	param_sql = replace(param_sql, "Package.Size","Package.""SIZE""")
	BaseTablecmd.CommandText = param_sql

	Set RS = Server.CreateObject("ADODB.RECORDSET")
	RS.CursorType = 3
	RS.Open BaseTableCmd
	Trace "DoFlatFileExport HITLISTID:" & Session("HitListID" & dbkey & formgroup) & ":SQL= " & param_sql, 20
	'Response.Write param_sql & session("hitlistid" & dbkey & formgroup)
	'Response.end
	recordcount = getRecordcount(dbkey, formgroup, RS)

	if maxexportNumber<> "" then
		FlushMessageToClient("export is limited to a maximum of " & maxexportNumber & " records.")
		FlushMessageToClient("exporting " & recordcount & " records...")
	else
		FlushMessageToClient("exporting " & recordcount & " records...")
	end if
	'FlushMessageToClient("exporting " & recordcount & " records")

	if err.number <> 0 or Not recordcount <> "" then
		Session("fEmptyRecordset" & dbkey & formgroup) = True
		FlushMessageToClient("The recordset was not succesfully created: <br>" & sql)
		FlushMessageToClient("Error : <br>" &  err.description)
		Response.end
	else
			storeTimeout = server.ScriptTimeout
			server.ScriptTimeout = 10000000
			currentLogin = UCase(Session("UserName" & dbkey))
			If not (RS.EOF and RS.BOF) = true then
				
				InitializeProgressBar true, ""
				Set fso = Server.CreateObject("Scripting.FileSystemObject")
				Set oData = Server.CreateObject("MSXML2.FreeThreadedDOMDocument.4.0")
				oData.validateOnParse=true
				oData.async=false
				'save as xml
				RS.Save oData, 1
				RS.Close
			
				if outputDebug = true then
					oData.save(server.MapPath("/CFWTemp/" & Application("Appkey")  & "/" & dbkey & "temp/sessiondir/" & session.sessionid & "/InputRS.xml"))
				end if	
				
				oData.setProperty "SelectionLanguage","XPath"
				oData.setProperty "SelectionNamespaces","xmlns:s='uuid:BDC6E3F0-6DA3-11d1-A2A3-00AA00C14882' xmlns:dt='uuid:C2F41010-65B3-11d1-A29F-00AA00C14882' xmlns:rs='urn:schemas-microsoft-com:rowset'"
				
				'first we will go through and set the field to those from the export templates
				set dataNodeList = oData.getElementsByTagName("s:ElementType")
				Set dataNode = dataNodeList.Item(0)
				tempName = dataNode.getAttribute("name")
				'this should be "row" since this is flatfile
					on error resume next
					Dim i
				
					fields_to_show = split(strGetFields_aliasOnly, ",", -1)
					fields_to_show_orig = split(orig_strGetFields, ",", -1)
				
					for i = 0 to UBound(fields_to_show)
						if Not (UCase(fields_to_show_orig(i))= "CSDOHITLIST." & Ucase(IDcolName)) and not (UCase(fields_to_show(i))=  UCase(StrucUniqueID)) then
						fieldname = fields_to_show(i)
					
						'LJB 5/1/2004 check to see if current field was added only because it is in the order by clause. it should not be displayed.
						if Not HideFieldFromDisplay(fields_to_show_orig(i)) then
							
							'LJB 3/2005 get display names from export specific dictionary created in export_hits_dialog.asp
							display_fieldName = getDisplayNamesForSDExport(fields_to_show_orig(i))
							display_fieldName = replace(display_fieldName, "<sup>", "")
							display_fieldName = replace(display_fieldName, "</sup>", "")
							display_fieldName = replace(display_fieldName, "<sub>", "")
							display_fieldName = replace(display_fieldName, "</sub>", "")
							display_fieldName = replace(display_fieldName, "<", "")
							display_fieldName = replace(display_fieldName, ">", "")
							if not display_fieldName <> "" then
								display_fieldName =fieldname
							end if
							
							xpath_query="//s:ElementType[@name='" & tempName & "']/s:AttributeType[@name='" & UCase(fields_to_show(i)) & "']"
							set dataNode2 = oData.selectSingleNode(xpath_query)
							Set newAtt = oData.createAttribute("rs:name")	
							newAtt.value = display_fieldName
							dataNode2.setAttributeNode(newAtt)	
							dataNode2.setAttribute("name") = UCase(fields_to_show(i))
							
							err.Clear()
							
								
							end if
						end if
					Next 'i
					'now do this for structure, mw and formula
					xpath_query="//s:ElementType[@name='" & tempName & "']/s:AttributeType[@name='STRUCTURE']"
					set dataNode2 = oData.selectSingleNode(xpath_query)
					Set newAtt = oData.createAttribute("rs:name")	
					newAtt.value = "Structure"
					dataNode2.setAttributeNode(newAtt)	
					dataNode2.setAttribute("name") = "STRUCTURE"
					
					xpath_query="//s:ElementType[@name='" & tempName & "']/s:AttributeType[@name='MOLWEIGHT']"
					set dataNode2 = oData.selectSingleNode(xpath_query)
					Set newAtt = oData.createAttribute("rs:name")	
					newAtt.value = "MolWeight"
					dataNode2.setAttributeNode(newAtt)	
					dataNode2.setAttribute("name") = "MOLWEIGHT"
					
					xpath_query="//s:ElementType[@name='" & tempName & "']/s:AttributeType[@name='FORMULA']"
					set dataNode2 = oData.selectSingleNode(xpath_query)
					Set newAtt = oData.createAttribute("rs:name")	
					newAtt.value = "Formula"
					dataNode2.setAttributeNode(newAtt)	
					dataNode2.setAttribute("name") = "FORMULA"
					
					finaldoc = "/CFWTemp/" & Application("Appkey")  & "/" & dbkey & "temp/sessiondir/" & session.sessionid & "/TempTransformRS.xml"
					oData.save(server.MapPath(finaldoc))
					Set oXSL = Server.CreateObject("MSXML2.FreeThreadedDOMDocument.4.0")
					Set oFinalData = Server.CreateObject("MSXML2.FreeThreadedDOMDocument.4.0")
					XSLpath = "/" & Application("Appkey")  & "/export/convert_flat.xsl"
					oXSL.load(Server.MapPath(XSLpath))
					oFinalData.load(Server.MapPath(finaldoc))
					'create object for transform
					 bname = currentLogin & fso.GetBaseName(fso.GetTempName)
					'put the transform into a variable and write it to a file. 
					'If you put this in an object and save it as XML you end up loosing the &#10; which are key to the child table data rows delineation.
					'I can't find any other way to do this.
 
					Dim myvar
					myvar = oFinalData.transformNode(oXSL)
					on error resume next
					xmlName = "/CFWTemp/" & Application("Appkey")  & "/" & dbkey & "temp/sessiondir/" & session.sessionid & "/" & bname & ".xml"
					Set fs = Server.CreateObject("Scripting.FileSystemObject")
					Set a = fs.OpenTextFile(server.MapPath(xmlName), 8, True, -1)  
					a.Write myvar
					a.close
					xlsName = "/CFWTemp/" & Application("Appkey")  & "/" & dbkey & "temp/sessiondir/" & session.sessionid & "/" & bname & ".xls"
	
  
					'now let's open this in Excel
					dim ExcelApp, ExcelWB, oSheet, oCell, foundCell
					set ExcelApp = Server.createobject("Excel.Application")
					ExcelApp.visible = True


					set ExcelWB = ExcelApp.Workbooks.Open( Server.MapPath(xmlName))

					Set oSheet = ExcelWB.ActiveSheet

					ExcelWB.SaveAs Server.MapPath(xlsName), FileFormat=xlNormal

					ExcelWB.Close
					ExcelApp.quit

 
					'DisplayProcessingCount "UpdateWindow", counter-1
					Progressbar counter, recordcount,5
					counter = counter + 1
					if err.number <> 0 then
						'response.write err.number
					end if
				
			'DisplayProcessingCount "CloseWindow", ""
			
			
			server.ScriptTimeout = storeTimeout
		end if
		
	end if

	ExportFlatExcel = xlsName
End Function

Function AddLookups(dbkey, formgroup, paramSQL,strucid,export_type)
	if Session("bypass_ini" & dbkey & formgroup) = true then
		Select_Names = Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup)
	else
	
		if Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup) <> "" then
			if Not Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup)="NULL" then
				Select_Names = Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup)
			end if
		else
			Select_Names = GetLookupNameSelect(dbkey, formgroup)
		end if
	end if
	if Select_Names <> "" and Not Select_Names = "NULL" then
		temp = split(paramSQL, "FROM", -1)
		Working_from_where = " FROM " & temp(1)
		
		temp2 = split(temp(0), "SELECT",  -1)
		if inStr(temp2(1), "DISTINCTROW") then
			working_select = " SELECT DISTINCTROW " 
			working_fields = replace(temp2(1), "DISTINCTROW ", "")
		else
			if inStr(temp2(1), "DISTINCT") then
				working_select = "SELECT DISTINCT " 
				working_fields = replace(temp2(1), "DISTINCT ", "")
			else
				working_select = " SELECT "
				working_fields = temp2(1)
			end if
		end if
		
		Select_Names = replace(Select_Names, "||','||", "CS_CONCAT")
		working_fields_array= split(working_fields, ",", -1)
		working_lookup_fields = split(Select_Names, "|", -1)

		for i = 0 to UBound(working_fields_array)
			if UCase(export_type) = "FLAT" then
				field_name = working_fields_array(i)
				if instr(field_name, " as ")> 0 then
					temp1 = split(field_name, " as ", -1)
					field_name = trim(temp1(1))
				else 
						if instr(trim(field_name), " ")> 0 then
							temp1 = split(trim(field_name), " ", -1)
							field_name = trim(temp1(1))
						end if
				end if
			else
				field_name = working_fields_array(i)
			end if
		bItemFound =false
			for j = 0 to UBound(working_lookup_fields)
				if Instr(working_lookup_fields(j), "::")> 0 then
					working_lookup_fields_array = split(working_lookup_fields(j), "::", -1)
					if UCase(export_type) = "FLAT" then
							test_field = working_lookup_fields_array(0)
							test_field = replace(test_field, ".", "_")
							test_length = len(test_field)
							if CInt(test_length)> 27 then
								trim_length =  CInt(test_length) - 27
								test_field = right(test_field, CInt(test_length)-CInt(trim_length))
							end if
					else
						test_field = working_lookup_fields_array(0)
					end if
					select_value = working_lookup_fields_array(1)
					select_value = replace(select_value, "SELECT ", " LOOKUP_S ")
					select_value = replace(select_value, " FROM ", " LOOKUP_F ")
					select_value = replace(select_value, " WHERE ", " LOOKUP_W ")
					
				else
					if UCase(export_type) = "FLAT" then
							test_field = working_lookup_fields(j)
							test_field = replace(test_field, ".", "_")
							test_length = len(test_field)
							if CInt(test_length)> 27 then
								trim_length =  CInt(test_length) - 27
								test_field = right(test_field, CInt(test_length)-CInt(trim_length))
							end if
					else
						test_field = working_lookup_fields(j)
					end if
				end if
					if strucid <> "" then
						if Not Instr(UCase(Trim(field_name)),UCase(strucid))>0 then
							if UCase(export_type) = "FLAT" then
								working_field_test =working_fields_array(i)
								if instr(working_field_test, " as ")> 0 then
									temp1 = split(working_field_test, " as ", -1)
									working_field_test = trim(temp1(1))
								else 
										if instr(trim(working_field_test), " ")> 0 then
											temp1 = split(trim(working_field_test), " ", -1)
											working_field_test = trim(temp1(1))
										end if
								end if
							else
								working_field_test =working_fields_array(i)
							end if
							if  UCase(Trim(working_field_test))= UCase(Trim(test_field)) AND select_value <> "" then
								if Not UCase(export_type) = "FLAT" then
									
									temp_final=split(working_fields_array(i), ".", -1)
								end if
								
								if UCase(export_type) = "FLAT" then
									field_name_as =working_field_test
									
								else
									field_name_as = temp_final(UBound(temp_final))
								end if
								if return_fields <> "" then
									return_fields = return_fields & "," & "(" & select_value & ")" & " as " & field_name_as
								else
									return_fields = "(" & select_value & ")" & " as " & field_name_as
								end if
								bItemFound = true
							end if
						end if
					else
						
							if (UCase(Trim(field_name)) = UCase(Trim(test_field))) AND select_value <> "" then
								if UCase(export_type) = "FLAT" then
									working_field_test =working_fields_array(i)
									if instr(working_field_test, " as ")> 0 then
										temp1 = split(working_field_test, " as ", -1)
										working_field_test = trim(temp1(1))
									else 
											if instr(trim(working_field_test), " ")> 0 then
												temp1 = split(trim(working_field_test), " ", -1)
												working_field_test = trim(temp1(1))
											end if
									end if
								else
									temp_final=split(working_fields_array(i), ".", -1)
								end if
								if UCase(export_type) = "FLAT" then
									field_name_as = working_field_test
								else
									field_name_as = temp_final(UBound(temp_final))
								end if
								if return_fields <> "" then
									return_fields = return_fields & "," & "(" & select_value & ")" & " as " & field_name_as
								else
									return_fields = "(" & select_value & ")" & " as " & field_name_as
								end if
								bItemFound = true
							end if
						
					end if
			next 'j
			if bItemFound = false then
				if return_fields <> "" then
					return_fields = return_fields & "," & working_fields_array(i)
				else
					return_fields =working_fields_array(i)
				end if
			end if
		next 'i
		'protect keywords
		
		theReturn  = working_select & return_fields & working_from_where
		
	else	
		theReturn = paramSQL
	end if
	
	AddLookups = theReturn	
End Function

Function GetLookupNameSelect(dbkey, formgroup)
		LookupNames = GetINIValue( "optional", formgroup, "SDFILE_LOOKUP_FIELDS", "web_app", dbkey)
		if Instr(UCase(LookupNames), "ADD_LINES")>0 then
			LookupNames=AppendToSDFileStr(formgroup, dbkey, LookupNames,"SDFILE_LOOKUP_FIELDS" )
		end if
		Application.Lock
		Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup)=LookupNames
		if (Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup)="INIEmpty" or Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup) = "NULL" or Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup) = "") then
			Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup)="NULL"
		end if
		Application.UnLock
		GetLookupNameSelect=Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup)
End function

Function AppendToSDFileStr(ByVal section_name,ByVal currentDB, ByVal inputStr,ByVal key_name)
	Dim finalStr, NewEntry,AppendedStr,tempArray,tempArray2,theCount,lineIdent,tempINIEntry,NumAdditional
	
	StrSeparator = "|"
	ItemSeparator = "::"
	
	tempArray = Split(inputStr, StrSeparator, -1)
	theCount = UBound(tempArray)
	lineIdent = tempArray(theCount)
	newArray = Split(lineIdent, ItemSeparator, -1)
	NumAdditional = newArray(1)
	if Not NumAdditional <> "" then 
		NumAdditional = 0
		finalStr = Replace(inputStr, StrSeparator & lineIdent, " ")
	end if
	if NumAdditional > 0 then

		For i = 1 to NumAdditional
			NewEntry =GetINIValue("optional",  UCase(section_name), UCase(key_name) & i, "web_app", currentDB)
			if AppendedStr <> "" then
				AppendedStr = AppendedStr & StrSeparator & NewEntry
			Else
				AppendedStr = NewEntry
			End if
		Next 'i
	finalStr = Replace(inputStr, lineIdent, AppendedStr)
	End if
	
	AppendToSDFileStr = finalStr

End Function

Function RemoveLookupKeywords(sql)

	theReturn = replace(sql, " LOOKUP_S ", " SELECT ")
	theReturn = replace(theReturn, " LOOKUP_F ", " FROM ")
	theReturn = replace(theReturn, " LOOKUP_W ", " WHERE ")
	theReturn = replace(theReturn, "CS_CONCAT", "||','||")

RemoveLookupKeywords = theReturn
End Function

Function alias_all_names(syntax,inputstr)

	temp = split(inputstr, ",", -1)
	
	if syntax = "ORACLE" then
		for i = 0 to UBound(temp)
			alias_name = replace(temp(i), ".", "_")
			test_length = len(alias_name)
			if CInt(test_length)> 27 then
				trim_length_try=27
				trim_length =  CInt(test_length) - trim_length_try
				alias_name = right(alias_name, CInt(test_length)-CInt(trim_length))
				Do Until Not (left(alias_name,1) = Chr(95))
					trim_length =  CInt(test_length) - trim_length_try
					alias_name = right(alias_name, CInt(test_length)-CInt(trim_length))
					trim_length_try = trim_length_try - 1
				loop
				'DJP test if 27the char is a num if so then use "a" if not then use what is there
				leftChar = left(alias_name,1)
				if instr("0123456789",leftChar)>0 then
					alias_name = "a" & right(alias_name,len(alias_name)-1)
				end if
			end if
			if new_list <> "" then
			
				new_list = new_list & "," &  temp(i) & " " & alias_name 
				alias_only = alias_only & "," & alias_name 
			else
				new_list=temp(i) & " " & alias_name 
				alias_only =alias_name 
			end if
		next
	
	else
		for i = 0 to UBound(temp)
			alias_name = replace(temp(i), ".", "_")
			test_length = len(alias_name)
			if CInt(test_length)> 27 then
				trim_length_try=27
				trim_length =  CInt(test_length) - trim_length_try
				alias_name = right(alias_name, CInt(test_length)-CInt(trim_length))
				Do Until Not (left(alias_name,1) = Chr(95))
					trim_length =  CInt(test_length) - trim_length_try
					alias_name = right(alias_name, CInt(test_length)-CInt(trim_length))
					trim_length_try = trim_length_try - 1
				loop
			end if
			if new_list <> "" then
				new_list = new_list & "," & temp(i) & " as " & alias_name 
				alias_only = alias_only & "," & alias_name 
			else
				new_list=temp(i) & " as " & alias_name 
				alias_only = alias_name 
			end if
		next
	
	end if
	final_list = new_list & "|||" & alias_only
	
	alias_all_names = split(final_list, "|||", -1)
End function


Function makeAliasCompat(syntax,alias_name)
	test_length = len(alias_name)
	if CInt(test_length)> 27 then
		trim_length_try=27
		trim_length =  CInt(test_length) - trim_length_try
		alias_name = right(alias_name, CInt(test_length)-CInt(trim_length))
		Do Until Not (left(alias_name,1) = Chr(95))
			trim_length =  CInt(test_length) - trim_length_try
			alias_name = right(alias_name, CInt(test_length)-CInt(trim_length))
			trim_length_try = trim_length_try - 1
		loop
		if UCase(syntax) = "ORACLE" then
			'DJP test if 27the char is a num if so then use "a" if not then use what is there
			leftChar = left(alias_name,1)
			if instr("0123456789",leftChar)>0 then
				alias_name = "a" & right(alias_name,len(alias_name)-1)
			end if
		end if
	end if
	makeAliasCompat = alias_name
End Function

'LJB 3/2005 function for getting display names for fields. This dictionary is created in the export_hits_dialog.asp file prior to export
function getDisplayNamesForSDExport(fieldname)
	if session("export_hits_display_names_DICT").Exists(UCase(fieldname)) then
		displayName = session("export_hits_display_names_DICT").Item(UCase(fieldname))
	else
		displayName = fieldname
	end if
	getDisplayNamesForSDExport= displayName
end function

'DGB to fix CSBR-50143
' When structures are edited in ChemReg the base64_cdx saved in the
' database contains a linebrake every 65 characters.  Ocasionally, 
' a line brake coincides with the end of the base64_cdx string. This causes a
' problem while exporting the base64_cdx field to an sdf because
' the sdf spec does not allow for two consecutive linebrakes at
' the end of a data field.  
' To avoid this problem, the line brake at the end of the field is
' now only added if the data does not already contain a line brake at the end.
'
' f is a reference to the text file, val is the value of the data field.
Sub WriteSdfDataField(byref f, val)
'LJB 3/2005 If fields are blank a line should be written with a space. 
'Otherwise upon import to excel the fields are not recognized and all data after the empty field is misaligned
	if trim(val) <> "" then
		f.writeline val
		if NOT ((asc(right(val,2)) = 13) AND (asc(right(val,1))= 10)) then f.writeline ""
	else
		f.writeline " "
	end if
End sub

'LJB 5/1/2005 Function to get the fields in the sort list for a child table when the XML widget is used to sort
function GetLastWidgetChildTableSort(childTableName)'
	dim theReturn
	theReturn=""
	hitlistid = Session("HitListID" & "biosar_browser" & "1189")
	if Session("allInnerSorts") <> "" then
		temp = split(Session("allInnerSorts"), "|", -1) 
		'loop backwards since we are interested in the most recent sort
		for i = 0 to UBound(temp)
			temp2 = split(temp(i), ".", -1)
			test = Trim(replace(childTableName, ".", "_"))& "_RS"
			if Trim(UCase(temp2(0))) = test then
				theReturn = childTableName & "." & temp2(1) ' return the fieldname and the sort direction
				exit for
			end if
		next
	end if
	GetLastWidgetChildTableSort=theReturn
end function

'LJB 4/30/2005 break off order by clause and alias all names. This was causing sorting to break
Function aliasOrderBy(SQLSyntax, param_sql)
	'if SQLSyntax = "ORACLE" then
		temp_param = split(param_sql, "ORDER BY", -1)
		param_sql = temp_param(0)
		order_by = temp_param(1)
			temp_order_by = split(order_by, ",", -1)
			
			for k = 0 to UBound(temp_order_by)
				sortByField=temp_order_by(k)
				if Trim(sortByField)<> "" then
					if instr(UCase(temp_order_by(k)), "DESC") > 0 then
							storeDirection = " DESC"
							
							sortByField=replace(sortByField, " asc", " ASC")
							sortByField=replace(sortByField, " Asc", " ASC")
							sortByField=replace(sortByField, " desc", " DESC")
							sortByField=replace(sortByField, " Desc", " DESC")
							fieldNameTemp =split(sortByField, " DESC", -1)
							fieldName = Trim(fieldNameTemp(0))
					else
							if instr(UCase(temp_order_by(k)), "ASC") > 0 then
								storeDirection = " ASC"
								sortByField=replace(sortByField, " asc", " ASC")
								sortByField=replace(sortByField, " Asc", " ASC")
								sortByField=replace(sortByField, " desc", " DESC")
								sortByField=replace(sortByField, " Desc", " DESC")
								fieldNameTemp =split(sortByField, " ASC", -1)
								fieldName = Trim(fieldNameTemp(0))
							else
								storeDirection = " " 
								fieldName=sortByField
							end if
					end if
					
					newAliasedFieldName = alias_all_names(SQLSyntax,fieldName)
				
					
					finalAliasedName = newAliasedFieldName(1)
				
				
					if new_order_by <> "" then
						new_order_by = new_order_by & "," & finalAliasedName  & storeDirection
					else
						new_order_by = finalAliasedName  & storeDirection
					end if
				end if
			next
	
			aliasOrderBy = param_sql & " ORDER BY " & new_order_by
		'else
			'aliasOrderBy = param_sql
		'end if
end function

'LJB 5/1/2005 Function to get the fields in the sort list fo the base table when the XML widget is used to sort
function GetLastWidgetBaseTableSort(basetable)
	dim theReturn
	theReturn = ""
	if Session("allOuterSorts") <> "" then
		temp = split(Session("allOuterSorts"), "|", -1)
		'return the last sort
		theReturn = basetable & "." & temp(UBound(temp))
	end if
	GetLastWidgetBaseTableSort=theReturn
End Function

'LJB 5/1/2005 function to add fields from the order by clause to the select list. Also keeps a running list of fields
'added so they will be hidden when the sdf file is written
function AddFieldToSelectList(sortByField,fieldList)
	temp = split(fieldList, ",", -1)
	sortByField=replace(sortByField, " asc", " ASC")
	sortByField=replace(sortByField, " Asc", " ASC")
	sortByField=replace(sortByField, " desc", " DESC")
	sortByField=replace(sortByField, " Desc", " DESC")
	if instr(UCase(sortByField), "ASC") > 0 then
		fieldNameTemp =split(sortByField, " ASC", -1)
		fieldName = Trim(fieldNameTemp(0))
	else
		if instr(UCase(sortByField), "DESC") > 0 then
			fieldNameTemp =split(sortByField, " DESC", -1)
			fieldName = Trim(fieldNameTemp(0))
		else
			fieldName = Trim(sortByField)
		end if 
	end if 
	itemFound = false
	for i = 0 to UBound(temp)
		if UCase(temp(i)) = UCase(fieldName) then
			itemFound = true
			exit for
		end if
	next
	
	
	if itemFound = true then
		AddFieldToSelectList = ""
	else
		AddFieldToSelectList = fieldName
		'keep a list of added fields so they will not be displayed in the sdfile.
		if Session("FieldsToHideFromDisplay") <> "" then
			Session("FieldsToHideFromDisplay") = Session("FieldsToHideFromDisplay") & "," & fieldName
		else
			Session("FieldsToHideFromDisplay") = fieldName
		end if
	end if
	
End function
'LJB 5/1/2005 function to add fields from the order by clause to the select list for Nested export of child tables. Also keeps a running list of fields
'added so they will be hidden when the sdf file is written
function AddFieldToSelectListNested(sortByField,fieldList)
	temp = split(fieldList, ",", -1)
	sortByField=replace(sortByField, " asc", " ASC")
	sortByField=replace(sortByField, " Asc", " ASC")
	sortByField=replace(sortByField, " desc", " DESC")
	sortByField=replace(sortByField, " Desc", " DESC")
	if instr(UCase(sortByField), "ASC") > 0 then
		fieldNameTemp =split(sortByField, " ASC", -1)
		fieldName = Trim(fieldNameTemp(0))
	else
		if instr(UCase(sortByField), "DESC") > 0 then
			fieldNameTemp =split(sortByField, " DESC", -1)
			fieldName = Trim(fieldNameTemp(0))
		end if
	end if 
	itemFound = false
	for i = 0 to UBound(temp)
		if UCase(temp(i)) = UCase(fieldName) then
			itemFound = true
			exit for
		end if
	next
	
	
	if itemFound = true then
		AddFieldToSelectListNested = ""
	else
		AddFieldToSelectListNested = fieldName
		'keep a list of added fields so they will not be displayed in the sdfile.
		if Session("FieldsToHideFromDisplayNested") <> "" then
			Session("FieldsToHideFromDisplayNested") = Session("FieldsToHideFromDisplayNested") & "," & fieldName
		else
			Session("FieldsToHideFromDisplayNested") = fieldName
		end if
	end if
	
End function

'LJB 5/1/2005 function to determine if a field should be hidden form the sdf output because it was added only because it was in the order by clause.
Function HideFieldFromDisplay(testField)
	dim hideField
	hideField = false
	if Session("FieldsToHideFromDisplay") <> "" then
		temp = split(Session("FieldsToHideFromDisplay"), ",", -1)
		for i = 0 to Ubound(temp)
			if UCase(temp(i)) = UCase(testField) then
				hideField = true
				exit for
			end if
		next
	end if
	HideFieldFromDisplay = hideField
End Function

'LJB 5/1/2005 function to determine if a field should be hidden form the sdf output for nested child table fields because it was added only because it was in the order by clause.
Function HideFieldFromDisplayNested(testField)
	dim hideField
	hideField = false
	if Session("FieldsToHideFromDisplayNested") <> "" then
		temp = split(Session("FieldsToHideFromDisplayNested"), ",", -1)
		for i = 0 to Ubound(temp)
			if UCase(temp(i)) = UCase(testField) then
				hideField = true
				exit for
			end if
		next
	end if
	HideFieldFromDisplayNested = hideField
End Function


Function getShapeConn()
	if Not isObject(shapeConn) then
		Set shapeConn = GetNewDataShapeConnection(dbkey, formgroup, "base_connection")
	else
		if shapeConn.state = 0 then
			Set shapeConn = GetNewDataShapeConnection(dbkey, formgroup, "base_connection")
		end if
	end if
	Set getShapeConn = shapeConn
end  function
%>