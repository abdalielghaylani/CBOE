<%' Copyright 1998-2002, CambridgeSoft Corp., All Rights Reserved
'DO NOT EDIT THIS FILE

'-------------------------------------------------------------------------------
' Purpose: 'Nested SD File export
' Assumes:
' Inputs:
'-------------------------------------------------------------------------------

Function exportSDFile(ByVal dbkey, ByVal formgroup, ByVal fieldstoexport_input, ByVal ExportType, ByVal MaxExportNumber, ByVal bStrucDataOut)
	hitlistid = Session("HitListID" & dbkey & formgroup)
	test = Application("ALLOW_SORT_ALL_FIELDS")
	test2= Session("order_by" & dbkey & formgroup)
	fieldstoexport=TrimItemsInString(dbkey, formgroup, fieldstoexport_input)
	subFormsString = getTablesString(dbkey, formgroup, fieldstoexport)
	orig_fieldstoexport = fieldstoexport
	'LJB 5/1/2002 clear variable that is used to add fields from the order by clause to the select statement. They are necessary for the select
	'but should not be output to the sdf file
	Session("FieldsToHideFromDisplay")=""
	Session("FieldsToHideFromDisplayNested")=""
	basetable = GetBaseTable(dbkey, formgroup, "basetable")
	SQLSyntax = GetTableVal(dbkey, basetable,kSQLSyntax)
	formmode = request("formmode")
	'LJB 5/1/2002 Get list of field from sort statements that need to be added to the base table select clause
	if Session("allOuterSorts") <> "" then
		'Session("order_by" & dbkey & formgroup)=""
		basetableSort = GetLastWidgetBaseTableSort(basetable)
		'make sure the sort by field is in the field list
		
		fieldsToAddTemp= AddFieldToSelectList(basetableSort,fieldstoexport)
		if fieldsToAddTemp <> "" then
			if fieldstoexport <> "" then
				fieldstoexport  = fieldstoexport & ","&  fieldsToAddTemp
			else
				fieldstoexport  =fieldsToAddTemp
			end if
		end if
		order_by =" ORDER BY " & basetableSort
	else
		if Session("order_by" & dbkey & formgroup) <> "" then
			order_by_temp=" ORDER BY " & Session("order_by" & dbkey & formgroup)
			if Session("sort_direction" & dbkey & formgroup) <> "" then
				sort_direction = Session("sort_direction" & dbkey & formgroup)
			end if
			order_by =order_by_temp & " " & sort_direction
		end if 
	end if
	
	Select case UCase(ExportType)
		Case "VIEW"
			Session("error" & dbkey & formgroup)= False
			true_basetable = GetBaseTable(dbkey, formgroup, "basetable")
			basetable = true_basetable
			true_baseid = GetTableVal(dbkey, basetable, kPrimaryKey)
			ViewInfo = GetFormGroupVal(dbkey, formgroup,kSDFileFields)
			ViewInfoArray = Split(ViewInfo,";", -1)
			ViewInfoArray2 = Split(ViewInfoArray(0), ":", -1)
			view_basetable = ViewInfoArray2(1)
			view_baseid =  true_baseid
			StrucUniqueID = "MOL_ID"
			if maxexportNumber <> "" then
				maxhits = maxexportNumber
			else
				maxhits = ""
			end if
			set DataConn = GetNewConnection(dbkey, formgroup, "base_connection")
			if Not StrucUniqueID = "NULL" then
				fieldstoexport_final = checkForMolid(dbkey, formgroup, fieldstoexport,basetable & "." & "mol_id")
			else
				fieldstoexport_final =fieldstoexport
			end if
			strGetFields = replace(fieldstoexport_final, view_basetable, UCase(true_basetable))
			dim hitlistid
			
			param_sql = BuildSelectStatement(dbkey, formgroup, true_basetable, "",strGetFields,maxhits)
		
			param_sql=replace(param_sql, UCase(true_basetable), view_basetable)
		
			'creates sql where hitlistid is the parameter
			if MaxHits <> "" then
				param_sql=AddLookups(dbkey,formgroup,param_sql, StrucUniqueID,"NESTED")
				param_sql = AddParamCSDOHitListToSelect_WithMAX(dbkey, formgroup, param_sql,"?","?" )
				param_sql = replace(param_sql, ",,", ",") & order_by

				If CBool(Application("ALLOW_SORT_ALL_FIELDS"))= true and Session("order_by" & dbkey & formgroup) <> "" then
					param_sql= removeDistinct(dbkey, formgroup, param_sql)
				end if
				param_sql=RemoveLookupKeywords(param_sql)
				Set BaseTablecmd = Server.CreateObject("ADODB.Command")
				BaseTablecmd.CommandText = param_sql
				BaseTablecmd.CommandType = adCmdText
				
				
				BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("hitlistid", 5, 1,0,Session("HitListID" & dbkey & formgroup))
				BaseTablecmd.ActiveConnection = DataConn 
				
			else
		
				param_sql=AddLookups(dbkey,formgroup,param_sql,StrucUniqueID,"NESTED")
				param_sql = AddParamCSDOHitListToSelect(dbkey, formgroup, param_sql,"?")
				param_sql = replace(param_sql, ",,", ",") & order_by

				If CBool(Application("ALLOW_SORT_ALL_FIELDS"))= true and Session("order_by" & dbkey & formgroup) <> "" then
					param_sql= removeDistinct(dbkey, formgroup, param_sql)
				end if
				param_sql=RemoveLookupKeywords(param_sql)
				Set BaseTablecmd = Server.CreateObject("ADODB.Command")
				BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("hitlistid", 5, 1,0,Session("HitListID" & dbkey & formgroup))
				
				BaseTablecmd.CommandText = param_sql
				BaseTablecmd.CommandType = adCmdText
				BaseTablecmd.ActiveConnection = DataConn 
				
			end if
		
		Case Else 'Tables
			Session("error" & dbkey & formgroup)= False
			
			if UCase(formgroup) = "REG_CTRBT_COMMIT_FORM_GROUP" or UCase(formgroup)="REVIEW_REGISTER_FORM_GROUP" then
				hitlistID= Session("HitListID" & dbkey & formgroup)
				formgroup =  "REG_CTRBT_FORM_GROUP"
				Session("HitListID" & dbkey & formgroup) = hitlistID
			end if
			basetable = GetBaseTable(dbkey, formgroup, "basetable")
			
			baseid = GetTableVal(dbkey, basetable, kPrimaryKey)
			
			StrucUniqueID = GetTableVal(dbkey, basetable,kStrucFieldID)
			
			
			if maxexportNumber <> "" then
				maxhits = maxexportNumber
			else
				maxhits = ""
			end if
			set DataConn = GetNewConnection(dbkey, formgroup, "base_connection")
			tempFields = getTableExportFields(basetable, fieldstoexport)
			
			if Not StrucUniqueID = "NULL" then
				fieldstoexport_final = checkForMolid(dbkey, formgroup, tempFields,basetable & "." & StrucUniqueID )
			else
			fieldstoexport_final =tempFields
			end if
		
			if not Instr(UCase(fieldstoexport_final), UCase(basetable) & "." & UCase(baseid) )> 0  AND not Instr(UCase(fieldstoexport_final), "[" & UCase(basetable) & "].[" & UCase(baseid)  & "]")> 0  then
				strGetFields = basetable & "." & baseid & "," & fieldstoexport_final
			else
				strGetFields = fieldstoexport_final
			end if
			'LJB don't send subforms when creating select statment when XML Widget sorting is being used
			If CBool(Application("ALLOW_SORT_ALL_FIELDS"))= true and Session("order_by" & dbkey & formgroup) <> "" then
				param_sql = BuildSelectStatement(dbkey, formgroup, basetable, Session("strWhereSubforms" & dbkey & formgroup),strGetFields,"")
			else
				param_sql = BuildSelectStatement(dbkey, formgroup, basetable,"",strGetFields,"")
			end if
			param_sql = FinalizeSQl(dbkey, formgroup, param_sql, basetable)
			
			
			'creates sql where hitlistid is the parameter
			if MaxHits <> "" then
				basetable = getBaseTable(dbkey, formgroup, "basetable")
				SQLSyntax = getTableVal(dbkey, basetable, kSQLSyntax)
				param_sql=AddLookups(dbkey,formgroup,param_sql,StrucUniqueID,"NESTED")
				if UCase(SQLSyntax) = "ORACLE" then
					param_sql = AddParamCSDOHitListToSelect_WithMAX(dbkey, formgroup, param_sql,"?","?" )
				else
					param_sql = AddParamCSDOHitListToSelect_WithMAX(dbkey, formgroup, param_sql,"?",maxhits )
				end if
				param_sql = replace(param_sql, ",,", ",") & order_by

				If CBool(Application("ALLOW_SORT_ALL_FIELDS"))= true and Session("order_by" & dbkey & formgroup) <> "" then
					param_sql= removeDistinct(dbkey, formgroup, param_sql)
				end if
				param_sql=RemoveLookupKeywords(param_sql)
				Set BaseTablecmd = Server.CreateObject("ADODB.Command")
				BaseTablecmd.CommandText = param_sql
				BaseTablecmd.CommandType = adCmdText
				
				if UCase(SQLSyntax) = "ORACLE" then
					BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("hitlistid", 5, 1,0,Session("HitListID" & dbkey & formgroup))
					BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("max", 5, 1,0,MaxHits)
				else
					BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("hitlistid", 5, 1,0,Session("HitListID" & dbkey & formgroup))
				end if

				BaseTablecmd.ActiveConnection = DataConn 
				
			else
				
				param_sql=AddLookups(dbkey,formgroup,param_sql,StrucUniqueID,"NESTED")
				param_sql = AddParamCSDOHitListToSelect(dbkey, formgroup, param_sql,"?")
				param_sql = replace(param_sql, ",,", ",") & order_by
				If CBool(Application("ALLOW_SORT_ALL_FIELDS"))= true and Session("order_by" & dbkey & formgroup) <> "" then
					param_sql= removeDistinct(dbkey, formgroup, param_sql)
				end if
				param_sql=RemoveLookupKeywords(param_sql)
				Set BaseTablecmd = Server.CreateObject("ADODB.Command")
				BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("hitlistid", 5, 1,0,Session("HitListID" & dbkey & formgroup))
				BaseTablecmd.CommandText = param_sql
				BaseTablecmd.CommandType = adCmdText
				BaseTablecmd.ActiveConnection = DataConn 
				
			end if
	End Select
	on error resume next

	Set RS = Server.CreateObject("ADODB.RECORDSET")
	RS.CursorType = 3
	RS.Open BaseTableCmd
	Trace "DoNestedExport HITLISTID:" & Session("HitListID" & dbkey & formgroup) & ":SQL= " & param_sql, 20
	recordcount = GetRecordCount(dbkey, formgroup, rs)

	
	if maxexportNumber<> "" then
		FlushMessageToClient("export is limited to a maximum of " & maxexportNumber & " records.")
		FlushMessageToClient("exporting " & recordcount & " records...")
	else
		FlushMessageToClient("exporting " & recordcount & " records...")
	end if
	
	if err.number <> 0 or Not recordcount <> "" then
		Session("fEmptyRecordset" & dbkey & formgroup) = True
		FlushMessageToClient("The recordset was not succesfully created: <br>" & param_sql)
		FlushMessageToClient("Error : <br>" &  err.number & err.description)
		Response.end
	else
			molfilepath = Application("TempFileDirectory" & dbkey) & "Sessiondir\" & Session.sessionid & "\"
			molfilepathhttp =Application("TempFileDirectoryHTTP" & dbkey) & "Sessiondir/" & Session.sessionid & "/"
	
			sdfilename=  GetTimeStamp()
	
			Set fs = Server.CreateObject("Scripting.FileSystemObject")
			Set a = fs.CreateTextFile(molfilepath & sdfilename & ".sdf")  
			storeTimeout = server.ScriptTimeout
			server.ScriptTimeout = 10000000
			
			If not (RS.EOF and RS.BOF) = true then
				if Not UseCartridge(dbkey, formgroup) then
					Set myConnection = CSDOGetCSDOConnection(dbkey, formgroup)
				end if
				RS.MoveFirst
				counter = 1
				
				if Not detectNS4() = true then
					InitializeProgressBar true, ""
				end if
'stop
				'DGB this block used to be inside the loop.  
				'I pulled it out since it has no depency in loop variable l
				Tablename = GetBaseTable(dbkey, formgroup, "moltable")
				if Not UCase(ExportType) = "VIEW" then
						if UseCartridge(dbkey, formgroup) then
							on error resume next
							strucFields = getFormGroupVal(dbkey, formgroup, kStructureFields)
							temp_fields_array = split(strucFields, ",", -1)
							for p = 0 to Ubound(temp_fields_array)
								temp_fields2= split(temp_fields_array(p), ".", -1)
								
								if UBound(temp_fields2) = 2 then
									struc_table_name = temp_fields2(0) & "." & temp_fields2(1)
									'struc_table_name = GetTableVal(dbkey, struc_table_name, kTableRealName)
									struc_fieldname = temp_fields2(2)
								else
									struc_table_name = temp_fields2(0)
									'struc_table_name = GetTableVal(dbkey, struc_table_name, kTableRealName)
									struc_fieldname = temp_fields2(1)
								end if
								currentTable = UCase(Trim(Tablename))
								theStrucTable = UCase( Trim(struc_table_name))
								if (theStrucTable =currentTable) or (currentTable = Ucase(basetable)) then
									if struc_fields <> "" then
										struc_fields = struc_fields & "," & struc_fieldname
									else
										struc_fields = struc_fieldname
									end if
								end if
							next
							Structure_Fieldname = "Structure"
							'DGB Fix for CSBR-74336
							'When the base table is not the strurctures table struc_fields was not populated above
							if struc_fields = "" then struc_fields = Structure_Fieldname
						else
							Structure_Fieldname = "Structure"
						end if
					else
						if UseCartridge(dbkey, formgroup) then
						
							on error resume next
							strucFields = getFormGroupVal(dbkey, formgroup, kStructureFields)
							temp_fields_array = split(strucFields, ",", -1)
							for p = 0 to Ubound(temp_fields_array)
								temp_fields2= split(temp_fields_array(p), ".", -1)
								
								if UBound(temp_fields2) = 2 then
									struc_table_name = temp_fields2(0) & "." & temp_fields2(1)
									struc_fieldname = temp_fields2(2)
								else
									struc_table_name = temp_fields2(0)
									struc_fieldname = temp_fields2(1)
								end if
								
								if  UCase(ExportType) = "VIEW" then
									TableName = view_basetable
								end if
							
								currentTable = UCase(Trim(Tablename))
								theStrucTable = UCase( Trim(struc_table_name))
								if (theStrucTable =currentTable) or (currentTable = Ucase(basetable)) then
									if struc_fields <> "" then
										struc_fields = struc_fields & "," & struc_fieldname
									else
										struc_fields = struc_fieldname
									end if
								end if
							next
							Structure_Fieldname = "View_Structure"
						else
							Structure_Fieldname = "View_Structure"
						end if
					end if
				' DGB end of block pulled from loop
	
				For l = 1 to recordcount ' This is the loop over base table records
				
					if Not detectNS4() = true then
						FlushMessageToClient(" ")
					end if
					
					UniqueID = RS(StrucUniqueID)
					baseid_value = RS(Baseid)
				
					if (Not UniqueID = "") AND (Not isEmpty(UniqueID)) then
						if Not UCase(ExportType) = "VIEW" then
							UniqueID = RS(StrucUniqueID)
						else
							basetable = view_basetable
							UniqueID = RS(StrucUniqueID)
						end if
					end if
					if bStrucDataOut = true then 'output structure mw and formula
						if (Not UniqueID = "") AND (Not isEmpty(UniqueID)) then
							If CLng(UniqueID) > 0 then
								myTime = Timer()
								Fieldname = Structure_Fieldname
								' return molweight
								'check to see if there is a structure
								if UseCartridge(dbkey, formgroup) then
									
									mw_table_name = struc_table_name
									CSDOGetChemData dbkey, formgroup, mw_table_name, Fieldname, UniqueID, "MOLWEIGHT", DataConn
								else ' Use CSDO to produce sdout.mol
								
									mw_table_name = TableName
									struc_table_name = mw_table_name
									CSDOGetChemData dbkey, formgroup, mw_table_name, Fieldname, UniqueID, "sdout.mol", myConnection
								end if
								If Not Session("MW" & dbkey & formgroup & struc_table_name & Fieldname & UniqueID)="" then
									if UseCartridge(dbkey, formgroup) then
										CSDOGetChemData dbkey, formgroup, struc_table_name, Fieldname, UniqueID, "FORMULA", DataConn
									
										fields_array = split(struc_fields, ",", -1)
										for q = 0 to UBound(fields_array)
											Session("molfile" & dbkey & formgroup) =""
											
											CSDOGetChemData dbkey, formgroup, struc_table_name,fields_array(q), UniqueID, "get_molfile", DataConn
											'DGB Remove extra line after Connection Table
											a.WriteLine TrimRightCrlf(Session("molfile" & dbkey & formgroup)) 
										next
									else ' Used CSDO read sdout.mol
										myDir = molfilepath & "sdout.mol"
										Set b = fs.OpenTextFile(myDir)
										do while b.AtEndOfStream <> True
											myvar = b.ReadLine
											a.WriteLine myvar
										loop
										b.close
									end if
								end if
								'no need to output this
								'a.WriteLine ">  <" & StrucUniqueID & "> " & "(" & counter & ")"
								'a.WriteLine UniqueID
								'DGB Remove extra line after Connection Table
								'a.WriteLine " "
								fieldvalue = Session("MW" & dbkey & formgroup & struc_table_name & Fieldname & UniqueID)
								output_fieldname = "MolWeight"
								a.WriteLine ">  <" & output_fieldname & "> " & "(" & counter & ")"
								'DGB Isis/Base does not like too many decimals in the MW
								WriteSdfDataField a, Round(fieldvalue,4)
								
								output_fieldname = "Formula"
								fieldvalue = Session("Formula" & dbkey & formgroup & struc_table_name & Fieldname & UniqueID)
								a.WriteLine ">  <" & output_fieldname & "> " & "(" & counter & ")"
								WriteSdfDataField a, fieldvalue
								
							end if
						end if
					end if
						
					on error resume next
				
					Dim i
					
					For i = 0 to RS.Fields.Count-1 ' This loop outputs base table fields other than chemical fields
						fieldname = ""
						fieldname = RS.Fields.Item(i).Name
						display_fieldName = ""
						
						if Not UCase(fieldname) = UCase(StrucUniqueID) then
							'LJB 5/1/2004 check to see if current field was added only because it is in the order by clause. it should not be displayed.
							if Not HideFieldFromDisplay(basetable & "." & fieldname) then
								if UCase(fieldname) = UCase(Baseid) AND CheckOrigRequest(basetable & "." & baseid,fieldstoexport ) then
										
										'LJB 3/2005 get display names from export specific dictionary created in export_hits_dialog.asp
										display_fieldName = getDisplayNamesForSDExport(basetable & "." & fieldname)
										display_fieldName = replace(display_fieldName, "<sup>", "")
										display_fieldName = replace(display_fieldName, "</sup>", "")
										display_fieldName = replace(display_fieldName, "<sub>", "")
										display_fieldName = replace(display_fieldName, "</sub>", "")
										display_fieldName = replace(display_fieldName, "<", "")
										display_fieldName = replace(display_fieldName, ">", "")
										if not display_fieldName <> "" then
											display_fieldName =fieldname
										end if
										fieldvalue = RS.Fields.Item(i).Value
										a.WriteLine ">  <" & display_fieldName & "> " & "(" & counter & ")"
										WriteSdfDataField a, fieldvalue
										
								else
										'display_fieldName = getLabelNameFromDict(dbkey, formgroup, formmode,basetable & "." & fieldname)
										'LJB 3/2005 get display names from export specific dictionary created in export_hits_dialog.asp
										display_fieldName = getDisplayNamesForSDExport(basetable & "." & fieldname)
										display_fieldName = replace(display_fieldName, "<sup>", "")
										display_fieldName = replace(display_fieldName, "</sup>", "")
										display_fieldName = replace(display_fieldName, "<sub>", "")
										display_fieldName = replace(display_fieldName, "</sub>", "")
										display_fieldName = replace(display_fieldName, "<", "")
										display_fieldName = replace(display_fieldName, ">", "")
										if not display_fieldName <> "" then
											display_fieldName =fieldname
										end if
										fieldvalue = RS.Fields.Item(i).Value
										a.WriteLine ">  <" & display_fieldName & "> " & "(" & counter & ")"
										WriteSdfDataField a, fieldvalue
										
								end if
							end if
						end if
					Next 'i
					
					subFormsString_array = split(subFormsString, ",", -1)
					Set RSp = Server.CreateObject("ADODB.RECORDSET")
					RSp.CursorType=3
					Set SubTablecmd = Server.CreateObject("ADODB.Command")
					Intertables=""
			
					for j = 0 to UBound(subFormsString_array) ' This loops over each subtable
						Set RSp = Server.CreateObject("ADODB.RECORDSET")
						RSp.CursorType=3
						Set SubTablecmd = Server.CreateObject("ADODB.Command")
						InterTables=GetTableVal(dbkey, subFormsString_array(j), kInterTables) & "," & subFormsString_array(j)
						tempFields = getTableExportFields(subFormsString_array(j), fieldstoexport)
						order_by =""
						Session("FieldsToHideFromDisplayNested")=""
						strGetFields = tempFields
					
						'LJB 5/1/2005 add support for XML Widget sorting
						if Session("allInnerSorts") <> "" then
							
							tempFields =modifySQl(tempFields)
							childTableSort = GetLastWidgetChildTableSort(subFormsString_array(j))
							'add sort by for child table
							'make sure the sort by field is in the field list
							
							fieldsToAddTemp= AddFieldToSelectListNested(childTableSort,tempFields)
							if fieldsToAddTemp <> "" then
								if strGetFields <> "" then
									strGetFields  = strGetFields & "," & fieldsToAddTemp
								else
									strGetFields  =fieldsToAddTemp
								end if
							end if
							if order_by <> "" then
								order_by = order_by & "," & childTableSort
							else
								order_by = childTableSort
							end if
						end if
						
						
						SubTablecmd.ActiveConnection = DataConn 
						SubTablecmd.CommandType = adCmdText
						strGetFields =modifySQl(strGetFields)
						'DGB Alias the fields because Addlookups expects 
						'them to be aliased fixes CSBR-56477
						strGetFields_temp = alias_all_names(SQLSyntax,strGetFields)
						strGetFields = strGetFields_temp(0)
						
						SubFormParamSQL=GetDisplaySQL(dbkey, formgroup, strGetFields,basetable,InterTables,"?","SQL_COWS")
					
						SubFormParamSQL=AddLookups(dbkey,formgroup,SubFormParamSQL, "","FLAT")
						SubFormParamSQL=RemoveLookupKeywords(SubFormParamSQL)
						'add order by clause to support XML Widget sorting
					
						SubTablecmd.parameters.append SubTablecmd.CreateParameter("baseID", 5, 1,0,baseid_value)

						if Session("add_childtable_criteria" & dbkey & formgroup) = "LIMIT" then
							SubFormParamSQL = AddChildTableCriteria( dbkey, formgroup, subFormsString_array(j), SubFormParamSQL)
							SubFormParamSQL = modifySql(SubFormParamSQL)
						end if
						if Session("allInnerSorts") <> "" and order_by <> "" then
							SubFormParamSQL=SubFormParamSQL & " ORDER BY " & order_by
						end if
						'DGB fix ACX Size problem
						SubFormParamSQL = replace(SubFormParamSQL,"Package.Size","Package.""SIZE""")
						SubTablecmd.CommandText = SubFormParamSQL
						on error resume next
						RSp.Open SubTablecmd
						if err then
							if err then
								TraceError "Error while opening subtable recordset in nested sdf export. SQL= " & SubFormParamSQL & " (ParamValue= " & SubTablecmd.Parameters("baseID")& ")", err.Source, err.number, err.Description
								Response.Write "Error while opening exportsdf recordset.<BR>" 
								Response.Write "For details see application <b><a target=""_new"" href=""/" & Application("appkey") & "/logfiles/" & Application("appkey") & "_trace.html"">log file</a></b>"
								Response.end
							end if
						end if
						Trace "DoNestedExport:SubTableSQL= " & SubFormParamSQL & " (ParamValue= " & SubTablecmd.Parameters("baseID")& ")", 25

						
						SubTablecmd.Parameters.Delete "baseID"
						tablename_val = getTableNameFromDict(dbkey, formgroup,formmode, subFormsString_array(j))
						
						if not tablename_val <> "" then
							tablename_val = subFormsString_array(j)
						end if
						a.WriteLine ">  <" & tablename_val & "> " & "(" & counter & ")"
						theValue = ""
						fieldvalues=""
						fieldnames = ""
						fieldname_value=""
						
						If Not (RSp.BOF AND RSp.EOF) then
							rsprecordcount = GetRecordCount(dbkey, formgroup, rsp)
							RSp.MoveFirst
							For f = 0 to Rsp.Fields.Count-1 ' This loops over each field in the current subtable to build the child table header
								fieldname_value = RSp.Fields.Item(f).Name
								'5/1/2004 check to see if current field was added only because it is in the order by clause. it should not be displayed.
								hideField = ""
								if Not HideFieldFromDisplayNested(subFormsString_array(j) & "." & fieldname_value) then
									'LJB 3/2005 get display names from export specific dictionary created in export_hits_dialog.asp
									
									display_fieldName = getDisplayNamesForSDExport(subFormsString_array(j) & "." & fieldname_value)
									display_fieldName = replace(display_fieldName, "<sup>", "")
									display_fieldName = replace(display_fieldName, "</sup>", "")
									display_fieldName = replace(display_fieldName, "<sub>", "")
									display_fieldName = replace(display_fieldName, "</sub>", "")
									display_fieldName = replace(display_fieldName, "<", "")
									display_fieldName = replace(display_fieldName, ">", "")
									if not display_fieldname <> "" then
										display_fieldname = fieldname_value
									end if
									if fieldnames <> "" then
										fieldnames = fieldnames & " -- " & display_fieldname
									 else
										fieldnames =  display_fieldname
									 end if
								 end if
							Next
							fieldnames = fieldnames & CHr(13)
							
							
							for n = 0 to rsprecordcount-1 'this loops the records in the current subtable
							
								For k = 0 to Rsp.Fields.Count-1 'This loops the current subtable record to display the subtable data
									theName = RSp.Fields.Item(k).Name
									if Not HideFieldFromDisplayNested(subFormsString_array(j) & "." & theName) then
										theValue = RSp.Fields.Item(k).Value
									
										if theValue = "" or isNull(theValue) then
											theValue = "  "
										end if
										if k = 0 then
											if fieldvalues <> "" then
												fieldvalues = fieldvalues &  theValue
											else
												fieldvalues =  theValue
											end if
										else
											if fieldvalues <> "" then
												
												fieldvalues = fieldvalues & " -- " & theValue
											else
												fieldvalues =  theValue
											end if
										end if
									end if 
								next ' end loop over fields of current subtable record
								if Trim(fieldvalues) <> "" then
									fieldvalues = fieldvalues & CHr(13)
								end if
								
								Rsp.MoveNext
							next ' end loop over current record of current subtable
								if rsprecordcount>1 then
									a.WriteLine fieldnames & fieldvalues  & " -- " & CHr(13)
								else
									a.WriteLine fieldnames & fieldvalues  
								end if
							
						
							Rsp.Close
						else
						'LJB 3/2005 if child table has no data, there needs to be new line or ChemDraw for Excel misaligns data 
						a.WriteLine " "
						end if
					next ' end loop over list of subtables
					'DGB Remove extra line before end record
					'a.WriteLine " "
					'a.WriteLine " "
					a.WriteLine "$$$$"
					RS.MoveNext
				
					if Not detectNS4() = true then
						 Progressbar counter, recordcount,5
					end if
					counter = counter + 1
					if err.number <> 0 then
						'response.write err.number
					end if
				next 'j end loop over base table records
				
			
			Set myConnection = Nothing	
			a.close
			RS.Close
			server.ScriptTimeout = storeTimeout
		end if
		
	end if
	
	Set RS= Nothing
	exportSDFile = molfilepathhttp & sdfilename & ".sdf"
End Function

'-------------------------------------------------------------------------------
' Purpose: 'Flat SD File export
' Assumes:
' Inputs:
'-------------------------------------------------------------------------------
Function DoSDFileExport(ByVal dbkey, ByVal formgroup, ByVal fieldstoexport_input, ByVal ExportType, ByVal MaxExportNumber,ByVal bStrucDataOut)
	Dim subFormsArray
	Dim expFieldsArray
	
	fieldstoexport=TrimItemsInString(dbkey, formgroup, fieldstoexport_input)
	subFormsString = getTablesString(dbkey, formgroup, fieldstoexport)

	'LJB 5/1/2002 clear variable that is used to add fields from the order by clause to the select statement. They are necessary for the select
	'but should not be output to the sdf file
	'DGB moved up because I needed basetable earlier
	Session("FieldsToHideFromDisplay")=""
	basetable = GetBaseTable(dbkey, formgroup, "basetable")
	SQLSyntax = GetTableVal(dbkey, basetable,kSQLSyntax)	
	
	
	' DGB Inplemented UNCORRELATED_SDF_FLATENING option
	' Before now, the flatening involved generating a single sql
	' statement with a full cartesian join between the base table
	' and all child tables.
	' Here we introduce a new method that will result in an uncorrelated
	' join between the child tables.  This new method is required because
	' most of the time the rows in different child tables are not correlated
	' doing a cartesian join results in unesessary repetion.
	' To achieve the uncorrelated join without having to rework a bunch of
	' fragile code, we use a trick.  We simple reuse the exiting cartesian
	' join code but for one child table at a time.
	' The uncorrelated sdf is therefore produced by looping over the entire
	' DoSDFileExport function as many times as there are child tables, but
	' ensuring that each loop deals with a single child table.	
	
	bUseUncorrelatedFlatening = (Application("UNCORRELATED_SDF_FLATENING") = "1") 
	
	If not bUseUncorrelatedFlatening or subFormsString = "" then
		'This is the cartesian join case.
		'We only need to loop once and don't need to modify the subFormsString
		numLoops = 0
		bUseUncorrelatedFlatening = false ' set this for the no subforms case
	Else 
		' This is the uncorrelated case 
		' We will loop over each child table individually
		subFormsArray = split(subFormsString,",")	
		allfieldstoexport = fieldstoexport	
		numLoops = Ubound(subFormsArray)
	End if
	
	' Here is the loop introduced to support UNCORRELATED_SDF_FLATENING	 		
	For s = 0 to numLoops
		
		' This block is for the Uncorrelated case only	
		if bUseUncorrelatedFlatening then
			
			' Modify the subFormsString and fieldstoexport values 
			' to ensure a join to a single (current) table
			struc_fields = ""
			Newfieldstoexport =""
			
			' Overwrite subFormsString with the current child table
			subFormsString = subFormsArray(s)
			
			' Overwrite the fieldstoexport with fields related to the current child table
			expFieldsArray = split(allfieldstoexport,",")
			For f = 0 to Ubound(expFieldsArray)
				if InStr(1,expFieldsArray(f),subFormsString & ".") <> 0 OR InStr(1,expFieldsArray(f),basetable & ".") <> 0 then
					Newfieldstoexport = Newfieldstoexport & expFieldsArray(f) & ","
				end if	
			Next
			fieldstoexport = left(Newfieldstoexport, len(Newfieldstoexport)-1)
		End if	
		
		
		
		'LJB 5/1/2002 Get list of field from sort statements that need to be added to the select clause
		if Session("allOuterSorts") <> "" or Session("order_by" & dbkey & formgroup) <> "" then
			if Session("allOuterSorts") <> "" then
				basetableSort = GetLastWidgetBaseTableSort(basetable)
				'make sure the sort by field is in the field list
				fieldsToAddTemp= AddFieldToSelectList(basetableSort,fieldstoexport)
				if fieldsToAddTemp <> "" then
					if fieldstoexport <> "" then
						fieldstoexport  = fieldstoexport & ","&  fieldsToAddTemp
					else
						fieldstoexport  =fieldsToAddTemp
					end if
				end if
				order_by =" ORDER BY " & basetableSort
			else
			
				if Session("order_by" & dbkey & formgroup) <> "" then
					fieldsToAddTemp= AddFieldToSelectList(Session("order_by" & dbkey & formgroup) ,fieldstoexport)
					if fieldsToAddTemp <> "" then
						if fieldstoexport <> "" then
							fieldstoexport  = fieldstoexport & ","&  fieldsToAddTemp
						else
							fieldstoexport  =fieldsToAddTemp
						end if
					end if
				end if
				
			end if
		end if
		
		if subFormsString <> "" then
			temp = split(subFormsString, ",", -1)
			for m = 0 to UBound(temp)
					
					if Session("allInnerSorts") <> "" then
						childTableSort = GetLastWidgetChildTableSort(temp(m))
						'make sure the sort by field is in the field list
						fieldsToAddTemp= AddFieldToSelectList(childTableSort,fieldstoexport)
						if fieldsToAddTemp <> "" then
							if fieldstoexport <> "" then
								fieldstoexport  = fieldstoexport & "," & fieldsToAddTemp
							else
								fieldstoexport  =fieldsToAddTemp
							end if
						end if
						if order_by <> "" then
							order_by = order_by & "," & childTableSort
						else
							order_by = childTableSort
						end if
					end if
			next
		end if
			
		
		
		
		
		if Session("add_childtable_criteria" & dbkey & formgroup) = "LIMIT" then
			test_array = Split(Session("strWhereSubforms" & dbkey & formgroup), ",", -1)
			for i = 0 to UBound(test_array)
				bItemFound = instr(UCase(subFormsString), UCase(test_array(i)))>0
				if bItemFound = false then
					if subFormsString <> "" then
						subFormsString = subFormsString & "," & test_array(i)
					else
						subFormsString = test_array(i)
					end if
				end if
			next
		end if
		
		if Session("order_by" & dbkey & formgroup) <> "" then
			temp = replace(Session("order_by" & dbkey & formgroup), " ASC", "")
			temp = replace(temp, " DESC", "")
			test_array2 = split(temp, ",", -1)
			dim x
				for x = 0 to UBound(test_array2)
					temp2 = split(test_array2(x), ".", -1)
					if UBound(temp2) = 2 then
						test = temp2(0) & "." & temp2(1)
					else
						test = temp2(0) 
					end if
					if not UCase(test) = UCase(basetable) then
						bItemFound = instr(UCase(subFormsString), UCase(test))>0 
						if bItemFound = false then
							if subFormsString <> "" then
								subFormsString = subFormsString & "," & test
							else
								subFormsString =test
							end if
						end if
					end if
				next
		
		end if
		
		if UseCartridge(dbkey, formgroup) then
			IDColName = "ROWID"
		else
			IDColName = "ID"
		end if

		if Session("order_by" & dbkey & formgroup) <> "" then
			'support XML Widget Sorting
			if Not Session("allOuterSorts")<> "" then
			
				order_by_temp=" ORDER BY " & Session("order_by" & dbkey & formgroup) 
				if Session("sort_direction" & dbkey & formgroup) <> "" then
					sort_direction = Session("sort_direction" & dbkey & formgroup)
				end if
				order_by =order_by_temp & " " & sort_direction
			end if
		else
			
			if UCase(SQLSyntax) = "ORACLE" then
				if Not Session("allOuterSorts")<> "" then
					order_by = " ORDER BY " & "csdohitlist." & IDcolName
					if fieldstoexport <> "" then
						fieldstoexport = fieldstoexport & "," & "csdohitlist." & IDcolName 
					else
						fieldstoexport = "csdohitlist." & IDcolName
					end if
				end if
			else
				order_by = ""
			end if
		end if
		set DataConn = GetNewConnection(dbkey, formgroup, "base_connection")
		Select case UCase(ExportType)
			Case "VIEW"
				Session("error" & dbkey & formgroup)= False
				true_basetable = GetBaseTable(dbkey, formgroup, "basetable")
				basetable = true_basetable
				true_baseid = GetTableVal(dbkey, basetable, kPrimaryKey)
				ViewInfo = GetFormGroupVal(dbkey, formgroup,kSDFileFields)
				ViewInfoArray = Split(ViewInfo,";", -1)
				ViewInfoArray2 = Split(ViewInfoArray(0), ":", -1)
				view_basetable = ViewInfoArray2(1)
				view_baseid =  true_baseid
				StrucUniqueID = "MOL_ID"
				if maxexportNumber <> "" then
					maxhits = maxexportNumber
				else
					maxhits = ""
				end if
			
				fieldstoexport_final = checkForMolid(dbkey, formgroup, fieldstoexport,basetable & "." & "mol_id")
				strGetFields = replace(fieldstoexport_final, view_basetable, UCase(true_basetable))
				
				'strGetFields = true_basetable & ".*"
				baseSQL = BuildSelectStatement(dbkey, formgroup, true_basetable, "",strGetFields,maxhits)
				sql = AddCSDOHitListToSelect(dbkey, formgroup, baseSQL)
				
				sql = RemoveDistinct(dbkey, fromgroup, sql)
				sql=replace(sql, UCase(true_basetable), view_basetable)
				sql = FinalizeSQl(dbkey, formgroup, sql, basetable)
				if maxhits <> "" then
					sql = SetMaxHitsSQL(dbkey, formgroup, sql,basetable, maxhits)
				end if
			Case Else
				Session("error" & dbkey & formgroup)= False
				basetable = GetBaseTable(dbkey, formgroup, "basetable")
				StrucUniqueID = GetTableVal(dbkey, basetable,kStrucFieldID)
				if maxexportNumber <> "" then
					maxhits = maxexportNumber
				else
					maxhits = ""
				end if
				
				if Not StrucUniqueID = "NULL" then
					fieldstoexport_final = checkForMolid(dbkey, formgroup, fieldstoexport,basetable & "." & StrucUniqueID )
				else
					fieldstoexport_final=fieldstoexport
				end if
			
				SQLSyntax = GetTableVal(dbkey, basetable,kSQLSyntax)
				strGetFields = fieldstoexport_final
				orig_strGetFields = strGetFields
				
				strGetFields_temp = alias_all_names(SQLSyntax,strGetFields)
				strGetFields = strGetFields_temp(0)
				strGetFields_aliasOnly = strGetFields_temp(1)
			
				'strGetFields = BuildAllStrFields(dbkey, formgroup,  subFormsString) & "," & basetable & ".*"
				param_sql = BuildSelectStatement(dbkey, formgroup, basetable, subFormsString,strGetFields,"")
				'creates sql where hitlistid is the parameter
				if MaxHits <> "" then
					basetable = getBaseTable(dbkey, formgroup, "basetable")
					SQLSyntax = getTableVal(dbkey, basetable, kSQLSyntax)
					param_sql=AddLookups(dbkey,formgroup,param_sql,StrucUniqueID,"FLAT")
					if UCase(SQLSyntax) = "ORACLE" then
						param_sql = AddParamCSDOHitListToSelect_WithMAX(dbkey, formgroup, param_sql,"?","?" )
					else
						param_sql = AddParamCSDOHitListToSelect_WithMAX(dbkey, formgroup, param_sql,"?",maxhits)
					end if
					param_sql = replace(param_sql, ",,", ",") & order_by
					If CBool(Application("ALLOW_SORT_ALL_FIELDS"))= true and Session("order_by" & dbkey & formgroup) <> "" then
						basetable = GetBaseTable(dbkey, formgroup, "basetable")
						test_str = Session("order_by" & dbkey & formgroup)
							
						test_array1 = split(test_str, ".", -1)
						if Ubound(test_array1) = 2 then
							table_name = test_array1(0) & "." &  test_array1(1)
						else
							table_name = test_array1(0)
						end if
							
						if UCase(Trim(basetable))= UCase(Trim(table_name)) then
							bRemoveDistinct = false
						else
							bRemoveDistinct = True
						end if
						if bRemoveDistinct = true then
							param_sql= removeDistinct(dbkey, formgroup, FullSelect)
						end if
					end if
					param_sql=RemoveLookupKeywords(param_sql)
					param_sql=FinalizeSQl(dbkey, formgroup, param_sql, basetable)
					Set BaseTablecmd = Server.CreateObject("ADODB.Command")
					BaseTablecmd.ActiveConnection = DataConn
					BaseTablecmd.CommandType = adCmdText
				
					
					if UCase(SQLSyntax) = "ORACLE" then
						BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("hitlistid", 5, 1,0,Session("HitListID" & dbkey & formgroup))
						BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("max", 5, 1,0,MaxHits)
					else
						BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("hitlistid", 5, 1,0,Session("HitListID" & dbkey & formgroup))
					end if
					
					
					
				else
				
					param_sql=AddLookups(dbkey,formgroup,param_sql,StrucUniqueID,"FLAT")
					param_sql = AddParamCSDOHitListToSelect(dbkey, formgroup, param_sql,"?")
					if Not Session("add_childtable_criteria" & dbkey & formgroup) = "LIMIT" then				
						param_sql = replace(param_sql, ",,", ",") & order_by
					end if
					If CBool(Application("ALLOW_SORT_ALL_FIELDS"))= true and Session("order_by" & dbkey & formgroup) <> "" then
						basetable = GetBaseTable(dbkey, formgroup, "basetable")
						test_str = Session("order_by" & dbkey & formgroup)
							
						test_array1 = split(test_str, ".", -1)
						if Ubound(test_array1) = 2 then
							table_name = test_array1(0) & "." &  test_array1(1)
						else
							table_name = test_array1(0)
						end if
							
						if UCase(Trim(basetable))= UCase(Trim(table_name)) then
							bRemoveDistinct = false
						else
							bRemoveDistinct = True
						end if
						if bRemoveDistinct = true then
							param_sql= removeDistinct(dbkey, formgroup, FullSelect)
						end if
					end if
					param_sql=FinalizeSQl(dbkey, formgroup, param_sql, basetable)
					param_sql=RemoveLookupKeywords(param_sql)
					Set BaseTablecmd = Server.CreateObject("ADODB.Command")
					BaseTablecmd.parameters.append BaseTablecmd.CreateParameter("hitlistid", 5, 1,0,Session("HitListID" & dbkey & formgroup))
					
					
					BaseTablecmd.CommandType = adCmdText
					BaseTablecmd.ActiveConnection = DataConn 
					
				end if
				'sql = RemoveDistinct(dbkey, fromgroup, sql)
				'sql = FinalizeSQl(dbkey, formgroup, sql, basetable)
				'if maxhits <> "" then
					'sql = SetMaxHitsSQL(dbkey, formgroup, sql, basetable, maxhits)
				'end if
				
		End Select

		if Session("add_childtable_criteria" & dbkey & formgroup) = "LIMIT" then
			if subFormsString<> "" then
				temp = split(subFormsString, ",", -1)
				for m = 0 to UBound(temp)
						param_sql = AddChildTableCriteria( dbkey, formgroup, temp(m), param_sql)
						param_sql = modifySql(param_sql)
				next
			
					'sql= sql & " AND " & Session("SearchData" & "FullStrWhere" & dbkey & formgroup)
					'sql = modifySql(sql)
			end if
			param_sql = replace(param_sql, ",,", ",") & order_by
		end if
		'add outer join syntax for each subtable
		if subFormsString <> "" then
		'support child table supports done with XML widget
				

			temp = split(subFormsString, ",", -1)
			for m = 0 to UBound(temp)
					tablejoin = getTableVal(dbkey, temp(m), kselectjoin)
					
					if not instr(tablejoin, "(+)")> 0 then
						if instr(tablejoin, "|") > 0 then
							temp_split = split(tablejoin, "|", -1)
							for n =0 to UBound(temp_split)
								temp_split2 = split(temp_split(n), "=", -1)
								outer_join = temp_split2(0) & "(+)" &   "=" &  temp_split2(1)
								param_sql = replace(param_sql, temp_split(n),outer_join)
							next
						else
							temp2 = split(tablejoin, "=", -1)
							outer_join = temp2(0) & "(+)" &   "=" &  temp2(1)
							param_sql = replace(param_sql, tablejoin,outer_join)
						end if
					end if
					
					
			next
		end if
		
		
		
		param_sql = replace(param_sql, ",,", ",")
		
		if Not inStr(param_sql, "ORDER BY") > 0   then
			if Trim(order_by) <> "" then
				if not inStr(UCase(order_by), "ORDER BY")>0 then
					order_by = " ORDER BY " & order_by
				end if
				param_sql = param_sql & order_by
			end if
			
			
		end if

		if order_by <> "" then
			if Not (UCase(Trim(order_by)) = "ORDER BY CSDOHITLIST.ROWID" or UCase(Trim(order_by)) = "CSDOHITLIST.ROWID")then
				param_sql = aliasOrderBy(SQLSyntax, param_sql)
			end if
		end if

	
		rsname = "SD_File"
		on error resume next
		'DGB Fixed ACX Oracle problem with Size field
		param_sql = replace(param_sql, "Package.Size","Package.""SIZE""")	
		'DGB Ensure that Distinct is not used with Order by.
		if instr(1,param_sql, "ORDER BY") > 0 then
			param_sql = replace(param_sql, " DISTINCT ", " ")
		end if
		BaseTablecmd.CommandText = param_sql
		Set RS = Server.CreateObject("ADODB.RECORDSET")
		RS.CursorType = 3
		RS.Open BaseTableCmd
		if err then
			TraceError "Error while opening exportsdf recordset. SQL= " & param_sql, err.Source, err.number, err.Description
			Response.Write "Error while opening exportsdf recordset.<BR>" 
			Response.Write "For details see application <b><a target=""_new"" href=""/" & Application("appkey") & "/logfiles/" & Application("appkey") & "_trace.html"">log file</a></b>"
			Response.end
		end if
		Trace "DoFlatFileExport HITLISTID:" & Session("HitListID" & dbkey & formgroup) & ":SQL= " & param_sql, 20
		'Response.Write param_sql & session("hitlistid" & dbkey & formgroup)
		'Response.end
		recordcount = getRecordcount(dbkey, formgroup, RS)

		if maxexportNumber<> "" then
			FlushMessageToClient("export is limited to a maximum of " & maxexportNumber & " records.")
			FlushMessageToClient("exporting " & recordcount & " records...")
		else
			FlushMessageToClient("exporting " & recordcount & " records...")
		end if
		'FlushMessageToClient("exporting " & recordcount & " records")

		if err.number <> 0 or Not recordcount <> "" then
			Session("fEmptyRecordset" & dbkey & formgroup) = True
			FlushMessageToClient("The recordset was not succesfully created: <br>" & sql)
			FlushMessageToClient("Error : <br>" &  err.description)
			Response.end
		else
				molfilepath = Application("TempFileDirectory" & dbkey) & "Sessiondir\" & Session.sessionid & "\"
				molfilepathhttp =Application("TempFileDirectoryHTTP" & dbkey) & "Sessiondir/" & Session.sessionid & "/"
		
				

				'Set Fields = Session("SD_File" & dbkey & formgroup).Fields
				
				'Because of the outer loop introduced by Uncorrelated flatening method
				'we only create the sdf on the first loop
				'every other loop simply appends to the first loops file 
				if s = 0 then
					sdfilename=  GetTimeStamp()
					Set fs = Server.CreateObject("Scripting.FileSystemObject")
					Set a = fs.CreateTextFile(molfilepath & sdfilename & ".sdf")  
				end if
				
				storeTimeout = server.ScriptTimeout
				server.ScriptTimeout = 10000000
				If not (RS.EOF and RS.BOF) = true then
					if Not UseCartridge(dbkey, formgroup) then
						Set myConnection = CSDOGetCSDOConnection(dbkey, formgroup)
					end if
					RS.MoveFirst
					counter = 1
					'DisplayProcessingCount "OpenWindow", counter-1 
					'DGB added struc_fields
'stop
					Tablename = GetBaseTable(dbkey, formgroup, "moltable")
					if Not UCase(ExportType) = "VIEW" then
							if UseCartridge(dbkey, formgroup) then
								on error resume next
								strucFields = getFormGroupVal(dbkey, formgroup, kStructureFields)
								temp_fields_array = split(strucFields, ",", -1)
								for p = 0 to Ubound(temp_fields_array)
									temp_fields2= split(temp_fields_array(p), ".", -1)
									
									if UBound(temp_fields2) = 2 then
										struc_table_name = temp_fields2(0) & "." & temp_fields2(1)
										struc_fieldname = temp_fields2(2)
									else
										struc_table_name = temp_fields2(0)
										struc_fieldname = temp_fields2(1)
									end if
									currentTable = UCase(Trim(Tablename))
									theStrucTable = UCase( Trim(struc_table_name))
									if (theStrucTable =currentTable) or (currentTable = Ucase(basetable)) then
										if struc_fields <> "" then
											struc_fields = struc_fields & "," & struc_fieldname
										else
											struc_fields = struc_fieldname
										end if
									end if
								next
								Fieldname = "Structure"
								'DGB Fix for CSBR-74336
							    'When the base table is not the strurctures table struc_fields was not populated above
							    if struc_fields = "" then struc_fields = Fieldname
							else
								Fieldname = "Structure"
							end if
						else
							if UseCartridge(dbkey, formgroup) then
								on error resume next
								strucFields = getFormGroupVal(dbkey, formgroup, kStructureFields)
								temp_fields_array = split(strucFields, ",", -1)
								for p = 0 to Ubound(temp_fields_array)
									temp_fields2= split(temp_fields_array(p), ".", -1)
									
									if UBound(temp_fields2) = 2 then
										struc_table_name = temp_fields2(0) & "." & temp_fields2(1)
										struc_fieldname = temp_fields2(2)
									else
										struc_table_name = temp_fields2(0)
										struc_fieldname = temp_fields2(1)
									end if
									
									if  UCase(ExportType) = "VIEW" then
										TableName = view_basetable
									end if
								
									currentTable = UCase(Trim(Tablename))
									theStrucTable = UCase( Trim(struc_table_name))
									if (theStrucTable =currentTable) or (currentTable = Ucase(basetable)) then
										if struc_fields <> "" then
											struc_fields = struc_fields & "," & struc_fieldname
										else
											struc_fields = struc_fieldname
										end if
									end if
								next
								Fieldname = "View_Structure"
							else
								Fieldname = "View_Structure"
							end if
							
						end if
					'DGB added struc_fields
					'DGB show progress only on first loop
					if s=0 then InitializeProgressBar true, ""
					Tablename = GetBaseTable(dbkey, formgroup, "moltable")
					StrucUniqueID= replace(tablename & "." & StrucUniqueID, ".", "_")
					'CBOE-401 SJ to display structures in flat SD file export
					if formgroup = "containers_np_form_group" then StrucUniqueID = "v_containers_Compound_id_fk"
					'DGB hack for reg batch export fixes CSBR-74336
					if formgroup = "batches_form_group" then StrucUniqueID = "Batches_Cpd_Internal_ID"
					'JHS 1/17/2008 - Essentially the same hack as above but for DrugDeg
					'Not doing an if else so that we don't need to change DGB fix
					if UCase(dbkey) = "DRUGDEG" and UCase(formgroup)="BASE_FORM_GROUP" then StrucUniqueID = "DrugDeg_Parents_Mol_ID"
					'JHS 1/17/2008 - Essentially the same hack as above but for DrugDeg
					'Not doing an if else so that we don't need to change DGB fix
					if UCase(dbkey) = "D3" and UCase(formgroup)="BASE_FORM_GROUP" then StrucUniqueID = "D3_Parents_Mol_ID"
										
					'since all fields are aliased this field must be converted to the alias name so it can be retrieved
					
					StrucUniqueID=makeAliasCompat(SQLSyntax,StrucUniqueID)
					Do While Not RS.EOF
					
						FlushMessageToClient(" ")
						
						if Not UCase(ExportType) = "VIEW" then
							Fieldname = "Structure"
						else
							Fieldname = "View_Structure"
						end if
						
						if UseCartridge(dbkey, formgroup) then
							UniqueID = RS(StrucUniqueID)
						else
							UniqueID = RS(StrucUniqueID)
						end if
						if (Not UniqueID = "") AND (Not isEmpty(UniqueID)) then
							if Not UCase(ExportType) = "VIEW" then
								UniqueID = RS(StrucUniqueID)
							else
								UniqueID = RS(StrucUniqueID)
							end if
						end if
						if bStrucDataOut = true then 'output structure mw and formula
							if (Not UniqueID = "") AND (Not isEmpty(UniqueID)) then
								If CLng(UniqueID) > 0 then
									
									myTime = Timer()
								'-- CSBR ID:134244
								'-- Change Done by : Manoj Unnikrishnan
								'-- Purpose: Modified to support SDF export from views; It supports more than one structure field in a view
								'--			 However Chemfinder doesn't support more than 1 structure in the same view/table
								'-- Date: 06/12/2010
									if CBool(Application("ALLOW_SDF_EXPORT_FROM_VIEW"))= true then
										Fieldname = struc_fields
									end if
									fields_array = split(Fieldname, ",", -1)
									for q = 0 to UBound(fields_array)
										Fieldname = fields_array(q)
										if UseCartridge(dbkey, formgroup) then									
											mw_table_name = struc_table_name
											CSDOGetChemData dbkey, formgroup, mw_table_name, Fieldname, UniqueID, "MOLWEIGHT", DataConn
										else
											mw_table_name = TableName
											struc_table_name = mw_table_name
											CSDOGetChemData dbkey, formgroup, TableName, Fieldname, UniqueID, "sdout.mol", myConnection
										end if
										If Not Session("MW" & dbkey & formgroup & mw_table_name & Fieldname & UniqueID)="" then
											if UseCartridge(dbkey, formgroup) then
												CSDOGetChemData dbkey, formgroup, struc_table_name, Fieldname, UniqueID, "FORMULA", DataConn
												
												'fields_array = split(struc_fields, ",", -1)
												'for q = 0 to UBound(fields_array)
												Session("molfile" & dbkey & formgroup) =""
													
												CSDOGetChemData dbkey, formgroup, struc_table_name, Fieldname, UniqueID, "get_molfile", DataConn
												'DGB Remove extra line after Connection Table
												a.WriteLine TrimRightCrlf(Session("molfile" & dbkey & formgroup)) 
												'next
											else
											
												myDir = molfilepath & "sdout.mol"
												Set b = fs.OpenTextFile(myDir)
												do while b.AtEndOfStream <> True
													myvar = b.ReadLine
													a.WriteLine myvar
												loop
												b.close
											end if
										end if
										'fs.DeleteFile myDir, True
										
										'no need to output this
										'a.WriteLine ">  <" & StrucUniqueID & "> " & "(" & counter & ")"
										'a.WriteLine UniqueID
										
										'DGB Remove extra line after Connection Table
										'a.WriteLine " "
										fieldvalue = Session("MW" & dbkey & formgroup & struc_table_name & Fieldname & UniqueID)
										output_fieldname = "MolWeight"
										a.WriteLine ">  <" & output_fieldname & "> " & "(" & counter & ")"
										'DGB Isis/Base does not like too many decimals in the MW
										WriteSdfDataField a, Round(fieldvalue,4)
										
										output_fieldname = "Formula"
										fieldvalue = Session("Formula" & dbkey & formgroup & struc_table_name & Fieldname & UniqueID)
										a.WriteLine ">  <" & output_fieldname & "> " & "(" & counter & ")"
										WriteSdfDataField a, fieldvalue
									next							
								'-- End of Change #134244#
								end if
							end if
						end if
						on error resume next
						Dim i
					
						fields_to_show = split(strGetFields_aliasOnly, ",", -1)
						fields_to_show_orig = split(orig_strGetFields, ",", -1)
					
						for i = 0 to UBound(fields_to_show)
							if Not (UCase(fields_to_show_orig(i))= "CSDOHITLIST." & Ucase(IDcolName)) and not (UCase(fields_to_show(i))=  UCase(StrucUniqueID)) then
							fieldname = fields_to_show(i)
						
							'LJB 5/1/2004 check to see if current field was added only because it is in the order by clause. it should not be displayed.
							if Not HideFieldFromDisplay(fields_to_show_orig(i)) then

								'LJB 3/2005 get display names from export specific dictionary created in export_hits_dialog.asp
								display_fieldName = getDisplayNamesForSDExport(fields_to_show_orig(i))
								display_fieldName = replace(display_fieldName, "<sup>", "")
								display_fieldName = replace(display_fieldName, "</sup>", "")
								display_fieldName = replace(display_fieldName, "<sub>", "")
								display_fieldName = replace(display_fieldName, "</sub>", "")
								display_fieldName = replace(display_fieldName, "<", "")
								display_fieldName = replace(display_fieldName, ">", "")
								if not display_fieldName <> "" then
									display_fieldName =fieldname
								end if
							
								fieldvalue = RS(fieldname)
							
								err.Clear()
								a.WriteLine ">  <" & display_fieldName & "> " & "(" & counter & ")"
								WriteSdfDataField a, fieldvalue
									
								end if
							end if
						Next 'i

						a.WriteLine "$$$$"
						RS.MoveNext
						
						'DisplayProcessingCount "UpdateWindow", counter-1
						'DGB show progress only on first loop
						if s= 0 then Progressbar counter, recordcount,5
						counter = counter + 1
						if err.number <> 0 then
							'response.write err.number
						end if
					loop 'j
				'DisplayProcessingCount "CloseWindow", ""
				Set myConnection = Nothing	
				'Don't close the sdf until the loop over subtables is done
				'a.close
				RS.Close
				server.ScriptTimeout = storeTimeout
			end if
			
		end if
		Set RS= Nothing
	next 'loop over subtables to support uncorrelated flatening
	'Now we can close the sdf
	a.close		
	DoSDFileExport = molfilepathhttp & sdfilename & ".sdf"
End Function

Function AddLookups(dbkey, formgroup, paramSQL,strucid,export_type)
	
	if Session("bypass_ini" & dbkey & formgroup) = true then
		Select_Names = Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup)
	else
	
		if Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup) <> "" then
			if Not Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup)="NULL" then
				Select_Names = Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup)
			end if
		else
			Select_Names = GetLookupNameSelect(dbkey, formgroup)
		end if
	end if
	if Select_Names <> "" and Not Select_Names = "NULL" then
		temp = split(paramSQL, "FROM", -1)
		Working_from_where = " FROM " & temp(1)
		
		temp2 = split(temp(0), "SELECT",  -1)
		if inStr(temp2(1), "DISTINCTROW") then
			working_select = " SELECT DISTINCTROW " 
			working_fields = replace(temp2(1), "DISTINCTROW ", "")
		else
			if inStr(temp2(1), "DISTINCT") then
				working_select = "SELECT DISTINCT " 
				working_fields = replace(temp2(1), "DISTINCT ", "")
			else
				working_select = " SELECT "
				working_fields = temp2(1)
			end if
		end if
		
		Select_Names = replace(Select_Names, "||','||", "CS_CONCAT")
		working_fields_array= split(working_fields, ",", -1)
		working_lookup_fields = split(Select_Names, "|", -1)

		for i = 0 to UBound(working_fields_array)
		
			if UCase(export_type) = "FLAT" then
				field_name = working_fields_array(i)
				if instr(field_name, " as ")> 0 then
					temp1 = split(field_name, " as ", -1)
					field_name = trim(temp1(1))
				else 
						if instr(trim(field_name), " ")> 0 then
							temp1 = split(trim(field_name), " ", -1)
							field_name = trim(temp1(1))
						end if
				end if
			else
				field_name = working_fields_array(i)
			end if
		bItemFound =false
			for j = 0 to UBound(working_lookup_fields)
				if Instr(working_lookup_fields(j), "::")> 0 then
					working_lookup_fields_array = split(working_lookup_fields(j), "::", -1)
					if UCase(export_type) = "FLAT" then
							test_field = working_lookup_fields_array(0)
							test_field = replace(test_field, ".", "_")
							test_length = len(test_field)
							if CInt(test_length)> 27 then
								trim_length =  CInt(test_length) - 27
								test_field = right(test_field, CInt(test_length)-CInt(trim_length))
							end if
					else
						test_field = working_lookup_fields_array(0)
					end if
					select_value = working_lookup_fields_array(1)
					select_value = replace(select_value, "SELECT ", " LOOKUP_S ")
					select_value = replace(select_value, " FROM ", " LOOKUP_F ")
					select_value = replace(select_value, " WHERE ", " LOOKUP_W ")
					
				else
					if UCase(export_type) = "FLAT" then
							test_field = working_lookup_fields(j)
							test_field = replace(test_field, ".", "_")
							test_length = len(test_field)
							if CInt(test_length)> 27 then
								trim_length =  CInt(test_length) - 27
								test_field = right(test_field, CInt(test_length)-CInt(trim_length))
							end if
					else
						test_field = working_lookup_fields(j)
					end if
				end if
					if strucid <> "" then
						if Not Instr(UCase(Trim(field_name)),UCase(strucid))>0 then
							if UCase(export_type) = "FLAT" then
								working_field_test =working_fields_array(i)
								if instr(working_field_test, " as ")> 0 then
									temp1 = split(working_field_test, " as ", -1)
									working_field_test = trim(temp1(1))
								else 
										if instr(trim(working_field_test), " ")> 0 then
											temp1 = split(trim(working_field_test), " ", -1)
											working_field_test = trim(temp1(1))
										end if
								end if
							else
								working_field_test =working_fields_array(i)
							end if
							if  UCase(right(trim(working_field_test),26))= UCase(right(Trim(test_field),26)) AND select_value <> "" then
								if Not UCase(export_type) = "FLAT" then
									
									temp_final=split(working_fields_array(i), ".", -1)
								end if
								
								if UCase(export_type) = "FLAT" then
									field_name_as =working_field_test
									
								else
									field_name_as = temp_final(UBound(temp_final))
								end if
								if return_fields <> "" then
									return_fields = return_fields & "," & "(" & select_value & ")" & " as " & field_name_as
								else
									return_fields = "(" & select_value & ")" & " as " & field_name_as
								end if
								bItemFound = true
							end if
						end if
					else
							if (UCase(Trim(field_name)) = UCase(Trim(test_field))) AND select_value <> "" then
								if UCase(export_type) = "FLAT" then
									working_field_test =working_fields_array(i)
									if instr(working_field_test, " as ")> 0 then
										temp1 = split(working_field_test, " as ", -1)
										working_field_test = trim(temp1(1))
									else 
											if instr(trim(working_field_test), " ")> 0 then
												temp1 = split(trim(working_field_test), " ", -1)
												working_field_test = trim(temp1(1))
											end if
									end if
								else
									temp_final=split(working_fields_array(i), ".", -1)
								end if
								if UCase(export_type) = "FLAT" then
									field_name_as = working_field_test
								else
									field_name_as = temp_final(UBound(temp_final))
								end if
								if return_fields <> "" then
									return_fields = return_fields & "," & "(" & select_value & ")" & " as " & field_name_as
								else
									return_fields = "(" & select_value & ")" & " as " & field_name_as
								end if
								bItemFound = true
							end if
						
					end if
			next 'j
			if bItemFound = false then
				if return_fields <> "" then
					return_fields = return_fields & "," & working_fields_array(i)
				else
					return_fields =working_fields_array(i)
				end if
			end if
		next 'i
		'protect keywords
		
		theReturn  = working_select & return_fields & working_from_where
		
	else	
		theReturn = paramSQL
	end if
	
	AddLookups = theReturn	
End Function

Function GetLookupNameSelect(dbkey, formgroup)
		LookupNames = GetINIValue( "optional", formgroup, "SDFILE_LOOKUP_FIELDS", "web_app", dbkey)
		if Instr(UCase(LookupNames), "ADD_LINES")>0 then
			LookupNames=AppendToSDFileStr(formgroup, dbkey, LookupNames,"SDFILE_LOOKUP_FIELDS" )
		end if
		Application.Lock
		Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup)=LookupNames
		if (Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup)="INIEmpty" or Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup) = "NULL" or Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup) = "") then
			Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup)="NULL"
		end if
		Application.UnLock
		GetLookupNameSelect=Application("LOOKUP_NAMES_SELECT" & dbkey & formgroup)
End function

Function AppendToSDFileStr(ByVal section_name,ByVal currentDB, ByVal inputStr,ByVal key_name)
	Dim finalStr, NewEntry,AppendedStr,tempArray,tempArray2,theCount,lineIdent,tempINIEntry,NumAdditional
	
	StrSeparator = "|"
	ItemSeparator = "::"
	
	tempArray = Split(inputStr, StrSeparator, -1)
	theCount = UBound(tempArray)
	lineIdent = tempArray(theCount)
	newArray = Split(lineIdent, ItemSeparator, -1)
	NumAdditional = newArray(1)
	if Not NumAdditional <> "" then 
		NumAdditional = 0
		finalStr = Replace(inputStr, StrSeparator & lineIdent, " ")
	end if
	if NumAdditional > 0 then

		For i = 1 to NumAdditional
			NewEntry =GetINIValue("optional",  UCase(section_name), UCase(key_name) & i, "web_app", currentDB)
			if AppendedStr <> "" then
				AppendedStr = AppendedStr & StrSeparator & NewEntry
			Else
				AppendedStr = NewEntry
			End if
		Next 'i
	finalStr = Replace(inputStr, lineIdent, AppendedStr)
	End if
	
	AppendToSDFileStr = finalStr

End Function

Function RemoveLookupKeywords(sql)

	theReturn = replace(sql, " LOOKUP_S ", " SELECT ")
	theReturn = replace(theReturn, " LOOKUP_F ", " FROM ")
	theReturn = replace(theReturn, " LOOKUP_W ", " WHERE ")
	theReturn = replace(theReturn, "CS_CONCAT", "||','||")

RemoveLookupKeywords = theReturn
End Function

Function alias_all_names(syntax,inputstr)

	temp = split(inputstr, ",", -1)
	
	if syntax = "ORACLE" then
		for i = 0 to UBound(temp)
			alias_name = replace(temp(i), ".", "_")
			test_length = len(alias_name)
			if CInt(test_length)> 27 then
				trim_length_try=27
				trim_length =  CInt(test_length) - trim_length_try
				alias_name = right(alias_name, CInt(test_length)-CInt(trim_length))
				Do Until Not (left(alias_name,1) = Chr(95))
					trim_length =  CInt(test_length) - trim_length_try
					alias_name = right(alias_name, CInt(test_length)-CInt(trim_length))
					trim_length_try = trim_length_try - 1
				loop
				'DJP test if 27the char is a num if so then use "a" if not then use what is there
				leftChar = left(alias_name,1)
				if instr("0123456789",leftChar)>0 then
					alias_name = "a" & right(alias_name,len(alias_name)-1)
				end if
			end if
			if new_list <> "" then
			
				new_list = new_list & "," &  temp(i) & " " & alias_name 
				alias_only = alias_only & "," & alias_name 
			else
				new_list=temp(i) & " " & alias_name 
				alias_only =alias_name 
			end if
		next
	
	else
		for i = 0 to UBound(temp)
			alias_name = replace(temp(i), ".", "_")
			test_length = len(alias_name)
			if CInt(test_length)> 27 then
				trim_length_try=27
				trim_length =  CInt(test_length) - trim_length_try
				alias_name = right(alias_name, CInt(test_length)-CInt(trim_length))
				Do Until Not (left(alias_name,1) = Chr(95))
					trim_length =  CInt(test_length) - trim_length_try
					alias_name = right(alias_name, CInt(test_length)-CInt(trim_length))
					trim_length_try = trim_length_try - 1
				loop
			end if
			if new_list <> "" then
				new_list = new_list & "," & temp(i) & " as " & alias_name 
				alias_only = alias_only & "," & alias_name 
			else
				new_list=temp(i) & " as " & alias_name 
				alias_only = alias_name 
			end if
		next
	
	end if
	final_list = new_list & "|||" & alias_only
	
	alias_all_names = split(final_list, "|||", -1)
End function


Function makeAliasCompat(syntax,alias_name)
	test_length = len(alias_name)
	if CInt(test_length)> 27 then
		trim_length_try=27
		trim_length =  CInt(test_length) - trim_length_try
		alias_name = right(alias_name, CInt(test_length)-CInt(trim_length))
		Do Until Not (left(alias_name,1) = Chr(95))
			trim_length =  CInt(test_length) - trim_length_try
			alias_name = right(alias_name, CInt(test_length)-CInt(trim_length))
			trim_length_try = trim_length_try - 1
		loop
		if UCase(syntax) = "ORACLE" then
			'DJP test if 27the char is a num if so then use "a" if not then use what is there
			leftChar = left(alias_name,1)
			if instr("0123456789",leftChar)>0 then
				alias_name = "a" & right(alias_name,len(alias_name)-1)
			end if
		end if
	end if
	makeAliasCompat = alias_name
End Function

'LJB 3/2005 function for getting display names for fields. This dictionary is created in the export_hits_dialog.asp file prior to export
function getDisplayNamesForSDExport(fieldname)
	if session("export_hits_display_names_DICT").Exists(UCase(fieldname)) then
		displayName = session("export_hits_display_names_DICT").Item(UCase(fieldname))
	else
		displayName = fieldname
	end if
	getDisplayNamesForSDExport= displayName
end function

'DGB to fix CSBR-50143
' When structures are edited in ChemReg the base64_cdx saved in the
' database contains a linebrake every 65 characters.  Ocasionally, 
' a line brake coincides with the end of the base64_cdx string. This causes a
' problem while exporting the base64_cdx field to an sdf because
' the sdf spec does not allow for two consecutive linebrakes at
' the end of a data field.  
' To avoid this problem, the line brake at the end of the field is
' now only added if the data does not already contain a line brake at the end.
'
' f is a reference to the text file, val is the value of the data field.
' DGB added fix from Mitch to avoid probelm with blank fields.
Sub WriteSdfDataField(byref f, val)
	if val <> "" then
		f.writeline val
	else
		f.write vbcrlf
		f.write vbcrlf
	end if
 	if NOT ((asc(right(val,2)) = 13) AND (asc(right(val,1))= 10)) then f.writeline ""
End sub



'LJB 5/1/2005 Function to get the fields in the sort list for a child table when the XML widget is used to sort
function GetLastWidgetChildTableSort(childTableName)'
	dim theReturn
	theReturn=""
	if Session("allInnerSorts") <> "" then
		temp = split(Session("allInnerSorts"), "|", -1) 
		'loop backwards since we are interested in the most recent sort
		for i = 0 to UBound(temp)
			temp2 = split(temp(i), ".", -1)
			test = Trim(replace(childTableName, ".", "_"))& "_RS"
			if Trim(UCase(temp2(0))) = test then
				theReturn = childTableName & "." & temp2(1) ' return the fieldname and the sort direction
				exit for
			end if
		next
	end if
	GetLastWidgetChildTableSort=theReturn
end function

'LJB 4/30/2005 break off order by clause and alias all names. This was causing sorting to break
Function aliasOrderBy(SQLSyntax, param_sql)
	'DGB Uncommented the if block because we don't want to 
	' alias for ACCESS SQLSyntax
	if SQLSyntax = "ORACLE" then
		temp_param = split(param_sql, "ORDER BY", -1)
		param_sql = temp_param(0)
		order_by = temp_param(1)
			temp_order_by = split(order_by, ",", -1)
			for k = 0 to UBound(temp_order_by)
				sortByField=temp_order_by(k)
				if Trim(sortByField)<> "" then
					if instr(UCase(temp_order_by(k)), " DESC") > 0 then
							storeDirection = " DESC"
							
							sortByField=replace(sortByField, " asc", " ASC")
							sortByField=replace(sortByField, " Asc", " ASC")
							sortByField=replace(sortByField, " desc", " DESC")
							sortByField=replace(sortByField, " Desc", " DESC")
							fieldNameTemp =split(sortByField, " DESC", -1)
							fieldName = Trim(fieldNameTemp(0))
					else
							if instr(UCase(temp_order_by(k)), " ASC") > 0 then
								storeDirection = " ASC"
								sortByField=replace(sortByField, " asc", " ASC")
								sortByField=replace(sortByField, " Asc", " ASC")
								sortByField=replace(sortByField, " desc", " DESC")
								sortByField=replace(sortByField, " Desc", " DESC")
								fieldNameTemp =split(sortByField, " ASC", -1)
								fieldName = Trim(fieldNameTemp(0))
							else
								storeDirection = " " 
								fieldName=sortByField
							end if
					end if
					
					newAliasedFieldName = alias_all_names(SQLSyntax,fieldName)
				
					
					finalAliasedName = newAliasedFieldName(1)
				
				
					if new_order_by <> "" then
						new_order_by = new_order_by & "," & finalAliasedName  & storeDirection
					else
						new_order_by = finalAliasedName  & storeDirection
					end if
				end if
			next
	
			aliasOrderBy = param_sql & " ORDER BY " & new_order_by
		else
			aliasOrderBy = param_sql
		end if
end function

'LJB 5/1/2005 Function to get the fields in the sort list fo the base table when the XML widget is used to sort
function GetLastWidgetBaseTableSort(basetable)
	dim theReturn
	theReturn = ""
	if Session("allOuterSorts") <> "" then
		temp = split(Session("allOuterSorts"), "|", -1)
		'return the last sort
		theReturn = basetable & "." & temp(UBound(temp))
	end if
	GetLastWidgetBaseTableSort=theReturn
End Function

'LJB 5/1/2005 function to add fields from the order by clause to the select list. Also keeps a running list of fields
'added so they will be hidden when the sdf file is written
function AddFieldToSelectList(sortByField,fieldList)
	temp = split(fieldList, ",", -1)
	sortByField=replace(sortByField, " asc", " ASC")
	sortByField=replace(sortByField, " Asc", " ASC")
	sortByField=replace(sortByField, " desc", " DESC")
	sortByField=replace(sortByField, " Desc", " DESC")
	if instr(UCase(sortByField), " ASC") > 0 then
		fieldNameTemp =split(sortByField, " ASC", -1)
		fieldName = Trim(fieldNameTemp(0))
	else
		if instr(UCase(sortByField), " DESC") > 0 then
			fieldNameTemp =split(sortByField, " DESC", -1)
			fieldName = Trim(fieldNameTemp(0))
		else
			fieldName = Trim(sortByField)
		end if 
	end if 
	itemFound = false
	for i = 0 to UBound(temp)
		if UCase(temp(i)) = UCase(fieldName) then
			itemFound = true
			exit for
		end if
	next
	
	
	if itemFound = true then
		AddFieldToSelectList = ""
	else
		AddFieldToSelectList = fieldName
		'keep a list of added fields so they will not be displayed in the sdfile.
		if Session("FieldsToHideFromDisplay") <> "" then
			Session("FieldsToHideFromDisplay") = Session("FieldsToHideFromDisplay") & "," & fieldName
		else
			Session("FieldsToHideFromDisplay") = fieldName
		end if
	end if
	
End function
'LJB 5/1/2005 function to add fields from the order by clause to the select list for Nested export of child tables. Also keeps a running list of fields
'added so they will be hidden when the sdf file is written
function AddFieldToSelectListNested(sortByField,fieldList)
	temp = split(fieldList, ",", -1)
	sortByField=replace(sortByField, " asc", " ASC")
	sortByField=replace(sortByField, " Asc", " ASC")
	sortByField=replace(sortByField, " desc", " DESC")
	sortByField=replace(sortByField, " Desc", " DESC")
	if instr(UCase(sortByField), " ASC") > 0 then
		fieldNameTemp =split(sortByField, " ASC", -1)
		fieldName = Trim(fieldNameTemp(0))
	else
		if instr(UCase(sortByField), " DESC") > 0 then
			fieldNameTemp =split(sortByField, " DESC", -1)
			fieldName = Trim(fieldNameTemp(0))
		end if
	end if 
	itemFound = false
	for i = 0 to UBound(temp)
		if UCase(temp(i)) = UCase(fieldName) then
			itemFound = true
			exit for
		end if
	next
	
	
	if itemFound = true then
		AddFieldToSelectListNested = ""
	else
		AddFieldToSelectListNested = fieldName
		'keep a list of added fields so they will not be displayed in the sdfile.
		if Session("FieldsToHideFromDisplayNested") <> "" then
			Session("FieldsToHideFromDisplayNested") = Session("FieldsToHideFromDisplayNested") & "," & fieldName
		else
			Session("FieldsToHideFromDisplayNested") = fieldName
		end if
	end if
	
End function

'LJB 5/1/2005 function to determine if a field should be hidden form the sdf output because it was added only because it was in the order by clause.
Function HideFieldFromDisplay(testField)
	dim hideField
	hideField = false
	if Session("FieldsToHideFromDisplay") <> "" then
		temp = split(Session("FieldsToHideFromDisplay"), ",", -1)
		for i = 0 to Ubound(temp)
			if UCase(temp(i)) = UCase(testField) then
				hideField = true
				exit for
			end if
		next
	end if
	HideFieldFromDisplay = hideField
End Function

'LJB 5/1/2005 function to determine if a field should be hidden form the sdf output for nested child table fields because it was added only because it was in the order by clause.
Function HideFieldFromDisplayNested(testField)
	dim hideField
	hideField = false
	if Session("FieldsToHideFromDisplayNested") <> "" then
		temp = split(Session("FieldsToHideFromDisplayNested"), ",", -1)
		for i = 0 to Ubound(temp)
			if UCase(temp(i)) = UCase(testField) then
				hideField = true
				exit for
			end if
		next
	end if
	HideFieldFromDisplayNested = hideField
End Function

' Used for striping a carriage return at the end of ctable
' in molfile while building sdf.
function TrimRightCrlf(str)
    
    Dim length
    Dim lastChar
    
    length = len(str)
    last = right(str,2)
    
    if (last = vbCrLf) then
        str = left(str, length-2)
    end if 
    TrimRightCrlf= str
end function

%>