<% ' Copyright 1998-2003, CambridgeSoft Corp., All Rights Reserved
'DO NOT EDIT THIS FILE %>
<%
'**********************************************************************************
'Cartridge Enhancement Code
'**********************************************************************************
bDebugCartridge = false
bDebugSdfSearch = false

'Determine if Cartridge is being used. Returns boolean UseCartridge
function UseCartridge(byVal dbkey, ByVal formgroup)
	if Session("bypass_ini" & dbkey & formgroup) = true then
		UseCartridge = true
	else
		CHEMconnection_str = GetChemLinksStr(dbkey, formgroup)
		CHEMconnection_array = Split(CHEMconnection_str, ",", -1)
		on error resume next
		for i = 0 to UBound(CHEMconnection_array)
			conn_name=CHEMconnection_array(i)
			if UCase(GetChemConnGroupVal(dbkey, conn_name, kStrucEngine)) = "CARTRIDGE" then
				bCartridge = true
		exit for
			end if
		next
		if bCartridge = true then
			UseCartridge = true
		else
			UseCartridge = false
		end if
	end if
End function 

'--------------------------------------------------------------------------------------
' Purpose:Performs a search, optionally stores results in hitlist.
' Arguments: sqlString, dbKey, formgroup, maxHits, conn
' Returns:returns the TOP Maxhits as a recordset.
'-------------------------------------------------------------------------------
function DoCartridgeSearch(ByVal sqlString, ByVal dbkey, byval formgroup, byval maxHits, byref conn)
	'stop
	Dim  cmd
	Dim arrlength
	Dim i
	if isObject(Conn) then
		if Conn.state = 0  then
			Set Conn = GetNewConnection(dbkey, formgroup, "base_connection")
		end if
	else
		Set Conn = GetNewConnection(dbkey, formgroup, "base_connection")
	end if

	Set Cmd = Server.CreateObject("ADODB.Command")
	Cmd.ActiveConnection = Conn
	Cmd.CommandType = adCmdText
	
	
	bBaseRS = false
	bRefineRS = false
	'clear this message variable. Used on table privileges error.
	Session("Message_Append" & dbkey & formgroup)  = ""
	'The ContentsField session variable determines whether the results of the search is
	'saved to the hitlist table.  If a non blank value is passed the hits are saved.
	if Session("ContentsField" & dbkey & formgroup)<> "" then  'Search and store hits
		if Session("SearchDomain" & dbkey & formgroup)= 0 then 'search is over entire DB
			bBaseRS = true
			hit_list_id = WriteHitList(dbkey, formgroup, sqlString, Session("hitlistID" & dbkey & formgroup), Session("ContentsField" & dbkey & formgroup),Cmd, Conn)
			if Not Trim(Session("BaseRShitlistID" & dbkey & formgroup)) <> "" then
				Session("BaseRShitlistID" & dbkey & formgroup) = Clng(hit_list_id)
			end if
		else ' Search is limited to the previous hitlist 
			bRefineRS = true
			sqlstring = JoinhitlistTableToRelSql(sqlstring)
			hit_list_id = WriteHitList(dbkey, formgroup, sqlString, Session("hitListID" & dbkey & formgroup),Session("ContentsField" & dbkey & formgroup),Cmd, Conn)
			if Not Trim(Session("RefineHitlistID" & dbkey & formgroup))  <> "" then
				Session("RefineHitlistID" & dbkey & formgroup) = Clng(hit_list_id)
			end if		
		end if
		Session("hitlistID" & dbkey & formgroup) = Clng(hit_list_id)
		'Return the TOP Maxhits in a recordsets
		baseTable = GetBaseTable(dbkey, formgroup, "basetable")
		hitlistTable = getSchemaName(dbkey, formgroup, "") & ".CSDOHITLIST"
		
		'TSM 5/21/2008: Horrible hack to get around CSBR-96385, hopefully without affecting other COE apps
		if lcase(baseTable) = lcase("inv_containers_subsearch_alias") then
			baseTable = GetTableVal(dbkey, baseTable, kTableRealName)
		end if
		
		if instr(UCase(sqlstring), " ORDER BY ")>0 then
			sqlString = rebuildOrderBySelect(dbkey, formgroup,baseTable)
		else
			sqlString = "SELECT " & Session("ContentsField" & dbkey & formgroup) & " FROM " & baseTable & ", " & hitlistTable & " WHERE " & baseTable & ".rowid = " & hitlistTable  & ".ID AND hitlistID=" & Session("hitlistID" & dbkey & formgroup)
		end if
		'JHS - Add nls sort session change to make text searches work better
		'however only set this when there is a sort order so that we limit scope of the change
		if Session("order_by" & dbkey & formgroup) <> "" then
		    Conn.Execute("ALTER SESSION SET nls_sort='BINARY_AI'")
        end if		
        if lcase(dbkey) = "docmanager" and lcase(formgroup) = "base_form_group" then
		     Cmd.CommandText = GetTopRowsDocMgr(sqlString, maxHits)
        else
            Cmd.CommandText = GetTopRows(sqlString, maxHits)
        end if 
		on error resume next
		Set RS = Cmd.Execute
		
		if err then
			
			TraceError "Error in DoCartridgeSearch while returnning TOP hits: SQL: " & sqlString, err.Source, err.number, err.Description
			Response.Write "Error in DoCartridgeSearch while returnning TOP hits.<BR>"
			Response.Write "For details see application <b><a target=""_new"" href=""/" & Application("appkey") & "/logfiles/" & Application("appkey") & "_trace.html"">log file</a></b>"
			Response.end
		end if
	else ' No need to save the hits; just run the search
		'stop
		SetOracleSessionCursorSharingParameter conn, "force"
		'SYAN modified on 11/22/2006 to fix CSBR-73085
		on error resume next
		Conn.Begintrans()
		if err.number <> 0 then
			err.Clear
			Conn.Begintrans()
		end if
		'End of SYAN modification
		
		if IsArray(Session("base64Array")) then 
			arrlength = Ubound(Session("base64Array"))
			for i= 0 to arrlength
				sql = "BEGIN INSERT INTO cscartridge.tempQueries (id, query) VALUES (" & i & ", ?); END;"
				b64 = Session("base64Array")(i)
				Trace "DoCartridgeSearch Query Molecule " & i & " = " & b64, 20
				Cmd.Parameters.Append Cmd.CreateParameter("p1", 201, 1, len(b64), b64 )	
				cmd.CommandText = sql
				cmd.properties("SPPRMSLOB") = true
				cmd.Execute
				cmd.properties("SPPRMSLOB") = false
				cmd.Parameters.delete "p1"
			Next
        end if
        if lcase(dbkey) = "docmanager" and lcase(formgroup) = "base_form_group" then
		    sql = GetTopRowsDocMgr(sqlString, maxHits)
        else
            sql = GetTopRows(sqlString, maxHits)
        end if 
		Cmd.CommandText = sql
		Trace "DoCartridgeSearch SQL= " & sql, 19
		t0 = timer
		
		
        Set RS = Cmd.Execute
        ' The following line accesses the RS.  If this is not done then the RS
        ' dies during the commit.
        a= RS.EOF
        'response.Write RS.Source (debug)
        'response.end (debug)
        conn.CommitTrans
        SetOracleSessionCursorSharingParameter conn, "exact"
        Trace "DoCartridgeSearch Search Time= " & timer-t0 & " seconds", 8
	end if
	Set cmd = Nothing
	Set DoCartridgeSearch = RS
End Function

'SYAN added on 2/15/2005 to fix CSBR-50932
'--------------------------------------------------------------------------------------
' Purpose:Performs a sdf batch search, optionally stores results in hitlist.
' Arguments: sqlString, dbKey, formgroup, maxHits, conn
' Returns:returns the TOP Maxhits as a recordset.
'-------------------------------------------------------------------------------
function DoCartridgeSDFSearch(ByVal sqlString, ByVal dbkey, byval formgroup, byval maxHits, byref conn)
	'stop
	Dim imptr
	Dim importReturn
	Dim Cmd, sql
	Dim hit_list_id, baseTable
	Dim arr, structuresTable
	Dim schemaName
	Dim sdfPath, sdfName
		
	
	sdfPath = replace(Application("TempFileDirectory" & dbkey),"\\","\") & "SessionDir" & "\" & CStr(Session.SessionID)
	sdfName = Session("sdfFileName")
	arr = Split(Session("SearchData" & "MultipleExact" & dbkey & formgroup), ".")
	'LJB 6/21/2005. Must allow for fully qualified names such as from biosar
	if UBound(arr) = 2 then
		schemaName = arr(0)
		app_schema = LCase(Application(dbkey & "_USERNAME"))
		'DGB CSBR-91651 Reverting sameer's previous change
		'This if block is used by BioSAR only and it expects
		'a fully qualified table name to be passed to the getTableVal function
		'sameer was correct in adding the use of the kTableRealName, but
		'failed to pass the qualified name into this function.
		structuresTable =arr(0) & "." & arr(1)
		structuresTable =getTableVal(dbkey,structuresTable,kTableRealName)
	else
		schemaName = LCase(Application(dbkey & "_USERNAME"))
		app_schema = schemaName
		structuresTable =GetTableVal(dbkey, arr(0), kTableRealName)
	end if
	
	'sdfTable = app_schema & "." & "SDF_STRUCTURES_" & Session.SessionID
	sdfTable = "SDF_STRUCTURES_" & Session.SessionID
	baseTable = GetBaseTable(dbkey, formgroup, "basetable")
	
	Set Conn=Server.CreateObject("ADODB.Connection")	
	Conn.Open Application("UseSettingsConnString" & dbkey)

	Set Cmd = Server.CreateObject("ADODB.Command")
	Cmd.ActiveConnection = Conn
	Cmd.CommandType = adCmdText	
	
		
	on error resume next
	Set imptr = Server.CreateObject("ChemImp.Importer")
	if err then
		if InStr(err.Description, "Create") > 0 then
			Response.Write "Error Creating the ChemImp Importer object:<BR>"
			Response.Write err.Source & ":" & err.number & ":" & err.Description & "<BR>"
			berr = true	
		end if
	end if
	on error resume next

	
	imptr.Import Cstr(Application(dbkey & "_USERNAME")), Cstr(Application(dbkey & "_PWD")), Cstr(Application("ORA_SERVICENAME")), Cstr(sdfPath), CStr(sdfName), Cstr(sdfTable)

	''Make sure sdfTable is there before continue. Otherwise there is a timing issue.	
	'Stop
	Sql = "select count(*) from " & sdfTable
	Cmd.CommandText = sql 
	'stop
	err.clear
	On error resume next 
	Cmd.Execute 
	'stop
	
	if instr(1,err.Description,"ORA-00942") >0 then '= "ORA-00942: table or view does not exist" then
		EndTime = DateAdd("s", 5, Now)
		Do Until Now > EndTime
			DoEvents
			err.clear
		Loop
	end if
	
	On error resume next 
	Cmd.Execute 
	
	'End of checking sdfTable existance

	if err AND NOT berr then
		
		Response.Write "Error Importing the uploaded sdf with ChemImp:<BR>"
		Response.Write err.Source & ":" & err.number & ":" & err.Description & "<BR>"
		Response.Write "Please contact the administrator<BR>"
		Response.Write "Possible causes:<BR>"
		Response.Write "&nbsp;&nbsp;&nbsp;- Incorrect ORA_SERVICE_NAME in cfserver.ini<BR>"
		Response.Write "&nbsp;&nbsp;&nbsp;- Incorrect schema owner/password in cfserver.ini<BR>"
		Response.Write "&nbsp;&nbsp;&nbsp;- Problem with data in source sdf<BR>"
		Response.Write "&nbsp;&nbsp;&nbsp;- Problem with sdf file name (Remove the spaces in the file name and retry)<BR>"
		Response.Write "The failed Chemimp command has been spooled to the cfwlog.txt file<BR>"
		berr = true 
		oranetstring = LCase(Application(dbkey & "_USERNAME"))& "/" & LCase(Application(dbkey & "_PWD")) & "@" & Application("ORA_SERVICENAME")		
		logAction "ChemImp failed command: " & " chemimp " & oranetstring & " file=" & sdfPath & " Table=" & sdfTable
	    On Error GoTo 0
	end if
		
	Set imptr = Nothing
		
	'Read the chemimp log file
	Dim chemimplog
	chemimplog = ReadTextFile(sdfPath & "\chemimp.out")
		
	'if instr(1, chemimpLog, "Records loaded:") = 0 AND NOT berr then
	'	Response.Write "Error while importing sdf with ChemImp<BR>"
	'	Response.Write "The Administrator should check the ChemImp.out log file for session " & Session.SessionID 
	'	berr = true
	'End if
	if berr then 
		'Response.Write "<BR><a href=/cs_Security/home.asp >Home</a>"	
		Response.Write "<P><INPUT TYPE=""button"" VALUE=""Go Back"" onClick=""history.back()"">"
		Response.End
	end if
		
		
	sql = "ALTER TABLE " &  sdfTable &  " ADD (CANONICAL VARCHAR2(1000))"
	Cmd.CommandText = sql
	Cmd.Execute
		
    'JHS 06/14/2011 - Hack Fix.  Cartridge 13 has changed behavior (entered as CSBR-143413) where it no longer likes sdf files generated 
    'by MolServer 12 (ChemFinder, CDXL, export from Inventory itself)
    'There seems to be another bug (entered as CSBR-143418) which allows you to update the so called bad structure and make it good using the 
    'following call.  Thus running this ugly update and utilizing one bug to get passed the other allows the query to have correct behavior.
    'Of course if cartridge fixes the latter behavior we will probably be stuck
    sql = "	UPDATE " & sdfTable &  " s " & _ 
		  "	SET STRUCTURE = (select CsCartridge.ConvertCDX.CDXToMolFile(STRUCTURE) from "& sdfTable & " t WHERE t.rowid = s.rowid)"			
	Cmd.CommandText = sql
	Cmd.Execute		
			
	sql = "	UPDATE " & sdfTable &  " s " & _ 
		  "	SET CANONICAL = (select CsCartridge.Canonical(STRUCTURE) from "& sdfTable & " t WHERE t.rowid = s.rowid)"			
	Cmd.CommandText = sql
	Cmd.Execute	
		
	Dim CNTab1, CNTab2, CNRidName1, CNFldName1, CNRidName2, CNFldName2
	Dim r 
	Set r = Server.CreateObject("ADODB.Recordset")

	ixName = GetCartIndexName2(dbkey, formgroup, Conn, schemaName, structuresTable)
	CNTab1 = GetCNTable2(dbkey, formgroup,Conn, ixName, schemaName)
	CNTab2 =  sdfTable
	CNRidName1 = GetCNRidName(Conn)
	CNFldName1 = GetCNFldName(Conn)
	CNFldName2 = "CANONICAL"
	'To fix CSBR-144175: Providing permission on the Index table
	GrantOnCartridgeIndexTable CNTab1, app_schema	
	'if not instr(structureTable, ".") > 0 then
	'	structuresTable = schemaname & "." & structuresTable
	'end if
		
	if UCase(structuresTable) <> Ucase(baseTable) then
		Select case(Ucase(baseTable))
		case "INV_PLATES"
		    sql = "SELECT " & structuresTable & ".rowid  FROM " & _
			    structuresTable & ", " & baseTable & ", inv_wells, inv_well_compounds, " & CNTab1 & ", " & CNTab2 & _
			    " WHERE " & CNTab1 & "." & CNFldName1 & " = " + CNTab2 & "." & CNFldName2 & _
			    " AND " & structuresTable & ".ROWID = " & CNTab1 & "." & CNRidName1 & _
			    " AND inv_wells.plate_id_fk=" & baseTable & ".plate_id " &_
			    " AND inv_well_compounds.well_id_fk=inv_wells.well_id" & _
			    " AND inv_well_compounds.compound_id_fk = " & structuresTable & ".compound_id"
		case "INV_CONTAINER_BATCHES"
		    sql = "SELECT " & structuresTable & ".rowid  FROM " & _
			    structuresTable & ", inv_containers, " & baseTable & ", " & CNTab1 & ", " & CNTab2 & _
			    " WHERE " & CNTab1 & "." & CNFldName1 & " = " + CNTab2 & "." & CNFldName2 & _
			    " AND " & structuresTable & ".ROWID = " & CNTab1 & "." & CNRidName1 & _
			    " AND inv_containers.batch_id_fk = " & baseTable & ".batch_id " & _ 
			    " AND inv_containers.compound_id_fk = " & structuresTable & ".compound_id "
		case "INV_CONTAINERS"
		    sql = "SELECT " & structuresTable & ".rowid  FROM " & _
			    structuresTable & ", " & baseTable & ", " & CNTab1 & ", " & CNTab2 & _
			    " WHERE " & CNTab1 & "." & CNFldName1 & " = " + CNTab2 & "." & CNFldName2 & _
			    " AND " & structuresTable & ".ROWID = " & CNTab1 & "." & CNRidName1 & _
			    " AND " & baseTable & ".compound_id_fk = " & structuresTable & ".compound_id "
		case else 
		    sql = "SELECT " & structuresTable & ".rowid  FROM " & _
			    structuresTable & ", " & baseTable & ", " & CNTab1 & ", " & CNTab2 & _
			    " WHERE " & CNTab1 & "." & CNFldName1 & " = " + CNTab2 & "." & CNFldName2 & _
			    " AND " & structuresTable & ".ROWID = " & CNTab1 & "." & CNRidName1 & _
			    " AND " & structuresTable & ".CPD_INTERNAL_ID = " & baseTable & ".CPD_INTERNAL_ID"
		end select 	
	else
		sql = "SELECT " & structuresTable & ".rowid  FROM " & _
			structuresTable & ", " & CNTab1 & ", " & CNTab2 & _
			" WHERE " & CNTab1 & "." & CNFldName1 & " = " + CNTab2 & "." & CNFldName2 & _
			" AND " & structuresTable & ".ROWID = " & CNTab1 & "." & CNRidName1 
	end if
		
	hit_list_id = WriteHitList(dbkey, formgroup, sql, Session("hitlistID" & dbkey & formgroup), Session("ContentsField" & dbkey & formgroup), Cmd, Conn)
		
	if not bDebugSdfSearch then
		sql = "DROP TABLE " & sdfTable 
		Cmd.CommandText = sql
		Cmd.Execute
	end if
		
	if Not Trim(Session("BaseRShitlistID" & dbkey & formgroup)) <> "" then
		Session("BaseRShitlistID" & dbkey & formgroup) = Clng(hit_list_id)
	end if
	
	Session("hitlistID" & dbkey & formgroup) = Clng(hit_list_id)
	baseTable = GetBaseTable(dbkey, formgroup, "basetable")
	hitlistTable = getSchemaName(dbkey, formgroup, "") & ".CSDOHITLIST"
			
	if instr(UCase(sql), " ORDER BY ")>0 then
		sql = rebuildOrderBySelect(dbkey, formgroup,baseTable)
	else
		sql = "SELECT " & Session("ContentsField" & dbkey & formgroup) & " FROM " & baseTable & ", " & hitlistTable & " WHERE " & baseTable & ".rowid = " & hitlistTable  & ".ID AND hitlistID=" & Session("hitlistID" & dbkey & formgroup)
	end if
    if lcase(dbkey) = "docmanager" and lcase(formgroup) = "base_form_group" then
        Cmd.CommandText = GetTopRowsDocMgr(sql, maxHits)
    else
        Cmd.CommandText = GetTopRows(sql, maxHits)
    end if 
	Set r = Cmd.Execute

	Set DoCartridgeSDFSearch = r
End function

Function GetCNTable2(dbkey, formgroup, byRef Conn, IndexName, schemaName)
	Dim rc
	if Not Application("CNTabName" & dbkey & formgroup & schemaName & IndexName) <> "" then
		sql = "SELECT CsCartridge.Aux.CNTabName('" & schemaName & "', '" & IndexName & "') FROM DUAL"
		Set r = Conn.Execute(sql)
		If Not r.EOF Then rc = r.Fields(0)
		Application.Lock	
			Application("CNTabName"  & dbkey & formgroup & schemaName & IndexName)=rc
		Application.UnLock
	Else
		rc = Application("CNTabName"  & dbkey & formgroup & schemaName & IndexName )
	End if
	GetCNTable2 = rc
End Function

Function GetCNRidName(byRef Conn)
	Dim rc
	
	if Not Application("CNRidName"  & dbkey & formgroup) <> "" then
		sql = "SELECT CsCartridge.Aux.CNRidName FROM DUAL"
		Set r = Conn.Execute(sql)
		If Not r.EOF Then rc = r.Fields(0)
		Application.Lock	
			Application("CNRidName")=rc
		Application.UnLock
	Else
		rc = Application("CNRidName")
	End if
	GetCNRidName = rc
End Function

Function GetCNFldName(byRef Conn)
	Dim rc
	
	if Not Application("CNFldName") <> "" then
		sql = "SELECT CsCartridge.Aux.CNFldName FROM DUAL"
		Set r = Conn.Execute(sql)
		If Not r.EOF Then rc = r.Fields(0)
		Application.Lock	
			Application("CNFldName")=rc
		Application.UnLock
	Else
		rc = Application("CNFldName")
	End if
	GetCNFldName = rc
End Function

Function GetCartIndexName2(byVal dbkey, byVal formgroup, byRef DataConn, byVal schema_name, byVal tablename)

	Application("CART_INDEXNAME"& Trim(tablename) & dbkey & formgroup & schema_name  & tablename)=""
	if Not Application("CART_INDEXNAME"& Trim(tablename) & dbkey  & formgroup & schema_name  & tablename) <> "" then
		Dim s 
		Dim r
		Dim s2
		Dim r2 
		Dim tTemp
		on error resume next
		Set r = Server.CreateObject("ADODB.RECORDSET")
		Set r2 = Server.CreateObject("ADODB.RECORDSET")
		temparray=split(tablename, ".", -1)
		tablename = temparray(UBound(temparray))
		
		'JHS 10/2/2009
		'do check if view
		s2 = "select 1 from all_views where view_name = '" & UCase(tablename) & "'  and OWNER='" & UCase(schema_name) & "'"
		Set r2 = DataConn.Execute(s2)
        
		if Not (r2.EOF and r2.BOF) then
		    'if it's a view
		     s = "SELECT INDEX_NAME FROM CsCartridge.all_csc_indexes WHERE upper(OWNER) = '" & UCase(schema_name) & "' AND Upper(TABLE_NAME) = (SELECT REFERENCED_NAME FROM DBA_DEPENDENCIES WHERE OWNER = '" & UCase(schema_name) & "' AND NAME = '" & UCase(tablename) & "' AND REFERENCED_TYPE='TABLE')"
		    r2.Close
		else
		    'if it'snot a view
             s = "SELECT INDEX_NAME FROM CsCartridge.all_csc_indexes WHERE upper(OWNER) = '" & UCase(schema_name) & "' AND Upper(TABLE_NAME) = '" & UCase(tablename) & "'"
	    end if
		
	
		Set r = DataConn.Execute(s)
		if Not (r.EOF and r.BOF) then
			theReturn =  r.Fields("INDEX_NAME").Value
			r.close
		else
			theReturn = ""
		end if
		if err.number <> 0 then
			logaction(err.number & err.Description)
		end if
		Application.Lock	
			Application("CART_INDEXNAME"& Trim(tablename) & dbkey & formgroup & schema_name  & tablename)=theReturn
		Application.UnLock
	else
		theReturn= Application("CART_INDEXNAME" & Trim(tablename) & dbkey & formgroup & schema_name  & tablename)
	end if
		
	GetCartIndexName2 = theReturn
End Function

'To fix CSBR-144175: Providing permission on the Index table
Function GrantOnCartridgeIndexTable(tableName, app_schema_name)
	Dim ConnStr
	Dim Conn
	ConnStr = "Provider=OraOLEDB.Oracle.1;Persist Security Info=False;User ID=" & Application("CSCARTRIDGE_USERNAME") & ";Data Source=" & Application("ORA_SERVICENAME") & ";Password=" & Application("CSCARTRIDGE_PWD")
	Set Conn = Server.CreateObject("ADODB.Connection")
	Conn.open ConnStr
	Conn.Execute("grant select on " & tableName & " to " & app_schema_name)
	Conn.Close
end function

Function GetOraServerName2(dbkey)
	Dim conn_info_array, conn_string, conn_name
	Dim fso, txtStream, s
	Dim idx
	Dim retVal
	
	if conn_name = "" then conn_name = "base_connection"

	conn_info_array = Application(conn_name & dbkey)
	
	conn_type = conn_info_array(kConn)
	conn_string = conn_info_array(kConnStr)
	
	If UCase(conn_type) = "FILE NAME" AND InStr(UCase(conn_string), ".UDL") > 0 then
		
		Set fso = Server.CreateObject("Scripting.FileSystemObject")
		Set txtStream = fso.OpenTextFile(conn_string, 1)
		s = txtStream.ReadAll
		
		idx = InStr(UCase(s), "DATA SOURCE=")
		If idx > 0 then
			retVal = Right(s, len(s) - idx)
		End if
	Else
		retVal = "NULL"
	End if 
	
	GetOraServerName2 = retVal
	
End Function
'End of SYAN modification

'--------------------------------------------------------------------------------------
' Purpose:Implements TOP N select by appending a RowNum < N +1 clause to SELECT statement 
' Arguments:sql, numRows
' Returns:Modified SQL statement (GetTopRows)
'-------------------------------------------------------------------------------
Function GetTopRows(sql, numRows)
	Dim RowNumClause
	
	if numRows <> "" AND numRows > 0 then RowNumClause = " AND RowNum < " & numRows + 1
	if inStr(ucase(sql), "ORDER BY") > 0 then
		sql = replace(ucase(sql), "ORDER BY", RowNumClause & " ORDER BY")
	Else
		sql = sql & RowNumClause	
	End if
	GetTopRows = sql
End function
'--------------------------------------------------------------------------------------
' SMathur - Fixing CSBR-164386
' Purpose:Implements TOP N select by appending a RowNum < N +1 clause to SELECT statement 
' Arguments:sql, numRows
' Returns:Modified SQL statement (GetTopRowsDocMgr) 
'-------------------------------------------------------------------------------
Function GetTopRowsDocMgr(sql, numRows)
	Dim RowNumClause
    sql = RemoveDuplicates(sql)
    if numRows <> "" AND numRows > 0 then RowNumClause = " RowNum < " & numRows + 1
    sql = "Select a.* from (" & sql & ") a where " & RowNumClause
	GetTopRowsDocMgr = sql
End function
'--------------------------------------------------------------------------------------
' SMathur - Fixing CSBR-164386
' Purpose:Function to remove the duplicates from select statement to avoid 'column ambiguously defined' error
' Arguments:sql
' Returns:Modified SQL statement (after removing duplicates) 
'-------------------------------------------------------------------------------
Function RemoveDuplicates(sql)
    Dim tempStr1, tempStr2, tempArr
    ' get the string after FROM clause
    tempStr1 = Mid(sql, InStr(sql, "FROM")) 
    ' get the string before FROM clause
    tempStr2 = Mid(sql, 1, InStr(sql, "FROM") - 1)
    tempArr = Split(tempStr2, ",")
    tempStr2 = ""
    For Each elem In tempArr
        If tempStr2 = "" Then
            tempStr2 = elem
        Else
        'check for duplicates
            If InStr(ucase(tempStr2), ucase(Trim(elem))) = 0 Then
            tempStr2 = tempStr2 & "," & elem
            End If
        End If
    Next
    RemoveDuplicates = tempStr2 & " " & tempStr1 
End function
'--------------------------------------------------------------------------------------
'Parse base64 into 4000 byte chunks. If > 8000 then return string is "?" and chunks are stored in a session object for use when building
'the paramtereized command object. Returns string
'--------------------------------------------------------------------------------------

Function ParseBase64toChunkStr(sBase64)
	dim n, pos, i, segmentLength, myChunkStr, parname, si
	
	n = Len(sBase64) 'number of characters
	pos = 1 'starting position
	i = 0 'starting index
	segmentLength = 4000 'thelength of the segment in bytes
	if n > 7999 then
		Dim StoredParamArray
		segmentLength = 1999 'length of segment for XArray
		while pos < n 
			si = Mid(sBase64, pos, segmentLength)
			parname = "xpar:" & CStr(i)
			if StoredParamArray <> "" then
				StoredParamArray = StoredParamArray & "," & si
			else
				StoredParamArray = si
			end if
			
			if myChunkStr <> "" then
				myChunkStr = myChunkStr & "," & "?"
			else
				myChunkStr =  "?"
			end if
			pos = pos + segmentLength 
			i = i + 1
		wend
		if Session("StoredParamArray")  <> "" then
			Session("StoredParamArray") = Session("StoredParamArray") & "," & StoredParamArray
		else
			Session("StoredParamArray") = StoredParamArray
		end if
	else
		if n > 3999 then
			while pos < n 
				si = Mid(sBase64, pos, segmentLength)
				if myChunkStr <> "" then
					myChunkStr = myChunkStr & "," & si
				else
					myChunkStr = si
				end if
				pos = pos + segmentLength 
				i = i + 1
			wend
		else
			myChunkStr = sBase64
		end if
	end if
	ParseBase64toChunkStr = myChunkStr
End Function

'Add parameters for >8000K base64 to command object 
sub AddParameters(byRef Cmd, byVal StoredParamArray)
	on error resume next
	myArray = split(StoredParamArray, ",", -1)
	for i = 0 to UBound(myArray)
		
		parname = "xpar:" & CStr(i)
		Cmd.Parameters.Append Cmd.CreateParameter(parname, 200, 1,Len(myArray(i)), myArray(i)) 
	next
End sub

'--------------------------------------------------------------------------------------
'create Cartridge Formatted sql for structure, mw and formula searching. Returns where clause
'--------------------------------------------------------------------------------------

function CartridgeCreateCombinedSql(ByVal strRelSql, byval dbkey, byval formgroup) 
	dim SearchOptionsString	
	SearchOptionsString = GetCartridgeOptionString(dbkey, formgroup)
	' add chemical criteria to end of sql statement
	dim subsearch, exactsearch, simsearch
	dim  search, molweightsearch
	dim simpct,sim_full_struc
	dim addSqlStr
	dim strwhere
	dim needAND
	'LJB 4/6/2004. Support addition of hints
	Session("MOL_SEARCH_TABLE")=""
	searchtype = ""
	subSearch = Session(searchtype & "SearchData" & "SubStructure" & dbkey & formgroup)
	exactSearch = Session(searchtype & "SearchData" & "Exact" & dbkey & formgroup)
	idenSearch = Session(searchtype & "SearchData" & "Identity" & dbkey & formgroup)
	simSearch= Session(searchtype & "SearchData" & "Similarity" & dbkey & formgroup)
	formulaSearch= Session(searchtype & "SearchData" & "Formula" & dbkey & formgroup)
	molweightSearch= Session(searchtype & "SearchData" & "MolWeight" & dbkey & formgroup)
	Session("StoredParamArray")=""
	simpct = Session("PrefsS6" & dbkey)	' tanimoto sim percentage
	sim_full_struc = Session("PrefsS7" & dbkey)
	' default sim percentage to 90 if unspecified
	if simpct = "" then simpct = "90"
	if sim_full_struc = "0" or sim_full_struc = "" OR lcase(sim_full_struc) = "false" then
		full_struc = "" ' This means FULL=NO but that's the cartride default
	else
		full_struc = "FULL=YES"
	end if
	
	' if existing rel where str is empty, don't need to append AND for the first criterion
	if strRelSql = "" then
		needAND = false
	else
		needAND = true
	end if
	
	Dim final_molweightsearch_fld
	Dim finalValue
	Dim MWMin, MWMax
	Dim fieldValue
	' add molweight criterion
	if molweightsearch <> "" then
		molweightsearch_array = Split(molweightsearch, ",", -1)
		
		for i = 0 to UBound(molweightsearch_array)
			final_molweightsearch_fld = CartridgePrepChemField(dbkey, formgroup, _
												molweightsearch_array(i), "MolWeight", _
												reltype, searchtype)
			fieldValue = Session(searchtype & "SearchData" & molweightsearch_array(i) & dbkey & formgroup)
			temptest = split(final_molweightsearch_fld, ".", -1)
			
			if UCase(temptest(UBound(temptest)))= "MOLWEIGHT" then
				if UBound(temptest) = 2 then
					final_molweightsearch_fld = temptest(0) & "." & temptest(1) & ".BASE64_CDX"
				else
					final_molweightsearch_fld = temptest(0) & ".BASE64_CDX"
				end if
			end if
			'LJB 4/6/2004. Support addition of hints
			if Application("USE_LEADING_HINT") = 1 then
				if UBound(temptest) = 2 then
					Session("MOL_SEARCH_TABLE")=AddToStrucFieldList(Session("MOL_SEARCH_TABLE"), temptest(1))
				else
					Session("MOL_SEARCH_TABLE")=AddToStrucFieldList(Session("MOL_SEARCH_TABLE"), temptest(0))
				end if
			end if
			final_molweightsearch_fld = replace(UCase(final_molweightsearch_fld), "_MOLWEIGHT", "")
			'get rid of commns
		
			fieldValue = replace(fieldValue, ",", "")
			if instr(trim(fieldValue), "*")>0 then
				MWMin = "0"
				MWMax = "100000000"
			else
				if trim(fieldValue)="0" or trim(fieldValue)="=0" then
					MWMin = "0"
					MWMax = "0"
				else
					if left(fieldValue,1)= "=" then
						temp = split(fieldValue, "=", -1)
						if IsNumeric(temp(1)) then	
							GetSearchRange temp(1), MWMin, MWMax
						else
							MWMin = "0"
							MWMax = "0"
						end if
					else
						if left(fieldValue,1)= "<" then
							temp = split(fieldValue, "<", -1)
							MWMin = "0"
							if IsNumeric(temp(1)) then	
								MWMax = temp(1)
							'SYAN modified 8/16/2004 to fix CSBR-42207
							elseif left(fieldValue, 2)= "<=" then
								temp = split(fieldValue, "<=", -1)
								if IsNumeric(temp(1)) then	
									MWMax = temp(1)
								else
									MWMax = "0"
								end if
							else
								MWMax = "0"
							end if
							'End of SYAN modification
						else
							if left(fieldValue,1)= ">" then
								temp = split(fieldValue, ">", -1)
								if IsNumeric(temp(1)) then
									MWMin = temp(1)
									MWMax = "100000000"
								'SYAN modified 8/16/2004 to fix CSBR-42207
								elseif left(fieldValue, 2)= ">=" then
									temp = split(fieldValue, ">=", -1)
									if IsNumeric(temp(1)) then
										MWMin = temp(1)
										MWMax = "100000000"
									else
										MWMin = "0"
										MWMax = "0"
									end if
								else
									MWMin = "0"
									MWMax = "0"
								end if
								'End of SYAN modification
							else
									temparr = split(fieldValue,"-")
									arrlen = ubound(temparr)
									'This is overkill because we don't need to support negative number ranges!
									'Only Cases 0 and 1 will ever be used but this code might come in handy elswhere
										Select Case arrlen
											Case 0 ' single value
													if IsNumeric(temparr(0)) then
														if not (temparr(0) = 0 or temparr(0)="") then
																GetSearchRange temparr(0), MWMin, MWMax
														else
															MWMin = "0"
															MWMax = "0"
														end if
													else
														MWMin = "0"
														MWMax = "0"
													end if
											Case 1 ' single negative value or simple range
												if temparr(0) = "" then 'single negative value
													if IsNumeric(temparr(1))then
														GetSearchRange "-" & temparr(1), MWMin, MWMax
													else
														MWMin = "0"
														MWMax = "0"
													end if
												else	' simple range
													if IsNumeric(temparr(0))and IsNumeric(temparr(1))then
														MWMin = temparr(0)
														MWMax = temparr(1)
													else
														MWMin = "0"
														MWMax = "0"
													end if
												end if	
											Case 2	' range with one negative
												if temparr(0) = "" then	'first is negative
													if IsNumeric(temparr(0))and IsNumeric(temparr(2))then
														MWMin = "-" & temparr(1)
														MWMax = temparr(2)
													else
														MWMin = "0"
														MWMax = "0"
													end if
												Else	' second is negative
													if IsNumeric(temparr(0))and IsNumeric(temparr(2))then
														MWMin = temparr(0)
														MWMax = "-" & temparr(2)
													else
														MWMin = "0"
														MWMax = "0"
													end if
												End if
											Case 3	' range with two negatives
												if IsNumeric(temparr(0))and IsNumeric(temparr(3))then
													MWMin = "-" & temparr(1)
													MWMax = "-" & temparr(3)
												else
													MWMin = "0"
													MWMax = "0"
												end if
										End select
								
								end if
							end if
						end if
					end if
			end if
			
			if final_molweightsearch <> "" then
				final_molweightsearch = final_molweightsearch & " AND " &_
				"CSCartridge.MolWeightContains(" & final_molweightsearch_fld & "," & MWMin & "," & MWMax & ",'')=1"
			else
				final_molweightsearch = "CSCartridge.MolWeightContains(" & final_molweightsearch_fld & "," & MWMin & "," & MWMax & ",'')=1"
			end if
		next
		if buildString <> "" then
			buildString =  buildString & " AND " & final_molweightsearch 
		else
			buildString = final_molweightsearch 
		end if
		if needAND then
			addSqlStr = buildString & " AND "
		else
			addsqlstr = buildString
			'needAND = true
		end if
	end if 
	
	Dim formulasearch_array
	Dim final_formulasearch_fld
	Dim formula_option
	
	' add formula criteria
	if formulasearch <> "" then
		formulasearch_array = Split(formulasearch, ",", -1)
		for i = 0 to UBound(formulasearch_array)
			final_formulasearch_fld = CartridgePrepChemField(dbkey, formgroup, _
											  formulasearch_array(i), "Formula", _
											  reltype, searchtype)
		
			fieldValue = Session(searchtype & "SearchData" & formulasearch_array(i) & dbkey & formgroup)
			temptest = split(final_formulasearch_fld, ".", -1)
			if UCase(temptest(UBound(temptest)))= "FORMULA" then
				if UBound(temptest) = 2 then
					final_formulasearch_fld = temptest(0) & "." & temptest(1) & ".BASE64_CDX"
				else
					final_formulasearch_fld = temptest(0) & ".BASE64_CDX"
				end if
			end if
			'LJB 4/6/2004. Support addition of hints
			if Application("USE_LEADING_HINT") = 1 then
				if UBound(temptest) = 2 then
					Session("MOL_SEARCH_TABLE")=AddToStrucFieldList(Session("MOL_SEARCH_TABLE"), temptest(1))
				else
					Session("MOL_SEARCH_TABLE")=AddToStrucFieldList(Session("MOL_SEARCH_TABLE"), temptest(0))
				end if
			end if
			
		
			final_formulasearch_fld = replace(UCase(final_formulasearch_fld), "_FORMULA", "")
			if inSTr(fieldvalue, "=") > 0 then
				fieldvalue=replace(fieldvalue, "=", "")
				formula_option = "FULL=YES"
			else
				formula_option = ""
			end if
			
				if final_formulasearch <> "" then
					final_formulasearch = final_formulasearch & " AND " &_
						" CsCartridge.FormulaContains(" & final_formulasearch_fld & ",'" & fieldValue & "','" & formula_option & "')=1"
				else
					final_formulasearch = "CsCartridge.FormulaContains(" & final_formulasearch_fld & ",'" & fieldValue & "','" & formula_option & "')=1"
				end if
			
			
		next
		
			if buildString <> "" then
				buildString =  buildString & " AND " & final_formulasearch 
			else
				buildString = final_formulasearch 
			end if
			if needAND then
				addSqlStr = buildString & " AND "
			else
				addsqlstr = buildString
				'needAND = true
			end if
		
		
	end if	
	

	dim structure_fld_name
	dim test
	Dim Base64
	Dim ChunkString
	Dim strSearch
	Dim strucSearchType	
	
	if subSearch <> "" then 
		strSearch = subSearch
		strucSearchType = "SubStructure"
		SearchOptionsString = "" & SearchOptionsString
	elseif exactSearch <> "" then
		strSearch = exactSearch
		strucSearchType = "Exact"
		SearchOptionsString = "FULL=YES," & SearchOptionsString
	elseif idenSearch <> "" then
		strSearch = idenSearch
		strucSearchType = "Identity"	
		'SearchOptionsString = "IDENTITY=YES"
		if SearchOptionsString <> "" then
			SearchOptionsString =  "IDENTITY=YES" & "," & SearchOptionsString
		else
			SearchOptionsString =  "IDENTITY=YES"
		end if
	elseif simSearch <> "" then
		strSearch = simSearch
		strucSearchType = "Similarity"
		SearchOptionsString = full_struc & ",SIMILAR=YES,SIMTHRESHOLD=" & simpct & "," & SearchOptionsString
	else
		strSearch = ""
	End if


	if strSearch <> "" then
		search_array = Split(strSearch, ",", -1)	
		arrlength = UBound(search_array)
		Redim base64Array(arrlength)
		for i = 0 to arrlength
				final_structure_fld_name = CartridgePrepStrucSearch (dbkey, formgroup, _
												  search_array(i), strucSearchType, _
												  reltype, searchtype)
				
				' set struc_name
				temptest = split(final_structure_fld_name, ".", -1)
				'CSBR-153857: Instead of blindly hardcoding the structure field to BASE64_CDX, first check whether there is such column for the table/view;
				'otherwise use the same field
				hasBase64Field = true
				if UBound(temptest) > 1 then
					Dim s2
					Dim r2 
					on error resume next
					Set DataConn = getNewConnection(dbkey, formgroup, "base_connection")
					Set r2 = Server.CreateObject("ADODB.RECORDSET")
					temparray = split(tablename, ".", -1)
					tablename = temparray(UBound(temparray))
					s2 = "SELECT 1 FROM ALL_TAB_COLS WHERE OWNER='" & UCase(temptest(0)) & "' AND TABLE_NAME = '" & UCase(temptest(1)) & "' AND COLUMN_NAME='BASE64_CDX'" 
					Set r2 = DataConn.Execute(s2)
					if r2.EOF or r2.BOF then hasBase64Field = false
					CloseRS(r2)
					CloseConn(DataConn)
				end if
				if UCase(temptest(UBound(temptest))) = "STRUCTURE" and hasBase64Field then
					struc_name = Join(temptest,".")
					if UBound(temptest) = 2 then
						struc_name = temptest(0) & "." & temptest(1) & ".BASE64_CDX"
					else
						struc_name = temptest(0) & ".BASE64_CDX"
					end if
				else
					struc_name = final_structure_fld_name
				end if
				'LJB 4/6/2004. Support addition of hints
				if Application("USE_LEADING_HINT") = 1 then
					if UBound(temptest) = 2 then
						Session("MOL_SEARCH_TABLE")=AddToStrucFieldList(Session("MOL_SEARCH_TABLE"),  temptest(1))
					else
						Session("MOL_SEARCH_TABLE")=AddToStrucFieldList(Session("MOL_SEARCH_TABLE"), temptest(0))
					end if
				end if
				subSelectSQL = "SELECT query from cscartridge.tempQueries where id = " & i
				final_strucfieldsearch = "CSCartridge.MoleculeContains(" &  struc_name & ",'" & subSelectSQL &  "', '','" & SearchOptionsString & "')=1"
				base64Array(i) = Session(searchtype & "SearchData" & search_array(i) & dbkey & formgroup)
		Next
		Session("base64Array") = base64Array
		if buildString <> "" then
			buildString =  buildString & " AND " & final_strucfieldsearch 
		else
			buildString = final_strucfieldsearch 
		end if
		if needAND then
			addsqlstr = buildString & " AND "
		else
			addsqlstr = buildString
		end if
	end if ' end of structure search
	strWhere=addsqlstr & strrelsql
	Session("SearchData" & "FullStrWhere" & dbkey & formgroup) = strWhere
	CartridgeCreateCombinedSql = strWhere
end function

'determine actually field names for Struc Search based on ini setting. Returns list of names

function CartridgePrepStrucSearch(ByVal dbkey, ByVal formgroup, _
						ByVal inputStr, ByVal storetype, _
						ByVal reltype, ByVal searchtype)
	If UCase(searchtype) = "NEW" then
		searchtype = ""
    End If	
   'get the fieldArray by splitting the inputStr passed from the calling subroutine
	fieldArray = split(inputStr, ",", -1)
	count = UBound(fieldArray)
	for i = 0 to count
		inputdata = split(fieldArray(i), ".", -1)
		AddSubFormNames dbkey, formgroup, fieldArray(i) 
		' This change is there to fix structure searches bug in ChemINV plates and Batches. 
		'It is getting the real table names in both cases, if the names passed are qualified or not qualified.   
		'DGB 10/19/2007 reverted change to if  block because it broke
		'biosar structure searching.  Left the else case alone so the Inv fix would
		'not be affected.
		if UBound(inputdata) = 2 then
			tablename = inputdata(0) & "." & inputdata(1)
			fieldname = inputdata(2) 
		else
			tablename = GetTableVal(dbkey, inputdata(0), kTableRealName)
			fieldname = inputdata(1) 
		end if
		fieldValue = Session(searchtype & "SearchData" & fieldArray(i) & dbkey & formgroup)
		formgroupflag = GetFormGroupVal(dbkey, formgroup, kFormGroupFlag)
		If formgroupflag = "GLOBAL_SEARCH" then
			fullfieldname = GetFieldCorr(dbkey, formgroup, "Structure", fieldArray(i))
			temp = split(fullfieldname, ".", -1)
			if Ubound(temp) = 2 then
				tablename = temp(0) & "." & temp(1)
				fieldname = temp(2)
			else
				tablename = temp(0)
				fieldname = temp(1)
			end if
			tablename =GetTableVal(dbkey, tablename, kTableRealName)
		End If
		'reg system related.  You need to pass the information from the temp table into the commit table
		'the tablename and fieldname are changed relative to the GetFieldCorre results
		formgroupflag = GetFormGroupVal(dbkey, formgroup,kFormGroupFlag)
		formmode = Request.QueryString("formmode")
		If formgroupflag = "REG_COMMIT" AND formmode = "register" then
		
			CorrFieldname = Request.QueryString("field_name")
			fullfieldname = GetFieldCorr(dbkey, formgroup, "Structure", CorrFieldname)
			temp = split(fullfieldname, ".", -1)
			if UBound(temp) = 2 then
				tablename = temp(0) & "." & temp(1)
				fieldname = temp(2)

			else
				tablename = temp(0)
				fieldname = temp(1)
			end if
			tablename =GetTableVal(dbkey, tablename, kTableRealName)
			'store the path and vield values for the reg system 
			Session("RegCandidateTableName" & dbkey & formgroup) = tablename
			Session("RegCandidateFieldName" & dbkey & formgroup) = fieldname
			mypath = mypartialPath & "RegCandidate" & ".cdx"
			'Session("RegCandidateStructurePath" & dbkey & formgroup)=mypath
		Else
			'DGB getreal table name only for BioSAR case
			'for other apps this breaks the export to sdf
			if Session("bypass_ini" & dbkey & formgroup) = true then
				tablename =GetTableVal(dbkey, tablename, kTableRealName)
			end if
			'!DGB! added dot
			myPath = tablename & "." & fieldname 
		End if
		
		'AtomsExist = CheckChemicalContent(myPath)
		'if Not AtomsExist = true then
			'HandleError dbkey, formgroup, "structure query contains no atoms", "", "",""
		'end if
	next
	'!DGB! fixed the name of the function on the return
	CartridgePrepStrucSearch = mypath

end function

'determine actually field names for MW and Formula Search based on ini setting. Returns list of names

function CartridgePrepChemField(ByVal dbkey, ByVal formgroup, ByVal inputStr, ByVal storetype, ByVal reltype, ByVal searchtype)
    If searchtype = "New" then
		searchtype = ""
    End If
    formgroupflag = GetFormGroupVal(dbkey, formgroup, kFormGroupFlag)
    'get the structure field names for the formgroup
	If formgroupflag = "GLOBAL_SEARCH" then
		fullfieldname = GetFieldCorr(dbkey, formgroup, storetype, inputStr)
		temp = split(fullfieldname, ".", -1)
		if UBound(temp) = 2 then
			tablename = temp(0) & "." & temp(1)
			fieldname = temp(2)		
		else
			tablename = temp(0)
			fieldname = temp(1)		
							
		end if
	else
		temp = split(inputStr, ".", -1)
		if UBound(temp) = 2 then
			tablename = temp(0) & "." & temp(1)
			fieldname = temp(2)		
		else
			tablename = temp(0)
			fieldname = temp(1)		
		end if
	end if
	
	tablename =GetTableVal(dbkey, tablename, kTableRealName)
	If storetype = "Formula" then
		Session("formuladone" & dbkey & formgroup) = true
	End If
	If storetype = "MolWeight" then
		Session("molweightdone" & dbkey & formgroup) = true
	End If
	
	CartridgePrepChemField = tablename & "."  & fieldname
End function


'--------------------------------------------------------------------------------------
'Set search options depending on post type. No return
'--------------------------------------------------------------------------------------
Sub CartridgeSearchOptions(ByVal dbkey, ByVal formgroup)
	' fill chemsearch options with user's session
	' preferences
	'just in case this if from the post, set the appropriate session variables. They also may be set from another routine so don't change what may be there
	if UCase(Request("OverrideSearchPrefs")) = "TRUE" then 
		Session("OverrideDefaultPrefs") = "TRUE"
	end if
	if UCase(Request("GetPrefsFromPost")) = "TRUE" then 
		Session("GetPrefsFromPost") = "TRUE"
	end if
	if UCase(Request("GetDupSearchAppPrefs")) = "TRUE" then 
		Session("GetDupSearchAppPrefs") = "TRUE"
	end if
	
	if ((UCase(Session("OverrideSearchPrefs")) = "TRUE") OR (UCase(Session("GetPrefsFromPost")) = "TRUE") OR (UCase(Session("GetDupSearchAppPrefs")) = "TRUE")) then
		if UCase(Session("GetDupSearchAppPrefs") = "TRUE") then
				GetExactSearchPrefs dbkey, formgroup
		else
			if UCase(Session("GetPrefsFromPost") = "TRUE") then
				GetPrefsFromPost dbkey, formgroup
			else
				'take the prefs as they are. they may have been set by some other routine
			end if
		end if
	else
		GetCurrentPrefsCSDO dbkey, formgroup
	end if
	Session("OverrideDefaultPrefs") = ""
	Session("GetPrefsFromPost")=""
	Session("GetDupSearchAppPrefs")=""
end Sub
    
'--------------------------------------------------------------------------------------
'Formats string of search options for the cartridge. Returns a String 
'--------------------------------------------------------------------------------------
Function GetCartridgeOptionString(dbkey, formgroup)  
	CartridgeSearchOptions dbkey, formgroup
	
	Dim OptionsString
	
	'New implementation only adds to string NON default options.  We must pass
	'the cartridge default value as the last parameter.
	'SetCartridgeOption(byRef str, sOptionName, sOptionValue, sCartridgeDefault)
	
	'MATCH_TET_STEREO = PrefsS1
	SetCartridgeOption OptionsString, "TETRAHEDRALSTEREO", Session("PrefsS1" & dbkey), "YES"
	'MATCH_TET_DB = PrefsS2
	SetCartridgeOption OptionsString, "DOUBLEBONDSTEREO", Session("PrefsS2" & dbkey), "YES"
	'HIT_ANY_CHARGE_CARBON = PrefsS3
	SetCartridgeOption OptionsString, "HITANYCHARGECARBON", Session("PrefsS3" & dbkey), "YES"
	'RXN_HIT_RXN_CENTER = PrefsS4
	SetCartridgeOption OptionsString, "REACTIONCENTER", Session("PrefsS4" & dbkey), "YES"
	'HIT_ANY_CHARGE_HETERO = PrefsS5
	SetCartridgeOption OptionsString, "HITANYCHARGEHETERO", Session("PrefsS5" & dbkey), "YES"
	'PrefsS6: SIMTHRESHOLD added elsewhere
	'PrefsS7: FULL_SIM ADDED elsewhere PrefsS7
	'EXTRA_FRAGS_OK = PrefsS8
	SetCartridgeOption OptionsString, "PERMITEXTRANEOUSFRAGMENTS", Session("PrefsS8" & dbkey), "NO"
	'EXTRA_FRAGS_OK_IF_RXN = PrefsS9
	SetCartridgeOption OptionsString, "PERMITEXTRANEOUSFRAGMENTSIFRXN", Session("PrefsS9" & dbkey), "NO"
	'FRAGS_CAN_OVERLAP = PrefsS10
	SetCartridgeOption OptionsString, "FRAGMENTSOVERLAP", Session("PrefsS10" & dbkey), "NO" 
	'IDENTITY = PrefsS11
	SetCartridgeOption OptionsString, "IDENTITY", Session("PrefsS11" & dbkey), "NO" 
	'RELATIVE_TET_STEREO = PrefsS12
	SetCartridgeOption OptionsString, "RELATIVETETSTEREO", Session("PrefsS12" & dbkey), "NO"
	'ABSOLUTEHITSREL = PrefsS13
	SetCartridgeOption OptionsString, "ABSOLUTEHITSREL", Session("PrefsS13" & dbkey), "NO"
	'TAUTOMER = PrefsS14
	SetCartridgeOption OptionsString, "TAUTOMER", Session("PrefsS14" & dbkey), "NO"
	'LOOSEDELOCALIZATION = PrefsS15
	SetCartridgeOption OptionsString, "LOOSEDELOCALIZATION", Session("PrefsS15" & dbkey), "NO"
	'IGNOREIMPLICITH = PrefsS16
	SetCartridgeOption OptionsString, "IGNOREIMPLICITH", Session("PrefsS16" & dbkey), "NO"
	GetCartridgeOptionString = OptionsString
End Function

'Set search options depending on post type. No return
'Set search options depending on post type. No return
Sub SetCartridgeOption(byRef str, sOptionName, sOptionValue, sCartridgeDefault)
	
	if sOptionValue = "0" OR sOptionValue = "" OR lcase(sOptionValue) = "false" then sOptionValue = "NO"
	if sOptionValue = "1" OR lcase(sOptionValue) = "true" then sOptionValue = "YES"
	if sOptionValue = Ucase(sCartridgeDefault) then exit sub '=====> EXIT POINT
	if len(str)>0 then str = str & ","
	str = str & Ucase(sOptionName) & "=" & sOptionValue
	'str = "IDENTITY=YES,RELATIVETETSTEREO=YES"
End sub


'******************************Support Functions**************************
Function GetIndexName(byRef DataConn, Username, tablename)
	Dim s 
	Dim r 
	on error resume next
	Set r = Server.CreateObject("ADODB.RECORDSET")
	s = "SELECT INDEX_NAME FROM ALL_INDEXES WHERE TABLE_OWNER = '" & UCase(Username) & "' AND TABLE_NAME = '" & UCase(tablename) & "' AND ITYP_OWNER = 'CSCARTRIDGE' AND ITYP_NAME = 'MOLECULEINDEXTYPE'"
	Set r = DataConn.Execute(s)
	if Not (r.EOF and r.BOF) then
		theReturn = r.Fields("INDEX_NAME").Value
		r.close
	else
		theReturn = ""
	end if
	if err.number <> 0 then
		logaction(err.number & err.Description)
	end if
	GetIndexName = theReturn
End Function


 
Function CheckEOFBOF(byRef DataConn, UserName, tablename)
	Dim s 
	Dim indexName
	Set r = Server.CreateObject("ADODB.RECORDSET")
	indexName = GetIndexName(DataConn, UserName, tablename)
	s = "CALL CsCartridge.UpdateEOFBOF('" & UserName &  "', '" &  tablename + "', '" & indexName &  "')"
	DataConn.Execute(s)

	Dim r 
	Set r = DataConn.Execute("SELECT * FROM CsCartridge." &  UserName &  "_" &  indexName &  "_O")

	Dim isEOF, isBOF 
	Dim rowid 

	isEOF = r.Fields("EOF").Value = "YES"
	isBOF = r.Fields("BOF").Value = "YES"
	rowid = r.Fields("CURRENT_ROWID").Value

	if isEOF and isBOF then
		theReturn = "EMPTY"
	end if
	if isEOF and not isBOF then
		theReturn = "EOF"
	end if

	if not isEOF and  isBOF then
		theReturn = "BOF"
	end if
	if not isEOF and not isBOF then
		theReturn = ""
	end if
	r.close
	CheckEOFBOF = theReturn
End function


Sub CartridgeSuspend(byRef DataConn, index_name)
	sql = "ALTER INDEX " & index_name & " PARAMETERS('SUSPEND')"
	DataConn.Execute(sql)
End Sub

Sub CartridgeResume(byRef DataConn, index_name)
	sql = "ALTER INDEX " & index_name & " PARAMETERS('RESUME')"
	DataConn.Execute(sql)
End Sub


function DoCartridgeDuplicateSearch(dbkey, formgroup, fullfieldname, base64, byRef DataConn,returnfield)
	
	dim SearchOptionsString
	dim base64Array(0)
	Session("GetDupSearchAppPrefs") = "TRUE"
	Session("OverrideDefaultPrefs") = "TRUE"
	full_struc = "FULL=YES"
	SearchOptionsString = GetCartridgeOptionString(dbkey, formgroup)
	SearchOptionsString = full_struc & "," & SearchOptionsString
	if instr(fullfieldname, ".")> 0 then
		temp_table = split(fullfieldname, ".", -1)
		if UBound(temp_table) = 2 then
			tablename = temp_table(0) & "." & temp_table(1)
			fieldname = temp_table(2)
		else
			tablename = temp_table(0)
			fieldname = temp_table(1)
		end if
		if inStr(UCase(fieldname), "STRUCTURE") then
			struc_name = tablename & ".BASE64_CDX"
		else
			struc_name = fullfieldname
		end if
	else
		tablename = fullfieldname
		struc_name = tablename & ".BASE64_CDX"
	end if
		
	'get base64 from poststring
	if not Trim(base64) <> "" then
		base64 = Request.Form(fullfieldname)
	end if

	if base64 <> "" then
		subSelectSQL = "SELECT query from cscartridge.tempQueries where id = 0"
		buildString = "CSCartridge.MoleculeContains(" &  struc_name & ",'" & subSelectSQL &  "', '','" & SearchOptionsString & "')=1"
		base64Array(0) = base64
		Session("base64Array") = base64Array
		if returnfield <> "" then
			baseid = returnfield
		else
			baseid = GetTableVal(dbkey, tablename, kPrimaryKey)
		end if
		sqlstring = "Select " & baseid  &  " from " & tablename & " WHERE " & buildstring
		on error resume next
		Set RS = DoCartridgeSearch(sqlstring, dbkey, formgroup, maxhits, DataConn)
		dim ids
		'stop
		if NOT (RS.EOF AND RS.BOF) then
			ids =  RS.GetString(2,,,",","")
			ids = Left(ids, Len(ids)-1)
		else
			ids = ""
		End if
		if err.number <> 0 then
			logaction(err.number & err.Description)
		end if
	else
		ids= ""
	end if 'if base64 <> ""

	Session("GetDupSearchAppPrefs") = ""
	Session("OverrideDefaultPrefs") = ""
	DoCartridgeDuplicateSearch = ids
End Function

'Add Structure field for Cartridge. Returns boolean for success

Function DoCartridgeAddStructure(dbkey, formgroup, fullfieldname, uniqueid, ByVal base64string, ByRef DataConn, ByRef RS)
	on error resume next
	if not isObject(DataConn) or DataConn.State = 0  then
		Set DataConn = getNewConnection(dbkey, formgroup, "base_connection")
	end if
	temp = split(fullfieldname, ".", -1)
	if UBound(temp) = 2 then
		compound_moltable= temp(0) & "." & temp(1)
		fieldname= temp(2)
	else
		compound_moltable= temp(0)
		fieldname= temp(1)
	end if
	compound_strucIDField = GetTableVal(dbkey, compound_moltable, kStrucFieldID)
	compound_moltable_baseid = GetTableVal(dbkey, compound_moltable, kPrimaryKey)
	if not base64string <> "" then
		base64string = Session("SearchData" & fullfieldname  & dbkey & formgroup)
	end if
	Session("BASE64_CDX" & uniqueid & dbkey & formgroup) = base64string
	if bCoreOracleTrace=true then
		sql = "ALTER SESSION SET SQL_TRACE=TRUE"
		DataConn.Execute(sql)
	end if
	if UCase(fieldname) = "STRUCTURE" then
		fieldname="BASE64_CDX"
	end if

	if base64string <> "" then
		on error resume next
		if not isObject(RS) then 'use a command object if there is no RS passed in.
			Set RS = Server.CreateObject("ADODB.RECORDSET")
			sql = "SELECT * FROM " & compound_moltable & " WHERE " & compound_moltable_baseid & " = " & uniqueid
			RS.Open sql,DataConn, adOpenKeyset,  adLockOptimistic
			RS(fieldname).value  = base64string
			RS.Update
		else
			RS(fieldname).value = base64string
			RS.Update
		end if
		if err.number <> 0 Or  Session("errors_found" & dbkey & formgroup)<> "" then
			Session("errors_found" & dbkey & formgroup)= Session("errors_found" & dbkey & formgroup) & err.description & err.source
			theReturn = false
			logaction(err.number & err.Description)
		else
			theReturn = true
		end if
	else
		theReturn = false
	end if 'if base64 <>""

	DoCartridgeAddStructure= theReturn
End Function


'Update Structure field for Cartridge Returns boolean for success
Function DoCartridgeUpdateStructure(dbkey, formgroup, strucFields, ByVal tablename, ByVal uniqueid, ByRef DataConn,ByRef RS)
	
			 Session("errors_found" & dbkey & formgroup) = ""
			on error resume next
			if not isObject(DataConn) or DataConn.State = 0  then
				Set DataConn = getNewConnection(dbkey, formgroup, "base_connection")
			end if
			strucFields_array = split(strucFields, ",", -1)
			
			for i=0 to UBound(strucFields_array)
				fullfieldname = strucFields_array(i)
				if InStr(fullfieldname, "UID")> 0 then
					test ="UID." & uniqueid & ":" &  UCase(tablename)& "."
					temp_name = split(fullfieldname, ".", -1)
					if UBound(temp_name) = 3 then
						fieldname = temp_name(3)'format is UID.unqi:tablename.fieldname
					else
						fieldname = temp_name(2)'format is UID.unqi:tablename.fieldname
					end if
				else
					test = UCase(tablename)& "."
					temp = split(fullfieldname, ":", -1)
					temp_new = split(temp(1), ".", -1)
					if Ubound(temp_new) = 2 then
						fieldname = temp_new(2)
					else
						fieldname = temp_new(1)
					end if
				end if
				'ljb 12/16 this avoids BASE64_CDX64-> BASE_CDX if id = 64
				if fieldname = "BASE64_CDX" & uniqueid then
					fieldname = "BASE64_CDX"
				else
					fieldname = replace(fieldname, uniqueid, "") 'remove the unique_id from teh fieldname
				end if
				if UCase(fieldname) = "STRUCTURE" then
					fieldname="BASE64_CDX"
				end if
				
				compound_moltable_baseid = GetTableVal(dbkey, tablename, kPrimaryKey)
				if inStr(UCase(fullfieldname),UCase(test))> 0 then
					base64string = Trim(Request.form(fullfieldname))
					Session("BASE64_CDX" & uniqueid & dbkey & formgroup) = base64string
					'DecodeBase64 base64string, "C:/sampletest.cdx"
					if NOT UCase(base64string) = "NO_STRUCTURE" or Len(base64string)= 0 then
						on error resume next
						if not isObject(RS) then 'use a command object if there is no RS passed in.
							Set RS = Server.CreateObject("ADODB.RECORDSET")
							sql = "SELECT * FROM " & tablename & " WHERE " & compound_moltable_baseid & " = " & uniqueid
						    RS.Open sql,DataConn, adOpenKeyset,  adLockOptimistic
							RS(fieldname).value  = base64string
							RS.Update
						else
							RS(fieldname).value  = base64string
							RS.Update
						end if
						
						Session("MW"& dbkey & formgroup & tablename & "MolWeight" & uniqueid)=""
						Session("Formula"& dbkey & formgroup & tablename &  "Formula" & uniqueid)=""
					end if
				end if
		next 'strucfield	
		Session("reload_form") = true	
		Session("reload_list") = true
		if err.number <> 0 Or  Session("errors_found" & dbkey & formgroup)<> ""then
			Session("errors_found" & dbkey & formgroup)= Session("errors_found" & dbkey & formgroup) & err.description & err.source
			theReturn = false
			logaction(err.number & err.Description)
		else
			theReturn = true
		end if
		DoCartridgeUpdateStructure= theReturn
End Function


		
'******************HIT LIST
Function WriteHitlist(dbkey, formgroup, aSql, hitlistID, hitlistContentsField, ByRef Cmd, ByRef DataConn)
	'stop
	aSql = replace(aSql, " Where ", " WHERE ")
	aSql = replace(aSql, " From ", " FROM ")
	aSql = replace(aSql, " from ", " FROM ")
	aSql = replace(aSql, "Select ", "SELECT ")
	aSql = replace(aSql, "select ", "SELECT ")
	aSql = replace(aSql, " order by ", " ORDER BY ")
	aSql= replace(aSql, " Order By ", " ORDER BY ")
	aSql= replace(aSql, " ORDER By ", " ORDER BY ")
    
    Set RS = Server.CreateObject("ADODB.RECORDSET")
    ' Get the name of the field to be saved from the ChemSearchOptions object

    hitListIDTableName = GetFullTableName(dbkey, formgroup, "CSDOHITLISTID")
	hitListTableName = GetFullTableName(dbkey, formgroup, "CSDOHITLIST")
    baseTable = GetBaseTable(dbkey, formgroup, "basetable")
    If  hitlistContentsField <> "" Then
        ' Come up with a unique hitlistID
         if hitlistID = "" OR hitlistID = 0 then
			'!DGB! Use the function from manage_hitlists to get the new hitlistid
			hitlistID = GetNewHitlistID(dbkey, formgroup, Session("USER_SETTINGS_ID" & dbkey), "TEMP", "CSDO")
		else
			if NOT Application("allow_hitlist_management") then
				' Delete the previous hitlist
				cmd.CommandText= "DELETE FROM " & hitListTableName & " WHERE hitlistID=" & hitlistID
				cmd.Execute lrecsaffected
			End if
        end if
        ' Write Hitlist to table
        err.Clear()
     
        FromClause = Right(aSql, Len(aSql) - InStr(1, aSql, "FROM") + 2)
		
         '!LJB! 10/9/01 allow for order by and group sql
        If InStr(FromClause, " ORDER BY ") > 0 Or InStr(FromClause, " GROUP BY ") > 0 Then
           
            If InStr(FromClause, " ORDER BY ") Then
                OrderByArray = Split(FromClause, " ORDER BY ", -1)
                FromClause = OrderByArray(0)
            End If
            If InStr(FromClause, " GROUP BY ") Then
                GroupByArray = Split(FromClause, " GROUP BY ", -1)
                FromClause = GroupByArray(0)
            End If
        End If
		' In order to use the cscartridge.tempQueries table to store the query the insert and 
		' select must occurr within the same transaction.  So we submit both commands a single transaction 
		SetOracleSessionCursorSharingParameter DataConn, "force"
		DataConn.Begintrans()
        if IsArray(Session("base64Array")) then 
			
			arrlength = Ubound(Session("base64Array"))
			for i= 0 to arrlength
				sql = "BEGIN INSERT INTO cscartridge.tempQueries (id, query) VALUES (" & i & ", ?); END;"
				b64 = Session("base64Array")(i)
				Trace "WriteHitlist Query Molecule " & i & " = " & b64, 20
				Cmd.Parameters.Append Cmd.CreateParameter("p1", 201, 1, len(b64), b64 )	
				cmd.CommandText = sql
				cmd.properties("SPPRMSLOB") = true
				cmd.Execute
				cmd.properties("SPPRMSLOB") = false
				cmd.Parameters.delete "p1"
			Next
        End if

        'LJB 4/6/2004 add hint to insert statment 
        Dim theHINT
		if Application("USE_LEADING_HINT") = 1 then
				Dim subformlist
				Dim moleculeTable
				moleculeTable = Session("MOL_SEARCH_TABLE")
				subformlist = Session("strWhereSubforms" & dbkey & formgroup)
				if moleculeTable <> "" and  subformlist <> "" then
					theHINT = "/*+ LEADING(" &  Session("MOL_SEARCH_TABLE") & ") */ "
				else
					theHINT = ""
				end if
		end if
		
		'SYAN added on 5/26/2004 to support long list
		
		ClobToTableSPName = GetFullTableName(dbkey, formgroup, "ClobToTable")

		If session("IDList" & dbkey & formgroup) <> "" then
			Cmd.Parameters.Append Cmd.CreateParameter("c", 201, 1, len(session("IDList" & dbkey & formgroup)), session("IDList" & dbkey & formgroup))	
			Cmd.CommandText = "{call " & ClobToTableSPName & "(?)}" '"{call REGDB.ClobToTable(?)}"
			cmd.properties("SPPRMSLOB") = true
			cmd.Execute
			cmd.properties("SPPRMSLOB") = false
			cmd.Parameters.delete "c"
			session("IDList" & dbkey & formgroup) = ""
		End if
		'End of SYAN modification
		'6/20/2005 need to get table real name to support aliases of the basetable
		basetable = GetTableVal(dbkey, basetable, kTableRealName)
	
		if theHINT <> "" then
			sql ="INSERT /*+ APPEND */ INTO " & hitListTableName & " SELECT " & theHINT & " DISTINCT " & hitlistID & " AS hitlistID, " & baseTable & ".rowid AS ID " & FromClause
		else
			sql ="INSERT /*+ APPEND */ INTO " & hitListTableName & " SELECT DISTINCT " & hitlistID & " AS hitlistID, " & baseTable & ".rowid AS ID " & FromClause
        end if
        
        if Session("limited_search") then sql = sql & " AND rownum <= " & Session("displayLimit")
        Session("limited_search")= false
        Cmd.CommandText = sql
        Trace "WriteHilist sql: " & sql & " (hitlistID=" & hitlistID & ")", 9
        t0 = timer
		'LJB 8_31_2004. Check for errors were the table does not exist. This usually indicates the user does not have privileges and they should be alerted.
		on error resume next
        Cmd.Execute lrecsaffected
        if instr(UCase(err.Description), "DOES NOT EXIST")> 0  then
			Session("TablePermissions" & dbkey & formgroup) = "You do not have permissions on one or more of the tables for which you entered criteria."
		end if
        

        DataConn.CommitTrans
        
        SetOracleSessionCursorSharingParameter DataConn, "exact"
		Session("base64Array") = ""	
		hitlistWriteTime = timer - t0
        Trace "Time to search and write hitlist:(" & lRecsAffected & ")hits: " & hitlistWriteTime & " seconds.", 8
        Session("hitlistWriteTime") = hitlistWriteTime
        Session("hitlistrecordcount" & dbkey & formgroup) = lRecsAffected
        Session("hitlistid" & dbkey & formgroup) = hitlistID
        if err.number <> 0 then
			logaction(err.number & err.Description)
		end if
    Else
        sql = "Hitlist not saved"
    End If
    WriteHitList =  hitlistID
End Function 

Function TableExists(aTableName,ByRef DataConn)
   
    if Not  Session(aTableName & "_table_check_done") <> "" then
        sql = "SELECT ID FROM " & aTableName
        On Error Resume Next
        DataConn.Execute (sql)
            If Err.Number <> 0 Then
                TableExists = False
            Else
                TableExists = True
                Session(aTableName & "_table_check_done") = "done"
            End If
    else
	 TableExists = true
    end if
      
End Function


'!DGB! 04/22/01
 Function JoinhitlistTableToRelSql(aSql) 
	schema_name = getSchemaName(dbkey, formgroup, "")
	baseTable = GetBaseTable(dbkey, formgroup, "basetable")
  ' Add CSDOhitlist at the front of the the FROM clause
   aSql = Replace(aSql, "FROM ", "FROM " & schema_name& ".CSDOhitlist, ")
    ' Add Join and constrain at the front of the WHERE clause
   ' hitlist table now contains rowids
   aSql = Replace(aSql, "WHERE ", "WHERE " & schema_name & ".CSDOhitlist.ID = " &  baseTable & ".rowid AND " & schema_name & ".CSDOhitlist.hitlistID =" & Session("SearchDomain" & dbkey & formgroup) & " AND ")
    JoinhitlistTableToRelSql = aSql
End Function

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Function GetSigFigs derived from Cs_RealNum:ParseString C++ code used by CFW
'ParseString   Examines the provided string, which represents a real number, possibly      '
'       in exponential notation, and determines the number of significant figures present.  '
'       In the conventional simple and scientific representations of real numbers, there is '
'       one region within the string that represents the significant digits.  The position  '
'       of this region given by (start,finish).                                             '
'                                                                                           '
'       To determine this region:                                                           '
'           1)  Locate the decimal point.                                                   '
'           2)  Remove a leading minus or plus sign.                                        ' 
'                                                                                           '
'           3)  Remove leading zeroes.                                                      '
'           4)  Strip off everything including and following an exponent (E).               '
'           5)  If a decimal point is not present, strip off trailing zeroes.               '
'           6)  Count the number of characters left, ignoring any decimal point.            '
'           7)  Every number is considered to have *at least* one significant figure.       '
'                                                                                           '
'       Examples of "significant regions" are:                                              '
'               "-003.14E01"    -> "3.14",      3 sig figs.                                 '
'               "0.0300"        -> ".0300",     3 sig figs.                                 '
'               "3020"          -> "3020",      3 sig figs.                                 '
'               ".00E-7"        -> ".00",       1 sig figs.                                 '
'       Penned by HEH, 12/15/95.                                                            ' 
'       Ported by DGB 7/2003                                                                '
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Function GetSigFigs(src)

    ' 1) Locate the decimal point.
    decPt = InStr(src, ".")
    If decPt >= 0 Then decPt = decPt - 1 ' -1 if not present
    ' 2-3) Remove leading zeroes, pluses, minuses (and periods for chuckles).
    start = 0
   
    While start < Len(src) And InStr("+-0.", Mid(src, start + 1, 1))
        start = start + 1
    Wend

    finish = Len(src) - 1

    ' 4) Strip off an exponent and everything after.
    exponent = InStr(LCase(src), "e")
    If exponent >= 0 Then exponent = exponent - 1
    If exponent > 0 Then
        finish = exponent - 1
    End If
    ' 5) If a decimal point is not present, strip off trailing zeroes.
    If decPt = -1 Then
        While (finish > start And Mid(src, finish + 1, 1) = "0")
            finish = finish - 1
        Wend

    End If
    ' 5.5) Handle the special case of ".00" (with or without a trailing exponential).
    If finish < start Then
    
        start = 0
        While start < Len(src) And InStr("+-0", Mid(src, start + 1, 1))
            start = start + 1
        Wend
        numSigFigs = 1
    Else

    '   6)  Count the number of characters left, ignoring any decimal point.
    '       start and finish are the first and last digits in the significant region.

        numSigFigs = finish - start + 1

        If decPt > start And decPt < finish Then
            numSigFigs = numSigFigs - 1
        End If
    End If

    ' 7) Every number has at least one significant figure.
    If (numSigFigs < 1) Then
        numSigFigs = 1
    End If
    GetSigFigs = numSigFigs
End Function

Sub GetSearchRange(src, ByRef loVal, ByRef hiVal)
    v = CDbl(src)
    figs = GetSigFigs(src)
    tol = SetToleranceFromSigFig(v, figs)
    delta = 0.5 * tol
    If delta > 1 Then delta = 0.5
    
    loVal = v - delta
    hiVal = v + delta
End Sub

Function SetToleranceFromSigFig(v, numsigfig)
        SetToleranceFromSigFig = 10 ^ (PowerOfMostSignificantFig(v) - numsigfig + 1)
End Function

Function PowerOfMostSignificantFig(val)
    PowerOfMostSignificantFig = Floor(Log10(Abs(val)))
End Function

Function Log10(X)
   Log10 = Log(X) / Log(10)
End Function

Function Floor(ByVal n)
    Dim iTmp, bErr
    On Error Resume Next
    n = CDbl(n)
    If Err Then bErr = True
    On Error GoTo 0
    If bErr Then Err.Raise 5000, "Floor Function", _
        "Input must be convertible to a sub-type of double"
    iTmp = Round(n)
    'test rounded value against the non rounded value
    'if greater, subtract 1
    If iTmp > n Then iTmp = iTmp - 1
    Floor = CInt(iTmp)
End Function 

function CheckTooManyHits(sqlString,  dbkey,  formgroup, existingConnection)
	if Session("limited_search") then exit function  '===>EXIT POINT
	Session("fEmptyRecordset" & dbkey & formgroup) = false
	If Application("TooManyHitsWarningThreshHold") > 0 then
			myTemp = Session("ContentsField" & dbkey & formgroup)
			Session("ContentsField" & dbkey & formgroup) = ""
			FromClause = Right(sqlString, Len(sqlString) - InStr(1, sqlString, "FROM") + 2)
			sql = "SELECT Count(*) As hitCount" & FromClause
			Set CountRS = CSDODoCommand( sql,  dbkey,  formgroup,  maxHits,  existingConnection)
			hitCount = clng(CountRS("hitCount"))
			Session("hitlistrecordcount" & dbkey & formgroup) = hitCount
			if hitCount > Application("TooManyHitsWarningThreshHold") then 
				Session("TooManyHitsCount" & dbkey & formgroup) = hitCount
				Session("fEmptyRecordset" & dbkey & formgroup) = true
				CheckTooManyHits = true
			else
				Session("ContentsField" & dbkey & formgroup) = myTemp
				CheckTooManyHits = false
			End if
	Else
		CheckTooManyHits = false			
	end if	
End function

function rebuildOrderBySelect(dbkey, formgroup,basetable)
		'need to rebuild the order by clause without referencing the cscartridge, but rather substituting the hilist.
		dim subforms
		subforms = ""
		basetable = getTableVal(dbkey, basetable, kTableRealName)
		baseid = GetTableVal(dbkey, basetable, kPrimaryKey)
		strGetFields  = basetable & "." & baseid
		'determine if any of the fields in the order_by are for tables other then the basetable
		order_by_temp = split(Session("order_by" & dbkey & formgroup), ",", -1)
		
		for i = 0 to UBound(order_by_temp)
			temp = split(order_by_temp(i), ".", -1)
			if UBound(temp)=2 then
				table_temp = temp(0) & "." & temp(1)
			else
				table_temp = temp(0)
			end if
			if Not Trim(UCase(table_temp)) = Trim(Ucase(basetable)) then
				if subforms <> "" then
					subforms = subforms & "," & table_temp
				else
					subforms = table_temp
				end if
			end if
		next
		
		'rebuild select statement with only basetable. Sort fields tables will be added if they are in the session("order_by" & dbkey & formgroup) table
		full_sql=	BuildSelectStatement(dbkey, formgroup, basetable, subforms, strGetFields, "")
	
		'change case to upper case to avoid parsing issues
		full_sql = replace(full_sql, " From ", " FROM ")
		full_sql = replace(full_sql, " from ", " FROM ")
		full_sql = replace(full_sql, "Select ", "SELECT ")
		full_sql = replace(full_sql, "select ", "SELECT ")
		
		'get the order by clause from the inputSQL- only for docmanager 
        if lcase(dbkey)="docmanager" and lcase(formgroup)="base_form_group" then
            temp_array = split(session("order_by" & dbkey & formgroup), ",")
            For Each elem In temp_array
                tempStr=  tempStr & " " & elem & " " & Session("Sort_direction" & dbkey & formgroup) & ","
            next
            tempStr= mid(tempstr,1,len(tempStr)-1)
            order_by_clause = " ORDER BY " & tempStr  & " "
        else 
            order_by_clause = " ORDER BY " & session("order_by" & dbkey & formgroup) &  " " & Session("Sort_direction" & dbkey & formgroup)
        end if 
		
		'get the FROM cluase (exclude the where portion)
		temp_array2 = split(full_sql, " FROM ", -1)
		FromWhereClause = temp_array2(1)
		temp_array3 = split(FromWhereClause, " WHERE ", -1)
		FromClause = temp_array3(0)
		
		'get the Select clause
		SelectClause = temp_array2(0)
		'get the schema neame
		schema_name= Application(dbkey & "_USERNAME")
		'rebuild statement with the current hitlist name and id.
		'JHS ordering fix
		additionaljoinclause = temp_array3(1)
		'sql =  SelectClause &  " FROM " & FromClause & ","  & schema_name & ".CSDOhitlist" & " WHERE  " & schema_name & ".CSDOHitList.hitlistID=" & Session("hitlistID" & dbkey & formgroup) & " AND " & schema_name & ".CSDOhitlist.ID=" &  basetable & ".rowid "   & order_by_clause 
		sql = SelectClause & " FROM " & FromClause & "," & schema_name & ".CSDOhitlist" & " WHERE " & additionaljoinclause & schema_name & ".CSDOHitList.hitlistID=" & Session("hitlistID" & dbkey & formgroup) & " AND " & schema_name & ".CSDOhitlist.ID=" & basetable & ".rowid " & order_by_clause 
		'JHS end fix
		rebuildOrderBySelect=sql
End function

Sub SetOracleSessionCursorSharingParameter(conn, value)
	Dim bCursorSharing

	if Application("FORCE_ORACLE_SESSION_CURSOR_SHARING") = "" then
		Application.Lock
		bCursorSharing = GetINIValue( "optional", "GLOBALS", "FORCE_ORACLE_SESSION_CURSOR_SHARING", "chemoffice", "chemoffice")
		Application("FORCE_ORACLE_SESSION_CURSOR_SHARING")= bCursorSharing
		if (bCursorSharing="INIEmpty" or bCursorSharing = "NULL" or bCursorSharing = "") then
			Application("FORCE_ORACLE_SESSION_CURSOR_SHARING")="0"
		end if
		Application.UnLock
	end if
	
	
	if Application("FORCE_ORACLE_SESSION_CURSOR_SHARING") then
		on error resume next
		conn.execute("alter session set cursor_sharing = " & value)
		trace "Oracle Session cursor_sharing has been set to " & value,  25
	End if
	if err then
		trace "error while setting cursor_sharing : " & err.source & " : "  & err.Description, 0
	end if
	
	
	if Session("10046TraceLevel") <> "" then
		if lcase(value) = "force" then 
			on error resume next
			conn.execute("alter session set events '10046 trace name context forever, level " & session("10046TraceLevel") & "'")
			trace "Oracle 10046 trace for Cartridge SQL enabled" , 25
		else
			conn.execute("alter session set events '10046 trace name context off'")
			trace "Oracle 10046 trace for Cartridge SQL disabled" , 25
		end if
		if err then
			trace "error while setting 10046 trace : " & err.source & " : "  & err.Description, 0
		end if
	End if	
End sub
	
Function AddToStrucFieldList(currentList, tableToAdd)
		If currentList <> "" then
			AddToStrucFieldList = currentList
		else
			AddToStrucFieldList = tabletoadd
		end if
End Function

%>
