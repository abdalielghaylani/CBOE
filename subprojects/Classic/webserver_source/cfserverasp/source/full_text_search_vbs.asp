<%' Copyright 1999-2003 CambridgeSoft Corporation. All rights reserved
'DO NOT EDIT THIS FILE%>

<%
Dim countrecs
Dim bDebugFullText
Dim processmessage
bDebugFullText = false

'prepare full text search string based on DBMS 
Function PrepFullTextSQL(ByVal dbkey, ByVal Formgroup, ByVal strFieldName, ByVal strCriteria, ByVal SQLSyntax)
	Select Case UCase(SQLSyntax)
		Case "ORACLE" 'use Oracle Intermedia
			strDelimiter = "'"
			if (Application("INDEX_FIELD") = "NULL" or Application("INDEX_FIELD") = "") OR Not Request("INDEX_FIELD") <> "" then
					HandleError dbkey, formgroup, "no_index_field", "", "", ""
			else
				arr = split(strFieldName, ".", -1)
				if Ubound(arr) = 2 then
					Table = arr(0) & "." & arr(1)
					Field= arr(2)
				else
					Table = arr(0)
					Field= arr(1)
				end if
				if Request("INDEX_FIELD") <> "" then
					'JHS comments about new code 1/25/2007
					'start of new JHS code
					'There are two problems with the code as used for DocManager
					'1) The code supports only 1 table and 1 field because there is no way to add search fields to the INDEX_FIELD
						'This will be handled by adding a comma check.  Since a comma will not exist for 
						'DocManager this will only effect non-DocManger Implementation
						'To use the Index Field will have a comma delimited list of search fields
						'simple example.... USPTO_DDESC.DETDESC, USPTO_CLAIMSS.ACLM
					'2) The above will allow one search field per table, but not more than one in a single table.
						'Core already has a mechanism for using using Alias tables more using a :&# where #=0,1,2,3, etc
						'However in this case the id field is used as the search field, but a different field is actually being searched
						'The solution is to Alias each full text field
						'First add fields to the search form
						'ShowInputField dbkey, formgroup, "USPTO_DDESC.INDX:&1", 25, "70"
						'ShowInputField dbkey, formgroup, "USPTO_DDESC.INDX:&2", 25, "70"
						'ShowInputField dbkey, formgroup, "USPTO_CLAIMSS.INDX", 25, "70"
						'The trick is knowing that USPTO_DDESC.INDX:&1 gets translated to USPTO_DDESC1.INDX
						'Note the 1 gets moved to the end of the table name to create the alias
						'However since the USPTO_DDESC1 does not exist as a real table it needs to be translated to the real table name
						'So we create a INDEX_FIELD_TRANSLATOR that must be in the same order as INDEX_FIELD
						'<input type="hidden" name="INDEX_FIELD" value="USPTO_DDESC1.DETDESC,USPTO_DDESC2.BRFSUM,USPTO_CLAIMSS.ACLM">
						'<input type="hidden" name="INDEX_FIELD_TRANSLATOR" value="USPTO_DDESC.DETDESC,USPTO_DDESC.BRFSUM,USPTO_CLAIMSS.ACLM">

					'start of new code JHS
					if instr(1,Request("INDEX_FIELD"),",") > 0 then
						'if it's in the string you need to determine the one to choose
						'technically this can be done without the else but it is safer for docmgr with it
						indexarr = split(Request("INDEX_FIELD"), ",", -1)
						indexarrstop = Ubound(indexarr)
						i = 0
						indexfieldused = ""
						'the goal is to take the table name from above and find the fulltext field to match
						while (i <= indexarrstop) 
							'adding a period as part of the match although you still have to be
							'careful about the field name
							if instr(1,indexarr(i),Table & ".") > 0 then
								'you found the correct one
								'indexfieldused = indexarr(i)
								iused = i
								i = indexarrstop + 1
							else
								i = i + 1
							end if
						wend
						
						'Now that you matched the table use the translator to get the real table name
						'This translates the &0 which became TableName0 to TableName
						
						transarr = split(Request("INDEX_FIELD_TRANSLATOR"), ",", -1)
						tableinfo = transarr(iused)
						indexfieldused = tableinfo
						tableinfoarr = split(tableinfo,".",-1)
						Table = tableinfoarr(0)
						
						'now use that field
						PrepFullTextSQL = "SELECT " & Field & " FROM " & Table & " WHERE CONTAINS(" & indexfieldused & ", " & strDelimiter & strCriteria & strDelimiter & ") > 0" 					

					else
						'do original if , is not instr
						PrepFullTextSQL = "SELECT " & Field & " FROM " & Table & " WHERE CONTAINS(" & Request("INDEX_FIELD") & ", " & strDelimiter & strCriteria & strDelimiter & ") > 0" 					
					end if	
					'End of new code JHS
					
					'Original code
					'PrepFullTextSQL = "SELECT " & Field & " FROM " & Table & " WHERE CONTAINS(" & Request("INDEX_FIELD") & ", " & strDelimiter & strCriteria & strDelimiter & ") > 0" 
				else
					PrepFullTextSQL = "SELECT " & Field & " FROM " & Table & " WHERE CONTAINS(" & Application("INDEX_FIELD") & ", " & strDelimiter & strCriteria & strDelimiter & ") > 0" 
				end if
				PrepFullTextSQL = "IN (" & PrepFullTextSQL & ")"
			end if
		CASE "ACCESS","SQLSERVER" 'prep for MS index server
			'add determin best fit search type for index server
			SQLsearchfield = Request("index_alternate_searchfield")
			UseReverseText = Request("index_use_reverse_text")
			searchType = getFullTextSearchType(strCriteria, SQlSearchField, UseReverseText)
			if bDebugFullText then
				Response.Write "SQLsearchfield: " & SQLsearchfield & "<br>"
				Response.Write "UseReverseText: " & UseReverseText & "<br>"
				Response.Write "searchType: " & searchType & "<br>"
			end if
			Select Case UCase(searchType)
				Case "INDEXSERVERSEARCH"
					tempTableName= prepFullTextIndexServer(dbkey, formgroup, strCriteria)
					
					PrepFullTextSQL = "SELECT FILE_NAME FROM " & tempTableName
					PrepFullTextSQL = "IN (" & PrepFullTextSQL & ")"
				Case "SQLSEARCH"
					AddSubFormNames dbkey, formgroup, SQLsearchfield 
					strFldType = "0" 'text field. "7" is memo, but currently it repeats the statment which is incorrect.
					parsedstring =  ParseDataQuery(strCriteria, SQLsearchfield, strFldType,dbkey, formgroup) 
					strRealName = GetTableRealName(dbkey, formgroup, SQLsearchfield, "full_name")
					finalName = AddRelBrackets(strRealName)
					final_parsedstring = replace(parsedstring, SQLsearchfield, finalName)
					PrepFullTextSQL =  " " & "(" & final_parsedstring & ")"	
					'append double_pipe to indicate to calling function to use an alternate fieldname
					PrepFullTextSQL = finalName & "||" & PrepFullTextSQL
					if bDebugFullText then
						Response.Write strRealName & "<br>"
						Response.Write PrepFullTextSQL & "<br>"
					end  if
			End Select
		Case Else
			PrepFullTextSQL = ""
		End Select
End Function


'figure out what type of search to do based on the searchstring and the presence or absence of an alternate sql field for straight searching or a reverse index
Function getFullTextSearchType(SearchString, SQlSearchField, UseReverseText)
	bLeadWildCardsInStr = LeadWildCardCheck(SearchString)
	if bDebugFullText then
		Response.Write "Lead Wild Cards In Submitted String: " & bLeadWildCardsInStr & "<br>"
	end if
	bSQLAvailable = SQLAvailableCheck(SQLsearchfield)
	if bDebugFullText then
		Response.Write "SQL Field Available: " & bSQLAvailable & "<br>"
	end if
	bReverseAvailable = UseReverseText
	if bDebugFullText then
		Response.Write "Reverse Text Available: " & bReverseAvailable & "<br>"
	end if
	if bLeadWildCardsInStr then
		if bReverseAvailable then
			bDoubleWildCardsInStr = DoubleWildCardCheck(SearchString)
			if bDoubleWildCardsInStr then
				if bSQLAvailable then
					SearchString = SearchString
					FullTextSearchType = "SQLSearch"
				else
					SearchString = RemoveLeadWildCard(SearchString)
					FullTextSearchType = "IndexServerSearch"
				end if
			else		
				SearchString = ReverseSearchTerm(SearchString)
				FullTextSearchType = "IndexServerSearch"
			end if
		else
				if bSQLAvailable then
					SearchString = SearchString
					FullTextSearchType = "SQLSearch"
				else
					SearchString = RemoveLeadWildCard(SearchString)
					FullTextSearchType = "IndexServerSearch"
				end if
		end if	
	else
		SearchString = SearchString
		FullTextSearchType = "IndexServerSearch"
	end if	
	if bDebugFullText then
		Response.Write "Search String: " & SearchString & "<br>"
		Response.Write "Full Text Search Type: " & FullTextSearchType & "<br>"
	end if
	getFullTextSearchType=FullTextSearchType
End Function

'search using index server and populate a temp table with a file_name column of results. 
Function PrepFullTextIndexServer(ByVal dbkey, ByVal formgroup,  ByVal SearchString)
	'gather information from the post
	catalog = request("index_catalog") 
	columns = "filename"
	site_local = request("index_sitelocale")
	file_extension_in=request("index_file_ext_in")
	file_extension_out=request("index_file_ext_out")
	cursor_type = request("index_rs_cursor")
	prop_name = request("index_prop_name")
	set Q = Server.CreateObject("ixsso.Query")
	set util = Server.CreateObject("ixsso.Util")
	Q.Catalog = catalog 
	if prop_name <> "" then
		Q.Query = "{prop name=" & prop_name & "}" & SearchString
	else
		Q.Query = SearchString
	end if
	Q.Columns = columns
	if site_locale <> "" then
		'convert a languange code to a win32 localeID
		Q.LocaleID = util.ISOToLocaleID(site_locale) 'LocaleID determines the language components 
	end if
	
	'Execute the query, creating an OLE DB results table or an ADO recordset
	on error resume next
	set RS = Q.CreateRecordSet(cursor_type) 'cursor type sequential or nonsequential
	
	if not  err.number <> 0 then
	'create temp table to load data
		if not (RS.BOF and RS.EOF) then ' IndexServer RS
			
			RS.MoveFirst
		         'Create a temp table
				Set conn = GetNewConnection (dbkey, formgroup, "base_connection")
				Set cmd = Server.CreateObject("ADODB.Command")
				Set oTempTableRS = Server.CreateObject("ADODB.Recordset")
				temptablename = "INDEXSVRTEMP" & Session.SessionID
				Session("MSIS_TempTableName") = temptablename
				
		        Set cmd.ActiveConnection = conn
		        cmd.CommandType = adCmdText
		        ' complains if table doesn't already exist
		        On Error Resume Next
		        cmd.CommandText = "drop table " & tempTableName
		        cmd.Execute
		        On Error GoTo 0
		        cmd.CommandText = "create table " & tempTableName & " (FILE_NAME CHAR(100))"
		        cmd.Execute
		        
		       	'JHS'				
				sql = "create table TempTableList" & " (TempTableName CHAR(250))"
					
				on error resume next
				conn.Execute(sql)
					
				err.Clear
					
				oTempTableRS.Open "TempTableList", Conn, adOpenDynamic,adLockOptimistic,adCmdTable
			
				
				oTempTableRS.AddNew
				oTempTableRS.Fields("TempTableName") = tempTableName
				oTempTableRS.Update
				oTempTableRS.Close
				'JHS'
				
		        Set cmd = Nothing
		        ' fill with filenames from IndexServer RS
		           oTempTableRS.Open tempTableName, Conn, adOpenDynamic,adLockOptimistic,adCmdTable
		            'Loop over the hitlist and populate the temptable by updating the RS
						while not RS.EOF 'loop through the rs from index server
							filename = RS("filename")
							'get rid of ".html" and concatenate together
							filename = replace(filename, file_extension_in, file_extension_out)
							'if instr(filename, ".html") and not (file_extension = "" Or UCase(file_extension) = "HTML") then
								'theFinalfilename =  Left(filename, Len(filename) - 5) & "." & file_extension
							'else
								'theFinalfilename = filename
							'end if
							oTempTableRS.AddNew
							oTempTableRS.Fields("FILE_NAME") = filename
							RS.MoveNext
						wend
						RS.Close
						Set RS = Nothing
						oTempTableRS.Update
						CloseRS(oTempTableRS)
						CloseConn(conn)
		              
			fullTextSearchResult = Session("MSIS_TempTableName")
		else
			fullTextSearchResult=""
		end if
	else
		fullTextSearchResult=""
	end if
	PrepFullTextIndexServer=fullTextSearchResult
end function


'Checks for any leading wildcard
'returns boolean for whether the are any leading wildcards
function LeadWildCardCheck(strSearchString)
	
	Set objRegExp = New RegExp

	objRegExp.Pattern = "\*[^ ]+" 'This should match *[nowhitespace]*
	objRegExp.IgnoreCase = True
	objRegExp.Global = True
	
	leadwildsexist = objRegExp.Test(strSearchString)
	
	LeadWildCardCheck = leadwildsexist

end function

'check if an another sql field exists for searching as as an alternate to index server
function SQLAvailableCheck(strSQLsearchfield)
	if strSQLsearchfield <> "" then
		sqlavailable = true
	else
		sqlavailable = false
	end if
	
	SQLAvailableCheck = sqlavailable
			
end function


'check for leading and trailing wild cards
function DoubleWildCardCheck(strSearchString)

	Set objRegExp = New RegExp

	objRegExp.Pattern = "\*[^ ]*\*" 'This should match *[nowhitespace]*
	objRegExp.IgnoreCase = True
	objRegExp.Global = True

	CheckForDoubleWildcards = objRegExp.Test(strSearchString)

	DoubleWildCardCheck = CheckForDoubleWildcards
end function

'remove leading wild cards
function RemoveLeadWildCard(strSearchTerm)
	PreparedNoLeadStr = strSearchTerm
	Set objRegExp = New RegExp
	objRegExp.Pattern = "\*([^ ]+)" 'This should match *[nowhitespace]*
	objRegExp.IgnoreCase = True
	objRegExp.Global = True

	Set CheckForDoubleWildcards = objRegExp.Execute(PreparedNoLeadStr)
	
	removedleadwild = PreparedNoLeadStr
	For each leadmatch in CheckForDoubleWildcards
			leadmatchvalue = leadmatch.value
			removedwild = Mid(leadmatchvalue, 2, len(leadmatchvalue)-1)
			removedleadwild = Replace(removedleadwild, leadmatchvalue, removedwild,1,1,vbBinaryCompare)
			
			if bDebugFullText then
				processmessage = "I removed the * because you do not have a sql field."
			end if
	Next
	RemoveLeadWildCard = removedleadwild
end function


'reverse search string for use with reverse index
function ReverseSearchTerm(strSearchString)

	PreparedReverseSearchString = strSearchString
	
	Set objRegExp = New RegExp

	objRegExp.Pattern = "\*([^ ]+)" 'This should match *[nowhitespace]*
	objRegExp.IgnoreCase = True
	objRegExp.Global = True

	Set CheckForDoubleWildcards = objRegExp.Execute(PreparedReverseSearchString)
	
	ReverseSearchTerm = PreparedReverseSearchString
	For each leadmatch in CheckForDoubleWildcards
		
		leadmatchvalue = leadmatch.value
		
		reversetext = ""
		for i=1 to len(leadmatchvalue)
			reversetext = Mid(leadmatchvalue,i,1) + reversetext
		Next
		
		ReverseSearchTerm = Replace(ReverseSearchTerm, leadmatchvalue, reversetext,1,1,vbBinaryCompare)
	Next		
		
end function

%>


