<%' Copyright 1999-2003 CambridgeSoft Corporation. All rights reserved
'DO NOT EDIT THIS FILE%>
<%
Dim traceLevel
Dim ServerTraceLevel
ServerTraceLevel= 0


'DGB Three ways to set the trace level for cfwlog.txt
' 1. Use the ServerTraceLevel above: Affects all applications all the time and overrides any other setting
' 2. Use http://<servername>/<appname>/SetCfwTraceLevel.asp?level=20&scope=application to set values for a given application.  Overriden by server level setting.
' 3. Use http://<servername>/<appname>/SetCfwTraceLevel.asp?level=20&scope=session to set values for the current session.  Overriden by either of the above.

if Session("CfwTraceLevel") <> "" then tracelevel = Session("CfwTraceLevel")
if Application("CfwTraceLevel") <> "" then tracelevel = Application("CfwTraceLevel")
if ServerTraceLevel <> 0 then tracelevel = ServerTraceLevel

sf_DEBUG= false
bCoreOracleTrace = false

'----------------------------------------------------------------------------'
'Name: GetChemLinksStr(dbkey, formgroup)
'Purpose: populate Application("ChemConnection_str") with data from "CHEM_CONNECTION_NAMES" string from ini file
'Parameter description: dbkey as String, formgroup as String
'Return Values: none
'Comments:  Application("ChemConnection_str") populates with comma delimited string of chem_connection names
'----------------------------------------------------------------------------'

Function GetChemLinksStr(ByVal dbkey, ByVal formgroup)
	if Session("bypass_ini" & dbkey & formgroup) = true then
		ChemConnString=Application("CHEMconnections_str" & dbkey & formgroup)
		
	else
		if  Application("CHEMconnections_str" & dbkey)= "" then
			Application.Lock
				Application("CHEMconnections_str" & dbkey) = GetINIValue( "optional", "GLOBALS", "CHEM_CONNECTION_NAMES", "web_app", dbkey)
			Application.UnLock
			ChemConnString=Application("CHEMconnections_str" & dbkey)
		else
			ChemConnString=Application("CHEMconnections_str" & dbkey)
		end if
	end if
	GetChemLinksStr = ChemConnString
End Function


'----------------------------------------------------------------------------'
'Name: GetADOConnVal(dbkey, conn_name, inputval)
'Purpose: return value from connection name array 
'Inputs: dbkey as String, conn_name as String, inputval as Enum
'Return Values: array value
'Comments:  Application(conn_name & dbkey) or Session(conn_name & dbkey) if session(bypass_ini & dbkey & formgroup) = true
'Enum Values:
				'kConn = 0
				'kConnStr = 1
				'kConnTimeOut = 2
				'kConnConnTimeOut = 3
				'kConnUserName = 4
				'kConnPassword = 5
				'kDBMS = 6
'----------------------------------------------------------------------------'


Function GetADOConnVal(ByVal dbkey, ByVal conn_name, ByVal inputval)
		if Session("bypass_ini" & dbkey & request("formgroup")) = true then
			thearray = Application(conn_name & dbkey)
		else
			thearray = Application(conn_name & dbkey)
		end if	
		thevalue = thearray(inputval)
		if err.number <> 0 then
				thevalue = ""
		end if
	GetAdoConnVal = thevalue
End function



'----------------------------------------------------------------------------'
'Name: GetFormGroupVal(dbkey, formgroup, inputval)
'Purpose: return value from formgorup  array 
'Inputs: dbkey as String, conn_name as String, inputval as Enum
'Return Values: array value
'Comments:  Application(formgroup & dbkey) or Session("FORM_GROUP" & dbkey & formgroup) = true if
			'session("bypass_ini" & dbkey & formgroup) = true
'Enum Values:
			'kRelFields=0
			'kInputFormPath=1
			'kResultFormPath=2
			'kInputFormMode=3
			'kResultFormMode=4
			'kPluginValue=5
			'kFormGroupFlag=6
			'kStructureFields=7
			'kMWFields=8
			'kFormulaFields=9
			'kSDFileFields=10
			' constant 11 is saved for later use
			'kTableGroup=12
			'kRequiredFields=13
			'kNumListView=14
			' for session("bypass_ini" & dbkey & formgroup)
			'kRelDetailFields=15
			'kRelListFields=16

'----------------------------------------------------------------------------'

Function GetFormGroupVal(ByVal dbkey, ByVal formgroup, ByVal inputval)
	'SYAN added on 6/27/2007 for CARA's alternative required field work flow	
	if LCase(session("c_type_text"))= "acquired" and inputval = 13 then
		inputval = 15
	end if
	'End of SYAN modification
	
	on error resume next
	if Session("bypass_ini" & dbkey & formgroup) = true then
	
		thearray = Application("FORM_GROUP" & dbkey & formgroup)
	else
		thearray = Application(formgroup & dbkey)
	end if
	
	thevalue = thearray(inputval)
	if err.number <> 0 then
		thevalue = ""
		TraceError "Error in call to GetFormGroupVal with parameters: dbkey=" & dbkey & " formgroup=" & formgroup & " inputVal=" & inputVal, err.Source, err.number, err.Description
	end if
	GetFormGroupVal = thevalue
End Function



'----------------------------------------------------------------------------'
'Name: GetFieldMapVal(dbkey, fieldmapgroup_name, inputval)
'Purpose: return value from field map name array used for global search
'Inputs: dbkey as String, fieldmapgroup_name as String, inputval as Enum
'Return Values: array value
'Comments:  Application(fieldmapgroup_name & dbkey) or Session("FIELD_MAP_GROUP" & fieldmapgroup_name & dbkey) if session(bypass_ini & dbkey & formgroup) = true
'Enum Values:
				'kStructureMap=0
				'kFormulaMap=1
				'kMolWeightMap=2
				'kOtherFieldMap=3
'----------------------------------------------------------------------------'
Function GetFieldMapVal(ByVal dbkey, ByVal fieldmapgroup_name, ByVal inputval)
	if Session("bypass_ini" & dbkey & request("formgroup")) = true then
		thearray = Application("FIELD_MAP_GROUP" & fieldmapgroup_name & dbkey)
	else
		thearray = Application(fieldmapgroup_name & dbkey)
	end if
	on error resume next
	thevalue = thearray(inputval)
	if err.number <> 0 then
		thevalue = ""
	end if
	GetFieldMapVal = thevalue
End Function


'----------------------------------------------------------------------------'
'Name: GetTableLinkVal(dbkey, table_name, inputval)
'Purpose: return table links array item for a table
'Inputs: dbkey as String, table_name as String, inputval as Enum
	'Enum values
		'kSourceFieldName = 0
		'kSourceFieldType = 1
		'kDestFieldName = 2
		'kDestFieldType = 3
'Return Values: variant depending on inputval
'Comments:  Application(fieldmapgroup_name & dbkey) or Session("FIELD_MAP_GROUP" & fieldmapgroup_name & dbkey) if session(bypass_ini & dbkey & formgroup) = true
'Example: Select Links entry: Compound_Salt.Reg_Internal_ID;1,Reg_Numbers.Reg_ID;1	
			'inputval:
					'0 returns: Compound_Salt.Reg_internal_id
					'1 returns: 1
					'2 returns Reg_Number.Reg_Id
					'3 returns: 1
'----------------------------------------------------------------------------'

Function GetTableLinkVal(ByVal dbkey, ByVal table_name, ByVal inputval)
		if Session("bypass_ini" & dbkey & formgroup) = true then
			the_table_array=Application(table_name & dbkey & formgroup)
		else
			the_table_array=Application(table_name & dbkey)
		end if
		the_select_links_temp = the_table_array(kSelectLinks)
		if instr(the_select_links_temp, "|")> 0 then
			the_select_links_temp_array = Split(the_select_links_temp, "|", -1)
			the_select_links = the_select_links_temp(0)
		else
			the_select_links=the_select_links_temp
		end if
		the_new_array = split(the_select_links, ",", -1)
		Select Case inputval
			Case "0" 'source name values
				temp = split(the_new_array(0), ";", -1)
				the_source_vals = split(temp(0), ".", -1)
				if UBound(the_source_vals)=2 then
					thevalue = the_source_vals(2)
				else
					thevalue = the_source_vals(1)
				end if
			Case "1" 'source type values
				the_source_vals = split(the_new_array(0), ";", -1)
				thevalue = the_source_vals(1)
			Case "2" 'destination name values
				 temp = split(the_new_array(1), ";", -1)
				 the_source_vals = split(temp(0), ".", -1)
				 if UBound(the_source_vals)=2 then
					thevalue = the_source_vals(2)
				else
					thevalue = the_source_vals(1)
				end if
			
			Case "3" 'destination type values
				 the_source_vals = split(the_new_array(1), ";", -1)
				thevalue = the_source_vals(1)
		End Select

	GetTableLinkVal = thevalue
End Function



'----------------------------------------------------------------------------'
'Name: GetTableGroupVal(dbkey, formgroup,inputval)
'Purpose: return table group value for a formgroup
'Parameter description: dbkey as String, formgroup as String, inputval as Enum
	'Enum Values:
		'kBaseTable=0
		'kMolTable=1
		'kTableSQLOrder=2
'Return Values: array item as string
'-------------------------------------------------------------------------------
Function GetTableGroupVal(ByVal dbkey, ByVal formgroup, ByVal inputval)
		if Session("bypass_ini" & dbkey & formgroup) = true then
			thearray = Application("FORM_GROUP" & dbkey & formgroup)
		else
			thearray = Application(formgroup & dbkey)			
		end if
		if IsArray(thearray) then
			the_table_group = thearray(kTableGroup)
		
			if Session("bypass_ini" & dbkey & formgroup) = true then
				thenewarray = Application(the_table_group)
			else
				thenewarray = Application(the_table_group & dbkey)
			end if
			on error resume next
			thevalue = thenewarray(inputval)
		else
			thevalue=""
		end if
		if err.number <> 0 then
			thevalue = ""
		end if
	
	GetTableGroupVal = thevalue
End Function



'----------------------------------------------------------------------------'
'Name: GetConnGroupVal(dbkey, formgroup,inputval)
'Purpose: return ado connection group name for a table
'Parameter description: dbkey as String, formgroup as String, inputval as  kADOConnection or 9
'Return Values: name of ado connection group as string
'-------------------------------------------------------------------------------
Function GetConnGroupVal(ByVal dbkey, ByVal table_name, ByVal inputval)
	if Session("bypass_ini" & dbkey & formgroup) = true then
		thearray = Application(table_name & dbkey & formgroup)
	else
		thearray = Application(table_name & dbkey)
	end if
	on error resume next
	thevalue = thearray(inputval)
	if err.number <> 0 then
		thevalue = ""
	end if
	GetConnGroupVal = thevalue
End Function




'----------------------------------------------------------------------------'
'Name: GetChemConnGroupVal(dbkey, chem_conn_group, inputval)
'Purpose: return value for chem_conn_group farray
'Inputs: dbkey as String, chem_conn_group as String, inputval as Enum
	'Enum Values:
			'kStrucEngine=0
			'kStrucFormName=1
			'kStrucFormPath=2
			'kStrucDBpath=3
			'kStrucTableName=4
			'kBaseFromPath=5
'Return Values: array value as string
'Comments:  Array stored in Application(chem_conn_group & dbkey) or:
			'Session(chem_conn_group) if session(bypass_ini & dbkey & formgroup) = true

'----------------------------------------------------------------------------'

Function GetChemConnGroupVal(ByVal dbkey, ByVal chem_conn_group, ByVal inputval)
	if Session("bypass_ini" & dbkey & request("formgroup"))= true then
		thearray = Application(chem_conn_group)
	else
		thearray = Application(chem_conn_group & dbkey)
	end if
	on error resume next
	thevalue = thearray(inputval)
	if err.number <> 0 then
		thevalue = ""
	end if
	GetChemConnGroupVal = thevalue
End Function



'----------------------------------------------------------------------------'
'Name: GetTableVal(dbkey, table_name, inputval)
'Purpose: return value for a table 
'Inputs: dbkey as String, table_name as String, inputval as Enum
	'Enum Values:
			'kTableRealName =0
			'kTableRelFields=1
			'kPrimaryKey=2
			'kSQLSyntax=3
			'kSelectKeyWord=4
			'kSelectJoin=5
			'kSelectLinks=6
			'kSelectAdditional=7
			'kInterTables=8
			'kADOConnection=9
			'kChemConnection=10
			'kStrucFieldID=11

'Return Values: array value as string
'Comments:  Array stored in Application(table_name & dbkey) or:
			'Session(table_name & dbkey & formgroup)) if session(bypass_ini & dbkey & formgroup) = true

'----------------------------------------------------------------------------'
Function GetTableVal(ByVal dbkey, ByVal table_name, ByVal inputval)
	if Session("bypass_ini" & dbkey & request("formgroup")) = true then
		thearray = Application(table_name & dbkey &  request("formgroup"))
	else
		thearray = Application(table_name & dbkey)
	end if
	
	on error resume next
	thevalue = thearray(inputval)
	if err.number <> 0 then
		thevalue = ""
	end if
	GetTableVal = thevalue
	
End Function

Function ConvertNull(varTemp)
	If IsNull(varTemp) Then
		ConvertNull = ""
	Else
		ConvertNull = Trim(varTemp)
	End If
End Function



'-------------------------------------------------------------------------------
' Name: QuotedString(varTemp)
' Purpose:  Embeds bracketing quotes around the string
' Parameters:   varTemp	as String
' Returns:	The processed value as String
'-------------------------------------------------------------------------------
Function QuotedString(varTemp)
	If isEmpty(varTemp) Then
		QuotedString = Chr(34) & Chr(34)
	Else
		QuotedString = Chr(34) & CStr(varTemp) & Chr(34)
	End If
End Function


'-------------------------------------------------------------------------------
' Name: buildSimpleSQL(table_name, table_link_field, table_link_value, field_type)
' Purpose:  build a simple sql statement -no joins
' Inputs:  dbkey as string, formgroup as string, table_name: name of table as string, table_link_field: name of linking field in table as string
	'table_link_value: value of linking field as int, field_type: field_type for getting appropriate delimter as int
' Returns:	sql statement as String
'-------------------------------------------------------------------------------

Function buildSimpleSQL(ByVal table_name, ByVal table_link_field, ByVal table_link_value, ByVal field_type)
	SQLSyntax = GetTableVal(dbkey, table_name,kSQLSyntax)
	delimiter = GetFieldDelimiter(field_type)
	Select Case UCase(SQLSyntax)
		case "ORACLE"
			if delimiter = "#" then
				Select case field_type
					Case "8" 
						sql = "SELECT " & table_name & ".*" & " FROM " & table_name & " WHERE Upper(" & table_link_field & ")=" & "TO_DATE('" & UCase(table_link_value) & "'," & "'MM,DD,YYYY')"' this is passed in as a parameter
					Case "9"
						sql = "SELECT " & table_name & ".*" & " FROM " & table_name & " WHERE Upper(" & table_link_field & ")=" & "TO_DATE('" & UCase(table_link_value) & "'," & "'DD,MM,YYYY')"'' this is passed in as a parameter
				end select
			else
				if delimiter = "'" then
					sql = "SELECT " & table_name & ".*" & " FROM " & table_name & " WHERE Upper(" & table_link_field & ")=" & delimiter & UCase(table_link_value) & delimiter' this is passed in as a parameter
				else
					sql = "SELECT " & table_name & ".*" & " FROM " & table_name & " WHERE " & table_link_field & "=" & table_link_value 
				end if 
			end if

		case "ACCESS"
			sql = "SELECT " & table_name & ".*" & " FROM " & table_name & " WHERE " & table_name & "."  & table_link_field & "=" & delimiter & table_link_value & delimiter' this is passed in as a parameter

		Case Else
			sql = "SELECT " & table_name & ".*" & " FROM " & table_name & " WHERE " & table_name & "."  & table_link_field & "=" & delimiter & table_link_value & delimiter' this is passed in as a parameter
	End Select
	buildSimpleSQL = sql
End Function


'-------------------------------------------------------------------------------
' Name: GetFieldDelimiter(inputstr)
' Purpose:  get field delimter based on field type
' Inputs:  inputval as enum
	'0 = TEXT
	'1 = INTEGER, NUMBER
	'2 = REAL
	'3 = TEXT force exact
	'6 = boolean
	'7 = MEMO
	'8 = Date /mmddyy
	'9 = Date /ddmmyy
' Returns:	delimiter
	'0 = TEXT -> "'"
	'1 = INTEGER, NUMBER  -> ""
	'2 = REAL ->  ""
	'3 = TEXT force exact  ->  "'"
	'6 = boolean  ->  ""
	'7 = MEMO  ->  "'"
	'8 = Date /mmddyy  ->  "#"
	'9 = Date /ddmmyy -> "#"
'-------------------------------------------------------------------------------
Function GetFieldDelimiter(inputstr)
	Select Case inputstr
		Case "0", "TEXT"				'string types
			strFieldDelimiter = "'"			
		Case "1", "INTEGER", "NUMBER"			'long integer types
			strFieldDelimiter = ""
		Case "2", "REAL"				'floating point integer types
			strFieldDelimiter = ""
		Case "3" 				'string types used in other areas to force exact search
			strFieldDelimiter = "'"	
		Case "6", "BOOLEAN"
			strFieldDelimiter = "" 		' boolean
		Case "7", "MEMO"
			strFieldDelimiter = "'" 		' memo
		Case "8", "DATE"				'date types (mm/dd/yy)
				strFieldDelimiter = "#"
		Case "9", "DATE"				'date types (dd/mm/yy)
				strFieldDelimiter = "#"
		Case Else
			strFieldDelimiter = ""
	End Select
	GetFieldDelimiter = strFieldDelimiter
End Function



'-------------------------------------------------------------------------------
' Purpose:
' Inputs:
' Returns:
'-------------------------------------------------------------------------------
Function GetParens(ByVal numParens)
	for i = 0 to numParens
		If parens = "" then
			parens = "(" 
		Else
			parens = parens + "(" 
		End If
	next
	GetParens = parens
End Function



'-------------------------------------------------------------------------------
' Name: SortPriorities(dbkey, formgorup, fullsubFormSelectAux
' Purpose: Sort tables for Select statement based on assigned priorities from ini file
' Inputs: dbKey as string, formgroup as string, fullsubFormSelectAux as comma delimite string
' Returns: sorted list as string
' Called by: BuildSelectStatement
'-------------------------------------------------------------------------------
Function SortPriorities(ByVal dbkey, ByVal formgroup, ByVal fullsubFormSelectAux)
	Dim i
	Dim j
	testarray = Split(fullsubFormSelectAux, ",", -1)
	priorities =GetTableGroupVal(dbkey, formgroup, kTableSQLOrder)
	tablepriorities = Split(priorities,",",-1)
	on error resume next
	For i = 0 to UBound(tablepriorities)
		for j = 0 to UBound(testarray)
			table_alias_pair = getTableAliasPair(testarray(j))
			if not table_alias_pair <> "" then
				If UCase(testarray(j)) = UCase(tablepriorities(i)) then
					If Not sortedstring <> "" then
						sortedstring = tablepriorities(i)
					Else
						sortedstring = sortedstring & "," & tablepriorities(i) 
					End If
				End If
			else
				table_alias_array = Split(table_alias_pair, ":", -1)
				
				realname =table_alias_array(0)
				aliasname = table_alias_array(1)
				If UCase(realname) = UCase(tablepriorities(i)) then
				
					If Not sortedstring <> "" then
						sortedstring = aliasname
					Else
						sortedstring = sortedstring & "," & aliasname
					End If
				End If
			end if
		next 'j
	Next 'i
	SortPriorities = sortedstring

End Function



'-------------------------------------------------------------------------------
' Name: RemoveDups(newtableAux)
' Purpose: Remove table name duplicates from string
' Inputs: newtableAux as comma delimited string
' Returns: dedupped list as  comma delimited string
' Called by: BuildSelectStatement
'-------------------------------------------------------------------------------

Function RemoveDups(ByVal newtableAux)
	firstarray = split(newtableAux, ",", -1)
	for i = 0 to UBound(firstarray)
		thetable = firstarray(i)
		secondarray = Split(finaltable, ",", -1)
		value = 0
		for j = 0 to UBound(secondarray)	
			thetest = secondarray(j)
			If UCase(thetable) = UCase(thetest) then
				value = value + 1
			End If
		next 'j
		If value = 0 then
			If finaltable <> "" then
				finaltable = finaltable & "," & thetable
			Else
				finaltable = thetable
			End If
		End If 	
	next 'i
	RemoveDups = finaltable
End Function


'-------------------------------------------------------------------------------
' Name: AddDependencies(dbkey, formgroup, subFormSelectBase, subFormSelectAux)
' Purpose: add table name dependencies to string
' Inputs: dbkey as string, formgroup as string, base table name as string, subtable names as commad delimited string
' Returns: new list with added table dependencies as  comma delimited string
' Comments: table dependendices are from INTERTABLES from table definition in ini file
'-------------------------------------------------------------------------------

Function AddDependencies(ByVal dbkey, ByVal formgroup, ByVal subFormSelectBase, ByVal subFormSelectAux)

	'check that base table dependencies
	tableAux =subFormSelectAux
	If tableAux <> ""  then
		on error resume next 'pass by error where there is only one entry without a comma
		subformarray = Split(tableAux, "," , -1)
		If err.number = 92 then
			on error goto 0
		End If
		for j = 0 to UBound(subformarray)
			table_alias_pair = getTableAliasPair(subformarray(j))
			
			if not table_alias_pair <> "" then
			
			on error resume next
			If err.number = 92 then
				on error goto 0
			End If
			'needs some type of recursive function that will look at the tables
			'that are pulled by Intertables to see if they ahave intermediate tables.
			InterTables=GetTableVal(dbkey, subformarray(j), kInterTables)
			subformdepend = Split(InterTables, ",", -1)
				for k = 0 to UBound(subformdepend)
					If subformdepend(k) = "NULL" then exit for
					for l = 0 to UBound(subformarray)
						If Not UCase(subformarray(l)) =   UCase(subformdepend(k))then
								If Not UCase(subformdepend(k)) = UCase(subFormSelectBase) then
									If depends <> "" then
										depends = depends & "," & subformdepend(k)
									Else
										depends = subformdepend(k)
									End If
								End If
						End If
					next 'l
				next 'k
			else
				
				table_alias_array = Split(table_alias_pair, ":", -1)
				realname =table_alias_array(0)
				aliasname = table_alias_array(1)
		
		
				on error resume next
				If err.number = 92 then
					on error goto 0
				End If
				'needs some type of recursive function that will look at the tables
				'that are pulled by Intertables to see if they ahave intermediate tables.
				InterTables=GetTableVal(dbkey, realname, kInterTables)
				
				subformdepend = Split(InterTables, ",", -1)
				
				for k = 0 to UBound(subformdepend)
					If subformdepend(k) = "NULL" then exit for
					
					for l = 0 to UBound(subformarray)
						If Not UCase(realname) =   UCase(subformdepend(k))then
					
								If Not UCase(subformdepend(k)) = UCase(subFormSelectBase) then
									If depends <> "" then
										depends = depends & "," & subformdepend(k)
									Else
										depends = subformdepend(k)
									End If
								End If
						End If
					next 'l
				next 'k
			end if
		next'j
	End If

	If depends <> "" then
		newtableAux = tableAux & "," & depends
	Else
		newtableAux = tableAux
	End If
	AddDependencies=RemoveDups(newtableAux)

End Function

'-------------------------------------------------------------------------------
' Name: ExpandAndAddBracketsInnJoin(tempjoin_temp, TableRealName)
' Purpose: convert table name to real table name add brackets to join statement around fieldname and tablename
' Inputs: join statement as string, real table name as string
' Returns: new join statement as string 
'-------------------------------------------------------------------------------


Function ExpandAndAddBracketsInnJoin(tempjoin_temp, TableRealName)
	join_array = split(tempjoin_temp, "|", -1)
		for i = 0 to UBound(join_array)
			TempJoin = (i)
			temp_part = split(TempJoin, "=", -1)
			temp_left = split(temp_part(0), ".", -1)
			if UBound(temp_left) = 2 then
				new_left_part = "[" & Trim(temp_left(0)) & "].[" & Trim(temp_left(1)) & "]" & "." & "[" & Trim(temp_left(2)) & "]"
			else
				new_left_part = "[" & Trim(temp_left(0)) & "]" & "." & "[" & Trim(temp_left(1)) & "]"
			end if
			temp_right = split(temp_part(1), ".", -1)
			if UBound(temp_right) = 2 then
				new_right_part = "[" & Trim(temp_right(0)) & "].[" & Trim(temp_right(1)) & "]" & "." & "[" & Trim(temp_right(2)) & "]"
			else
				new_right_part = "[" & Trim(temp_right(0)) & "]" & "." & "[" & Trim(temp_right(1)) & "]"
			end if
			SelectJoin_Temp = " INNER JOIN "&  "[" & Trim(TableRealName) & "]" & " ON " & new_left_part & "=" & new_right_part
			If SelectJoin <> "" then
				SelectJoin=  SelectJoin & " AND " & SelectJoin_Temp
			else
				SelectJoin=  SelectJoin_Temp
			end if
		next
	ExpandAndAddBracketsInnJoin=SelectJoin
End Function


'-------------------------------------------------------------------------------
' Name: ExpandAndAddBrackets(tempjoin_temp)
' Purpose: add brackets to join statement around fieldname and tablename
' Inputs: join statement as string
' Returns: new join statement as string 
'-------------------------------------------------------------------------------

Function ExpandAndAddBrackets(tempjoin_temp)
	
	join_array = split(tempjoin_temp, "|", -1)
	for i = 0 to UBound(join_array)
		TempJoin = join_array(i)
		temp_part = split(TempJoin, "=", -1)
		temp_left = split(temp_part(0), ".", -1)
		if UBound(temp_left) = 2 then
			new_left_part = "[" & Trim(temp_left(0)) & "].[" & Trim(temp_left(1)) & "]" & "." & "[" & Trim(temp_left(2)) & "]"
		else
			new_left_part = "[" & Trim(temp_left(0)) & "]" & "." & "[" & Trim(temp_left(1)) & "]"
		end if
		temp_right = split(temp_part(1), ".", -1)
		if UBound(temp_right) = 2 then
			new_right_part = "[" & Trim(temp_right(0)) & "].[" & Trim(temp_right(1)) & "]" & "." & "[" & Trim(temp_right(2)) & "]"
		else
			new_right_part = "[" & Trim(temp_right(0)) & "]" & "." & "[" & Trim(temp_right(1)) & "]"
		end if
		SelectJoin_Temp = new_left_part & "=" & new_right_part
		If SelectJoin <> "" then
			SelectJoin=  SelectJoin & " AND " & SelectJoin_Temp
		else
			SelectJoin=  SelectJoin_Temp
		end if
	next
	ExpandAndAddBrackets=SelectJoin
End Function

'-------------------------------------------------------------------------------
' Name: AddBrackets(tempjoin_temp)
' Purpose: add brackets to join statement around fieldname and tablename
' Inputs: join statement as string
' Returns: new join statement as string 
'-------------------------------------------------------------------------------
Function AddBrackets(TempJoin)
	on error resume next
	if not tempjoin <> "" then exit function
	temp_part = split(TempJoin, "=", -1)
	temp_left = split(temp_part(0), ".", -1)
	if UBound(temp_left) = 2 then
		new_left_part = "[" & Trim(temp_left(0)) & "].[" & Trim(temp_left(1)) & "]" & "." & "[" & Trim(temp_left(2)) & "]"
	else
		new_left_part = "[" & Trim(temp_left(0)) & "]" & "." & "[" & Trim(temp_left(1)) & "]"
	end if
	temp_right = split(temp_part(1), ".", -1)
	if UBound(temp_right) = 2 then
		new_right_part = "[" & Trim(temp_right(0)) & "].[" & Trim(temp_right(1)) & "]" & "." & "[" & Trim(temp_right(2)) & "]"
	else
		new_right_part = "[" & Trim(temp_right(0)) & "]" & "." & "[" & Trim(temp_right(1)) & "]"
	end if
	SelectJoin = new_left_part & "=" & new_right_part
	
	AddBrackets = SelectJoin
End Function



'-------------------------------------------------------------------------------
' Name: AddBrackets(strGetFields)
' Purpose: add brackets to select (field list) clause of statement around fieldname and tablename
' Inputs: fields list as string
' Returns: new select (field list) clause as string
'-------------------------------------------------------------------------------
Function AddStrGetBrackets(strGetFields)

	if InStr(strGetFields, "[")> 0 then
		AddStrGetBrackets=strGetFields
	else
	temp = split(strGetFields, ",", -1)
	for i = 0 to UBound(temp)
		if inStr(temp(i), ".")> 0 then
			temp2 = split(temp(i), ".", -1)
			if UBound(temp2) = 2 then
				if temp2(0) = "*" then
					table = temp2(0)
				else
					table = "[" & Trim(temp2(0))  & "].[" & Trim(temp2(1)) & "]"
				end if
				if temp2(1) = "*" then
					field = temp2(2) 
				else
					if inStr(Trim(UCase(temp2(1))), " AS ") > 0 then
								temp_temp2 = replace(temp2(1), " AS ", " as ")
								temp_temp2 = replace(temp_temp2, " As ", " as ")
								temp_temp2 = replace(temp_temp2, " aS ", " as ")
								temp_alias = split(Trim(temp_temp2), " as ", -1)
								field = "[" & temp_alias(0) & "]" & " as " & temp_alias(1)
					else
							if inStr(Trim(temp2(1)), " ") > 0  then
								temp_alias = split(Trim(temp2(1)), " ", -1)
								field = "[" & temp_alias(0) & "]" & " " & temp_alias(1)
							else
								field = "[" & Trim(temp2(2)) & "]"
							end if
					end if
				
					
					
						
				end if 
				if newstrGetFields <> "" then
					newstrGetFields = newstrGetFields & "," & table & "." & field
				else
					newstrGetFields = table & "." & field
				end if
			
			else
				if temp2(0) = "*" then
					table = temp2(0)
				else
					table = "[" & Trim(temp2(0)) & "]"
				end if
				if temp2(1) = "*" then
					field = temp2(1) 
				else
					if inStr(Trim(UCase(temp2(1))), " AS ") > 0 then
								temp_temp2 = replace(temp2(1), " AS ", " as ")
								temp_temp2 = replace(temp_temp2, " As ", " as ")
								temp_temp2 = replace(temp_temp2, " aS ", " as ")
								temp_alias = split(Trim(temp_temp2), " as ", -1)
								field = "[" & temp_alias(0) & "]" & " as " & temp_alias(1)
					else
							if inStr(Trim(temp2(1)), " ") > 0  then
								temp_alias = split(Trim(temp2(1)), " ", -1)
								field = "[" & temp_alias(0) & "]" & " " & temp_alias(1)
							else
								field = "[" & Trim(temp2(1)) & "]"
							end if
					end if
					
				end if 
				if newstrGetFields <> "" then
					newstrGetFields = newstrGetFields & "," & table & "." & field
				else
					newstrGetFields = table & "." & field
				end if
			end if
		Else
			if newstrGetFields <> "" then
				newstrGetFields = newstrGetFields & "," & "[" & Trim(temp(i)) & "]"
			else
				newstrGetFields = "[" & Trim(temp(i)) & "]"
			end if
		End if
	next 'i
	AddStrGetBrackets = newstrGetFields
end if
End Function

'-------------------------------------------------------------------------------
' Name: getTableAliasPair(alias_name)
' Purpose: return table alias for a table if one exists in  Session("TableAliasTracker" & dbkey & formgroup)
' Inputs: alias name as string
' Returns: table and table alias as string
' Comments: Session("TableAliasTracker" & dbkey & formgroup) is created when where clause if created in GetRelStrWhere
'-------------------------------------------------------------------------------

Function getTableAliasPair(alias_name)
	test_name = ":" & alias_name
	if inStr(UCase(Session("TableAliasTracker" & dbkey & formgroup)),UCase(test_name))>0 then
			dim thereturn
			temp_array = Split(Session("TableAliasTracker" & dbkey & formgroup), ",", -1)
				for i = 0 to UBound(temp_array)
					if inStr(UCase(temp_array(i)), UCase(test_name))>0 then
						thereturn = temp_array(i)
						exit for
					end if
				Next
	else
		thereturn = ""
	end if
	getTableAliasPair = thereturn	
End Function

'-------------------------------------------------------------------------------
' Name: prepareSortOrder(dbkey, formgroup, sqlSyntax)
' Purpose:  Add Sort by and Group by to where clause and populate variables used for building full sql statement
' Inputs: dbkey as string, formgroup as string, SqlSyntax as string
' Returns: where clause with order by and group by added
' Comments: updates Session("strWhereSubforms & dbkey & formgroup)
'-------------------------------------------------------------------------------
Function prepareSortOrder(dbkey,formgoup,sqlSyntax)
	group_by = request("group_by")
	if group_by <> "" then
		AddSubFormNames dbkey,formgoup, group_by
		sortOrderAppendString = "GROUP BY [" & group_by & "]"
	end if
	if  Session("order_by" & dbkey & formgroup) <> "" then
		order_by = Session("order_by" & dbkey & formgroup)
	else
		order_by = request("order_by")
	end if
	
	if Session("sort_direction" & dbkey & formgroup) <> "" then
		sort_direction = Session("sort_direction" & dbkey & formgroup)
	else
		sort_direction = request("sort_direction")
	end if
	if order_by <> "" then
		'remove possible DESC and ASC in clause before adding to subforms
		temp_order_by = order_by
		'DGB added space before ASC and DESC to avoid inadverted replacements of fields names
		temp_order_by = replace(temp_order_by, " DESC", "")
		temp_order_by = replace(temp_order_by, " ASC", "")
		temp_order_by = replace(temp_order_by, " ", "")
		AddSubFormNames dbkey,formgoup, temp_order_by
		'use full order_by to append to clasue
		if sort_direction <> "" then
			if sortOrderAppendString <> "" then
				sortOrderAppendString = sortOrderAppendString & " ORDER BY [" & temp_order_by & " " & sort_direction &  "]"
			else
				sortOrderAppendString =" ORDER BY " & temp_order_by & " " & sort_direction
			end if
		else
			if sortOrderAppendString <> "" then
				sortOrderAppendString = sortOrderAppendString & " ORDER BY [" & order_by & "]"
			else
				sortOrderAppendString =" ORDER BY " & order_by
			end if
			
		end if
	end if
	'sort_direction = request("sort_direction")
	'if sort_direction <> "" and sortOrderAppendString <> "" then
		'sortOrderAppendString=sortOrderAppendString & " " &  sort_direction 
	'end if
	prepareSortOrder=sortOrderAppendString
End function

'-------------------------------------------------------------------------------
' Name: getGroupByStrGetFields(dbkey, formgroup, temp_strGetFields)
' Purpose:  Updates select clause when group by in post
' Inputs: dbkey as string, formgroup as string,field list as comma delimited string
' Returns: select clause with group by modifications 
' Comments: group_by and group_by_type must be in post
'-------------------------------------------------------------------------------
Function getGroupByStrGetFields(dbkey, formgroup,temp_strGetFields)
	
	group_by = request("group_by")
	group_by_type = request("group_by_type")
	if group_by <> "" then
		if instr(temp_strGetFields, ".")> 0 then
			temp_array = split(temp_strGetFields, ".", -1)
			if UBound(temp_array) = 2 then
				fieldname = temp_array(2)
			else
				fieldname = temp_array(1)
			end if
		else
			fieldname = temp_strGetFields
		end if
		if group_by_type <> "" then
			if UCase(group_by_type) = "MIN" then
				temp_strGetFields = "MIN" & "(" & temp_strGetFields & ") As " & fieldname
			else
				temp_strGetFields = "MAX" & "(" & temp_strGetFields & ") As " & fieldname
			end if
		else 'default is max
			temp_strGetFields = "MAX" & "(" & temp_strGetFields & ") As " & fieldname
		end if
	end if
	getGroupByStrGetFields=temp_strGetFields
	
End Function

'-------------------------------------------------------------------------------
' Name: getSortOrderRelFields(dbkey, formgroup, strGetFields)
' Purpose:  add order by fields to select clause gather from  post or from Session("order_by" & dbkey & formgroup)
' Inputs: dbkey as string, formgroup as string,field list as comma delimited string
' Returns: select clause with order by modifications 
' Comments: order_by must be in post or store in Session("order_by" & dbkey & formgroup) from previous search
'-------------------------------------------------------------------------------


Function getSortOrderRelFields(dbkey, formgroup, strGetFields)
	group_by = request("group_by")
	order_by = request("order_by")
	if Not order_by <> "" then
		order_by = Session("order_by" & dbkey & formgroup)
	end if
	order_by = replace(order_by, " DESC", "")
	order_by = replace(order_by, " ASC", "")
	order_by = replace(order_by, " ", "")
	relfieldsreturn = ""
	
	if group_by <> "" and order_by <> "" then
		if not UCase(group_by) = UCase(order_by) then
			if not inStr(strGetFields, group_by)> 0 then
				relfieldsreturn = group_by 
				if not inStr(strGetFields, order_by)> 0 AND Not inStr(relfieldsreturn, order_by)> 0 then
					relfieldsreturn= relfieldsreturn & "," & order_by
				end if
			else 
				if not inStr(strGetFields, order_by)> 0 then
					relfieldsreturn= order_by
				end if
			end if
		else
			if not inStr(strGetFields, order_by)> 0 then
				relfieldsreturn= order_by
			end if
		end if
	end if
	if group_by <> "" and Not order_by <> "" then
		relfieldsreturn = group_by
	end if

	if order_by <> "" and Not group_by <> "" then
		relfieldsreturn = order_by
	end if
	getSortOrderRelFields = relfieldsreturn
End Function


'-------------------------------------------------------------------------------
' Name: removebaseTable(dbkey, formgroup, subforms, basetable)
' Purpose:  remove basetable from subforms list
' Inputs: dbkey as string, formgroup as string,table list as comma delimited string, base table as string
' Returns: new subform string without the base table in the list
'-------------------------------------------------------------------------------


Function removebaseTable(dbkey, formgroup, subforms, basetable)
	subformsarray = split(subforms, ",", -1)
	for i = 0 to UBound(subformsarray)
		if Not UCase(subformsarray(i)) = UCase(basetable) then
			if new_subforms <> "" then
				new_subforms =new_subforms & "," & subformsarray(i)
			else
				new_subforms = subformsarray(i)
			end if
		end if
	next
	removebaseTable=new_subforms
End Function

'-------------------------------------------------------------------------------
' Name: ExpandTempJoin(TempJoin)
' Purpose:  parsse selectjoins that have a "|" in the string indicating a double-join
' Inputs: join statement as string
' Returns: new concatentated joing statement
'-------------------------------------------------------------------------------
Function ExpandTempJoin(TempJoin)
	JoinArray = Split(TempJoin, "|", -1)
	for i= 0 to UBound(JoinArray)
		if newJoin <> "" then
			newJoin = newJoin & " AND " & JoinArray(i)
		else
			newJoin = JoinArray(i)
		end if
	next
	ExpandTempJoin = theResult
End Function

'-------------------------------------------------------------------------------
' Name: BuildSelectStatement(dbkey, formgroup, subFormSelectBase, subFormSelectAux, strGetFields, maxhits)
' Purpose:  build full select statment (without where clause) including all joins
' Inputs: dbkey as string, formgroup as string, base table as string, sub table as comma delimited list,
	'field names as comma delimited list, maximum number of hits as int
' Returns: select statement with joins (sans where clause)
'-------------------------------------------------------------------------------
Function BuildSelectStatement(ByVal dbkey, ByVal formgroup, ByVal subFormSelectBase, ByVal subFormSelectAux, ByVal strGetFields, ByVal maxhits)
	'get information for subFormSelectBase table
	If subFormSelectAux <> "" then
		fullsubFormSelectAux = AddDependencies(dbkey, formgroup, subFormSelectBase, subFormSelectAux)
	
	End If
	if UCase(subFormSelectBase) = Ucase(subFormSelectAux) then
		subFormSelectAux = ""
	End if
	
	temp_strGetFields=GetTableRealName(dbkey, formgroup, strGetFields, "full_name_string")
	if getSortOrderRelFields(dbkey, formgroup, temp_strGetFields) <> "" then
		temp_strGetFields_temp= getSortOrderRelFields(dbkey, formgroup,temp_strGetFields)
		tempStrGetFields_temp2=getGroupByStrGetFields(dbkey, formgroup,temp_strGetFields)
		if temp_strGetFields_temp<> "" then
			if tempStrGetFields_temp2 <> "" then
				temp_strGetFields = tempStrGetFields_temp2 & "," & temp_strGetFields_temp
			else
				temp_strGetFields=temp_strGetFields_temp
			end if
		else
			if tempStrGetFields_temp2 <> "" then
				temp_strGetFields = tempStrGetFields_temp2
			end if
		end if
		'DGB trying to fix aliasing problem
		'The above call to GetTableRealName is causing a disagreement between
		'field names in select list and aliased table names. 
		'Moved this into the if stament so that
		'strGetFields are replaced with "Real Names" only if sorting is required
		strGetFields = AddStrGetBrackets(temp_strGetFields)
	end if
	
	'DGB for biosar we don't want to do this
	if NOT (Session("bypass_ini" & dbkey & formgroup) = true) then 
		strGetFields = AddStrGetBrackets(temp_strGetFields)
	end if
	
	SQLSyntax = GetTableVal(dbkey, subFormSelectBase, kSQLSyntax)
	basetablearray = Application(subFormSelectBase & dbkey)
	if UCase(request("override_distinct")) = "TRUE" then
		KeyWord = "" 
	else
		KeyWord = GetTableVal(dbkey, subFormSelectBase, kSelectKeyWord)
	end if
	BaseSelectSpecial = GetTableVal(dbkey, subFormSelectBase,kSelectAdditional)
	revertSQLSyntax=SQLSyntax
	If subFormSelectAux <> "" then 
			OrigSQLSyntax = SQLSyntax
	' the access driver has issus for with the syntax generated for joing more then 2 tables so at that point switch to oracle join syntax
			SQLSyntax="ORACLE"
	end if
	basetable = getbasetable(dbkey, formgroup, "basetable")
	'get inner join and select statment for subFormSelectBase and subFormSelectAux tables
	Select Case SQLSyntax
		Case "ACCESS"
			'LJB 9/4/2002 - removed join code that was not being used. It was obsolete since the 2000b release, whenever a 
			'join is involved(subFormSelectAux <> "") , the syntax used is ORACLE 
			subFormSelectBase=GetTableRealName(dbkey, formgroup, subFormSelectBase, "table_name")
			FullInnerJoin =  " FROM " & "[" & Trim(subFormSelectBase) & "]" & " WHERE "
			If selectappEnd <> "" then
				selectappEnd = selectappEnd & " AND " 
			End If
		
		Case  "SQLSERVER"
			'LJB 9/4/2002 - removed join code that was not being used. It was obsolete since the 2000b release, whenever a 
			'join is involved(subFormSelectAux <> "") , the syntax used is ORACLE 
			subFormSelectBase=GetTableRealName(dbkey, formgroup, subFormSelectBase, "table_name")
			FullInnerJoin =  " FROM "   & "[" & Trim(subFormSelectBase)  & "]" & " WHERE "
			If selectappEnd <> "" then
				selectappEnd = selectappEnd & " AND " 
			End If
			
		Case "ORACLE"
			'the Oracle syntax is always used whenever their is a join
			If subFormSelectAux <> "" then
				'sort tables so priorities are correct
				
				prioritizedSubForms = SortPriorities(dbkey, formgroup, fullsubFormSelectAux)
				on error resume next
				
				prioritizedSubForms= removebaseTable(dbkey, formgroup, prioritizedSubForms,subFormSelectBase)
				
				subtables = split(prioritizedSubForms, ",", -1)
			
				on error goto 0
				'build inner join statement
				for i = 0 to UBound(subtables)
				
					alias_table_pair = getTableAliasPair(subtables(i))
					
					'syntax for join
					if not alias_table_pair <> ""	then
						'join statement for table
						'syntax for join 
						
							TempJoin=GetTableVal(dbkey, subtables(i), kSelectJoin)
							if instr(TempJoin, "|")> 0 then
								SelectJoin = ExpandAndAddBrackets(TempJoin)
							else
								SelectJoin = AddBrackets(TempJoin)		
							end if
						
						'LJB 1/8/2004 SUPPORT Table Aliases make sure the joins are using the alias name if the alias and real table name are different
							' AND the defined join uses the Alias name. This is done since, if the join uses the real name the table alias definition is just
							'being used to define a different join. This makes the code backwards compatible with the non-alias support 
							realName = GetTableVal(dbkey, subtables(i), kTableRealName)
							if Not (Trim(UCase(realName)) = Trim(UCase(subtables(i)))) then
								'only alias the table if the join has the alias in it
								
								if instr(SelectJoin, subtables(i)& ".")>0 or instr(SelectJoin, subtables(i)& "].")>0 then
									'make sure the join uses the ALIAS name not the real name
									SelectJoin = replace(SelectJoin, realName & ".", subtables(i)& ".")
									'add the real name -alias name to the tables list
									temp_prioritized = split(prioritizedSubForms, ",", -1)
									for m = 0 to UBound(temp_prioritized)
									if temp_prioritized(m) = subtables(i) then
										if new_string <> "" then
											new_string = new_string & "," & realName & " " & subtables(i)
										else
											new_string = realName & " " & subtables(i)
										end if
									else
										if new_string <> "" then
											new_string = new_string & "," & temp_prioritized(m)
										else
											new_string = temp_prioritized(m)
										end if
									end if
									next
									prioritizedSubForms = new_string
								end if
							end if

						'tablejoin = SelectJoin & " (*) "
						
						tablejoin = SelectJoin
						if Instr(tablejoin, " AND ")> 0 then
							If innerJoins = "" then
								innerJoins = tablejoin 
							Else
								innerJoins = innerJoins & " AND " &  tablejoin 
							End If
						else
							If innerJoins = "" then
								innerJoins = " (" & tablejoin & ") "
							Else
								innerJoins = innerJoins & " AND " & "(" & tablejoin & ") "
							End If
						end if
						
						'appEnd additional sql 
						selectadditional = GetTableVal(dbkey, subtables(i), kSelectAdditional)
						if Not inStr(selectadditional, ":")>0 then
							selectappEnd = AppEndSelectSpecial(selectappEnd, selectadditional)					
						else
							selectappEnd=  ""
						end if
					else
					
						alias_table_pair = getTableAliasPair(subtables(i))
						table_alias_array = Split(alias_table_pair, ":", -1)
						realName = table_alias_array(0)
						aliasName = table_alias_array(1)
						
						temp_prioritized = split(prioritizedSubForms, ",", -1)
						'JHS bug fix 1/25/2007
						'fairly certain that the old way causes very bad alias clauses
						'it adds many extra clauses
						'each time there is an alias table it loops through all of the alias tables
						'if you have *Table1* and *Table2* which are alias for *Table* you get
						' Table Table1, Table2, Table Table1, Table Table2
						'The Table2 without alias name is the main problem alhtough the duplicate Table1 is not good either
						'What this should do is the following:
						'loop through the temp_prioritized tables.....
						'if it does not match, then write it as is (do not append)
						'if it does match then replace with the alias term
						new_string = ""
						for m = 0 to UBound(temp_prioritized)
							if trim(temp_prioritized(m)) <> subtables(i) then
								new_string = new_string & temp_prioritized(m)
							else
								new_string = new_string & realName & " " & aliasName
							end if
							
							'as long as you are not at Ubound add the comma
							if m < UBound(temp_prioritized) then
								new_string = new_string & ", "
							end if
						next
						
						'this is the old code
						'for m = 0 to UBound(temp_prioritized)
						'	if temp_prioritized(m) = subtables(i) then
						'		if new_string <> "" then
						'			new_string = new_string & "," & realName & " " & aliasName
						'		else
						'			new_string = realName & " " & aliasName
						'		end if
						'	else
						'		if new_string <> "" then
						'			new_string = new_string & "," & temp_prioritized(m)
						'		else
						'			new_string = temp_prioritized(m)
						'		end if
						'	end if
						'next
						'end jhs
						prioritizedSubForms = new_string
							TempJoin = GetTableVal(dbkey, realName, kSelectJoin)
								
								AliasTempJoin = Replace(TempJoin, realName, aliasName)
								if instr(AliasTempJoin, "|")> 0 then
									SelectJoin = ExpandAndAddBrackets(AliasTempJoin)
								else
									SelectJoin = AddBrackets(AliasTempJoin)		
								end if
								
								tablejoin = SelectJoin
							if UCase(realName) = UCase(basetable) then 'takes care of issues where the basetable and the aliased are same
								temp_join=split(tablejoin, "=", -1)
								tablejoin = temp_join(0) & "=" & replace(temp_join(1),aliasName,realName)
							end if
							
							if Instr(tablejoin, " AND ")> 0 then
								If innerJoins = "" then
									innerJoins = tablejoin 
								Else
									innerJoins = innerJoins & " AND " &  tablejoin 
								End If
							else
								If innerJoins = "" then
									innerJoins = " (" & tablejoin & ") "
								Else
									innerJoins = innerJoins & " AND " & "(" & tablejoin & ") "
								End If
							end if
						
						'appEnd additional sql 
						selectadditional = GetTableVal(dbkey, subtables(i), kSelectAdditional)
						if Not inStr(selectadditional, ":")>0 then
							selectappEnd = AppEndSelectSpecial(selectappEnd, selectadditional)					
						else
							selectappEnd=  ""
						end if
					
					end if
				next
				
				subFormSelectBase=GetTableRealName(dbkey, formgroup, subFormSelectBase, "table_name")
				prioritizedSubForms=GetTableRealName(dbkey, formgroup, prioritizedSubForms, "table_name_string")
				
				prioritizedSubForms = RemoveDups(prioritizedSubForms)
				fulltables = Trim(subFormSelectBase) &  "," & prioritizedSubForms 
				'fulltables = Trim(subFormSelectBase) &  "," & prioritizedSubForms 
				fulltables = RemoveDups(fulltables)
				if innerJoins <> "" then
					FullInnerJoin =  " FROM "   &  fulltables & " WHERE " & innerJoins & " AND "
				else
					FullInnerJoin =  " FROM "   &  fulltables & " WHERE " 
				end if
			Else
				subFormSelectBase=GetTableRealName(dbkey, formgroup, subFormSelectBase, "table_name")
				FullInnerJoin =  " FROM "   & Trim(subFormSelectBase)  & " WHERE "
			End If
			If selectappEnd <> "" then
				selectappEnd = selectappEnd & " AND " 
			End If
			
			If not keyword = "NULL" then
				FullSelect = "SELECT " & keyword & " " &  strGetFields & FullInnerJoin & selectappEnd
			Else
				FullSelect = "SELECT "  & " " &  strGetFields & FullInnerJoin & selectappEnd
			End If
			
	End Select

	SQLSyntax = revertSQLSyntax
	if SQLSyntax = "ORACLE" then
		FullSelect = ModifySQL(FullSelect)
		If CBool(Application("ALLOW_SORT_ALL_FIELDS"))= true and Session("order_by" & dbkey & formgroup) <> "" then
			basetable = GetBaseTable(dbkey, formgroup, "basetable")
			test_str = Session("order_by" & dbkey & formgroup)
			
			test_array1 = split(test_str, ".", -1)
			if Ubound(test_array1) = 2 then
				table_name = test_array1(0) & "." &  test_array1(1)
			else
				table_name = test_array1(0)
			end if
			
			if UCase(Trim(basetable))= UCase(Trim(table_name)) then
				bRemoveDistinct = false
			else
				bRemoveDistinct = True
			end if
			if bRemoveDistinct = true then
				FullSelect= removeDistinct(dbkey, formgroup, FullSelect)
			end if
		end if
		BaseSelectSpecial= ModifySQL(BaseSelectSpecial)
		FullInnerJoin=ModifySQL(FullInnerJoin)
	else ' DGB now we take care of maxhits and keyword
		if Session("limited_search") then maxhits = Session("displayLimit")
		Session("limited_search") = false
		If maxhits <> "" then
			maxhits = " TOP " & maxhits
		End If

		If not keyword = "NULL" then
			FullSelect = "SELECT " & keyword & " " & maxhits  & " " &  strGetFields & FullInnerJoin & selectappEnd
		Else
			FullSelect = "SELECT " & maxhits  & " " &   strGetFields & FullInnerJoin & selectappEnd
		End If
	end if
	
	'append additional conditions from special entry for base table
	If Not BaseSelectSpecial  = "NULL" then
		if Not inStr(BaseSelectSpecial, ":")> 0 then
			'JHS fix.
			'BuildSelectStatement = FullSelect & " AND " & BaseSelectSpecial 
			BuildSelectStatement = FullSelect & BaseSelectSpecial & " AND " 
		else
			BuildSelectStatement =  FullSelect
		end if
			
	Else
		BuildSelectStatement =  FullSelect
	End If
	Session("SearchData" & "Rel_Full_Join" & dbkey & formgroup) = FullInnerJoin
End Function



'-------------------------------------------------------------------------------
' Name: AppEndSelectSpecial(selectappEnd,selectspecial)
' Purpose:  append and additional selection rules to select statement
' Inputs: current_select statement as string, select statement to be appended
' Returns: new select statement with addtional select criteria appended
'-------------------------------------------------------------------------------
Function AppEndSelectSpecial(ByVal selectappEnd, ByVal selectspecial)
	If NOT selectspecial = "NULL" then
		If not selectappEnd <> "" then
			selectappEnd = selectspecial
		Else
			selectappEnd = selectappEnd & " AND " & selectspecial
		End If
	End If
	AppEndSelectSpecial = selectappEnd
End function


'-------------------------------------------------------------------------------
' Name: GetDisplayRecordset(dbkey, formgroup, sql_get_fiedls, sql_base_table, sql_info, uniqueid, sql_options
' Purpose:  builds sql statement and returns recordset for list view display
' Inputs: dbkey as string, formgroup as string, field list as comma delimited list, base table as string,  
	'options as enum, addition tables to use in sql as comma  delimited string, base_id for recordset as Int, options as enum
' Returns:	a recordset and a session object containing a reference to the connection so it can be killed outside this function
' See GetDisplaySQL for additional information on parameters
'-------------------------------------------------------------------------------
Function GetDisplayRecordset(ByVal dbkey, ByVal formgroup, ByVal sql_get_fields, ByVal sql_base_table, ByVal sql_info, ByVal uniqueid, ByVal sql_options)
	sql = GetDisplaySQL(dbkey, formgroup, sql_get_fields, sql_base_table, sql_info, uniqueid, sql_options)
	on error resume next
	if isObject(Session("DataConn" & dbkey & formgroup)) then
		if Session("DataConn" & dbkey & formgroup).State = 0 then
			Set Session("DataConn" & dbkey & formgroup) = Nothing
			Session("DataConn" & dbkey & formgroup) = ""
			Set Session("DataConn" & dbkey & formgroup) = GetConnection(dbkey, formgroup, sql_base_table)
		end if
	else
		Set Session("DataConn" & dbkey & formgroup) = GetConnection(dbkey, formgroup, sql_base_table)
	end if
	'clear errors in connection before generating recordset
	Session("DataConn" & dbkey & formgroup).Errors.Clear
	'generate 
	if sql <> "" then
		Set rstlookup = Session("DataConn" & dbkey & formgroup).Execute(sql)
		'if errors occur log them to log file at inetpub/cfwlog.txt
		If Session("DataConn" & dbkey & formgroup).Errors.Count > 0 then
			for j = 0 to Session("DataConn" & dbkey & formgroup).Errors.Count
				'LogAction("GetDisplayRecordset: " & Session("DataConn" & dbkey & formgroup).Errors.Item(j).description)
			next
		end if
		if err.number > 0 then
			Session("DataConn" & dbkey & formgroup).Close
			Set Session("DataConn" & dbkey & formgroup) = Nothing
			Session("DataConn" & dbkey & formgroup) = ""
			rstlookup = Nothing	
			rstlookup = ""
		End If
		'create a reference to the conneciton and the recordset so you can close and kill after each row in list view.
	else
		Response.Write "sql missing"
	end if
	Set GetDisplayRecordset = rstlookup
End Function

'-------------------------------------------------------------------------------
' Name: GetDisplaySQL(dbkey, formgroup, sql_get_fields, sql_base_table, sql_info, uniqueid, sql_options
' Purpose:  GetDisplaySQL creates an sql statement based on the inputs
' Inputs:   dbkey as string, formgroup as string, the fields in the select clause as string, base table as string, sub tables required in join
'	 as comma delimited list, sql_options: enum value as string
'		sql_options enum:
'				showsql - response.writes resulting sql - used for debuggin
'				sql_where - indicates  that sql _info is the full where clause
'				sql_full - indicates that sql_info is the full select statment
'				sql_no_distinct - remove the distinct/distinct keyword from the resutling statement
' Returns:	a full sql statement for use in generating a recordset
'-------------------------------------------------------------------------------


Function GetDisplaySQL(ByVal dbkey, ByVal formgroup, ByVal sql_get_fields, ByVal sql_base_table, ByVal sql_info, ByVal uniqueid, ByVal sql_options)
	StoreSessionOrderby = Session("Order_BY" & dbkey & formgroup)
	StoreSessionSortDirection = Session("Sort_direction" & dbkey & formgroup)
	Session("Order_BY" & dbkey & formgroup)=""
	Session("Sort_direction" & dbkey & formgroup)=""
	
	SQLSyntax = GetTableVal(dbkey, sql_base_table,kSQLSyntax)
	if Not sql_options <> "" then
		sql_options = "SQL_COWS"
	end if
	sql_options = UCase(sql_options)
	Select Case sql_options
		Case "SHOWSQL"
			'get linking filed form createing strWhere
			sourceFieldName=GetTableLinkVal(dbkey, sql_base_table, kSourceFieldName)
			sourceFieldType=GetTableLinkVal(dbkey, sql_base_table, kSourceFieldType) 
			strFieldDelimiter=GetFieldDelimiter(sourceFieldType)
			'get value from input parameters
			value =uniqueid
			'create strWhere for select statement
			if UCase(sqlSyntax) = "ORACLE" then
				if delimiter = "#" then
					Select case sourceFieldType
						Case "8" 
						strWhere = sourceFieldName & "=TO_DATE('" & value & "'," & "'MM,DD,YYYY')"' this is passed in as a parameter
						Case "9"
						strWhere = sourceFieldName & "=TO_DATE('" & value & "'," & "'DD,MM,YYYY')"' this is passed in as a parameter
					end select
				else
					strWhere =  sourceFieldName & " ="  &  strFieldDelimiter & value & strFieldDelimiter
				end if
			else
				strWhere =  sourceFieldName & " ="  &  strFieldDelimiter & value & strFieldDelimiter
			end if

			'get final select statement based on fields involved, tables involved and search engine to use.
			maxhits = ""
			fullselect = BuildSelectStatement(dbkey, formgroup, sql_base_table, sql_info, sql_get_fields, maxhits)
			sql = fullselect  & strWhere
			if instr(sql, "DISTINCTROW") > 0 then
				sql = replace(sql, "DISTINCTROW", "")
			end if
			if instr(sql, "DISTINCT") > 0 then
				sql = replace(sql, "DISTINCT", "")
			end if
		

		Case "SQL_WHERE"
			sql = "SELECT " & sql_get_fields & " FROM " & sql_base_table & " WHERE " & sql_info & uniqueid
		Case "SQL_FULL"
			sql = sql_info
		Case "SQL_COWS"
			'get linking field for creating strWhere
			on error resume next
			
			if UCase(sqlSyntax) = "ORACLE" then
				tempFieldName=GetTableLinkVal(dbkey, sql_base_table, kSourceFieldName)
				sourceFieldName = sql_base_table & "." & tempFieldName
				sourceFieldType=GetTableLinkVal(dbkey, sql_base_table, kSourceFieldType) 
				strFieldDelimiter=GetFieldDelimiter(sourceFieldType)
			else
				sourceFieldName=GetTableLinkVal(dbkey, sql_base_table, kSourceFieldName)
				sourceFieldType=GetTableLinkVal(dbkey, sql_base_table, kSourceFieldType) 
				strFieldDelimiter=GetFieldDelimiter(sourceFieldType)
			end if
		
			'get value from input parameters
			value =uniqueid
			'create strWhere for select statement
			if UCase(sqlSyntax) = "ORACLE" then
				if delimiter = "#" then
					Select case sourceFieldType
						Case "8" 
						strWhere =  sourceFieldName & "=TO_DATE('" & value & "'," & "'MM,DD,YYYY')"' this is passed in as a parameter
						Case "9"
						strWhere =  sourceFieldName & "=TO_DATE('" & value & "'," & "'DD,MM,YYYY')"' this is passed in as a parameter
					end select
				else
					if UCASE(SQLSYNTAX) = "ACCESS" then
						strWhere = sql_base_table & "." & sourceFieldName & " ="  &  strFieldDelimiter & value & strFieldDelimiter
					else
						strWhere = sourceFieldName & " ="  &  strFieldDelimiter & value & strFieldDelimiter
					end if
				end if
			else
				if UCASE(SQLSYNTAX) = "ACCESS" then
					strWhere =  sql_base_table & "." & sourceFieldName & " ="  &  strFieldDelimiter & value & strFieldDelimiter
				else
					strWhere =  sourceFieldName & " ="  &  strFieldDelimiter & value & strFieldDelimiter
				end if
			end if
			'get final select statement based on fields involved, tables involved and search engine to use.
			maxhits = ""
			fullselect = BuildSelectStatement(dbkey, formgroup, sql_base_table, sql_info, sql_get_fields, maxhits)
			sql = fullselect  & strWhere
			if instr(sql, "DISTINCTROW") > 0 then
				sql = replace(sql, "DISTINCTROW", "")
			end if
			if instr(sql, "DISTINCT") > 0 then
				sql = replace(sql, "DISTINCT", "")
			end if
			
		Case "SQL_ADD_DISTINCT"
			'get linking filed form createing strWhere
			sourceFieldName=GetTableLinkVal(dbkey, sql_base_table, kSourceFieldName)
			sourceFieldType=GetTableLinkVal(dbkey, sql_base_table, kSourceFieldType) 
			strFieldDelimiter=GetFieldDelimiter(sourceFieldType)
			'get value from input parameters
			value =uniqueid
			'create strWhere for select statement
			if UCase(sqlSyntax) = "ORACLE" then
				if delimiter = "#" then
					Select case sourceFieldType
						Case "8"
						strWhere = sourceFieldName & "=TO_DATE('" & value & "'," & "'MM,DD,YYYY')"' this is passed in as a parameter
						Case "9"
						strWhere = sourceFieldName & "=TO_DATE('" & value & "'," & "'DD,MM,YYYY')"' this is passed in as a parameter
					end select
				else
					strWhere = sourceFieldName & " ="  &  strFieldDelimiter & value & strFieldDelimiter
				end if
			else
				strWhere = sourceFieldName & " ="  &  strFieldDelimiter & value & strFieldDelimiter
			end if
			'get final select statement based on fields involved, tables involved and search engine to use.
			maxhits = ""
			fullselect = BuildSelectStatement(dbkey, formgroup, sql_base_table, sql_info, sql_get_fields, maxhits)
			sql = fullselect  & strWhere
			if not InStr(sql, "DISTINCT") > 0 then
				sql = replace(sql, "SELECT ", "")
				sql = replace(sql, "SELECT DISTINCT", "")
			end if

		Case "SQL_ADD_DISTINCTROW"
			'get linking filed form createing strWhere
			sourceFieldName=GetTableLinkVal(dbkey, sql_base_table, kSourceFieldName)
			sourceFieldType=GetTableLinkVal(dbkey, sql_base_table, kSourceFieldType) 
			strFieldDelimiter=GetFieldDelimiter(sourceFieldType)
			'get value from input parameters
			value =uniqueid
			'create strWhere for select statement
			strWhere = sourceFieldName & " ="  &  strFieldDelimiter & value & strFieldDelimiter
			'get final select statement based on fields involved, tables involved and search engine to use.
			maxhits = ""
			fullselect = BuildSelectStatement(dbkey, formgroup, sql_base_table, sql_info, sql_get_fields, maxhits)
			sql = fullselect  & strWhere
			if not InStr(sql, "DISTINCT") > 0 then
				sql = replace(sql, "SELECT ", "")
				sql = replace(sql, "SELECT DISTINCTROW", "")
			end if
	End Select
	'if using oracle remove brackets
	if SQLSyntax = "ORACLE" then
		sql = ModifySQL(sql)
	end if
	Session("Order_BY" & dbkey & formgroup)=StoreSessionOrderby
	Session("Sort_direction" & dbkey & formgroup)=StoreSessionSortDirection		
	GetDisplaySQL = sql
End Function

'-------------------------------------------------------------------------------
' Name GetConnection(dbkey, formgroup, table_name)
' Type: Function
' Purpose: create a  data connection based on the ADO connection specified for the table_name
' Inputs:  dbkey as string, formgroup as string , table namd as string 
' Returns:a reference to the newly create data connection
'-------------------------------------------------------------------------------

Function GetConnection(byval dbkey, byval formgroup, byval table_name)
	Dim conn_name
	Dim DataConn
	conn_name = GetConnGroupVal(dbkey, table_name, kADOConnection)
	Set DataConn = GetNewConnection(dbkey, formgroup, conn_name)
	Set GetConnection = DataConn
End function


'-------------------------------------------------------------------------------
' Name:  CloseRS(rsname)
' Type: Sub
' Purpose: close a recordset
' Inputs:  rsname as reference
' Returns: nothing
'-------------------------------------------------------------------------------
Sub CloseRS(ByRef rsname)
	if isObject(rsname) then
		if rsname.state = adStateOpen then
			rsname.close
			Set rsname = Nothing
				rsname = ""
		else
			Set rsname = Nothing
			rsname = ""
		end if
	end if
end Sub


'-------------------------------------------------------------------------------
' Name:  CloseConn(rsname)
' Type: Sub
' Purpose: close a connection
' Inputs:  connection as reference
' Returns: nothing
'-------------------------------------------------------------------------------
Sub CloseConn(ByRef DataConn)
	if isObject(DataConn) then
		if DataConn.state = adStateOpen then
			DataConn.Close
			Set DataConn = Nothing
				DataConn = ""
			else
			Set DataConn = Nothing
			DataConn = ""
		end if
	end if
end Sub


'-------------------------------------------------------------------------------
' Name: GetIDFromRS( dbkey,  formgroup,  rsname)
' Type: Function
' Purpose:  Get baseid's from current recordset
' Inputs:   dbkey as string, formgroup as string, rsname as reference to recordset object
' Returns:	A comma delimited sting of baseids
'-------------------------------------------------------------------------------
Function GetIDFromRS(ByVal dbkey, ByVal formgroup, ByRef rsname)
	If Session("error" & dbkey & formgroup)= True then exit function
	basearray = Session(rsname & dbkey & formgroup)
	on error resume next
	for i = 0 to UBound(basearray, 2)
	'for i = 0 to  Session("GetNextMaxHits" & dbkey & formgroup)
		if err.number > 0 then HandleError dbkey, formgroup, "no records found", "", "", ""
		BaseID = basearray(0,i)
		If base_id_string <> "" then
			base_id_string = base_id_string & "," & BaseID
		Else
			base_id_string = BaseID
		End If
	next
	GetIDFromRS = base_id_string
End Function



'-------------------------------------------------------------------------------
' Name: RestoreNull(varTemp)
' Type: Function
' Purpose:  Substitutes Null for Empty
' Inputs:   varTemp	- the target value
' Returns:	The processed value
'-------------------------------------------------------------------------------
Function RestoreNull(varTemp)
	If Trim(varTemp) = "" Then
		RestoreNull = Null
	Else
		RestoreNull = varTemp
	End If
End Function


'-------------------------------------------------------------------------------
' Name: RestoreNull(varTemp)
' Type: Sub
' Purpose:  Raise as error 
' Inputs:   error enum, field name as string
	'intErrorValue enum values:
		'errInvalidPrefix
		'errInvalidOperator
		'errInvalidOperatorUse
		'errNoteditable
		'errValueRequired
		'vbOjectError +9000
		'vbOjectError + 8000
' Returns: none
' Comments: Adds error to error collection
'-------------------------------------------------------------------------------
Sub RaiseError(intErrorValue, strFieldname)
	Dim strMsg	
	Select Case intErrorValue
		Case errInvalidPrefix
			strMsg = "Wildcard characters * and % can only be used at the End of the criteria"
		Case errInvalidOperator
			strMsg = "Invalid filtering operators - use <= or >= instead."
		Case errInvalidOperatorUse
			strMsg = "The 'Like' operator can only be used with strings."
		Case errNoteditable
			strMsg = strFieldname & " field is not editable."
		Case errValueRequired
			strMsg = "A value is required for " & strFieldname & "."
		Case vbOjectError + 9000
			strMsg = "your search returned too many hits. Please enter a more specIfic structure, formula or molecular weight"
		Case vbOjectError + 8000
			strMsg = "your search returned no hits. Please enter a valid  structure, formula or molecular weight"
	End Select 'Case intErrorValue
	Err.Raise intErrorValue, "DataForm", strMsg
End Sub



'-------------------------------------------------------------------------------
' Name:GetRelStrWhere( dbkey,  formgroup,  strFldType,   strFieldname,  strValue,  inputStrWhere)
' Type: Function
' Purpose:	GetRelStrWhere returnes the WHERE portion of the select statement for the input fieldname and value
' Inputs:	dbkey: name of the dataview as string
'		    formgroup: name of the formgroup as string
'			strFieldType: type fo field as INT
'				0: text
'				3: text force "="
'				4: text force "IN()"
'				1,2: number
'				7: memo
'				6: boolean
'				8,9 date
'			remaining parameters are used to call prepStrWhereItem which formates and concatenates cyurrent item to existing
'			strWhereCluse .  See PrepStrWHereItem
'			strFieldName: name of field as string
'			strValue: value for field as string
'			inputStrWhere: if there is already a Where clause in progress this is passed fro appending to. As string
' Returns: Where clause with strFieldname formated appropriatedly and appended to inputStrWhere as string
'-------------------------------------------------------------------------------
Function GetRelStrWhere(ByVal dbkey, ByVal formgroup, ByVal strFldType,  ByVal strFieldname, ByVal strValue, ByVal inputStrWhere)
  'DGB added missing Dim statement to fix global search CSBR-66700
	Dim strWhere
	
	if sf_DEBUG=True then
		Response.Write "<P><FONT FACE=""Arial"" SIZE=""1"" COLOR=""Navy"">search_func_vbs.asp::GetRelStrWhere(FieldName: " & strFieldName & ", FieldType: " & strFldType & ", Search Term: " & strValue & ")</FONT></P>"
		'Response.End
	end if
	
	CheckAddSQL =False
	RangeSearch=False		'JHS added to set default
	addSQL= ""
	temp_table = split(strFieldName, ".", -1)
	if UBound (temp_table) = 2 then
		temp_tablename = temp_table(0) & "." &  temp_table(1)
	else
		temp_tablename = temp_table(0)
	end if 
	
	
	field_name =  temp_table(1)
	SQLSyntax = GetTableVal(dbkey, temp_tablename,kSQLSyntax)
	If inStr(strValue, "'") > 0 then
		strValue = replace(strValue, "'", "''") 
	End If
	if inStr(strFieldname, ":&")>0 then
		CheckAddSQL = True
		DoAdd = True
		temp=split(strFieldname, ":&", -1)
		
		real_fullName = temp(0)
		new_array = split(real_fullName, ".", -1)
		if UBound(new_array) = 2 then
			realtable = new_array(0) & "." & new_array(1)
			fieldname = new_array(2)
		else
			realtable = new_array(0)
			fieldname = new_array(1)
		end if
		
		aliasTable_name = realtable & temp(1)
		AddToTableAliasTracker realtable, aliasTable_name
		strFieldname = aliasTable_name & "." & fieldname
		addSQL = GetTableVal(dbkey, realtable,kSelectAdditional)
		
		if addSQL <> "" and Not addSQL = "NULL" then
			if inStr(addSQL, ":")> 0 then
				thearray = split(addSQL, ":", -1)
				thearray2 = split(thearray(0), ",", -1)
				for i = 0 to UBound(thearray2)
					if thearray2(i) =  temp(1) then
						DoAdd = False
					end if
				next
				
			
				if DoAdd = True then
				
					newval=replace(thearray(1), realtable, aliasTable_name)
					addSQL = newval & temp(1)
					
				else
					addSQL = ""
				end if
			else
				addSQL = addSQL & temp(1)
			end if
		else
			addSQL = ""
		end if
	
	end if
	' If empty then exit right away
	If strValue = "" Then Exit Function

	' Concatenate the And boolean operator
	If inputStrWhere <> "" Then strWhere = inputStrWhere & " AND"

	' Set delimiter based on data type
	Select Case strFldType
		Case "0"				'string types
			strFieldDelimiter = "'"	
			strOrgOperator = "LIKE"
		
			'JHS
			'fixes bug
			if instr(1,strValue, " OR ") > 0 or instr(1,strValue, " AND ") > 0 then
				RangeSearch = True
			end if
			 		
		Case "1"				'int
			strFieldDelimiter = ""
			strOrgOperator = "="
			RangeSearch = True
			
		Case "2"				'float
			strFieldDelimiter = ""
			strOrgOperator = "="
			RangeSearch = True
		Case "3"				'text forced to exact match
			strFieldDelimiter = "'"
			strOrgOperator = "="
			if instr(1,strValue, " OR ") > 0 or instr(1,strValue, " AND ") > 0 then
				RangeSearch = True
			end if		
		Case "4"		
				'text forced to IN clause numerical
				strValue=replace(strValue, chr(10), chr(44))
				strValue=replace(strValue, chr(13), chr(44))
				strValue=replace(strValue, chr(9), chr(44))
				strValue=replace(strValue,  chr(44)& chr(44), chr(44))
				if Instr(strValue, ",") > 0 then
					strFieldDelimiter = ""
					strOrgOperator = "IN"
					strValue = "(" & strValue & ")"
					strValue = replace(strValue, ", ",",")
					strValue = replace(strValue, " , ",",")
					strValue = replace(strValue, " ,",",")
				else
					strFieldDelimiter = ""
					strOrgOperator = "="
					RangeSearch = True
					if instr(strValue, ".")>0 then
						strFldType=2
					else
						strFldType=1
					end if
				end if
			
		Case "5"				'text forced to IN clause text
			'replace line feeds with commas
			strValue=replace(strValue, chr(10), chr(44))
			'replace carriage returns with commas
			strValue=replace(strValue, chr(13), chr(44))
			'replace tabs with commas
			strValue=replace(strValue, chr(9), chr(44))
			'replace double commas with commas
			strValue=replace(strValue,  chr(44)& chr(44), chr(44))
			if inStr(strValue, ",")> 0 then
				strFieldDelimiter = ""
				strOrgOperator = "IN"
				strValue = replace(strValue, ", ",",")
				strValue = replace(strValue, " , ",",")
				strValue = replace(strValue, " ,",",")
				strValue =Replace(strValue, ",","','")
				strValue = "('" & strValue & "')"
				
			else
				strFieldDelimiter = "'"
				if inStr(strValue, "*")>0 then
					strOrgOperator = "LIKE"
				else
					strOrgOperator = "="
				end if
			end if
			
		
		Case "6" 'boolean
			strFieldDelimiter = " " 		' BOOLEAN
			strOrgOperator = "="	
		Case "7"
			strFieldDelimiter = "'" 		' memo
			strOrgOperator = "LIKE"	
			strValue = "*" & strValue
			
			if instr(1,strValue, " OR ") > 0 or instr(1,strValue, " AND ") > 0 then
				RangeSearch = True
			end if
		Case "8"				'date types
			if inStr(strValue, "-")> 0 then
				strOrgOperator = "="
				RangeSearch = True
			else
				if UCase(sqlSyntax) = "ORACLE" then			
					strFieldDelimiter = "8#"
				else
					strFieldDelimiter = "#"
				end if
				strOrgOperator = "="
			end if
			
		Case "9"				'date types
			if inStr(strValue, "-")> 0 then
				strOrgOperator = "="
				RangeSearch = True
			else
				if UCase(sqlSyntax) = "ORACLE" then			
					strFieldDelimiter = "9#"
				else
					strFieldDelimiter = "#"
				end if
				strOrgOperator = "="
			end if
		Case "13" 'remove padding for number
				'LJB 6/6 fix error that occurs when > or = in str.
				if Not isEmpty(strValue) and isNumeric(strValue) then
					strValue = CLng(strValue)
				end if
				strFieldDelimiter = ""
				strOrgOperator = "="
		
		Case "20"				'string types no trim
			strFieldDelimiter = "'"	
			strOrgOperator = "LIKE"		
			bTrim = false
			
		Case "21"			'text forced to IN clause text - no trim
			'replace line feeds with commas
			strValue=replace(strValue, chr(10), chr(44))
			'replace carriage returns with commas
			strValue=replace(strValue, chr(13), chr(44))
			'replace tabs with commas
			strValue=replace(strValue, chr(9), chr(44))
			'replace double commas with commas
			strValue=replace(strValue,  chr(44)& chr(44), chr(44))
			if inStr(strValue, ",")> 0 then
				strFieldDelimiter = ""
				strOrgOperator = "IN"
				strValue =Replace(strValue, ",","','")
				strValue = "('" & strValue & "')"
			else
				strFieldDelimiter = "'"
				strOrgOperator = "="
			end if
			
		Case "23"				'text forced to exact match no trim
			strFieldDelimiter = "'"
			strOrgOperator = "="	
			bTrim = false
		Case "25", "FullText" 'full text search
			strFieldDelimiter = "'"
			strOrgOperator = "FULL_TEXT"
			
		Case "26"				'text forced to IN clause text
			if inStr(strValue, ",")> 0 then
				strFieldDelimiter = ""
				strOrgOperator = "IN"
				strValue =Replace(strValue, ",","','")
				strValue = "('" & strValue & "')"
			else
				strFieldDelimiter = "'"
				strOrgOperator = "="
			end if
			btrim = false
			
		Case "33", "Range" 		
			RangeSearch = True		
			strFldType=10
			override_brackets = True
		Case "34", "IndexLikeSearch" 		
			RangeSearch = True		
			strFldType=0
		Case "35", "IS NULL" 		
			strFieldDelimiter = ""
			strOrgOperator = ""
			if strValue = "1" then strValue = "IS NOT NULL"
			if strValue = "0" then strValue = "IS NULL"
		Case "36", "APPEND_AS_IS" 		
			Append_to_string = True
		
		Case "37", "Hill_Formula" 		
			Hill_Formula = True
		Case "38", "Normalize_Name" 		
			strValue = CleanTheSyns(strValue)
			strFieldDelimiter = "'"	
			strOrgOperator = "LIKE"	
		Case "39", "Normalize_Name_Exact" 		
			strValue = CleanTheSyns(strValue)
			strFieldDelimiter = "'"	
			strOrgOperator = "="	
		Case "40", "FULL_TEXT_TYPE0" 		
			strFieldDelimiter = "'"	
			RangeSearch = True
			strDataType = 0
		Case "41", "FULL_TEXT_TYPE7" 		
			strFieldDelimiter = "'"	
			RangeSearch = True
			strDataType = 7
		Case Else
			strFieldDelimiter = ""
			strOrgOperator = "="
	End Select 'Case strFldType
	if CheckAddSQL = True AND addSQL <> "" then
		if RangeSearch = True then
			parsedstring =  ParseDataQuery(strValue, strFieldName, strFldType,dbkey, formgroup) 
			strRealName = GetTableRealName(dbkey, formgroup, strFieldname, "full_name")
			if not override_brackets = True then
				finalName = AddRelBrackets(strRealName)
			else
				finalName = strRealName
			end if 
			final_parsedstring = replace(parsedstring, strFieldName, finalName)
			strWhere = strWhere & " (" & final_parsedstring & ")"		
		else
			strWhere = strWhere & " (" & PrepStrWhereItem(dbkey, formgroup, strFieldname, strValue, strFieldDelimiter, strOrgOperator) & " " & addSQL & ")"
		end if
	elseif RangeSearch=True then
		AddSubFormNames dbkey, formgroup, strFieldname 
		parsedstring =  ParseDataQuery(strValue, strFieldName, strFldType,dbkey, formgroup) 
		if Not CheckAddSQL = True then
			strRealName = GetTableRealName(dbkey, formgroup, strFieldname, "full_name")
		else
			strRealName = strFieldname
		end if
		if not override_brackets = True then
			finalName = AddRelBrackets(strRealName)
		else
			finalName = strRealName
		end if 
		final_parsedstring = replace(parsedstring, strFieldName, finalName)
		strWhere = strWhere & " (" & final_parsedstring & ")"	
		
		strWhere = Replace(strWhere,"LIKE '*ISNULL*'", "IS NULL")
		strWhere = Replace(strWhere,"LIKE '*IS NULL*'", "IS NULL")
		strWhere = Replace(strWhere,"= IS NULL", "IS NULL")
		strWhere = Replace(strWhere,"= ISNULL", "IS NULL")
		strWhere = Replace(strWhere,"= 'IS NULL'", "IS NULL")
		strWhere = Replace(strWhere,"= 'ISNULL'", "IS NULL")
	else
		if Append_to_string = true then
			AddSubFormNames dbkey, formgroup, strFieldname 
			'strWhere = strWhere & " AND " & strValue
			strWhere = strWhere  & strValue
		else
		
			if Hill_Formula = true then
				AddSubFormNames dbkey, formgroup, strFieldname 
				parsedstring = prepHillFormula(dbkey, formgroup, strFldType, strFieldname, strValue, inputStrWhere)
				strRealName = GetTableRealName(dbkey, formgroup, strFieldname, "full_name")
				finalName = AddRelBrackets(strRealName)
				final_parsedstring = replace(parsedstring, strFieldName, finalName)
				strWhere = strWhere & " " & parsedstring
			else
			
				strWhere = strWhere & " " & PrepStrWhereItem(dbkey, formgroup, strFieldname, strValue, strFieldDelimiter, strOrgOperator)
			end if
		end if
	end if
	GetRelStrWhere = strWhere
End Function
'-------------------------------------------------------------------------------
' Name: PrepStrWhereItem( dbkey,  formgroup,  strFieldname,  strCriteria,  strDelimiter,  strOrgOperator)
' Type: Function
' Purpose:  Constructs a name/value pair for a where clause
' Inputs:	dbkey: name of the dataview as string
'		    formgroup: name of the formgroup as string
'			strFieldDelimeter: character used to format fieldvalue as string
'			strOrgOperator: character used to precedd formatted fieldvalue as string
'			strFieldName: name of field as string
'			strValue: value for field as string
' Returns: Where clause item for input  values as string
'-------------------------------------------------------------------------------
Function PrepStrWhereItem(ByVal dbkey, ByVal formgroup, ByVal strFieldname, ByVal strCriteria, ByVal strDelimiter, ByVal strOrgOperator)
	Dim strOperator
	Dim intEndOfWord
	Dim strWord
	Dim orClause
	basetable = GetBaseTable(dbkey, formgroup, "basetable")
	SQLSyntax = GetTableVal(dbkey, basetable,kSQLSyntax)
	orClause = "false"
	strOperator = strOrgOperator  
	if bTrim then
		strCriteria = Trim(strCriteria)	'remove leading/trailing spaces
	End if
	strValue = strCriteria			'sets default
	browseRecordWord = UCase(strCriteria)
	bFullText = false
	if strOrgOperator = "FULL_TEXT" then 'don't process the strValue since you don't want anything stripped
			bFullText = true
			strValue = PrepFullTextSQL(dbkey, formgroup, strFieldName, strCriteria, SQLSyntax)
			if inStr(strValue, "||")>0 then
				thereturnArray = split(strValue, "||", -1)
				strFieldName = thereturnArray(0)
				strValue = thereturnArray(1)
				PrepStrWhereItem = strValue
				exit Function
			end if
			strDelimiter = ""
			strOrgOperator = ""
			strOperator = ""
			
	else 'if anything, BUT full_text
		if Not strOperator = "IN" then
			'Response.Write strOperator & ":" & strCriteria & ":" & strValue
			Select Case browseRecordWord
				'SYAN modified on 12/7/2005 to fix CSBR-61880
				'Case "ANY", "NOT NULL", "IS NOT NULL", "*", "%"
				Case "ANY", "NOT NULL", "IS NOT NULL"
				'End of SYAN modification
					AddSubFormNames dbkey, formgroup, strFieldname 
					strRealName = GetTableRealName(dbkey, formgroup, strFieldname, "full_name")
					finalName = AddRelBrackets(strRealName)
					PrepStrWhereItem = finalName & " is not null"
					exit Function
			End Select
			'Get first word and look for operator
	
			intEndOfWord = InStr(strCriteria, " ")
			If intEndOfWord Then
				strWord = UCase(Left(strCriteria, intEndOfWord - 1))
				
				' See If the word is an operator
				Select Case strWord
					Case "="
						strOperator = strWord
						strValue = Trim(Mid(strCriteria, intEndOfWord + 1))
					Case "LIKE"
						strOperator = strWord
						strValue = Trim(Mid(strCriteria, intEndOfWord + 1))
					Case "<", ">", "<=", ">=",  "<>"
						if Not strOperator = "LIKE" then
							strOperator = strWord
							strValue = Trim(Mid(strCriteria, intEndOfWord + 1))
						end if
					Case "=<", "=>"
						RaiseError errInvalidOperator, strFieldname
					Case Else
						strWord = UCase(Left(strCriteria, 1))
						Select Case strWord
							Case "="
								strOperator = strWord
								strValue = Trim(Mid(strCriteria, 2))
							Case  "<", ">"
								if Not strOperator = "LIKE" then
									strOperator = strWord
									strValue = Trim(Mid(strCriteria, 2))
								end if
						End Select
				End Select
			Else
				strWord = UCase(Left(strCriteria, 2))
				
				Select Case strWord
					Case "<=", ">=", "<>"
						strOperator = strWord
						strValue = Trim(Mid(strCriteria, 3))
					Case "=<", "=>"
						RaiseError errInvalidOperator, strFieldname
					Case Else
						strWord = UCase(Left(strCriteria, 1))
						Select Case strWord
							Case "="
								strOperator = strWord
								strValue = Trim(Mid(strCriteria, 2))
							Case  "<", ">"
								if Not strOperator = "LIKE" then
									strOperator = strWord
									strValue = Trim(Mid(strCriteria, 2))
								end if
						End Select
				End Select
			End If
	
			If Left(strValue, 1) = "%" then 
				strValue = "*" & Trim(Right(strValue, Len(strValue) - 1))
			End If

			If Right(strValue, 1) = "%" then
				strValue = Trim(Left(strValue, Len(strValue) - 1)) & "*"
			End If

			If inStr(strValue, "%")> 0 then
				strValue = Replace(strValue, "%", "*")
			End If
			
			

			If strOperator = "LIKE" then
				strValue = "*" & Trim(Left(strValue, Len(strValue))) & "*"
				
			End If
			
			if strOperator = "=" AND strDelimiter = "'" and Right(strValue, 1)="*" then
				strOperator = "LIKE" 
				strValue = Trim(Left(strValue, Len(strValue))) & "*"
			End if
			
			if strOperator = "=" AND strDelimiter = "'" and Left(strValue, 1)="*"  then
				strOperator = "LIKE" 
				strValue = Trim(Left(strValue, Len(strValue)))
			End if
			
			' Make sure LIKE is only used with strings
			If strOperator = "LIKE" and strDelimiter <> "'" Then
				RaiseError errInvalidOperatorUse, strFieldname
			End If		

			' Strip any extraneous delimiters because we add them anyway
			' Single Quote
			If Left(strValue, 1) = Chr(39) Then strValue = Mid(strValue, 2)
			If Right(strValue, 1) = Chr(39) Then strValue = Left(strValue, Len(strValue) - 1)

			' Double Quote - just in case
			If Left(strValue, 1) = Chr(34) Then strValue = Mid(strValue, 2)
			If Right(strValue, 1) = Chr(34) Then strValue = Left(strValue, Len(strValue) - 1)

			' Pound sign - dates
			If Left(strValue, 1) = Chr(35) Then strValue = Mid(strValue, 2)
			If Right(strValue, 1) = Chr(35) Then strValue = Left(strValue, Len(strValue) - 1)
			end if
			
		
		end if 'if FULL_TEXT
		
		AddSubFormNames dbkey, formgroup, strFieldname 
		'if using oracle for to lower case and appliy lower(fieldname) syntax
		'this forces case insensitivity
		
		'LJB 6/21/2005. This next line appars to be a bug that messes up table definition aliasing.
    'SMathur 09/26/2007. Fixing CSBR-84371. Commented first line and uncommented second line after discussing with DGB. This needs to be reverted, if the QA teams finds any issues.
		
		'SYAN modified on 1/8/2008 to fix CSBR-88447. Uncommented first line since otherwise Reg Identifier search fails.
    if dbkey = "reg" then
      strRealName = GetTableRealName(dbkey, formgroup, strFieldname, "full_name")
    else  
      strFieldname = GetTableRealName(dbkey, formgroup, strFieldname, "full_name")
		end if
    'End of SYAN modification
		
		if UCase(sqlSyntax) = "ORACLE" AND (inStr(strValue, "'") > 0 OR strDelimiter = "'") then 'means like text search
			if bFullText = true then
				finalName = strFieldname
				strValue = strValue
			else
				if inStr(strValue, "=")>0 then
					if strOperator = "=" then
						if inStr(strValue,"=")> 0 then
							finalName = AddRelBrackets(strFieldname)
							strValue = replace (strValue,"=", "")
						else
							finalName = "lower(" & strFieldname & ")"
							strValue = LCase(strValue)
						end if
					else  
						if strOperator = "IN" then
							if inStr(strValue, "'==") > 0 then
								finalName = AddRelBrackets(strFieldname)
								strValue = Replace(strValue, "'==", "'")
							else
								finalName = "lower(" & strFieldname & ")"
								strValue = Replace(strValue, "'=", "'")
								strValue = LCase(strValue)
							end if
						else
							finalName = AddRelBrackets(strFieldname)
							strValue = Mid(strValue, 2)
						end if
					end if
				
				else
					finalName = "lower(" & strFieldname & ")"
					strValue = LCase(strValue)
				end if
			end if 
		else
			finalName = AddRelBrackets(strFieldname)
		end if

		if UCase(sqlSyntax) = "ORACLE" then
			if inStr(strDelimiter, "#")> 0 then
			'Select case strDelimiter
			'	Case "8#" 
			'		PrepStrWhereItem = finalName & strOperator & "TO_DATE('" & strValue & "'," & "'MM,DD,YYYY')"' this is passed in as a parameter
			'	Case "9#"
			'		PrepStrWhereItem = finalName & strOperator & "TO_DATE('" & strValue & "'," & "'DD,MM,YYYY')"' this is passed in as a parameter
			'end select
			
			'SYAN changed 12/16/2003 to fix CSBR-35466
			Select case Application("DATE_FORMAT")
				Case "8" 
					PrepStrWhereItem = "TRUNC(" & finalName & ")" & strOperator & "TO_DATE('" & strValue & "'," & "'MM,DD,YYYY')"' this is passed in as a parameter
				Case "9"
					PrepStrWhereItem = "TRUNC(" & finalName & ")" & strOperator & "TO_DATE('" & strValue & "'," & "'DD,MM,YYYY')"' this is passed in as a parameter
				Case "10"
					PrepStrWhereItem = "TRUNC(" & finalName & ")" & strOperator & "TO_DATE('" & strValue & "'," & "'YYYY,MM,DD')"' this is passed in as a parameter
			end select
			'End of SYAN modification
		else
			if UCase(strOperator) = "LIKE" AND inStr(strValue, "_")>0 AND UCase(SQLSyntax) = "ORACLE" then
				strValue = replace(strValue, "_", "~_") 
				PrepStrWhereItem = finalName & " " & strOperator & " " & strDelimiter & strValue & strDelimiter & "ESCAPE '~'"
			else
				if (UCase(sqlSyntax) = "SQL_SERVER" or UCase(sqlSyntax) = "SQLSERVER") and UCase(strOperator) = "LIKE" AND inStr(strValue, "[")>0 then
					strValue = replace(strValue, "[", "[[")
					strValue = replace(strValue, "]", "]]")
				end if
				
				'SYAN changed 5/21/2004 to fix long list issue.
			
				'count = 1
				'For i = 1 To Len(strValue)
				'    If Mid(strValue, i, 1) = "," Then 
				'		count = count + 1
				'	End if
				'Next
				valueArr = Split(strValue, ",")
				count = UBound(valueArr) + 1
				
				if strOperator = "IN" then 
					strValue = replace(strValue, Chr(39), "") 'Change from ('AB-000001','AB-000002') to (AB-000001,AB-000002)
					strValue = replace(strValue, "(", "")
					strValue = replace (strValue, ")", "" )'Change from (AB-000001,AB-000002) to AB-000001,AB-000002
					session("IDList" & dbkey & formgroup) = strValue
					PrepStrWhereItem = finalName & " IN (" & BuildInClause(Chr(39) & strValue & Chr(39), count) & ")"
				else 
					PrepStrWhereItem = finalName & " " & strOperator & " " & strDelimiter & strValue & strDelimiter
				end if
				'End of SYAN modificaiton
							
			end if
		end if
	else
			if UCase(strOperator) = "LIKE" AND inStr(strValue, "_")>0 AND UCase(SQLSyntax) = "ORACLE" then
				strValue = replace(strValue, "_", "~_") 
				PrepStrWhereItem = finalName & " " & strOperator & " " & strDelimiter & strValue & strDelimiter & "ESCAPE '~'"
				
					
			else
				if (UCase(sqlSyntax) = "SQL_SERVER" or UCase(sqlSyntax) = "SQLSERVER") and UCase(strOperator) = "LIKE" AND inStr(strValue, "[")>0 then
					strValue = replace(strValue, "[", "[[")
					strValue = replace(strValue, "]", "]]")
					PrepStrWhereItem = finalName & " " & strOperator & " " & strDelimiter & strValue & strDelimiter

				else
					'SYAN changed 12/19/2003 to fix CSBR-35466
					'PrepStrWhereItem = finalName & " " & strOperator & " " & strDelimiter & strValue & strDelimiter
					if inStr(strDelimiter, "#")> 0 then
						strValue = ConvertStrToDate(Application("DATE_FORMAT"), strValue)
					end if
					PrepStrWhereItem = finalName & " " & strOperator & " " & strDelimiter & strValue & strDelimiter
					'End of SYAN modification
				end if
			end if
	end if
End Function


'-------------------------------------------------------------------------------
' Name: AddRelBrackets(strRealName)
' Type: Function
' Purpose: Add brackets to where clause
' Inputs: full field name as string
' Returns: fieldname with brackes
' Comments: brackets are stripped by later functions when Oracle is the DBMS
'-------------------------------------------------------------------------------
Function AddRelBrackets(strRealName)
	if inStr(strRealName, ".")> 0 then
		temp = split(strRealName, ".", -1)
		if temp(0) = "*" then
			table = temp(0)
		else
			if UBound(temp) = 2 then
				table = "[" & Trim(temp(0)) & "." & Trim(temp(1)) & "]"
			else
				table = "[" & Trim(temp(0)) & "]"
			end if
		end if
		if temp(1) = "*" then
			field = temp(1) 
		else
			if UBound(temp) = 2 then
				field = "[" & Trim(temp(2)) & "]"
			else
				field = "[" & Trim(temp(1)) & "]"
			end if
		end if 
		AddRelBrackets = table & "." & field
	Else
		AddRelBrackets = "[" & Trim(strRealName) & "]"
	End if
	
End Function

Sub AddToTableAliasTracker(real_name, alias_name)
	name_alias_item= real_name & ":" & alias_name
	if not inStr(UCase(Session("TableAliasTracker" & dbkey & formgroup)),UCase(name_alias_item))> 0 then
		If Session("TableAliasTracker" & dbkey & formgroup)<> "" then
			Session("TableAliasTracker" & dbkey & formgroup)=Session("TableAliasTracker" & dbkey & formgroup) & "," & name_alias_item
		else
			Session("TableAliasTracker" & dbkey & formgroup) = name_alias_item
		end if
	end if
End sub

'-------------------------------------------------------------------------------
' Name: GetTableRealName(dbkey, formgroup, strInput, InputType)
' Type: Function
' Purpose: Get the real table name for an input value from an ini file array variable
' Inputs: dbkey as string, formgroup as string, full field name as string or comma delimited list
' Returns: real table name based on ini file
'-------------------------------------------------------------------------------
Function GetTableRealName(ByVal dbkey, ByVal formgroup, ByVal strInput, ByVal InputType)
if Not inStr(UCase(Session("TableAliasTracker" & dbkey & formgroup)),UCase(strInput))> 0 then
	InputType = UCase(InputType)
	Select Case InputType

		Case "FULL_NAME_STRING"
			namesarray = Split(strInput, ",", -1)
			for i = 0 to UBound(namesarray)
				If inStr(namesarray(i), ".")> 0 then
					temp = Split(namesarray(i), ".", -1)
					if UBound(temp) = 2 then
						tablename = temp(0) & "." & temp(1)
						fieldname = temp(2)
					else
						tablename = temp(0)
						fieldname = temp(1)
					end if
						temp_name =GetTableVal(dbkey, tablename, kTableRealName)
						if Not temp_name <> "" then
							temp_name = tablename
						end if
						tempconvertedname =  temp_name & "." & fieldname	
						
				Else
					tempconvertedname = namesarray(i)
					
				End If

				If newnames <> "" then
					newnames = newnames & "," & tempconvertedname
				Else
					newnames = tempconvertedname
				End If
			next
			convertedname = newnames

		Case "FULL_NAME"
			temp = Split(strInput, ".", -1)
			if Ubound(temp) = 2 then
				tablename = temp(0) & "." & temp(1)
				fieldname = temp(2)
			else
				tablename = temp(0)
				fieldname = temp(1)
			end if
			convertedname = GetTableVal(dbkey, tablename, kTableRealName) & "." & fieldname

		Case "TABLE_NAME"
			convertedname = GetTableVal(dbkey, strInput, kTableRealName)

		Case "TABLE_NAME_STRING"
			namesarray = Split(strInput, ",", -1)
			for i = 0 to UBound(namesarray)
				tempconvertedname = GetTableVal(dbkey, namesarray(i), kTableRealName)
				if Not tempconvertedname <> "" then tempconvertedname=namesarray(i)
				If newnames <> "" then
					newnames = newnames & "," & tempconvertedname
				Else
					newnames = tempconvertedname
				End If
			next
			convertedname = newnames
	End Select
	GetTableRealName = convertedname
else
	GetTableRealName=strInput
end if
End Function


'-------------------------------------------------------------------------------
' Name: GetTableRealName(dbkey, formgroup, strInput, strFieldname)
' Type: Sub
' Purpose: add table name to Session("strWhereSubforms" & dbkey & formgroup)
' Inputs: dbkey as string, formgroup as string, Full field name as string
' Returns: none
'-------------------------------------------------------------------------------
Sub AddSubFormNames(ByVal dbkey, ByVal formgroup, ByVal strFieldname)
	on error resume next
	if strFieldname <> "" then
	'check to seee if strFieldname is a list
		if inStr(strFieldname, ",")> 0 then
			tempsubform=Session("strWhereSubforms" & dbkey & formgroup)
			temp_array = Split(strFieldname, ",", -1)
			for i = 0 to Ubound(temp_array)
				formgroupflag = GetFormGroupVal(dbkey, formgroup, kFormGroupFlag)
				If formgroupflag = "GLOBAL_SEARCH" then
					returnedfieldname = GetFieldCorr(dbkey, formgroup, "", temp_array(i))
					temp = split(returnedfieldname, "." , -1)
				else
					temp = split(temp_array(i), "." , -1)
				end if
				if Ubound(temp) = 2 then
					tablename = temp(0) & "." & temp(1)
				else
					tablename = temp(0)
				end if
				If tablename = GetBaseTable(dbkey, formgroup, "basetable") then exit sub
				If Len(tempsubform)>0 then
					temparray = Split(tempsubform, ",", -1)
					for j = 0 to UBound(temparray)
						If Not UCase(temparray(j)) = UCase(tablename) then
							If addNames <> "" then
								addNames = 	addNames  & "," & tablename
							Else 
								addNames = tablename
							End If
						End If
					Next 'j

					If addNames <> "" then
							tempsubform = 	tempsubform  & "," & addNames
					End If
				Else
					tempsubform = tablename
				End If
				Session("strWhereSubforms" & dbkey & formgroup)=tempsubform
			next 'i
		else
		tempsubform=Session("strWhereSubforms" & dbkey & formgroup)
			formgroupflag = GetFormGroupVal(dbkey, formgroup, kFormGroupFlag)
			If formgroupflag = "GLOBAL_SEARCH" then
				returnedfieldname = GetFieldCorr(dbkey, formgroup, "", strFieldname)
				temp = split(returnedfieldname, "." , -1)
			else
				temp = split(strFieldname, "." , -1)
			end if

			if Ubound(temp) = 2 then
				tablename = temp(0) & "." &  temp(1)
			else
				tablename = temp(0)
			end if

			If Ucase(tablename) = UCase(GetBaseTable(dbkey, formgroup, "basetable")) then exit sub
			If Len(tempsubform)>0 then
				temparray = Split(tempsubform, ",", -1)
				for i = 0 to UBound(temparray)
					If Not UCase(temparray(i)) = UCase(tablename) then
						If addNames <> "" then
							addNames = 	addNames  & "," & tablename
						Else 
							addNames = tablename
						End If
					End If
				Next 'i

				If addNames <> "" then
						tempsubform = 	tempsubform  & "," & addNames
				End If
			Else
				tempsubform = tablename
			End If
	Session("strWhereSubforms" & dbkey & formgroup)=tempsubform
	end if
end if
End sub



'-------------------------------------------------------------------------------
' Name: doFileExists(myDir)
' Type: Function
' Purpose: check to see if a file exists
' Inputs: full path to file as string
' Return: boolean. True if file exists
'-------------------------------------------------------------------------------
Function doFileExists(ByVal myDir)
	on error resume next
	fileExists = false
	Set checkFile = Server.CreateObject("Scripting.FileSystemObject")
	if checkFile.FileExists(myDir)= true then
		fileExists = true
	end if
	set checkFile = Nothing
	checkFile = ""
	if err.number > 0 then LogAction("doFileExists:" & err.number & err.description)
	doFileExists = fileExists
End Function

'-------------------------------------------------------------------------------
' Name: DecodeBase64 ( inputstring,  outputpath)
' Type: Sub
' Purpose:	Decodes base-encoded CDX string
' Inputs :	Base64-encoded CDX string, full path and file name for output as string
' Returns:	Decoded CDX file written to {outputpath}
'-------------------------------------------------------------------------------
Sub DecodeBase64 (ByVal inputstring, ByVal outputpath)
	If not isObject(Session("myDecoder"))then
		Set Session("myDecoder") = Server.CreateObject("Base64Decode.Decode")
	End If

	decodesuccess = Session("myDecoder").Decode(inputstring, outputpath)
	If decodesuccess = False then
		version=Request.form("version") 
		
		if inStr(version, "Net")>0 or Left(inputstr, 1) = "#" then
			DoRedirect dbkey, "/cfserverasp/source/error.asp?error_number=net_version" 
			Response.end
		else
			if try_createSessDir = true then
				decodesuccess = Session("myDecoder").Decode(inputstring, outputpath)
				If decodesuccess = False then
					HandleError dbkey, formgroup, "decode failed", "", "", ""
				end if
			else
				HandleError dbkey, formgroup, "decode failed", "", "", ""
			end if
		HandleError dbkey, formgroup, "decode failed", "", "", ""
		end if
	end if
End Sub

'-------------------------------------------------------------------------------
' Name: EncodeCDX (inputpath)
' Type: Function
' Purpose:	Encodes a *.cdx file to a base64 encoded string
' Inputs :	full path to cdx file as string
' Returns:	Base64 string
'-------------------------------------------------------------------------------
Function EncodeCDX (ByVal inputpath)

	If not isObject(Session("myDecoder"))then
		Set Session("myDecoder") = Server.CreateObject("Base64Decode.Decode")
	End If

	base64 = Session("myDecoder").Encode(inputpath)
	EncodeCDX = base64
End Function


'-------------------------------------------------------------------------------
' Name: try_createSessDir ()
' Type: Function
' Purpose:	Create Session directory if not found
' Inputs :	none
' Returns:	boolean. True if directory created
' Comments: path to session dir gathered from  Application("TempFileDirectory" & dbkey) & "Sessiondir\" & Session.sessionid
'-------------------------------------------------------------------------------
function try_createSessDir()
	on error resume next
	createperformed = false
	Set fs = Server.CreateObject("Scripting.FileSystemObject")
	theSessDirPath =  Application("TempFileDirectory" & dbkey) & "Sessiondir"
	theSessUserDirPath = Application("TempFileDirectory" & dbkey) & "Sessiondir\" & Session.sessionid
	if Not fs.FolderExists(theSessionPath) then
		fs.CreateFolder(theSessionPath)
		fs.CreateFolder(theSessUserDirPath)
		createperformed =true
	end if
	if Not fs.FolderExists(theSessUserDirPath) then
		fs.CreateFolder(theSessUserDirPath)
		createperformed =true
	end if
	Set fs = Nothing
	fs = ""
	try_createSessDir = createperformed
end function


'-------------------------------------------------------------------------------
' Name: GetTimeStamp ()
' Type: Function
' Purpose:	get a time stamp
' Inputs :	none
' Returns:	time stamp as string (Month & day & year & hour & minute & second)
'-------------------------------------------------------------------------------
Function GetTimeStamp()
	MyTime = Now()
	MyDay = Date()
	date_stamp=Month(MyDate) & Day(MyDate) & Year(MyDate) & Hour(MyTime) & Minute(MyTime) & Second(MyTime)
	GetTimeStamp = date_stamp
End Function




'-------------------------------------------------------------------------------
' Name: ClearSearchData(dbkey, formgroup, searchtype)
' Type: Sub
' Purpose: Clear Session variables that store search data
' Inputs dbkey as string, formgroup as string, type of search as string
' Returns: none
'-------------------------------------------------------------------------------
Sub ClearSearchData(ByVal dbkey, ByVal formgroup, ByVal searchtype)
	If searchtype = "New" then
		searchtype = ""
	End If
	Session("Order_BY" & dbkey & formgroup) = ""
	Session("Sort_direction" & dbkey & formgroup) = ""
	ClearData "ChemFields", searchtype,  Session("SearchData" & "Similarity" & dbkey & formgroup)
	ClearData "ChemFields", searchtype,  Session("SearchData" & "Identity" & dbkey & formgroup)
	ClearData "ChemFields", searchtype, Session("SearchData" & "Exact" & dbkey & formgroup)
	ClearData "ChemFields", searchtype, Session("SearchData" & "SubStructure" & dbkey & formgroup)
	ClearData "ChemFields", searchtype, Session("SearchData" & "MolWeight" & dbkey & formgroup)
	ClearData "ChemFields", searchtype, Session("SearchData" & "Formula" & dbkey & formgroup)
	ClearData "RelFields", searchtype, Session("SearchData" & "Relational" & dbkey & formgroup)
	
	Session(searchtype & "SearchData" & "SearchStrategy" & dbkey & formgroup) =""
	Session(searchtype & "SearchData" & "SubStructure" & dbkey & formgroup)= ""
	Session(searchtype & "SearchData" & "MolWeight" & dbkey & formgroup)= ""
	Session(searchtype & "SearchData" & "Formula" & dbkey & formgroup)= ""
	Session(searchtype & "SearchData" & "Relational" & dbkey & formgroup)= ""
	Session(searchtype & "SearchData" & "Exact" & dbkey & formgroup)= ""
	Session(searchtype & "SearchData" & "Similarity" & dbkey & formgroup)=  ""

End Sub


'-------------------------------------------------------------------------------
' Name: GetSearchData(dbkey, formgroup)
' Type: Sub
' Purpose: get search data from post and store in session variables by looking at posted session variables - see comments
' Inputs dbkey as string, formgroup as string
' Returns: none
' Comments: Assumes post has one or more of the following populated for chemical searhes:SubSearchFields, MolWeightSearchFields, FormulaSearchFields
'   ExactSearchFields, SimSearch Fields. Assumes list of rel fields in RelationalSearchFields for relationsal
'	search.
'-------------------------------------------------------------------------------
Sub GetSearchData(ByVal dbkey, ByVal formgroup)
	'enter search strategy
	ClearSearchData dbkey, formgroup, "New"
	bChemSearch = false
	bRelsearch = false
	SearchStrategy = Request("SearchStrategy")


	'//Grab the parameters for the query.
	SubSearchFields = Request("SubSearchFields")
	AddSubFormNames dbkey, formgroup, SubSearchFields 

	MWFields = Request("MolWeightSearchFields")
	AddSubFormNames dbkey, formgroup, MWFields 

	FormulaFields = Request("FormulaSearchFields")
	AddSubFormNames dbkey, formgroup, FormulaFields 

	ExactFields = Request("ExactSearchFields")
	AddSubFormNames dbkey, formgroup, ExactFields 

	SimSearchFields = Request("SimSearchFields")
	AddSubFormNames dbkey, formgroup, SimSearchFields 
	
	IdentitySearchFields = Request("IdentitySearchFields")
	AddSubFormNames dbkey, formgroup, IdentitySearchFields	
	'SYAN added on 2/15/2005 to fix CSBR-50932
	MultipleExactSearch = Request("MultipleExactSearch")
	'DGB If there is more than one structure query in the 
	'search page then there are multiple instances of the 
	'MultipleExactSearch hidden element which lead to ", " being
	'posted even when the two hidden elements are blank
	'This is causing problems in BioSAR.
	'While this should eventually be fixed by explicitly handling
	'the case of two plugins, here I just clear the variable if no
	'first character is a comma.
	
	if left(MultipleExactSearch,1)="," then MultipleExactSearch =""
	
	AddSubFormNames dbkey, formgroup, MultipleExactSearch
	'End of SYAN modification
	
	RelFields = Request("RelationalSearchFields")
	
	if Not SearchStrategy <> "" then
		if SubSearchFields <> "" then bChemSearch = True
		if MWFields <> "" then bChemSearch = True
		if FormulaFields <> "" then bChemSearch = True
		if SimSearchFields <> "" then bChemSearch = True
		if IdentitySearchFields <> "" then bChemSearch = True
		
		'SYAN added on 2/15/2005 to fix CSBR-50932
		if MultipleExactSearch <> "" then bChemSearch = True
		'End of SYAN modification

		if RelFields <> "" then bRelsearch = True
		if bChemSearch = True AND bRelSearch = True then SearchStrategy = "chem_rel"
		if bChemSearch = False AND bRelSearch = True then SearchStrategy = "rel"
		if bChemSearch = True AND bRelSearch = False then SearchStrategy = "chem_only"
	end if
	Session("Order_BY" & dbkey & formgroup) = request("order_by")
	Session("Sort_direction" & dbkey & formgroup) = request("sort_direction")
	Session("SearchData" & "SearchStrategy" & dbkey & formgroup) = SearchStrategy
	Session("SearchData" & "SubStructure" & dbkey & formgroup) = SubSearchFields
	Session("SearchData" & "MolWeight" & dbkey & formgroup) = MWFields
	Session("SearchData" & "Formula" & dbkey & formgroup) = FormulaFields
	Session("SearchData" & "Relational" & dbkey & formgroup) = RelFields
	Session("SearchData" & "Exact" & dbkey & formgroup) = ExactFields
	Session("SearchData" & "Similarity" & dbkey & formgroup) = SimSearchFields
	Session("SearchData" & "Identity" & dbkey & formgroup) = IdentitySearchFields
	'SYAN added on 2/15/2005 to fix CSBR-50932
	Session("SearchData" & "MultipleExact" & dbkey & formgroup) = MultipleExactSearch
	'End of SYAN modification

	'split field array and then get data from form using addData sub

	AddData "ChemFields", Session("SearchData" & "Similarity" & dbkey & formgroup)
	AddData "ChemFields", Session("SearchData" & "Identity" & dbkey & formgroup)
	AddData "ChemFields", Session("SearchData" & "Exact" & dbkey & formgroup)
	AddData "ChemFields", Session("SearchData" & "SubStructure" & dbkey & formgroup)
	AddData "ChemFields", Session("SearchData" & "MolWeight" & dbkey & formgroup)
	AddData "ChemFields", Session("SearchData" & "Formula" & dbkey & formgroup)
	'SYAN added on 2/15/2005 to fix CSBR-50932
	AddData "ChemFields", Session("SearchData" & "MultipleExact" & dbkey & formgroup)
	'End of SYAN modification
	AddData "RelFields", Session("SearchData" & "Relational" & dbkey & formgroup)
	relSearch = Session("SearchData" & "Relational" & dbkey & formgroup)
	If relSearch <> "" then
		Session("SearchData" & "RelPortion" & dbkey & formgroup)= GetRelFields(dbkey, formgroup, relSearch)
	
	End If
End Sub

'-------------------------------------------------------------------------------
' Name: GetSearchData_ByPassINI(dbkey, formgroup)
' Type: Sub
' Purpose: get search data from post and store in session variables.Without checking formgroup array from ini file
' Inputs dbkey as string, formgroup as string
' Returns: none
' Comments: Assumes post has one or more of the following populated for chemical searhes:SubSearchFields, MolWeightSearchFields, FormulaSearchFields
'   ExactSearchFields, SimSearch Fields. Assumes list of rel fields in RelationalSearchFields for relationsal
'	search.
'-------------------------------------------------------------------------------

Sub GetSearchData_ByPassINI(ByVal dbkey, ByVal formgroup)
	'enter search strategy
	ClearSearchData dbkey, formgroup, "New"
	bChemSearch = false
	bRelsearch = false
	SearchStrategy = Request("SearchStrategy")
	Session("Order_BY" & dbkey & formgroup) = request("order_by")
	Session("Sort_direction" & dbkey & formgroup) = request("Sort_direction")
	SubSearchFields = Request("SubSearchFields")
	AddSubFormNames dbkey, formgroup, SubSearchFields 
	MWFields = Request("MolWeightSearchFields")
	AddSubFormNames dbkey, formgroup, MWFields 
	FormulaFields = Request("FormulaSearchFields")
	AddSubFormNames dbkey, formgroup, FormulaFields 
	ExactFields = Request("ExactSearchFields")
	AddSubFormNames dbkey, formgroup, ExactFields 
	SimSearchFields = Request("SimSearchFields")
	IdentitySearchFields = Request("IdentitySearchFields")
	AddSubFormNames dbkey, formgroup, SimSearchFields 

	RelFields = Request("RelationalSearchFields")
	if Not SearchStrategy <> "" then
		if SubSearchFields <> "" then bChemSearch = True
		if MWFields <> "" then bChemSearch = True
		if FormulaFields <> "" then bChemSearch = True
		if SimSearchFields <> "" then bChemSearch = True
		if IdentitySearchFields <> "" then bChemSearch = True
		if RelFields <> "" then bRelsearch = True
		if bChemSearch = True AND bRelSearch = True then SearchStrategy = "chem_rel"
		if bChemSearch = False AND bRelSearch = True then SearchStrategy = "rel"
		if bChemSearch = True AND bRelSearch = False then SearchStrategy = "chem_only"
	end if

	Session("SearchData" & "SearchStrategy" & dbkey & formgroup) = SearchStrategy
	Session("SearchData" & "SubStructure" & dbkey & formgroup) = SubSearchFields
	Session("SearchData" & "MolWeight" & dbkey & formgroup) = MWFields
	Session("SearchData" & "Formula" & dbkey & formgroup) = FormulaFields
	Session("SearchData" & "Relational" & dbkey & formgroup) = RelFields
	Session("SearchData" & "Exact" & dbkey & formgroup) = ExactFields
	Session("SearchData" & "Similarity" & dbkey & formgroup) = SimSearchFields
	Session("SearchData" & "Identity" & dbkey & formgroup) = IdentitySearchFields
	'split field array and then get data from form using addData sub
	AddData "ChemFields", Session("SearchData" & "Similarity" & dbkey & formgroup)
	AddData "ChemFields", Session("SearchData" & "Identity" & dbkey & formgroup)
	AddData "ChemFields", Session("SearchData" & "Exact" & dbkey & formgroup)
	AddData "ChemFields", Session("SearchData" & "SubStructure" & dbkey & formgroup)
	AddData "ChemFields", Session("SearchData" & "MolWeight" & dbkey & formgroup)
	AddData "ChemFields", Session("SearchData" & "Formula" & dbkey & formgroup)
	AddData "RelFields", Session("SearchData" & "Relational" & dbkey & formgroup)
	relSearch = Session("SearchData" & "Relational" & dbkey & formgroup)
	If relSearch <> "" then
		Session("SearchData" & "RelPortion" & dbkey & formgroup)= GetRelFields(dbkey, formgroup, relSearch)
	End If

End Sub

'-------------------------------------------------------------------------------
' Name: GetSearchData_blind(dbkey, formgroup)
' Type: Sub
' Purpose: get search data from post by looking at possibly fields in formgroup array and requesting each field.
' Inputs dbkey as string, formgroup as string
' Returns: none
'-------------------------------------------------------------------------------
Sub GetSearchData_blind(ByVal dbkey, ByVal formgroup)
'check struc_fields
	struc_fields = GetFormGroupVal(dbkey, formgroup, kStructureFields)
	check_fields = Split(struc_fields, ",", -1)
	StrucFields = ""
	Session("Order_BY" & dbkey & formgroup) = request("order_by")
	Session("Sort_direction" & dbkey & formgroup) = request("Sort_direction")
	for i = 0 to UBound(check_fields)
		try_it = Request(check_fields(i))
		if try_it <> "" then
			if StrucFields <> "" then
				StrucFields = StrucFields & "," & check_fields(i)
			else
				StrucFields = check_fields(i)
			end if
		end if
	next

	mw_fields = GetFormGroupVal(dbkey, formgroup, kMWFields)
	check_fields = Split(mw_fields, ",", -1)
	MWFields = ""
	for i = 0 to UBound(check_fields)
		try_it = Request(check_fields(i))
		if try_it <> "" then
			if MWFields <> "" then
				MWFields = MWFields & "," & check_fields(i)
			else
				MWFields = check_fields(i)
			end if
			
		end if
	next
	AddSubFormNames dbkey, formgroup, MWFields 

	formula_fields = GetFormGroupVal(dbkey, formgroup, kFormulaFields)
	check_fields = Split(formula_fields, ",", -1)
	FormulaFields = ""

	for i = 0 to UBound(check_fields)
		try_it = Request(check_fields(i))
		if try_it <> "" then
			if FormulaFields <> "" then
				FormulaFields = FormulaFields & "," & check_fields(i)
			else
				FormulaFields = check_fields(i)
			end if
		end if
	next

	AddSubFormNames dbkey, formgroup, FormulaFields 
	rel_fields = GetFormGroupVal(dbkey, formgroup, kRelFields)
	check_fields = Split(rel_fields, ",", -1)
	RelFields = ""
	for i = 0 to UBound(check_fields)
		if inStr(check_fields(i), ";") >0 then
			try_it_split = Split(check_fields(i), ";", -1)
			try_it = Request(try_it_split(0))
		else
			try_it = Request(check_fields(i))
		end if
		if try_it <> "" then
			if RelFields <> "" then
				RelFields = RelFields & "," & check_fields(i)
			else
				RelFields = check_fields(i)
			end if
		end if
	next

	'populate arrays
	ClearSearchData dbkey, formgroup, "New"
	bChemSearch = false
	bRelsearch = false
	SearchStrategy = Request("SearchStrategy")
	SearchType = LCase(Request("struc_search_type"))
	if Not SearchType <> "" then SearchType = "exact"
	Select Case SearchType
		Case "substructure"
			SubSearchFields = StrucFields
			AddSubFormNames dbkey, formgroup, SubSearchFields 
		Case "exact"
			ExactFields = StrucFields
			AddSubFormNames dbkey, formgroup, ExactFields 
		Case "similarity"
			SimSearchFields = StrucFields
			AddSubFormNames dbkey, formgroup, SimSearchFields
		Case "identity"
			IdentitySearchFields = StrucFields
			AddSubFormNames dbkey, formgroup, IdentitySearchFields	 
	End Select

	if Not SearchStrategy <> "" then
		if SubSearchFields <> "" then bChemSearch = True
		if ExactFields <> "" then bChemSearch = True
		if MWFields <> "" then bChemSearch = True
		if FormulaFields <> "" then bChemSearch = True
		if SimSearchFields <> "" then bChemSearch = True
		if IdentitySearchFields <> "" then bChemSearch = True
		if RelFields <> "" then bRelsearch = True
		if bChemSearch = True AND bRelSearch = True then SearchStrategy = "chem_rel"
		if bChemSearch = False AND bRelSearch = True then SearchStrategy = "rel"
		if bChemSearch = True AND bRelSearch = False then SearchStrategy = "chem_only"
	end if

	Session("SearchData" & "SearchStrategy" & dbkey & formgroup) = SearchStrategy
	Session("SearchData" & "SubStructure" & dbkey & formgroup) = SubSearchFields
	Session("SearchData" & "MolWeight" & dbkey & formgroup) = MWFields
	Session("SearchData" & "Formula" & dbkey & formgroup) = FormulaFields
	Session("SearchData" & "Relational" & dbkey & formgroup) = RelFields
	Session("SearchData" & "Exact" & dbkey & formgroup) = ExactFields
	Session("SearchData" & "Similarity" & dbkey & formgroup) = SimSearchFields
	Session("SearchData" & "Identity" & dbkey & formgroup) = IdentitySearchFields
	'split field array and then get data from form using addData sub
	AddData "ChemFields", Session("SearchData" & "Similarity" & dbkey & formgroup)
	AddData "ChemFields", Session("SearchData" & "Identity" & dbkey & formgroup)
	AddData "ChemFields", Session("SearchData" & "Exact" & dbkey & formgroup)
	AddData "ChemFields", Session("SearchData" & "SubStructure" & dbkey & formgroup)
	AddData "ChemFields", Session("SearchData" & "MolWeight" & dbkey & formgroup)
	AddData "ChemFields", Session("SearchData" & "Formula" & dbkey & formgroup)
	AddData "RelFields", Session("SearchData" & "Relational" & dbkey & formgroup)
	relSearch = Session("SearchData" & "Relational" & dbkey & formgroup)

	If relSearch <> "" then
		Session("SearchData" & "RelPortion" & dbkey & formgroup)=  GetRelFields(dbkey, formgroup, relSearch)
	End If

End Sub

'-------------------------------------------------------------------------------
' Name: StoreChemSearchData(dbkey, formgroup)
' Type: Sub
' Purpose: Store all search session objects as LastSearch objects for later recall
' Inputs dbkey as string, formgroup as string
' Returns: none
' Comments: populates Session("LastSearchData" & ...) for each corresponding Session("SearchData" & ...) variable
'-------------------------------------------------------------------------------
Sub StoreChemSearchData(ByVal dbkey, ByVal formgroup)
	ClearSearchData dbkey, formgroup,  "Last"
	Session("LastSearchData" & "SearchStrategy" & dbkey & formgroup) = Session("SearchData" & "SearchStrategy" & dbkey & formgroup)
	Session("LastSearchData" & "SubStructure" & dbkey & formgroup)= Session("SearchData" & "SubStructure" & dbkey & formgroup)
	Session("LastSearchData" & "MolWeight" & dbkey & formgroup)= Session("SearchData" & "MolWeight" & dbkey & formgroup)
	Session("LastSearchData" & "Formula" & dbkey & formgroup)= Session("SearchData" & "Formula" & dbkey & formgroup)
	Session("LastSearchData" & "Relational" & dbkey & formgroup)= Session("SearchData" & "Relational" & dbkey & formgroup)
	Session("LastSearchData" & "Exact" & dbkey & formgroup)= Session("SearchData" & "Exact" & dbkey & formgroup)
	Session("LastSearchData" & "Similarity" & dbkey & formgroup)=  Session("SearchData" & "Similarity" & dbkey & formgroup)
	Session("LastSearchData" & "Identity" & dbkey & formgroup)=  Session("SearchData" & "Identity" & dbkey & formgroup)
	'split field array and then get data from form using addData sub
	StoreData "ChemFields", Session("SearchData" & "Similarity" & dbkey & formgroup)
	StoreData "ChemFields", Session("SearchData" & "Identity" & dbkey & formgroup)
	StoreData "ChemFields", Session("SearchData" & "Exact" & dbkey & formgroup)
	StoreData "ChemFields", Session("SearchData" & "SubStructure" & dbkey & formgroup)
	StoreData "ChemFields", Session("SearchData" & "MolWeight" & dbkey & formgroup)
	StoreData "ChemFields", Session("SearchData" & "Formula" & dbkey & formgroup)
	StoreData "RelFields", Session("SearchData" & "Relational" & dbkey & formgroup)
	Session("LastSearchData" & "RelPortion" & dbkey & formgroup)=Session("SearchData" & "RelPortion" & dbkey & formgroup)
End Sub



'-------------------------------------------------------------------------------
' Name: RestoreChemSearchData(dbkey, formgroup)
' Type: Sub
' Purpose: Restore all search session objects form Session("LastSearchData"...) objects 
' Inputs dbkey as string, formgroup as string
' Returns: none
' Comments: populates Session("SearchData" & ...) for each corresponding Session("LastsSearchData" & ...) variable
'-------------------------------------------------------------------------------
Sub RestoreChemSearchData(ByVal dbkey, ByVal formgroup)
	ClearSearchData dbkey, formgroup, "New"
	Session("SearchData" & "SearchStrategy" & dbkey & formgroup) = Session("LastSearchData" & "SearchStrategy" & dbkey & formgroup)
	Session("SearchData" & "SubStructure" & dbkey & formgroup)= Session("LastSearchData" & "SubStructure" & dbkey & formgroup)
	Session("SearchData" & "MolWeight" & dbkey & formgroup)= Session("LastSearchData" & "MolWeight" & dbkey & formgroup)
	Session("SearchData" & "Formula" & dbkey & formgroup)= Session("LastSearchData" & "Formula" & dbkey & formgroup)
	Session("SearchData" & "Relational" & dbkey & formgroup)= Session("LastSearchData" & "Relational" & dbkey & formgroup)
	Session("SearchData" & "Exact" & dbkey & formgroup)= Session("LastSearchData" & "Exact" & dbkey & formgroup)
	Session("SearchData" & "Similarity" & dbkey & formgroup)=  Session("LastSearchData" & "Similarity" & dbkey & formgroup)
	Session("SearchData" & "Identity" & dbkey & formgroup)=  Session("LastSearchData" & "Identity" & dbkey & formgroup)

	'split field array and then get data from form using addData sub
	RestoreData "ChemFields", Session("SearchData" & "Similarity" & dbkey & formgroup)
	RestoreData "ChemFields", Session("SearchData" & "Identity" & dbkey & formgroup)
	RestoreData "ChemFields", Session("SearchData" & "Exact" & dbkey & formgroup)
	RestoreData "ChemFields", Session("SearchData" & "SubStructure" & dbkey & formgroup)
	RestoreData "ChemFields", Session("SearchData" & "MolWeight" & dbkey & formgroup)
	RestoreData "ChemFields", Session("SearchData" & "Formula" & dbkey & formgroup)
	RestoreData "RelFields", Session("SearchData" & "Relational" & dbkey & formgroup)
	Session("SearchData" & "RelPortion" & dbkey & formgroup)=Session("LastSearchData" & "RelPortion" & dbkey & formgroup)
End Sub



'-------------------------------------------------------------------------------
' Name: StoreData(fieldtype, fldinputstr)
' Type: Sub
' Purpose: Store Field Data in Session("LastSearchData"...) variable
' Inputs fieldtype as INT, field name list  as comma delimited string
' Returns: none
'-------------------------------------------------------------------------------
Sub StoreData(ByVal fieldtype, ByVal fldinputstr)
	fieldarray =  Split(fldinputstr, ",", -1)
	for j = 0 to UBound(fieldarray)
		If fieldtype = "RelFields" then
			relname = split(fieldarray(j), ";", -1)
			Session("LastSearchData" & relname(0) & dbkey & formgroup)=Session("SearchData" & relname(0) & dbkey & formgroup)
		Else
			Session("LastSearchData" & fieldarray(j) & dbkey & formgroup)=Session("SearchData" & fieldarray(j) & dbkey & formgroup)
		End If
	Next
End Sub



'-------------------------------------------------------------------------------
' Name: RestoreData(fieldtype, fldinputstr)
' Type: Sub
' Purpose: Retore Field Data to Session("SearchData"...) variable
' Inputs fieldtype as INT, field name list  as comma delimited string
' Returns: none
'-------------------------------------------------------------------------------
Sub RestoreData(ByVal fieldtype, fldinputstr)
	fieldarray =  Split(fldinputstr, ",", -1)
	for j = 0 to UBound(fieldarray)
		If fieldtype = "RelFields" then
			relname = split(fieldarray(j), ";", -1)
			Session("SearchData" & relname(0) & dbkey & formgroup)=Session("LastSearchData" & relname(0) & dbkey & formgroup)
		Else
			Session("SearchData" & fieldarray(j) & dbkey & formgroup)=Session("LastSearchData" & fieldarray(j) & dbkey & formgroup)
		End If
	Next
End Sub



'-------------------------------------------------------------------------------
' Name: ClearData(fieldtype, searchtype, fldinputstr)
' Type: Sub
' Purpose: Clear Field Data to Session("SearchData"...) variable
' Inputs fieldtype as INT, search type as string (default "new"), field name list  as comma delimited string
' Returns: none
'-------------------------------------------------------------------------------
Sub ClearData(ByVal fieldtype, ByVal searchtype, ByVal fldinputstr)
	If searchtype = "New" then
		searchtype = ""
	End If
	fieldarray =  Split(fldinputstr, ",", -1)
	on error resume next
	for j = 0 to UBound(fieldarray)
		If UCase(fieldtype) = "RELFIELDS" then
			relname = split(fieldarray(j), ";", -1)
			Session(searchtype & "SearchData" & relname(0) & dbkey & formgroup)=""
		Else
			Session(searchtype & "SearchData" & fieldarray(j) & dbkey & formgroup)=""
		End If
	Next
End Sub



'-------------------------------------------------------------------------------
' Name: AddData(fieldtype, fldinputstr)
' Type: Sub
' Purpose: Add Relational Field Data to Session("SearchData"...) variables
' Inputs fieldtype as INT,  field name list  as comma delimited string
' Returns: none
'-------------------------------------------------------------------------------
Sub AddData(ByVal fieldtype, ByVal fldinputstr)
	fieldarray =  Split(fldinputstr, ",", -1)
	for j = 0 to UBound(fieldarray)
		If fieldtype = "RelFields" then
			'jhs 10/30/2007 - why are these i
			'i am switching to j to fix csbr-85255
			'the reason it shows up here is because data is being passed during the load
			'if Not inStr(fieldArray(i), ";") >0 then
			'	new_field_name= appendDataType(dbkey, formgroup, fieldArray(i))
				'if Not new_field_name <> "" then
				'	LogAction ("field_type_missing for" & fieldArray(i) & ": field ignored for sql query")
				'else
				'	fieldArray(i) = new_field_name
				'end if
			if Not inStr(fieldArray(j), ";") >0 then
				new_field_name= appendDataType(dbkey, formgroup, fieldArray(j))
				if Not new_field_name <> "" then
					LogAction ("field_type_missing for" & fieldArray(j) & ": field ignored for sql query")
				else
					fieldArray(j) = new_field_name
				end if
			end if
			relname = split(fieldarray(j), ";", -1)
			Session("SearchData" & relname(0) & dbkey & formgroup)= Request(relname(0))
		Else
			Session("SearchData" & fieldarray(j) & dbkey & formgroup)= Request(fieldarray(j))
		End If
	Next
End Sub



'-------------------------------------------------------------------------------
' Name: GetFieldCorr(dbkey, formgroup, fieldtype, fieldname)
' Type: Sub
' Purpose: map a generic field name to its real name
' Inputs dbkey as string, formgroup as string, fieldtype as Enum,  field name as string
'	fieldtype enum
		'MOLWEIGHT
		'FORMULA
		'STRUCTURE
		'OTHERFIELD
' Returns: none
'-------------------------------------------------------------------------------
Function GetFieldCorr(ByVal dbkey, ByVal formgroup, ByVal fieldtype, ByVal fieldname)
	fieldtype = UCase(fieldtype)
	fieldmapgroup = Application(formgroup & dbkey & "FieldMapGroup")
	fieldtype = UCase(fieldtype)
	Select Case fieldtype
		Case "MOLWEIGHT"
			mw_field_corr = GetFieldMapVal(dbkey, fieldmapgroup, kMolWeightMap)
			corr_field_name=GetFieldName(mw_field_corr, fieldname)
		Case "FORMULA"
			formula_field_corr = GetFieldMapVal(dbkey, fieldmapgroup, kFormulaMap)
			corr_field_name=GetFieldName(formula_field_corr, fieldname)
		Case "STRUCTURE"
			struc_field_corr =GetFieldMapVal(dbkey, fieldmapgroup, kStructureMap)
			corr_field_name=GetFieldName(struc_field_corr, fieldname)
		Case "OTHERFIELD"
			other_field_corr = GetFieldMapVal(dbkey, fieldmapgroup, kOtherFieldMap)
			corr_field_name=GetFieldName(other_field_corr, fieldname)
		Case Else
			strucfields = getFormGroupval(dbkey, formgroup, kStructureFields)
			
			if Instr(UCase(strucfields), Ucase(fieldname)) then
				struc_field_corr =GetFieldMapVal(dbkey, fieldmapgroup, kStructureMap)
				corr_field_name=GetFieldName(struc_field_corr, fieldname)
			else
				mwfields = getFormGroupval(dbkey, formgroup, kMWFields)
				if Instr(UCase(mwfields), Ucase(fieldname)) then
					mw_field_corr = GetFieldMapVal(dbkey, fieldmapgroup, kMolWeightMap)
					corr_field_name=GetFieldName(mw_field_corr, fieldname)
				else
					formulafields = getFormGroupval(dbkey, formgroup, kFormulaFields)
					if Instr(UCase(formulafields), Ucase(fieldname)) then
						formula_field_corr = GetFieldMapVal(dbkey, fieldmapgroup, kFormulaMap)
						corr_field_name=GetFieldName(formula_field_corr, fieldname)
					else
						other_field_corr = GetFieldMapVal(dbkey, fieldmapgroup, kOtherFieldMap)
						corr_field_name=GetFieldName(other_field_corr, fieldname)
					end if
				end if
			end if
				
	End Select
	GetFieldCorr=corr_field_name
End Function



'-------------------------------------------------------------------------------
' Name: GetFieldName(fieldstr, fieldname)
' Type: Sub
' Purpose: return a field name from a string
' Inputs fieldstr as ":" separated list, field name as string
' Returns: field name as string
'-------------------------------------------------------------------------------
Function GetFieldName(fieldstr, fieldname)
	on error resume next
	field_str_array_1 = Split(fieldstr, ":", -1)
	for i = 0 to UBound(field_str_array_1)
		if instr(1,field_str_array_1(i), ",") > 0 then 
			field_str_array_2 = Split(field_str_array_1(i), ",", -1)
			if inStr(1, UCase(field_str_array_2(0)),UCase(fieldname)) > 0 then
				corr_field = field_str_array_2(1)
			exit for
			End If
		End if	
	next
	GetFieldName = corr_field 
End Function

		

'-------------------------------------------------------------------------------
' Name: CreateTableList(dbkey, formgroup, strGetFields)
' Type: Function
' Purpose: get a list of tables (which exludes the base table) from an input string list with fieldname.tablename,fieldname2.tablename2 format.
' Inputs: dbkey as string, formgroup as string, comma delimite list of fieldname.tablename(s) as string
' Returns: list of tables parsed from list as string
'-------------------------------------------------------------------------------
Function CreateTableList(dbkey, formgroup, strGetFields)
	basetable = GetBaseTable(dbkey, formgroup, "basetable")
	temp_array= split(strGetFields, ",", -1)
		for i = 0 to UBound(temp_array)
			if inStr(temp_array(i), ".")>0 then
				temp2 = split(temp_array(i), ".", -1)
				if Ubound(temp2) = 2 then
					tablename = temp2(0) & "." & temp2(1)
				else
					tablename = temp2(0)
				end if
			else
				tablename = temp_array(i)
			end if
			If Not tablename =  basetable then
				if subform_list <> "" then
					subform_list = subform_list & "," & tablename
				else
					subform_list = tablename
				end if
			end if
		next
	CreateTableList = subform_list
End Function


'-------------------------------------------------------------------------------
' Name: GetBaseRecordset(dbkey, formgroup, stype, recsetflag, strwhere)
' Type: sub
' Purpose: build a select statement and return a recordset
' Inputs: dbkey as string, formgroup as string, search type as enum, recordset flag as enum, where clause as string
'	stype enum values:
'		cows_sql_session ' get returnfields from request("return_fields")
'		cows_sql_request  'get returnfield from  Session("strGetFields" & dbkey & formgroup)
'		full_sql    - strWhere input requires only the base table and base Id in select statement
'		full_sql_as_is - strWhere input represents full sql statement
'	recsetflag enum values
'		get_next -  - get next set of hits from csdo hitlist
'		chem_only - chemical search only
'		no_gui	- post is not using the gui
'		marked	- recordset is marked hits sting
'		Make_Table - no longer used
'		chem_rel - chemical and relational search
'		rel - relational search
' Returns: list of tables parsed from list as string
'-------------------------------------------------------------------------------
Sub GetBaseRecordset(ByVal dbkey, ByVal formgroup, ByVal stype, ByVal recsetflag, ByVal strWhere)
	If Session("error" & dbkey & formgroup)= True then exit Sub
		if not inStr(UCase(stype),"FULL_SQL")>0 then
			strWhere = Replace(strWhere, "*", "%")
		end if
		
			basetable = GetBaseTable(dbkey, formgroup, "basetable")
			moltable = GetBaseTable(dbkey, formgroup, "moltable")
			SQLSyntax = GetTableVal(dbkey, basetable,kSQLSyntax)
			baseid = GetTableVal(dbkey, basetable, kPrimaryKey)
			strucid = GetTableVal(dbkey, basetable, kStrucFieldID)
		
		if  UCase(basetable)= UCase(moltable) then
			bSameTable = True
		else
			bSameTable = False
		end if
		'check if there are group by or order by fields in the request
		sortOrderString = prepareSortOrder(dbkey, formgroup,SQLSyntax)
		if sortOrderString <> "" then
			strWhere = strWhere & " " & sortOrderString
		end if

		Select Case recsetflag
			Case "get_next"
				strWhere = Replace(strWhere, "*", "%")
				maxhits = Session("GetNextMaxHits" & dbkey & formgroup)
				strGetFields =  basetable  & "." & baseid
				baseselect=	BuildSelectStatement(dbkey, formgroup, basetable, Session("strWhereSubforms" & dbkey & formgroup), strGetFields, maxhits)
				sql = baseselect & strWhere
				rsname = "Base_RS"
				Session(rsname & dbkey & formgroup) = CreateRecordset(rsname, dbkey, formgroup, sql, maxhits, adOpenForwardOnly, adLockReadOnly)
			Case "chem_only"
				strWhere = Replace(strWhere, "*", "%")
				maxhits = Application("MaxHits" & dbkey) 
				strGetFields =  basetable  & "." & baseid
				baseselect=	BuildSelectStatement(dbkey, formgroup, basetable, Session("strWhereSubforms" & dbkey & formgroup), strGetFields, maxhits)
				sql = baseselect & strWhere	
				rsname = "Base_RS"
				Session(rsname & dbkey & formgroup) = CreateRecordset(rsname, dbkey, formgroup, sql, maxhits, adOpenForwardOnly, adLockReadOnly)
			Case "no_gui"
				
				select case stype
					case "cows_sql_request" 'used when post file is from an external directory 
					
						strGetFields = request("return_fields")
					
						AddSubFormNames dbkey, formgroup, strGetFields
						if Not strGetFields <> "" then
							strWhere = Replace(strWhere, "*", "%")
							strGetFields =  basetable  & "." & baseid
						end if	
						
						baseselect=	BuildSelectStatement(dbkey, formgroup, basetable, Session("strWhereSubforms" & dbkey & formgroup), strGetFields, maxhits)
						
						sql = baseselect & strWhere	
					
					case "cows_sql_session" 'used when post file is in a  local directory
						strGetFields = Session("strGetFields" & dbkey & formgroup)
						if Not strGetFields <> "" then
							strWhere = Replace(strWhere, "*", "%")
							strGetFields =  basetable  & "." & baseid
							tablelist = ""
						else
							tablelist = CreateTableList(dbkey, formgroup, strGetFields)
						end if
						baseselect=	BuildSelectStatement(dbkey, formgroup, basetable, tablelist, strGetFields, maxhits)
						sql = baseselect & strWhere	
						
					case "full_sql"
					
						if bSameTable = True then
							sql=strWhere
						else
							sql = "SELECT [" & Trim(basetable) & "]" & "." & "[" &  Trim(strucid)  & "]" & " WHERE (" & strWhere & ")"
						end if
					case "full_sql_as_is"
							sql=strWhere
							
					end select
					Session("SearchData" & "FULL_SQL" & dbkey & formgroup)=sql
					rsname = "no_gui"
					
					on error resume next
				
					Set Session(rsname & dbkey & formgroup) = CreateRecordset(rsname, dbkey, formgroup, sql, maxhits, adOpenForwardOnly, adLockReadOnly)
					on error goto 0
					exit sub				
				Case "marked"
					strWhere = Replace(strWhere, "*", "%")
					maxhits = Application("MaxHits" & dbkey) 
					strGetFields =  basetable  & "." & baseid
					
					StoreSessionOrderby = Session("Order_BY" & dbkey & formgroup)
					StoreSessionSortDirection = Session("Sort_direction" & dbkey & formgroup)
					Session("Order_BY" & dbkey & formgroup) = ""
					Session("Sort_direction" & dbkey & formgroup) = ""
					baseselect=	BuildSelectStatement(dbkey, formgroup, basetable, "", strGetFields, maxhits)
					Session("Order_BY" & dbkey & formgroup) = StoreSessionOrderby
					Session("Sort_direction" & dbkey & formgroup) = StoreSessionSortDirection
					if inStr(strWhere, "ORDER BY")> 0 then
						strWheretemp = split(strWhere, "ORDER BY", -1)
						strWhere = strWheretemp(0)
					end if
					if inStr(strWhere, "GROUP BY")> 0 then
						strWheretemp = split(strWhere, "GROUP BY", -1)
						strWhere =  strWheretemp(0)
					end if
					sql = baseselect & strWhere
					Session("SearchData" & "FullStrWhere" & dbkey & formgroup) = strWhere
					rsname = "Look_Ahead"
					Session("Base_RS" & dbkey & formgroup) = CreateRecordset(rsname, dbkey, formgroup, sql, maxhits, adOpenForwardOnly, adLockReadOnly)		
				Case "Make_Table" 'populates the MOL_ID field in the sessions temp directory in the database being searched
					if not stype = "full_sql" then
						strWhere = Replace(strWhere, "*", "%")
						maxhits = ""
						strGetFields =  basetable  & "." & strucid
						baseselect=	BuildSelectStatement(dbkey, formgroup, basetable,Session("strWhereSubforms" & dbkey & formgroup),strGetFields, maxhits)
						sql = baseselect & strWhere		
	
					else
						if bSameTable = True then 
							sql=strWhere
						else
							sql = "SELECT [" & Trim(basetable) & "]" & "." & "[" &  Trim(strucid)  & "]" & " WHERE (" & strWhere & ")"
						end if
					End if
					rsname = "Make_Table"
					rsname = CreateRecordset(rsname, dbkey, formgroup, sql, maxhits, adOpenForwardOnly, adLockReadOnly)
					Exit Sub
			Case "chem_rel"
				strWhere = Replace(strWhere, "*", "%")
				'DGB I don't see a reason to add 1 to max hits
				maxhits = Application("MaxHits" & dbkey)
				strGetFields =  basetable  & "." & baseid
				baseselect=	BuildSelectStatement(dbkey, formgroup, basetable, Session("strWhereSubforms" & dbkey & formgroup), strGetFields, maxhits)
				sql = baseselect & strWhere	
				rsname = "Base_RS"
				Session(rsname & dbkey & formgroup) = CreateRecordset(rsname, dbkey, formgroup, sql, maxhits, adOpenForwardOnly, adLockReadOnly)
			
			Case "rel"
			
				if stype = "full_sql" then
					sql = strWhere
					Session("SearchData" & "FULL_SQL" & dbkey & formgroup)=sql
					if UseCartridge(dbkey, formgroup) and instr(UCase(sql), " ORDER BY ")>0 then
							'need to populate session("order_by" & dbkey & formgroup) and session("sort_direction") & dbkey & formgroup
							setOrderBySessVariable dbkey, formgroup, sql 
					end if
					maxhits = 0
					rsname = "Base_RS"
				else 
					if stype = "full_sql_w_max" then
						sql = strWhere		
						Session("SearchData" & "FULL_SQL" & dbkey & formgroup)=sql
						if UseCartridge(dbkey, formgroup) and instr(UCase(sql), " ORDER BY ")>0 then
							'need to populate session("order_by" & dbkey & formgroup) and session("sort_direction") & dbkey & formgroup
							setOrderBySessVariable dbkey, formgroup, sql 
						end if
						'DGB I don't see a reason to add 1 to max hits
						maxhits = Application("MaxHits" & dbkey)
						rsname = "Look_Ahead"
					else
						strWhere = Replace(strWhere, "*", "%")
						strWhere = Replace(strWhere, "%%", "%")
						'DGB I don't see a reason to add 1 to max hits
						maxhits = Application("MaxHits" & dbkey)
						strGetFields =  basetable  & "." & baseid
						subForms = Session("strWhereSubforms" & dbkey & formgroup)
						baseselect=	BuildSelectStatement(dbkey, formgroup, basetable, Session("strWhereSubforms" & dbkey & formgroup), strGetFields, maxhits)
						startSQL = ""
						addedSQL = ""
						closingSQL = ""
						'Additional SQL to make Substructure search adhere Registration RLS restrictions too;
						'Fix also takes care of Inventory ONLY searches by including Union All
						if lcase(dbkey) = "cheminv" and lcase(formgroup) = "base_form_group" and lcase(basetable) = "inv_vw_compounds" and (subForms = "NULL" or subForms = "") then
							if instr(ucase(baseselect), " WHERE ") > 0 then
								startSQL = "select distinct * from (( "
								baseselect = replace(baseselect, " WHERE ", "")
								addedSQL = " WHERE (inv_vw_compounds.reg_id_fk is not null and "  & strWhere & " and exists (select 1 from INV_VW_REG_BATCHES, INV_VW_REG_STRUCTURES where inv_vw_compounds.reg_id_fk = INV_VW_REG_BATCHES.regid and INV_VW_REG_STRUCTURES.RegID=INV_VW_REG_BATCHES.RegID)) or (inv_vw_compounds.reg_id_fk is null and "
								closingSQL = " ))) inv_vw_compounds1, inv_vw_compounds where inv_vw_compounds1.compound_id = inv_vw_compounds.compound_id "
							end if
						end if
						sql = startSQL & baseselect & addedSQL & strWhere & closingSQL
						Session("SearchData" & "FULL_SQL" & dbkey & formgroup)=sql
						rsname = "Look_Ahead"
						
					end if
				end if
				
				Session("Base_RS" & dbkey & formgroup) = CreateRecordset(rsname, dbkey, formgroup, sql, maxhits, adOpenForwardOnly, adLockReadOnly)
					
			Case "get_next_rel"
		
				strWhere = Replace(strWhere, "*", "%")
				strWhere = Replace(strWhere, "%%", "%")
				'DGB I don't see a reason to add 1 to max hits
				maxhits = Session("GetNextMaxHits" & dbkey & formgroup)
				full_sql = replace(Session("SearchData" & "FULL_SQL" & dbkey & formgroup), " where ", " WHERE ")
				full_sql = replace(full_sql, " Where ", " WHERE ")
				full_sql = replace(full_sql, " From ", " FROM ")
				full_sql = replace(full_sql, " from ", " FROM ")
				full_sql = replace(full_sql, "Select ", "SELECT ")
				full_sql = replace(full_sql, "select ", "SELECT ")
				Session("SearchData" & "FULL_SQL" & dbkey & formgroup)=full_sql
				strWhere = replace(strWhere, " where ", " WHERE ")
				strWhere = replace(strWhere, " Where ", " WHERE ")
				strWhere = replace(strWhere, " From ", " FROM ")
				strWhere = replace(strWhere, " from ", " FROM ")
				strWhere = replace(strWhere, "Select ", "SELECT ")
				strWhere = replace(strWhere, "select ", "SELECT ")
				'Response.write Session("SearchData" & "FULL_SQL" & dbkey & formgroup)
				if inStr(Ucase(Session("SearchData" & "FULL_SQL" & dbkey & formgroup)), "ORDER BY") > 0 or inStr(UCase(strWhere), "GROUP BY")> 0 then
					if inStr(UCase(strWhere), "SELECT")=1 then
						sql = strWhere
					else
						strGetFields =  basetable  & "." & baseid				
						baseselect=	BuildSelectStatement(dbkey, formgroup, basetable, Session("strWhereSubforms" & dbkey & formgroup), strGetFields, maxhits)
						sql = baseselect & strWhere		
					end if
					'!DGB! 04/17/01 hardcoded sql for getmore from hitlist
					'LJB 4/19 made this more flexible so to include other DMBS
					'LJB 10/14 added support for order by and group by queries
					TranlateRelKey=baseid
					if inStr(UCase(Session("SearchData" & "FULL_SQL" & dbkey & formgroup)), " WHERE ")> 0 then
						temp_array = split(Session("SearchData" & "FULL_SQL" & dbkey & formgroup), " WHERE ", -1)
						WhereClause = temp_array(1)
						temp_array2 = split(temp_array(0), " FROM ", -1)
						FromClause = temp_array2(1)
					else
						WhereClause = ""
						temp_array2 = split(Session("SearchData" & "FULL_SQL" & dbkey & formgroup), " FROM ", -1)
						FromClause = temp_array2(1)
					end if
					SelectClause = temp_array2(0)
					basetable = getTableVal(dbkey, basetable, kTableRealName)
					on error goto 0
					Select Case UCase(SQLSyntax)
							Case "ACCESS"
								if inStr(SelectClause, ",")> 0 then
									SelectClauseTemp = Split(temp_array2(0),"[" & basetable & "].[" & baseid & "]",-1)
									if Not SelectClauseTemp(1)  = "," then
										SelectClause = "TOP  " & maxhits & " " &  "[" & basetable & "].[" & baseid & "]" & SelectClauseTemp(1) 
									else
										SelectClause = "TOP  " & maxhits & " " &  "[" & basetable & "].[" & baseid & "]"
									end if
								Else
									SelectClause = "TOP  " & maxhits & " " &  "[" & basetable & "].[" & baseid & "]"
								End if
								if WhereClause <> "" then
									WhereClause = " AND " & WhereClause
								end if
								sql = "SELECT " & SelectClause &  " FROM " & FromClause & ",CSDOhitlist" & " WHERE  CSDOHitList.hitlistID=" & Session("hitlistID" & dbkey & formgroup) & " AND CSDOhitlist.ID=" &  basetable & "." & TranlateRelKey  & WhereClause
								
							Case "ORACLE"
							
								if UCase(dbkey) = "REG" then
									schema_name= Application("REG_USERNAME")
								else
									schema_name= Application(dbkey & "_USERNAME")
								end if
								if WhereClause <> "" then
									WhereClause = " AND " & WhereClause
								end if
								
								if UseCartridge(dbkey, formgroup) then
									'LJB 2/2/2004 send in the original sql string, maxhits are taken care of in the cartridge code
									sql=Session("SearchData" & "FULL_SQL" & dbkey & formgroup)
								else
									sql =  SelectClause &  " FROM " & FromClause & ","  & schema_name & ".CSDOhitlist" & " WHERE  " & schema_name & ".CSDOHitList.hitlistID=" & Session("hitlistID" & dbkey & formgroup) & " AND " & schema_name & ".CSDOhitlist.ID=" &  basetable & "." & TranlateRelKey   & WhereClause 
								end if
								if UseCartridge(dbkey, formgroup) and instr(UCase(sql), " ORDER BY ")>0 then
									'need to populate session("order_by" & dbkey & formgroup) and session("sort_direction") & dbkey & formgroup
									setOrderBySessVariable dbkey, formgroup, sql 
								end if
							Case "SQLSERVER"
								if inStr(SelectClause, ",")> 0 then
									SelectClauseTemp = Split(temp_array2(0),"[" & basetable & "].[" & baseid & "]",-1)
									if Not SelectClauseTemp(1)  = "," then
										SelectClause = "TOP  " & maxhits & " " &  "[" & basetable & "].[" & baseid & "]" & SelectClauseTemp(1) 
									else
										SelectClause = "TOP  " & maxhits & " " &  "[" & basetable & "].[" & baseid & "]"
									end if
								Else
									SelectClause = "TOP  " & maxhits & " " &  "[" & basetable & "].[" & baseid & "]"
								End if
								if WhereClause <> "" then
									WhereClause = " AND " & WhereClause
								end if
								sql = "SELECT " & SelectClause &  " FROM " & FromClause & ",CSDOhitlist" & " WHERE  CSDOHitList.hitlistID=" & Session("hitlistID" & dbkey & formgroup) & " AND CSDOhitlist.ID=" &  basetable & "." & TranlateRelKey   & WhereClause 
						end select
					else 'if inStr(Ucase(Session("SearchData" & "FULL_SQL" & dbkey & formgroup)), "ORDER BY") > 0 or inStr(UCase(strWhere), "GROUP BY")> 0 then
						'else case assumes no order by clause and thus uses simpler sql
						on error goto 0
						basetable = GetBaseTable(dbkey, formgroup, "basetable")
						baseid = GetTableVal(dbkey, basetable, kPrimaryKey)
						SQLSyntax = GetTableVal(dbkey, basetable,kSQLSyntax)
						TranlateRelKey=baseid
						basetable = getTableVal(dbkey, basetable, kTableRealName)
						Select Case UCase(SQLSyntax)
							Case "ACCESS", "SQLSERVER"
								
								sql= "Select TOP  " & maxhits & " " &   basetable & "." & baseid & " From " &  basetable & ",CSDOhitlist WHERE CSDOhitlist.ID=" &  basetable & "." & TranlateRelKey & " AND CSDOHitList.hitlistID=" & Session("hitlistID" & dbkey & formgroup) & " ORDER BY " & basetable & "." & baseid
								trace "GetMore SQL:" & sql , 8
							Case "ORACLE"
								if UCase(dbkey) = "REG" then
									schema_name= Application("REG_USERNAME")
								else
									schema_name= Application(dbkey & "_USERNAME")
								end if
								if UseCartridge(dbkey, formgroup) then
									'LJB 2/2/2004 send in the original sql string, maxhits are taken care of in the cartridge code
									sql=Session("SearchData" & "FULL_SQL" & dbkey & formgroup)
								else
									sql= "Select " &   basetable & "." & baseid & " From " &  basetable & "," & schema_name & ".CSDOhitlist WHERE " &  schema_name & ".CSDOhitlist.ID=" &  basetable & "." & TranlateRelKey &  " AND " & schema_name & ".CSDOHitList.hitlistID=" & Session("hitlistID" & dbkey & formgroup) & " ORDER BY " & basetable & "." & baseid
								end if
							' DGB consolidated Acess and SQL server
							
						end select
					end if	'if inStr(Ucase(Session("SearchData" & "FULL_SQL" & dbkey & formgroup)), "ORDER BY") > 0 or inStr(UCase(strWhere), "GROUP BY")> 0 then			
					rsname = "Look_Ahead"
					Session("Base_RS" & dbkey & formgroup) = CreateRecordset(rsname, dbkey, formgroup, sql, maxhits, adOpenForwardOnly, adLockReadOnly)

			End Select
			if baseselect <> "" then
				Session("SearchData" & "BaseSelect" & dbkey & formgroup) = baseselect
			end if
			'create recordset object and recordset inSession("Base_RS" & dbkey & formgroup)
			If not Session("fEmptyRecordset" & dbkey & formgroup) = True then
				SetComment dbkey, formgroup
			Else
				
			Session("fEmptyRecordset" & dbkey & formgroup) = True
			HandleError dbkey, formgroup, "no_records_found", "","", ""
		
		End If
End Sub

	
'-------------------------------------------------------------------------------
' Name: CreateRecordset(rsname, dbkey, formgroup, sql, maxhits, cursertype, locktype)
' Type: Function
' Purpose: Create recordset object and populate 
' Inputs: name to use for recordset as enum, dbkey as string, formgroup as string, sql statement as string,
'	maxhits as CInt, cursortype as INT (no longer used set to ""), locktype as INT (no longer used set to "")
'		rsname enum values:
			' MakeTable - no longer used
			' SD_File - no longer ued
			' BaseRS - standard object for list and detail view
			'	populates array with baseids. recordset set to nothing
			' LookAhead - checks for greater then maxhits and sets flag
			' no_gui - returns hitlist list only
			'	returns recordset
' Returns: reference to recordset or array of baseids depenting on rsname enum value
'-------------------------------------------------------------------------------
Function CreateRecordset(ByVal rsname, ByVal dbkey, ByVal formgroup, ByVal sql,ByVal maxhits, ByVal cursertype, ByVal locktype)
  If Session("error" & dbkey & formgroup)= True then exit Function
	
		basetable = GetBaseTable(dbkey, formgroup, "basetable")
		moltable = GetBaseTable(dbkey, formgroup, "moltable")
		SQLSyntax = GetTableVal(dbkey, basetable,kSQLSyntax)
		baseid = GetTableVal(dbkey, basetable, kPrimaryKey)
		strucid = GetTableVal(dbkey, basetable, kStrucFieldID)
	
	if  UCase(basetable)= UCase(moltable) then
		bSameTable = True
	else
		bSameTable = False
	end if
	Session(rsname &"RecordCount" & dbkey & formgroup)=0
	'if using oracle remove brackets

	if SQLSyntax = "ORACLE" then
		sql = ModifySQL(sql)
	end if
	Select Case rsname
		Case "Make_Table"
			on error resume next
			existingConnection = ""
			Set rs = CSDODoCommand(sql, dbkey, formgroup, maxhits, existingConnection)
			If Not (rs.BOF AND rs.EOF) then
				Session("fEmptyRecordset" & dbkey & formgroup) = False
				uniqueid = strucid
				WriteHitsFromADOSearch rs, records_found, uniqueid
				rs.close
			else
				rs.close
				Session("fEmptyRecordset" & dbkey & formgroup) = True
				HandleError dbkey, formgroup, "no_records_found", "", "",""
			end if
			If err.number > 0 then
				Set rs = Nothing
				HandleError dbkey, formgroup, "make_table", "Chem_Rel Search failed", err.number, err.description
			End If	
			
			Set rs = Nothing
			DataConn.Close
			Set DataConn = Nothing
			CreateRecordset = ""
			Exit Function

		Case "SD_File"
			on error resume next
			'create new recordset object
			
			Set DataConn = GetNewConnection(dbkey, formgroup, "base_connection")
			Set rs = Server.CreateObject("ADODB.RECORDSET")
			if maxhits <> "" then
				rs.MaxRecords = maxhits
			end if
			Set rs = DataConn.Execute(sql)
		
			If err.number <> 0 then
				Session("fEmptyRecordset" & dbkey & formgroup) = True
				DataConn.Close
				Set DataConn = Nothing
				Set rs = Nothing
				HandleError dbkey, formgroup, "recordset", "CreateRecordset-sql", "the following sql did not generate a recordset", sql
			End If	
			record_count = GetRecordCount(dbkey, formgroup, rs)
			
			if Not record_count > 0 then
				Session("fEmptyRecordset" & dbkey & formgroup) = True
				Set rs = Nothing
				Session(rsname &"RecordCount" & dbkey & formgroup) = 0
				IF CBool(Application("ENABLE_SEARCH_LOGGING"))= true then
					on error resume next
						Log_Search dbkey, formgroup, "SD_FILE", sql, record_count
						if err.number = 13 then
							LogAction("Log_Search routine not found") 
							err.Clear()
						end if
					on error goto 0
				end if
				HandleError dbkey, formgroup, "no_records_found", "", "",""
			Else
				Session("fEmptyRecordset" & dbkey & formgroup) = False
				Set CreateRecordset = rs
				Session(rsname &"RecordCount" & dbkey & formgroup) = record_count
				IF CBool(Application("ENABLE_SEARCH_LOGGING"))= true then
					on error resume next
						Log_Search dbkey, formgroup, "SD_FILE", sql, record_count
						if err.number = 13 then
							LogAction("Log_Search routine not found") 
							err.Clear()
						end if
					on error goto 0
				end if
			End If
			
		Case "Base_RS", "Look_Ahead"
			on error goto 0
			
			if sf_DEBUG=True then
				Response.Write "<P width=""200"" align=""left""><FONT FACE=""Arial"" SIZE=""1"" COLOR=""Navy"">search_func_vbs.asp::CreateRecordset()<br>"
				Response.Write "Call CSDODoCommand with SQL:<br>" & sql & "</font></P>"
				Response.End
			end if
			on error resume next
			existingConnection = ""
			
			'DGB 

			
			Session("TooManyHitsCount" & dbkey & formgroup) = ""
			if lcase(Request("dataaction")) = "search" or lcase(Request("restore_hitlist")) = "search" or lcase(Request("dataaction")) = "retrieve_all"  or lcase(Request("dataaction")) = "show_marked" then
				bTooMayHits = CheckTooManyHits(sql,  dbkey,  formgroup, existingConnection)
			end if
			
			if Session("TooManyHitsCount" & dbkey & formgroup)= ""  then
				Set rs = CSDODoCommand(sql, dbkey, formgroup,maxhits,existingConnection)
				rsArray = rs.GetRows(-1)
			End if
			
			if isArray(rsArray) = True  then
			
				temp_record_count = UBound(rsArray, 2) 'array count real count is array + 1
				lastid = rsArray(0,temp_record_count)
				
				if sf_DEBUG=True then
					Response.Write "<P width=""200"" align=""left""><FONT FACE=""Arial"" SIZE=""1"" COLOR=""Red"">"
					Response.Write "CSDODoCommand returned " & temp_record_count+1 & " records.</font></P>"
					Response.End
				end if
				if rsname = "Look_Ahead" then 'rel or rel_get_next : check for get more state					
					check_ahead = (temp_record_count = CLng(maxhits -1))
					if check_ahead = true then
						Session("MoreMolids" & dbkey & formgroup) = True
						Session("LastID" & dbkey & formgroup) = lastid						
					Else
						Session("MoreMolids" & dbkey & formgroup) = False
						Session("LastID" & dbkey & formgroup) = ""
					end if
				end if
				record_count = temp_record_count + 1 'real num records for display 
			else
				record_count = 0
			end if

			if record_count = 0 then
				Session("fEmptyRecordset" & dbkey & formgroup) = True
				CreateRecordset = rsArray
				Set rs = Nothing
				Session("Base_RSRecordCount" & dbkey & formgroup) = 0
				HandleError dbkey, formgroup, "no_records_found", "", "",""
			Else
				Session("fEmptyRecordset" & dbkey & formgroup) = False
				CreateRecordset = rsArray
				Session("Base_RSRecordCount" & dbkey & formgroup)= record_count
				Set rs = Nothing
			End If
		Case  "no_gui"
			on error resume next
			existingConnection = ""
			Set rs = CSDODoCommand(sql, dbkey, formgroup, maxhits,existingConnection)
			If err.number > 0 then
				Session("fEmptyRecordset" & dbkey & formgroup) = True
				DataConn.Close
				Set DataConn = Nothing
				DataConn = ""
				Session("errors_found" & dbkey & formgroup) = err.number & err.description
			End If
			record_count = Session("hitlistrecordcount" & dbkey & formgroup)
			if Not record_count > 0 then
				Session("fEmptyRecordset" & dbkey & formgroup) = True
				Set rs = Nothing
				DataConn.Close
				Set DataConn = Nothing
				DataConn = ""
				Session("errors_found" & dbkey & formgroup) = "no_records_found"
				Session("records_found" & dbkey & formgroup) = 0
			Else
				Session("fEmptyRecordset" & dbkey & formgroup) = False
				Set CreateRecordset = rs
				Session("records_found" & dbkey & formgroup)= record_count
			End If
	End Select
	
	' Log the search
	IF CBool(Application("ENABLE_SEARCH_LOGGING"))= true then
		on error resume next
			Log_Search dbkey, formgroup, Ucase(rsname), sql, record_count
			if err.number = 13 then
				LogAction("Log_Search routine not found") 
				err.Clear()
			end if
		on error goto 0
	end if
	
	if Session("MSIS_TempTableName") <> "" then
		droptemptable dbkey, formgroup, Session("MSIS_TempTableName")
	end if
End Function


'-------------------------------------------------------------------------------
' Name: ModifySQL(sql)
' Type:  Function
' Purpose: remove brackets from sql statement for Oracle compatibility
' Inputs: sql statement as string
' Returns: new sql statement without brackets
'-------------------------------------------------------------------------------
Function ModifySQL(sql)
	newsql = replace(sql,"[","")
	newsql = replace(newsql,"]","")
	'newsql = replace(newsql,"#","'")
	
	'SYAN added 5/21/2004 to put the hint back
	newsql = replace(newsql, "/%", "/*")
	newsql = replace(newsql, "%/ %", "*/ *")
	'End of SYAN modification
	
	'SYAN modified on 11/18/2005 to fix CSBR-61386
	newsql = replace(newsql, "^^^", "[")
	newsql = replace(newsql, "~~~", "]")
	'End of SYAN modification
	ModifySQL = newsql
end Function



'-------------------------------------------------------------------------------
' Name: GetTableRecordCounts(dbkey, formgroup)
' Type:  Sub
' Purpose: Get current record count for base table of formgroup
' Inputs: dbkey as string, formgroup as string
' Returns: none
' Comments: Application("DBRecordCount" & currentDB) with current record count
'-------------------------------------------------------------------------------
Sub GetTableRecordCounts(dbkey, formgroup)
	currentDB = dbkey
	Table_groups_str=Application("TableGroups" & currentDB)
	table_groups_array = split(Table_groups_str, ",", -1)
	for i = 0 to UBound(table_groups_array)
		myCount=0
		theCount=0
		table_group_name = Trim(table_groups_array(i))
		TableGroupArray=Application(table_group_name & currentDB)
		basetable = TableGroupArray(0)
		TableArray = Application(basetable & currentDB)
		ADOConnName = TableArray(9)
		on error resume next
		Set DataConn = GetNewConnection(currentDB, formgroup, ADOConnName)
		'Set RS = Server.CreateObject("ADODB.Recordset")
		sql = "Select Count(*) From " & basetable
		Set RS = DataConn.Execute(sql)

		if err.number > 0 then
			theCount = 0
			Set DataConn = Nothing
			DataConn.Close
			Set RS = Nothing
		else
			if Not (RS.BOF AND RS.EOF)then
				RS.MoveFirst
				theCount=RS.Fields(0)
				RS.Close
			else
				theCount = 0
			end if
			Set RS = Nothing
			DataConn.Close
			Set DataConn = Nothing
		End if

		Application.Lock
		Application(basetable & "RecordCount" & currentDB) = theCount
		if i = 0 then 
			Application("DBRecordCount" & currentDB) = theCount
		end if
		Application.UnLock
	next 'i
End sub

'-------------------------------------------------------------------------------
' Name: GetADOConnString(dbkey, formgroup, conn_name)
' Type:  function
' Purpose: Get full connection string
' Inputs: dbkey as string, formgroup as string, table connection name as string
' Returns: connection string as string
'-------------------------------------------------------------------------------
Function GetADOConnString(ByVal dbkey, ByVal formgroup, ByVal conn_name)
	bLoginRequired = false
	bLoginInfoNeeded = false
	if Not conn_name <> "" then conn_name = "base_connection"
	' logaction "GACS conn_name = " & conn_name
	'if Session("bypass_ini" & dbkey & formgroup) = true then
		'conn_info_array = Application(conn_name)
	'else
		conn_info_array = Application(conn_name & dbkey)
	'end if	
	if not isArray(conn_info_array) then
		DoLoggedOutMsg "search_funcs", "GetADOConnString", "conn_info_Array:Conn_name=" & conn_name & " dbkey=" & dbkey
	end if
	conn_type=conn_info_array(kConn)
		if sf_DEBUG = true then Response.Write "<br>conn_type:" & conn_type
	conn_string=conn_info_array(kConnStr)
		if sf_DEBUG = true then Response.Write "<br>conn_string:" & conn_string

	conn_conn_timeout=conn_info_array(kConnTimeOut)
		if sf_DEBUG = true then Response.Write "<br>conn_conn_timeout:" & conn_conn_timeout

	conn_command_timeout=conn_info_array(kConnConnTimeOut)
		if sf_DEBUG = true then Response.Write "<br>conn_command_timeout:" & conn_command_timeout

	conn_username=conn_info_array(kConnUserName)
		if sf_DEBUG = true then Response.Write "<br>conn_username:" & conn_username
		
	conn_password=conn_info_array(kConnPassword)
		if sf_DEBUG = true then Response.Write "<br>conn_password:" & conn_password

	on error resume next
	conn_dbms = conn_info_array(kDBMS)
		if err.number > 0 then conn_dbms = "ACCESS"
	on error goto 0
	if not conn_dbms <> "" then conn_dbms = "ACCESS"
			if sf_DEBUG = true then Response.Write "<br>conn_dbms:" & conn_dbms
	Select case UCase(conn_dbms)
		Case "ORACLE"
			if conn_username = "login_required"	then
				bLoginRequired = true 
				UserIDKeyword = "UID"
				If Application("UserIDKeyword") <> "" then UserIDKeyword = Application("UserIDKeyword")
				conn_username = UserIDKeyword & "=" & Session("UserName" & dbkey)
			end if
			conn_password=conn_info_array(kConnPassword)
			if conn_password = "login_required"then
				bLoginRequired = true
				PWDKeyword = "PWD"
				If Application("PWDKeyword") <> "" then PWDKeyword =Application("PWDKeyword")
				conn_password = PWDKeyword & "=" & Session("UserID" & dbkey)				
			end if
			
		Case "SQLServer"
			if conn_username = "login_required"	then
				bLoginRequired = true 
				conn_username = "username=" & Session("UserName" & dbkey)
				
			end if
			conn_password=conn_info_array(kConnPassword)
			if conn_password = "login_required"then
				bLoginRequired = true
				conn_password = "password=" & Session("UserID" & dbkey)
				
			end if
				
		Case "ACCESS"
			if conn_username = "login_required"	then
				bLoginRequired = true 
				conn_username =  Session("UserName" & dbkey)
				
			end if
			conn_password=conn_info_array(kConnPassword)
			if conn_password = "login_required"then
				bLoginRequired = true
				conn_password = Session("UserID" & dbkey)
				
			end if
	End Select
	
	'create full connection string
	if conn_type = "NULL" or conn_type = "" or conn_type= "OLEDB" then
		full_conn_string = conn_string & "; " & conn_username & "; " & conn_password		
	else
		full_conn_string = conn_type & "=" & conn_string & "; " & conn_username & "; " & conn_password		
	end if	
	if sf_DEBUG = true then Response.Write "<br>full_conn_string:" & full_conn_string
	GetADOConnString = full_conn_string
	
end function



'-------------------------------------------------------------------------------
' Name: GetNewConnection(dbkey, formgroup, conn_name)
' Type:  function
' Purpose: Create data connection
' Inputs: dbkey as string, formgroup as string, table connection name as string
' Returns: data connection reference
'-------------------------------------------------------------------------------
Function GetNewConnection(ByVal dbkey, ByVal formgroup, ByVal conn_name)		
		full_conn_string = GetADOConnString(dbkey, formgroup, conn_name)
		Dim DataConn
		
		Set DataConn=Server.CreateObject("ADODB.Connection")
			
		on error resume next
		' IRL On error resume next
		DataConn.ConnectionTimeout = conn_conn_timeout
		DataConn.CommandTimeout = conn_command_timeout

		' IRL 1 line
		' LogAction full_conn_string & "(fullconnstring)"		
		DataConn.Open full_conn_string
		if err.number <> 0 then
			DataConn.Close
			Set DataConn = Nothing
			DataConn = ""
			trace "Error while connecting to "  & dbkey & " using connention string " & full_conn_string & ": " & err.source & " " & err.Description, 15  
			HandleError dbkey, formgroup, "conn_string", "GetNewConnection", err.number, err.description
		End if
		
		Set GetNewConnection = DataConn
	
End Function

'-------------------------------------------------------------------------------
' Name: GetNewDataShapeConnection(dbkey, formgroup, conn_name)
' Type:  function
' Purpose: Create data connection using MSDataShapeProvider
' Inputs: dbkey as string, formgroup as string, table connection name as string
' Returns: data connection reference
' Assumes: assumes that you have a uld that matches the base_connection udl, but with a name_msdatashape.udl instead of .udl
'		within this udl, the provider is "msdatashaper", the data provider is what was previously the provider in the original udl'
' Example: Base_connection udl named "sample.udl has the followoing description as viewed in notepad:
'	[oledb]
'	; Everything after this line is an OLE DB initstring
'	Provider=OraOLEDB.Oracle.1;Persist Security Info=False;User ID=biosardb;Data Source=alchemy
' DataShaper udl named "sample_msdatashape.udl has the following description as viewed in notepad:
'	[oledb]
'	; Everything after this line is an OLE DB initstring
'	Provider=MSDataShape.1;Persist Security Info=False;Data Source=alchemy;User ID=biosardb;Data Provider=OraOLEDB.Oracle.1

'-------------------------------------------------------------------------------
Function GetNewDataShapeConnection(ByVal dbkey, ByVal formgroup, ByVal conn_name)	

		full_conn_string = GetADOConnString(dbkey, formgroup, conn_name)
		full_conn_string = Replace(full_conn_string, ".udl", "_msdatashape.udl")
		Set DataConn=Server.CreateObject("ADODB.Connection")
		DataConn.ConnectionTimeout = conn_conn_timeout
		DataConn.CommandTimeout = conn_command_timeout
		DataConn.Open full_conn_string
		if err.number > 0 then
			DataConn.Close
			Set DataConn = Nothing
			DataConn = ""
			HandleError dbkey, formgroup, "conn_string", "GetNewConnection", err.number, err.description
		End if
		
		Set GetNewDataShapeConnection = DataConn
	
End Function

'-------------------------------------------------------------------------------
' Name: SetComment(dbkey, formgroup)
' Type:  Sub
' Purpose: populate Status Comment for current search
' Inputs: dbkey as string, formgroup as string
' Returns: none
' Commnets: Sets Session("StatusComment" & dbkey & formgroup) with any comments from search
'-------------------------------------------------------------------------------
Sub SetComment(ByVal dbkey, ByVal formgroup)
	If Session("fEmptyRecordset" & dbkey & formgroup) = True then
		Session("Message" & dbkey & formgroup) = "sorry no records found. " & Session("SearchSuccess" & dbkey & formgroup)
	Else
		If Session("MoreMolids" & dbkey & formgroup)= True then
			Session("RecordsFound" & dbkey & formgroup) = Session("Base_RSRecordCount" & dbkey & formgroup)
			Session("StatusComment" & dbkey & formgroup) = "More hits available" 
		Else
			Session("StatusComment" & dbkey & formgroup) = ""
		End If
	End If
	
End sub



'-------------------------------------------------------------------------------
' Name: HandleError(dbkey, formgroup, str, source, errnumber, errdescription)
' Type:  Sub
' Purpose: Handle an error and exist search gracefully
' Inputs: dbkey as string, formgroup as string
' Returns: none
' Comments: Sets Session("StatusComment" & dbkey & formgroup) with any comments from search
'-------------------------------------------------------------------------------
Sub HandleError(dbkey, formgroup, str, source, errnumber, errdescription)
	dim text
	formgroupflag = GetFormGroupVal(dbkey, formgroup, kFormGroupFlag)
	Session("fEmptyRecordset" & dbkey & formgroup) = True
	Select Case str
		Case "conn_string"
			text = "An error occurred in connecting to the datasource - check that the database path or dsn is correct."
		Case "recordset"
			text = "An error occurred when generating the recordset."
		Case "no_records_found"
			text = "Sorry, your query returned no results."
		Case "cfw_no_hits"
			str = "no_records_found"
			text = "Sorry, your query returned no results." 
		Case "cfw_molstr_no_hits"
			str = "no_records_found"
			text = "Sorry, your query returned no results.." 
		Case "make_table"
			text = source & ": " &  errnumber & " " &  errdescription
		Case "no_index_field"
			text = "Can't perform full text search, no indexed field entry found in cfserver.ini file."
			
		Case Else
		if errnumber <> "" then
			text = str & "Source: " & source & " Error Number: " &  errnumber & " Description:" &  errdescription
		else
			text = str
		end if
	End Select
		if Session("no_gui" & dbkey & formgroup) = False then
			err.clear()
			Session("error" & dbkey & formgroup) = True
			if Session("Message_Append" & dbkey & formgroup) <> ""  then
				Session("Message" & dbkey & formgroup) = text   & Replace(Session("Message_Append" & dbkey & formgroup), "\n\n", "<br>") 
			else
				Session("Message" & dbkey & formgroup) = text 
			end if
			action = request("dataaction")
			if Not action <> "" then
				action=request("dataaction2")
			end if 
			if not UCase(formgroup)="GS_FORM_GROUP" then
				ReturnResults dbkey, formgroup, action,  ""	
			end if		
		else
			err.clear()
			Session("error" & dbkey & formgroup) = True
			Session("errors_found" & dbkey & formgroup) = str
		end if
End Sub





'-------------------------------------------------------------------------------
' Purpose:  Converts to subtype of string - handles Null cases
' Inputs:   varTemp	- the target value
' Returns:	The processed value
'-------------------------------------------------------------------------------
Function ConvertToString(varTemp)
	If IsNull(varTemp) Then
		ConvertToString = Null
	Else
		ConvertToString = CStr(varTemp)
	End If
End Function



'-------------------------------------------------------------------------------
' Purpose:  Tests to equality while dealing with Null values
' Inputs:   varTemp1	- the first value
'			varTemp2	- the second value
' Returns:	True If equal, False If not
'-------------------------------------------------------------------------------
Function IsEqual(ByVal varTemp1, ByVal varTemp2)
	IsEqual = False
	If IsNull(varTemp1) And IsNull(varTemp2) Then
		IsEqual = True
	Else
		If IsNull(varTemp1) Then Exit Function
		If IsNull(varTemp2) Then Exit Function
	End If
	If varTemp1 = varTemp2 Then IsEqual = True
End Function



'-------------------------------------------------------------------------------
' Purpose:  Tests whether the field in the recordset is required
' Assumes: 	That the recordset containing the field is open
' Inputs:   strFieldname	- the name of the field in the recordset
' Returns:	True If updatable, False If not
'-------------------------------------------------------------------------------
Function IsRequiredField(strFieldname)
	IsRequiredField = False
	If (Session("Base_RS" & dbkey & formgroup)(strFieldname).Attributes And adFldIsNullable) = 0 Then 
		IsRequiredField = True
	End If
End Function



'-------------------------------------------------------------------------------
' Purpose:  Tests whether the field in the recordset is updatable
' Assumes: 	That the recordset containing the field is open
' Effects:	Sets Err object If field is not updatable
' Inputs:   strFieldname	- the name of the field in the recordset
' Returns:	True If updatable, False If not
'-------------------------------------------------------------------------------
Function CanUpdateField(strFieldname)
	Dim intUpdatable
	intUpdatable = (adFldUpdatable Or adFldUnknownUpdatable)
	CanUpdateField = True
	If (Session("Base_RS" & dbkey & formgroup)(strFieldname).Attributes And intUpdatable) = False Then
		CanUpdateField = False
	End If
End Function



'-------------------------------------------------------------------------------
' Name: LogAction(inputstr)
' Type: Sub
' Purpose:  writes imformation to a output file 
' Inputs:   inputstr  as string - variable to output
' Returns:	none
' Comments: writes informtion to /inetput/cfwlog.txt file
'-------------------------------------------------------------------------------
Sub LogAction(ByVal inputstr)
		on error resume next
		filepath = Application("ServerDrive") & "\" & Application("ServerRoot") & "\cfwlog.txt"
		Set fs = Server.CreateObject("Scripting.FileSystemObject")
		Set a = fs.OpenTextFile(filepath, 8, True)  
		a.WriteLine Now & ": " & inputstr
		a.WriteLine " "
		a.close
End Sub

'-------------------------------------------------------------------------------
' Name: Trace(ByVal inputstr, Level)
' Type: Sub
' Purpose:  conditionaly writes imformation to application log file depending on TraceLevel 
' Inputs:   inputstr  as string - variable to output, Level at which tracing occurs
' Returns:	none
' Comments: TraceLevel is set by page scope variable at the top of this file.
'-------------------------------------------------------------------------------
Sub Trace(ByVal inputstr, Level)
	on error resume next 'put this here so activity is not prevented if this file is locked.
		if not IsNumeric(traceLevel) then traceLevel = 0
		if Level <= cLng(traceLevel) then
			filepath = Application("logPath") & Application("COWSRoot") & "\" & Application("appkey") & "\logfiles\" & Application("appkey") & "_trace.html"
			Set fs = Server.CreateObject("Scripting.FileSystemObject")
			Set a = fs.OpenTextFile(filepath, 8, True)  
			if  not isObject(a) then 
			 Response.Write "Error while trying to write to application log file located at:<BR>"
			 Response.Write filepath & "<BR>"
			 Response.Write "Please verify the security settings on the file system or IIS to<BR>"
			 Response.Write "ensure that the ""Anonymous Access User"" for this ASP application<BR>" 
			 Response.Write "is allowed to write to the log file.<BR>"
			 Response.End 
			end if
			a.WriteLine Now & "|level " & Level & "|" & inputstr & "<BR>"
			a.WriteLine " " & "<BR>"
			a.close
		end if
End Sub


'-------------------------------------------------------------------------------
' Name: TraceError(ByVal sErrContext, ByRef err)
' Type: Sub
' Purpose:  Writes Error imformation to application log fil 
' Inputs:   sErrorContext = text to identify where error occurrs, err = the error object
' Returns:	none
'-------------------------------------------------------------------------------
Sub TraceError(sErrContext,eSource, eNumber, eDescription)
	
	on error resume next 'put this here so activity is not prevented if this file is locked.
	filepath = Application("logPath") & Application("COWSRoot") & "\" & Application("appkey") & "\logfiles\" & Application("appkey") & "_trace.html"
	
	Set fs = Server.CreateObject("Scripting.FileSystemObject")
	Set a = fs.OpenTextFile(filepath, 8, True)
	if  not isObject(a) then 
	 Response.Write "Error while trying to write to application log file located at:<BR>"
	 Response.Write filepath & "<BR>"
	 Response.Write "Please verify the security settings on the file system or IIS to<BR>"
	 Response.Write "ensure that the ""Anonymous Access User"" for this ASP application<BR>" 
	 Response.Write "is allowed to write to the log file.<BR>"
	 Response.End 
	end if
	a.WriteLine "<BR>" 
	a.WriteLine Now & "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<BR>"
	a.WriteLine " " & sErrContext & "<BR>"
	a.WriteLine " Error Source: " & eSource & "<BR>"
	a.WriteLine " Error Number: " & eNumber & "<BR>"
	a.WriteLine " Error Description: " & eDescription & "<BR>"  
	a.writeLine "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<BR>"
	a.WriteLine " "
	a.close	
	
End Sub


Sub TraceAndDisplayError(sErrContext,eSource, eNumber, eDescription)
	TraceError sErrContext, eSource, eNumber, eDescription
	Response.Write sErrContext & "<BR>"
	Response.Write "For details see application <b><a target=""_new"" href=""/" & Application("appkey") & "/logfiles/" & Application("appkey") & "_trace.html"">log file</a></b>"
	Response.end
End sub

'-------------------------------------------------------------------------------
' Name: Unescape(s)
' Type: Function
' Purpose:  Unescape a value
' Inputs:  value to Unescape as string
' Returns: unescaped value as string
'-------------------------------------------------------------------------------
Function Unescape(s)
    Dim i, L 
    Dim c, g
    If InStr(s, "%") = 0 Then               ' Catch simple case
        Unescape = s
        Exit Function
    End If
    L = Len(s)
    Unescape = ""
    For i = 1 To L
        c = Mid(s, i, 1)                   ' Next character
        If c = "%" Then
            If Mid(s, i + 1, 1) = "%" Then
                c = "%"
                i = i + 1                   ' Loop increments too
            Else
                c = x2c(Mid(s, i + 1, 2))
                i = i + 2                   ' Loop increments too
            End If
        End If
        Unescape = Unescape & c
    Next 
End Function


'-------------------------------------------------------------------------------
' Name: x2c(s)
' Type: Function
' Purpose:  used by unescape funtion to unescape input value 
' Inputs:  value to Unescape as string
' Returns: unescaped value as string
'-------------------------------------------------------------------------------
Function x2c(s)
    Dim t
    t = "&H" & s
    x2c = Chr(CLng(t))
End Function


'-------------------------------------------------------------------------------
' Name: GetLastID(dbkey, formgroup)
' Type: Function
' Purpose:  get last id in the BaseRS array
' Inputs:  dataview name as string, formgroup name as string
' Returns: last id as variant
'-------------------------------------------------------------------------------
Function GetLastID(dbkey, formgroup)
	basearray = Session("Base_RS" & dbkey & formgroup)
	count = UBound(basearray, 2)
	GetLastID = basearray(0,count)
End Function



'-------------------------------------------------------------------------------
' Name: RestoreLastSearchData(dbkey, formgroup)
' Type: Sub
' Purpose:  Restore all search data stored in Session("Last...") to active session objects
' Inputs:  dataview name as string, formgroup name as string
' Returns: none
' Comments: Repopulates all Session Ojbects used for describing a search and regenerating the results
'-------------------------------------------------------------------------------
Sub RestoreLastSearchData(dbkey, formgourp)
	Session("Message" & dbkey & formgroup) = Session("LastMessage" & dbkey & formgroup)
	Session("GetNextCount" & dbkey & formgroup) = Session("LastGetNextCount" & dbkey & formgroup)
	Session("strWhereSubforms" & dbkey & formgroup)= Session("LaststrWhereSubforms")
	Session("SearchData" & "BaseSelect" & dbkey & formgroup) = Session("LastSearchData" & "BaseSelect" & dbkey & formgroup)
	Session("SearchData" & "FullStrWhere" & dbkey & formgroup) = Session("LastSearchData" & "FullStrWhere" & dbkey & formgroup)
	Session("SearchData" & "RelPortion" & dbkey & formgroup) = Session("LastSearchData" & "RelPortion" & dbkey & formgroup)
	Session("SearchData" & "SearchStrategy" & dbkey & formgroup) = Session("LastSearchData" & "SearchStrategy" & dbkey & formgroup)
	Session("GetNextMaxHits" & dbkey & formgroup) = Session("LastGetNextMaxHits" & dbkey & formgroup)	
	Session("Base_RS" & dbkey & formgroup) = Session("LastBase_RS" & dbkey & formgroup)
	Session("Base_RSRecordCount" & dbkey & formgroup)=	Session("LastBase_RSRecordCount" & dbkey & formgroup)
	Session("MoreMolids" & dbkey & formgroup) = Session("LastMoreMolids" & dbkey & formgroup)
	Session("LastID" & dbkey & formgroup) = Session("LastLastID" & dbkey & formgroup)
	Session("GetNextArray" & dbkey & formgroup) = Session("LastGetNextArray" & dbkey & formgroup)
	Session("StatusComment" & dbkey & formgroup) = Session("LastStatusComment" & dbkey & formgroup)
End Sub



'-------------------------------------------------------------------------------
' Name: StoreSearchData(dbkey, formgroup)
' Type: Sub
' Purpose:  Store all search data stored in Session("Last...") from active session objects
' Inputs:  dataview name as string, formgroup name as string
' Returns: none
' Comments: populates all Session("Last...") Ojbects used for describing a search and regenerating the results
'-------------------------------------------------------------------------------
Sub StoreSearchData(dbkey, formgroup)
	Session("LastSearchData" & "RelPortion" & dbkey & formgroup)= Session("SearchData" & "RelPortion" & dbkey & formgroup)
	Session("LastStatusComment" & dbkey & formgroup) = Session("StatusComment" & dbkey & formgroup)
	Session("LastMessage" & dbkey & formgroup) = Session("Message" & dbkey & formgroup)
	Session("LastGetNextCount" & dbkey & formgroup) = Session("GetNextCount" & dbkey & formgroup)
	Session("LaststrWhereSubforms")= Session("strWhereSubforms" & dbkey & formgroup)
	Session("LastSearchData" & "BaseSelect" & dbkey & formgroup) = Session("SearchData" & "BaseSelect" & dbkey & formgroup)
	Session("LastSearchData" & "FullStrWhere" & dbkey & formgroup) = Session("SearchData" & "FullStrWhere" & dbkey & formgroup)
	Session("LastSearchData" & "SearchStrategy" & dbkey & formgroup) = Session("SearchData" & "SearchStrategy" & dbkey & formgroup)
	Session("LastGetNextMaxHits" & dbkey & formgroup) = Session("GetNextMaxHits" & dbkey & formgroup)	
	Session("LastBase_RS" & dbkey & formgroup) = Session("Base_RS" & dbkey & formgroup)
	Session("LastBase_RSRecordCount" & dbkey & formgroup)=	Session("Base_RSRecordCount" & dbkey & formgroup)
	Session("LastMoreMolids" & dbkey & formgroup) = Session("MoreMolids" & dbkey & formgroup)
	Session("LastLastID" & dbkey & formgroup) = Session("LastID" & dbkey & formgroup)
	Session("LastGetNextArray" & dbkey & formgroup) = Session("GetNextArray" & dbkey & formgroup)
End Sub



'-------------------------------------------------------------------------------
' Name: DoRelSearch(dbkey, formgroup, strategy, stype)
' Type: Function
' Purpose:  format strwhere clause for relational search
' Inputs:  dataview name as string, formgroup name as string, strategy as string can be anything, stype as string - can be anything
' Returns: returns where clause portion of search from Session("SearchData" & "RelPortion" & dbkey & formgroup)
' Comments: populates Session("SearchData" & "FullStrWhere" & dbkey & formgroup)
'	the strategy and stype parameters are no longer used - but must be part of the call. They can be any string or an
'   an empty string
'-------------------------------------------------------------------------------
Function DoRelSearch(ByVal dbkey, ByVal formgroup, ByVal strategy, ByVal stype)
	'CSBR:164386 - SMathur- Adding the order by clause only for docmanager.
   	if lcase(dbkey) = "docmanager" and lcase(formgroup) = "base_form_group" then
        basetable = GetBaseTable(dbkey, formgroup, "basetable")
        baseid = GetTableVal(dbkey, basetable, kPrimaryKey)
	    criteria = Request("order_by")
        if criteria <> "" then  
            if  InStr(criteria, "ASC") then   
                criteria = criteria + " , " & basetable & "." & baseid & " ASC "
            else 
                criteria = criteria + " , " & basetable & "." & baseid & " DESC "
            end if 
            Session("order_by" & dbkey & formgroup) =  criteria
        end if 
    end if
	strWhere =  Session("SearchData" & "RelPortion" & dbkey & formgroup)
	Session("SearchData" & "FullStrWhere" & dbkey & formgroup) = strWhere
	DoRelSearch = strWhere
End Function



'-------------------------------------------------------------------------------
' Name: DoIDSearch(dbkey, formgroup, stype)
' Type: Function
' Purpose:  format strwhere clause containing list of ids from marked hits
' Inputs:  dataview name as string, formgroup name as string, stype as enum value
'	stype enum value
'		"marked" -gets list of ids from Session("MarkedHits" & dbkey & formgroup)
' Returns: returns where clause portion of search 
' Comments: populates Session("SearchData" & "FullStrWhere" & dbkey & formgroup)
'	Populates Session("SearchData" & "SearchName" & dbkey & formgroup) = "Retrieve_All" for GUI
'-------------------------------------------------------------------------------
Function DoIDSearch(ByVal dbkey, formgroup, stype)
	Select Case stype
		Case "marked"
			basetable = GetBaseTable(dbkey, formgroup, "basetable")
			baseid = GetTableVal(dbkey, basetable, kPrimaryKey)
			markedhits = Session("MarkedHits" & dbkey & formgroup)
			'markedhits = Request.Cookies("MarkedHits" & dbkey & formgroup)
			if Not  markedhits <> "" then
				markedhits = Request("marked_hits")
			end if
			If inStr(markedhits, ",")>0 then
				strWhere = "[" & Trim(basetable) & "]" &  "." & "[" & Trim(baseid)  & "]" & " IN (" & markedhits & ")"
			Else
				strWhere = "[" & Trim(basetable) & "]" &  "." & "[" & Trim(baseid)  & "]" & "=" & markedhits
			End If
		End select
	
	Session("SearchData" & "FullStrWhere" & dbkey & formgroup) = strWhere
	Session("SearchData" & "SearchName" & dbkey & formgroup) = "Retrieve_All"
	DoIDSearch = strWhere
End Function



'-------------------------------------------------------------------------------
' Name: DoRetrieveAllSearch(dbkey, formgroup)
' Type: Function
' Purpose:  format strwhere for retreiving all hits for the formgroups base table
' Inputs:  dataview name as string, formgroup name as string, stype as enum value
' Returns: returns where clause portion of search 
' Comments: populates Session("SearchData" & "FullStrWhere" & dbkey & formgroup), Session("SearchData" & "RelPortion" & dbkey & formgroup)
'	with strWhere. Populates Session("SearchData" & "SearchName" & dbkey & formgroup) = "Retrieve_All" for GUI
'-------------------------------------------------------------------------------
Function DoRetrieveAllSearch(ByVal dbkey, ByVal formgroup)
	basetable = GetBaseTable(dbkey, formgroup, "basetable")
	baseid = GetTableVal(dbkey, basetable, kPrimaryKey)
	Session("order_by" & dbkey & formgroup) = basetable & "." & baseid
	strWhere = "[" & Trim(basetable) & "]" &  "." & "[" & Trim(baseid)  & "]" & ">0"
	Session("SearchData" & "RelPortion" & dbkey & formgroup)= strWhere
	Session("SearchData" & "FullStrWhere" & dbkey & formgroup) = strWhere
	Session("SearchData" & "SearchName" & dbkey & formgroup) = "Retrieve_All"
	DoRetrieveAllSearch = strWhere
End Function


'-------------------------------------------------------------------------------
' Name: DoQueryStringSearch(dbkey, formgroup)
' Type: Function
' Purpose:  To Format a querystring search
' Inputs:  dataview name as string, formgroup name as string, stype as enum value
' Post Inputs:  field_type = INTEGER,Empty|CLEAN_NAME,33|see GetFieldTypeDelimiter for other possible values
'				field_criteria = *,LIKE|=,empty| >, <, <=, >=, =|
'				field_value = value for where clause
' Returns: returns where clause portion of search 
'-------------------------------------------------------------------------------

Function DoQueryStringSearch(ByVal dbkey, ByVal formgroup)
	'?action =query_string&dbname = ddd&formgroup = """& full_field_name = LLL & fieldvalue = *** & field_type = III & field_criteria =KKK"
	
	if not request("formgroup") <> "" then formgroup = "base_form_group"
	full_field_name = Request.QueryString ("full_field_name")
	if not full_field_name <> "" then
		HandleError dbkey, formgroup, "no fieldname found in query string", "", "", ""
	end if
	field_value = Request.QueryString ("field_value")
	if not full_field_name <> "" then
		HandleError dbkey, formgroup, "no field value found in query string", "", "", ""
	end if
	
	
	field_type = Request.QueryString("field_type")
	if not field_type <> "" then field_type = "INTEGER"
	if field_type = "CLEAN_NAME" or field_type = "33" then
		field_value = CleanTheSyns(field_value)
		delimeter = "'"
	else
		delimeter = GetFieldDelimiter(UCase(field_type))
	end if
	field_criteria = Request.QueryString("field_criteria")
	if Instr(field_value, "*")> 0 then field_criteria = "LIKE"
	if Not field_criteria <>"" then field_criteria = "="
	if inStr(field_value, "'") > 0 then
		field_value = replace(field_value, "'", "''")
	end if
		
	Select Case field_criteria
		Case "LIKE"
		     ' DGB Make querystring like searches case insentitive for Oracle
	        SQLSyntax = Application("DBMS")
	        'JHS 2/4/2008 - set variable without lower so it doesn't break for access
	        lower_field_name = full_field_name
	        if UCase(sqlSyntax) = "ORACLE" then 
				lower_field_name = "lower(" & full_field_name & ")"
				field_value = LCase(field_value)
		    end if	
			strWhere =  lower_field_name & " " &  field_criteria & " " & delimeter & field_value & "%" & delimeter
		Case "IN"
			if inStr(field_value, ",")> 0 then
				field_value = replace(field_value, ",", delimeter & "," & delimeter)
			end if
			strWhere = full_field_name & " " &  field_criteria & " " &  "(" & delimeter & field_value & delimeter & ")"
			
		Case ">", "<", "<=", ">=",  "="
			strWhere =   full_field_name & " " &  field_criteria & " " &   delimeter & field_value & delimeter
	End Select
	AddSubFormNames dbkey, formgroup, full_field_name 
	DoQueryStringSearch = strWhere
End Function



'-------------------------------------------------------------------------------
' Name: GetResults(dbkey, formgroup,stype,recsetflag,strSQL)
' Type:  Sub
' Purpose: perform search and set comments
' Inputs: dbkey as string, formgroup as string, search type of enum, recordsetflag as enum, sql as string
' Returns: none
' Comments: See GetBaseRecordset for informationon stype and recsetflag
'------------------

Sub GetResults(ByVal dbkey, ByVal formgroup, ByVal stype, ByVal recsetflag, ByVal strSQL)
	If Session("error" & dbkey & formgroup)= True then exit Sub
		'figure out whether to get a recordset or return a message

		If Session("fEmptyRecordset" & dbkey & formgroup) = False then
			
			'SYAN modified on 2/15/2005 to fix CSBR-50932
			'If strSQL <> "" then
			If strSQL <> "" or InStr(UCase(Session("SearchData" & "MultipleExact" & dbkey & formgroup)), ".SDF") > 0 then
			'End of SYAN modification
			'if stype = "no_gui" then Response.write ""
				GetBaseRecordset dbkey, formgroup, stype, recsetflag, strSQL
				'!DGB! 02/03 update the histlistID table with user, formgroup and timestamp
				TagCSDOHitlistID Session("hitlistID" & dbkey & formgroup), formgroup, dbkey
			Else
				Session("fEmptyRecordset" & dbkey & formgroup) = True		
				SetComment dbkey, formgroup
			End If
		Else
			SetComment dbkey, formgroup
	End If
End Sub
		
'-------------------------------------------------------------------------------
' Name: GetRecordCount(dbkey, formgroup,recordset)
' Type:  Function
' Purpose: use a DBMS independend method to returne the record count for the current recordset
' Inputs: dbkey as string, formgroup as string, recordset reference
' Returns: record count as variant
'------------------
Function GetRecordCount(ByVal dbkey, ByVal formgroup, ByRef recordset)
	rs_open = false
	if Not (recordset.EOF AND recordset.BOF = true) then
		rs_open = true
	end if
	if rs_open= true then
			on error resume next
			rowsarray = recordset.GetRows()
			count=UBound(rowsarray, 2)
			
		If err.number > 0 then
			err.clear
			Session("fEmptyRecordset" & dbkey & formgroup) = true
			GetRecordCount = 0
		Else
			Session("fEmptyRecordset" & dbkey & formgroup) = false
			recordset.MoveFirst
			GetRecordCount=count + 1
		End If
		rowsarray = ""
	else
		GetRecordCount = 0
	end if
End Function


'-------------------------------------------------------------------------------
' Name: GetFieldNamesFromTable(dbkey, formgroup, view_table)
' Type:  Function
' Purpose: get a list of all the fields in a table
' Inputs: dbkey as string, formgroup as string, table name as string
' Returns: command delimited list of field names as string
'-------------------------------------------------------------------------------

Function GetFieldNamesFromTable(dbkey, formgroup, view_table)
		Set DataConn = GetNewConnection(dbkey, formgroup, "base_connection")
		Set RS = Server.CreateObject("ADODB.Recordset")
		on error resume next
		RS.Open view_table, DataConn, , ,adCmdTable
		if Not err.number <> 0 then
			Set AllFields = RS.Fields
			For i = 0 to Field.Count
				If fields_list <> "" then
					fields_list = fields_list & "," & AllFields.Item(i).Name
				else
					fields_list = fields_list & "," & AllFields.Item(i).Name
				end if
				AllFields.MoveNext
			Next
			theReturn = fields_list
		else
			theReturn = "ERROR_IN_VIEW"
		end if
		GetFieldNamesFromTable=theReturn

End Function 

'-------------------------------------------------------------------------------
' Name: BuildAllStrFields(dbkey, formgroup, inputstr)
' Type:  Function
' Purpose: build a table.* list for a select statment
' Inputs: dbkey as string, formgroup as string, table names as comma delimited list as string
' Returns: new string with table1.*, table2.* format as string
'-------------------------------------------------------------------------------

Function BuildAllStrFields(dbkey, formgroup, inputstr)
	dim i
	dim temp
	temp= split(inputstr, ",", -1)
	for i = 0 to UBound(temp)
		if Not isEmpty(temp(i)) then
			if theReturn <> "" then
				theReturn = theReturn & "," & temp(i) & ".*"
			else
				theReturn = temp(i) & ".*"
			end if
		end if
	Next
	BuildAllStrFields = theReturn
End function


'-------------------------------------------------------------------------------
' Name: SetMaxHitsSQL(dbkey, formgroup,  sql, basetable, maxhits)
' Type:  Function
' Purpose: create a select statment including maxhits for depending on DBMS stype
' Inputs: dbkey as string, formgroup as string, sql as string, base table name as string, maxhits and sting
' Returns: new sql string with max hits clause add in proper format base on dbms
'-------------------------------------------------------------------------------
Function SetMaxHitsSQL(dbkey, formgroup, sql, basetable, maxhits)
		SQLSyntax = getTableVal(dbkey, basetable, kSQLSyntax)
		Select Case UCase(SQLSyntax)
			Case "ACCESS" 
				if not Instr(sql, " TOP ") >0 then
					new_sql = replace(sql, "SELECT ", "SELECT TOP " & maxhits & " ")
				else
					new_sql = sql
				end if 
			Case "SQL_SERVER" 
				if not Instr(sql, " TOP ") >0 then
					new_sql = replace(sql, "SELECT ", "SELECT TOP " & maxhits & " ")
				else
					new_sql = sql
				end if 
			Case "SQLSERVER" 
				if not Instr(sql, " TOP ") >0 then
					new_sql = replace(sql, "SELECT ", "SELECT TOP " & maxhits & " ")
				else
					new_sql = sql
				end if 
			Case "ORACLE"
				if not Instr(sql, " ROWNUM ") >0 then
					new_sql  = sql & " AND ROWNUM <" & maxhits + 1
				else
					new_sql = sql
				end if 
			Case Else
				new_sql = sql
		End Select
		SetMaxHitsSQL = new_sql
End Function
	
'-------------------------------------------------------------------------------
' Name: getCSDOQualifiedName(dbkey, formgroup,  basetable)
' Type:  Function
' Purpose: get the fully qualified csdohitlist name depending on DBMS type
' Inputs: dbkey as string, formgroup as string,  base table name as string
' Returns: fully qualified csdohitlist table name. For example regdb.csdohitlist
'-------------------------------------------------------------------------------
Function getCSDOQualifiedName(dbkey, formgroup, basetable)
	if Not basetable <> "" then
		basetable = getBaseTable(dbkey, formgroup, "basetable")
	end if
	SQLSyntax = getTableVal(dbkey, basetable, kSQLSyntax)
	dim csdo_name
		Select Case UCase(SQLSyntax)
			Case "ACCESS"
				csdo_name= "CSDOHITLIST"
			Case "ORACLE"
				if UCase(dbkey) = "REG" then
					schema_name= Application("REG_USERNAME")
				else
					if Application(dbkey & "_USERNAME") <> "" then
						schema_name= Application(dbkey & "_USERNAME")
					else
						schema_name= dbkey
					end if
				end if
					csdo_name= schema_name & "." & "CSDOHITLIST"		
			Case "SQLSERVER"
					csdo_name= "CSDOHITLIST"
		end select
	getCSDOQualifiedName = csdo_name
End Function

'-------------------------------------------------------------------------------
' Name: getSchemaName(dbkey, formgroup,  basetable)
' Type:  Function
' Purpose: return the schema name, if applicable to DBMS
' Inputs: dbkey as string, formgroup as string,  base table name as string
' Returns: schema name as string. For example "regdb"
'-------------------------------------------------------------------------------
Function getSchemaName(dbkey, formgroup, basetable)
	if Not basetable <> "" then
		basetable = getBaseTable(dbkey, formgroup, "basetable")
	end if
	SQLSyntax = getTableVal(dbkey, basetable, kSQLSyntax)
	dim csdo_name
		Select Case UCase(SQLSyntax)
			Case "ACCESS"
				csdo_name= ""
			Case "ORACLE"
				if UCase(dbkey) = "REG" then
					schema_name= Application("REG_USERNAME")
				else
					if Application(dbkey & "_USERNAME") <> "" then
						schema_name= Application(dbkey & "_USERNAME")
					else
						schema_name= dbkey
					end if
				end if
					csdo_name= schema_name & "." 	
			Case "SQLSERVER"
					schema_name= ""
		end select
	getSchemaName = schema_name
End Function


'-------------------------------------------------------------------------------
' Name: AddCSDOHitListToSelect(dbkey, formgroup,  select_statement)
' Type:  Function
' Purpose: add csdohitlist to select statement
' Inputs: dbkey as string, formgroup as string,  select statement as string
' Returns: new select statement containing relevant csdohitlist id 
'-------------------------------------------------------------------------------
Function AddCSDOHitListToSelect(dbkey, formgroup, select_statement)
	
	basetable = getBaseTable(dbkey, formgroup, "basetable")
	fullCDSOName = getCSDOQualifiedName(dbkey, formgroup, basetable)
	SQLSyntax = getTableVal(dbkey, basetable, kSQLSyntax)
	temp = Split(select_statement, "FROM", -1)
	baseid = GetTableVal(dbkey, basetable, kPrimaryKey)
	TranlateRelKey=baseid
	if UseCartridge(dbkey, formgroup) then
		ModifiedSQLWithCSDO =  temp(0) & " FROM " & fullCDSOName & "," & temp(1) &_
			" " & fullCDSOName & ".ID=" &  UCase(basetable) & ".rowid " &_
			" AND " & fullCDSOName & ".hitlistID=" & Session("hitlistID" & dbkey & formgroup) 
	Else
		ModifiedSQLWithCSDO =  temp(0) & " FROM " & fullCDSOName & "," & temp(1) &_
			" " & fullCDSOName & ".ID=" &  UCase(basetable) & "." & UCase(TranlateRelKey) &_
			" AND " & fullCDSOName & ".hitlistID=" & Session("hitlistID" & dbkey & formgroup)
	End if
	AddCSDOHitListToSelect= ModifiedSQLWithCSDO
End Function 

'-------------------------------------------------------------------------------
' Name: AddParamCSDOHitListToSelect_WithMAX(dbkey, formgroup,  select_statement, hitlistid, maxhits)
' Type:  Function
' Purpose: add csdohitlist and maxhits formatting to select statement
' Inputs: dbkey as string, formgroup as string,  select statement as string, hitlist_id as INT, maxhits as INT
' Returns: new select statement containing relevant csdohitlist id and maxhits
'-------------------------------------------------------------------------------

Function AddParamCSDOHitListToSelect_WithMAX(dbkey, formgroup, select_statement,hitlistid,maxhits)
	basetable = getBaseTable(dbkey, formgroup, "basetable")
	SQLSyntax = getTableVal(dbkey, basetable, kSQLSyntax)
	basetable = getBaseTable(dbkey, formgroup, "basetable")
	fullCDSOName = getCSDOQualifiedName(dbkey, formgroup, basetable)
	temp = Split(select_statement, "FROM", -1)
	baseid = GetTableVal(dbkey, basetable, kPrimaryKey)
	
	TranlateRelKey=baseid
	if UCase(SQLSyntax) = "ORACLE" then
		
'-- CSBR ID:101924
'-- Change Done by : Manoj Unnikrishnan
'-- Purpose: updated the operator to <= to fetch the exact number of records as configured
'-- Date: 08/04/2011
		if UseCartridge(dbkey, formgroup) then
			ModifiedSQLWithCSDO =  temp(0) & " FROM " & fullCDSOName & "," & temp(1) &_
			" " & fullCDSOName & ".ID=" &  UCase(basetable) & ".rowid "&_
			" AND " & fullCDSOName & ".hitlistID= " & hitlistid & " AND ROWNUM <= " & maxhits
		else
			ModifiedSQLWithCSDO =  temp(0) & " FROM " & fullCDSOName & "," & temp(1) &_
			" " & fullCDSOName & ".ID=" &  UCase(basetable) & "." & Ucase(TranlateRelKey) &_
			" AND " & fullCDSOName & ".hitlistID= " & hitlistid & " AND ROWNUM <= " & maxhits
		end if
'-- End of Change #101924#
	else
		dim theRevisedText
		if inStr(temp(0), "DISTINCTROW") > 0 then
			theRevisedText = replace(temp(0), "DISTINCTROW", "")
			select_text = replace(theRevisedText, "SELECT ", "SELECT DISTINCTROW TOP " & maxhits & " ")
			ModifiedSQLWithCSDO = select_text & " FROM " & fullCDSOName & "," & temp(1) &_
			" " & fullCDSOName & ".ID=" &  UCase(basetable) & "." & UCase(TranlateRelKey) &_
			" AND " & fullCDSOName & ".hitlistID=" & hitlistid 
			'" ORDER BY " & basetable & "." & baseid 
		else
			if inStr(temp(0), "DISTINCT") > 0 then
				theRevisedText = replace(temp(0), "DISTINCT", "")
				select_text = replace(theRevisedText, "SELECT ", "SELECT DISTINCT TOP " & maxhits & " ")
				ModifiedSQLWithCSDO = select_text & " FROM " & fullCDSOName & "," & temp(1) &_
				" " & fullCDSOName & ".ID=" &  UCase(basetable) & "." & UCase(TranlateRelKey) &_
				" AND " & fullCDSOName & ".hitlistID=" & hitlistid 
				'" ORDER BY " & basetable & "." & baseid 
			else
				select_text = replace(temp(0), "SELECT ", "SELECT TOP " & maxhits & " ")
				ModifiedSQLWithCSDO = select_text & " FROM " & fullCDSOName & "," & temp(1) &_
				" " & fullCDSOName & ".ID=" &  UCase(basetable) & "." & UCase(TranlateRelKey) &_
				" AND " & fullCDSOName & ".hitlistID=" & hitlistid 
				'" ORDER BY " & basetable & "." & baseid 
			end if
		end if

	end if
	AddParamCSDOHitListToSelect_WithMAX= ModifiedSQLWithCSDO
End Function 


'-------------------------------------------------------------------------------
' Name: AddParamCSDOHitListToSelect(dbkey, formgroup,  select_statement, hitlistid)
' Type:  Function
' Purpose: add csdohitlist formatting to select statement
' Inputs: dbkey as string, formgroup as string,  select statement as string, hitlist_id as INT
' Returns: new select statement containing relevant csdohitlist id
'-------------------------------------------------------------------------------

Function AddParamCSDOHitListToSelect(dbkey, formgroup, select_statement,hitlistid)
	
	basetable = getBaseTable(dbkey, formgroup, "basetable")
	fullCDSOName = getCSDOQualifiedName(dbkey, formgroup, basetable)
	SQLSyntax = getTableVal(dbkey, basetable, kSQLSyntax)
	

	temp = Split(select_statement, "FROM", -1)
	baseid = GetTableVal(dbkey, basetable, kPrimaryKey)
	TranlateRelKey=baseid
	if UseCartridge(dbkey, formgroup) then 
			ModifiedSQLWithCSDO =  temp(0) & " FROM " & fullCDSOName & "," & temp(1) &_
		" " & fullCDSOName & ".ID=" &  UCase(basetable) & ".rowid " &_
		" AND " & fullCDSOName & ".hitlistID= " & hitlistid
	Else
			ModifiedSQLWithCSDO =  temp(0) & " FROM " & fullCDSOName & "," & temp(1) &_
		" " & fullCDSOName & ".ID=" &  UCase(basetable) & "." & UCase(TranlateRelKey) &_
		" AND " & fullCDSOName & ".hitlistID= " & hitlistid
	End if
	
	AddParamCSDOHitListToSelect= ModifiedSQLWithCSDO
End Function 

'-------------------------------------------------------------------------------
' Name: RemoveDistinct(dbkey, formgroup,  select_statement)
' Type:  Function
' Purpose: remove DISTINCT and DISTINCTROW from select statement
' Inputs: dbkey as string, formgroup as string,  select statement as string
' Returns: new select statement as string without DISTINCT/DISTINCTROW keyword
'-------------------------------------------------------------------------------
Function RemoveDistinct(dbkey, fromgroup, select_statement)
	theReturn = Replace(select_statement, "DISTINCTROW", "", 1)
	theReturn = Replace(theReturn, "DISTINCT", "", 1)
	RemoveDistinct= theReturn
End Function


'-------------------------------------------------------------------------------
' Name: getTableExportFields(table_name,  fieldstoexport)
' Type:  Function
' Purpose: get a list of field names for a particular table from a list of tableX.fieldnames
' Inputs: table name of desired fields as string, tablename.fieldname list as comma delimited string
' Returns: list of fields relevant for a particular table name as comma delimited string
'-------------------------------------------------------------------------------
Function getTableExportFields(table_name,fieldstoexport)
	temp_array = split(fieldstoexport, ",", -1)
	for i = 0 to Ubound(temp_array)
		temp_array2 = split(temp_array(i), "." , -1)
		if UBound(temp_array2) = 2 then
			test_table_name = temp_array2(0) & "." & temp_array2(1)
			field_name = temp_array2(2)
		else
			test_table_name = temp_array2(0) 
			field_name = temp_array2(1)
		end if
		if UCase(test_table_name) = UCase(table_name) then
			if final_fields <> "" then
				final_fields = final_fields & ","  & "[" & test_table_name & "].[" & field_name & "]"
			else
				final_fields =  "[" & test_table_name & "].[" & field_name & "]"
			end if
		end if
	next
	getTableExportFields = final_fields
End Function


'-------------------------------------------------------------------------------
' Name: FinalizeSQl(dbkey, formgroup, sql, basetable)
' Type:  Function
' Purpose: remove or add brackets to sql statement depending on dbms type
' Inputs: dataview as string, formgroup as string,sql statement as string, base table name as string
' Returns: sql with approparite use of brackets based on DBMS type
'-------------------------------------------------------------------------------
Function FinalizeSQl(dbkey, formgroup, sql, basetable)
	SQLSyntax = getTableVal(dbkey, basetable, kSQLSyntax)
	if SQLSyntax = "ORACLE" then

		finalsql = ModifySQL(sql)
		
	else
		finalsql = sql
	end if
	FinalizeSQl=finalsql
End Function


'-------------------------------------------------------------------------------
' Name: getTablesString(dbkey, formgroup,  inputStr)
' Type:  Function
' Purpose: get a list of field names for a particular table from a list of tableX.fieldnames
' Inputs: dataview as string, formgroup as string, comma delimited list of fields in tablename.fiedlname;datatype format
' Returns: list of table names parsed from inputstring as comma delimited string
'-------------------------------------------------------------------------------
Function getTablesString(dbkey, formgroup, inputStr)
	
	inputArray = split(inputStr, ",", -1)
	basetable = getBaseTable(dbkey, formgroup, "basetable")
	for i = 0 to Ubound(inputArray)
		if inStr(inputArray(i), ";")> 0 then
			item_split1=Split(inputArray(i), ";", -1)
			item_split2 =Split(item_split1(0), ".", -1)
			if UBound(item_split2) =2 then
				table_name = Trim(item_split2(0)) & "." & Trim(item_split2(1))
			else
				table_name = Trim(item_split2(0))
			end if
			if Not UCase(table_name) = UCase(basetable) then
				if all_names <> "" then
					all_names = all_names & "," & table_name
				else
					 all_names = table_name 
				end if
			end if
		else
			item_split2 =Split(inputArray(i), ".", -1)
			if UBound(item_split2) =2 then
				table_name = Trim(item_split2(0)) & "." & Trim(item_split2(1))
			else
				table_name = Trim(item_split2(0))
			end if
			if Not UCase(table_name) = UCase(basetable) then
				if all_names <> "" then
					all_names = all_names & "," & table_name
				else
					 all_names = table_name 
				end if
			end if
			
		end if
	next
	final_string = RemoveDups(all_names)
	getTablesString=final_string
	
end function 


'-------------------------------------------------------------------------------
' Name: checkForMolid(dbkey, fieldstoexport,  fullstrucfieldname)
' Type:  Function
' Purpose: determine if the mol_id for the base table is in a list of tablename.fieldnames. If not add it
' Inputs: dataview as string, formgroup as string, comma delimited list of fields in tablename.fiedlname format as string;name of mol_id field as string
' Returns: a new list of fields with structure id added if it was absent.
'-------------------------------------------------------------------------------

function  checkForMolid(dbkey, formgroup, fieldstoexport, fullstrucfieldname)

	bMolIDFound = false
	molidField = fullstrucfieldname
	if trim(fieldstoexport) <> "" then
		theArray = split(fieldstoexport, ",", -1)
		on error resume next
		Dim i
		for i = 0 to UBound(theArray)
			if UCase(theArray(i)) = UCase(molidField) then
				bMolIDFound = true
			exit for
			end if
		next
		
		if bMolIDFound = false then
			theReturn = fieldstoexport & "," & molidField
		else
			theReturn = fieldstoexport
		end if
	else
		theReturn = molidField
	end if
	checkForMolid = theReturn
end function


'-------------------------------------------------------------------------------
' Name: TrimItemsInString(dbkey, formgroup, inputstr)
' Type:  Function
' Purpose: remove all blank spaces within a comma delimited list
' Inputs: dataview as string, formgroup as string, comma delimited list as string
' Returns: a new trimmed list as string
'-------------------------------------------------------------------------------
Function TrimItemsInString(dbkey, formgroup, inputstr)
	theArray = split(inputstr, ",", -1)
	on error resume next
	Dim i
	for i = 0 to UBound(theArray)
		if theList <> "" then 
			theList = theList & "," & Trim(theArray(i))
		else
			theList = Trim(theArray(i))
		end if
	next
	
	TrimItemsInString=theList
End Function 

'-------------------------------------------------------------------------------
' Name: appendDataType(dbkey, formgroup,  fullfieldname)
' Type:  Function
' Purpose: append datatype from ini file to fieldname.table name
' Inputs: dbkey as string, formgroup as string,  fieldname.tablename
' Returns: new string with datatype
'-------------------------------------------------------------------------------
Function appendDataType(ByVal dbkey, ByVal formgroup, ByVal fullfieldname)
	on error resume next
	temp = split(fullfieldname, ".", -1)
	if Ubound(temp) = 2 then
		tablename = temp(0) & "." & temp(1)
		fieldname = temp(2)
	else
		tablename = temp(0)
		fieldname = temp(1)
	end if 
	adofields = GetTableVal(dbkey, tablename, kTableRelFields)
	temp_fields = split(adofields, ",", -1)
	iFoundItem = false
	for i = 0 to UBound(temp_fields)
		new_split = Split(temp_fields(i), ";", -1)
		if UCase(fieldname) = UCase(new_split(0)) then
			fieldtype = new_split(1)
			iFoundItem = true
			exit for
		end if
	next
	if iFoundItem = true then
		appendDataType = fullfieldname & ";" & fieldtype
	else
		appendDataType = ""
	end if
	if err.number > 0 then 
		Response.Write "Error Generated From appendDataType for the following field: " & fullfieldname
		Response.Write "Check format for data in  key: ""Rel_Fields"" for section: " & tablename & "in the ini file."
		Response.Write "Format must be: fieldname;fieldtype,"
		Response.Write "If the semi-colon and comma are reversed this error will occur."

	end if
end function



'-------------------------------------------------------------------------------
' Name: getDataType(dbkey, formgroup,  fullfieldname)
' Type:  Function
' Purpose: get the datatype from ini file to fieldname.table name
' Inputs: dbkey as string, formgroup as string,  fieldname.tablename
' Returns: datatype as variant
'-------------------------------------------------------------------------------
Function getDataType(ByVal dbkey, ByVal formgroup, ByVal fullfieldname)
	full_field_string = appendDataType(dbkey, formgroup, fullfieldname)

	if instr(full_field_string, ";")> 0 then
		theArray = Split(full_field_string, ";", -1)
		theDataType = theArray(1)
		getDataType = theDataType
	else
		Response.Write "Error Generated From getDataType for the following field: " & fullfieldname
		Response.Write "Check ini file for errors in the key ""Rel_Fields"" in the Section relevant to the Table."
		Response.Write "Format must be: fieldname;fieldtype,"
		Response.Write "If the field type is missing, you will get this error."
	end if
End Function


'-------------------------------------------------------------------------------
' Name: GetRelFields(dbkey, formgroup,  inputstr)
' Type:  Function
' Purpose: format a where cluase with all relationfields formatted properly based on fieldtype
' Inputs: dbkey as string, formgroup as string,  fieldname.tablename as comma delimited list
' Returns: formatted string for where clause
'-------------------------------------------------------------------------------
Function GetRelFields(ByVal dbkey, ByVal formgroup, ByVal inputstr)
    'DGB added missing Dim statement to fix global search CSBR-66700
    Dim strWhere
    
	fieldArray = split(inputstr, ",", -1)
	count = UBound(fieldArray)
	for i = 0 to  count
		if Not inStr(fieldArray(i), ";") >0 then
			new_field_name= appendDataType(dbkey, formgroup, fieldArray(i))
			if Not new_field_name <> "" then
				HandleError dbkey, formgroup, "field_type_missing", "no field type specified in query or ini file for:" & fieldArray(i), "", ""
			else
				fieldArray(i) = new_field_name
			end if
		end if
		temp = split(fieldArray(i), ";", -1)
		fieldtype = temp(1)
		fieldname = temp(0)
		'SYAN modified on 11/18/2005 to fix CSBR-61386
		'fieldvalue = Session("SearchData" & temp(0) & dbkey & formgroup)
		fieldvalue = Replace(Session("SearchData" & temp(0) & dbkey & formgroup), "[", "^^^")
		fieldvalue = Replace(fieldvalue, "]", "~~~")
		'End of SYAN modification
		

		if Not fieldvalue <> "" then exit function
		formgroupflag = GetFormGroupVal(dbkey, formgroup, kFormGroupFlag)
		If formgroupflag = "GLOBAL_SEARCH" then
			returnedfieldname = GetFieldCorr(dbkey, formgroup, "OtherField", fieldArray(i))
			
			if inStr(1, returnedfieldname, ";") > 0 then 
				temp = split(returnedfieldname, ";", -1)
				fieldtype = temp(1)
				fieldname = temp(0)
			Else
				breturnBlank = True
			End if
			
		End If
		
		strWhere = GetRelStrWhere(dbkey,formgroup, fieldtype, fieldname, fieldvalue, strWhere)
	Next 'i
	GetRelFields = strWhere

End Function

'-------------------------------------------------------------------------------
' Name: SetSessionVars(dbkey, formgroup,  stype)
' Type:  Sub
' Purpose: reset/set all session variables for a particular search type
' Inputs: dbkey as string, formgroup as string, stype as enum
' stype enum values
'	search
'	search_no_gui
'	register
'	register_all
'	add_record
'	update_record
'	get_next
'	edit_query
'	new_search,
'	db
'	restore_query
'	delete_query
'	refine_query
' Returns: clears appropriate session variables 
'-------------------------------------------------------------------------------
Sub SetSessionVars(ByVal dbkey, ByVal formgroup, ByVal stype)
	'set defaults
	if Not formgroup <> "" then formgroup = "base_form_group"
	Session("version" & dbkey & formgroup) = RTrim(Request("version"))
	'set unique values or override defaults
	Select Case stype

		Case "search"
			Session("no_gui" & dbkey & formgroup) = False
			Session("Base_RSRecordCount" & dbkey & formgroup)=0
			Session("error" & dbkey & formgroup)= False
			Session("CurrentLocation" & dbkey & formgroup)= ""
			Session("fEmptyRecordset" & dbkey & formgroup) = False
			Session("Message" & dbkey & formgroup) = ""
			Session("MoreMolids" & dbkey & formgroup) = ""
			Session("LastID" & dbkey & formgroup) = ""
			Session("LastStucID" & dbkey & formgroup) = ""
			Session("GetNextCount" & dbkey & formgroup) = 1
			Session("strWhereSubforms" & dbkey & formgroup)= ""
			Session("TableAliasTracker" & dbkey & formgroup)=""
			Session("SearchData" & "RelPortion" & dbkey & formgroup)=""
			Session("SearchData" & "SearchName" & dbkey & formgroup)=""
			Session("SearchData" & "FullStrWhere" & dbkey & formgroup)=""
			Session("Message" & dbkey & formgroup) = ""
			Session("RecordsFound" & dbkey & formgroup) = ""
			Session("StatusComment" & dbkey & formgroup) = ""
			Session("BaseCurrentIndex" & dbkey & formgroup) = 1
			Session("FilterReturnedWhere" & dbkey & formgroup)= ""
			Session("RegTrackingStr" & dbkey & formgroup) = "0"
			Session("DupTrackingStr" & dbkey & formgroup) = "0"
			Session("Refine" & dbkey & formgroup)=""
			Session("reload_basers" & dbkey & formgroup)=""
			Session("sort_direction" & dbkey & formgroup) = ""
			Session("order_by" & dbkey & formgroup)=""
			ClearStructuralData dbkey, Session("SearchData" & "SubStructure" & dbkey & formgroup)
			Session("SearchData" & "SubStructure" & dbkey & formgroup)=""
			
			ClearStructuralData dbkey, Session("SearchData" & "Exact" & dbkey & formgroup)
			Session("SearchData" & "Exact" & dbkey & formgroup)=""
			
			ClearStructuralData dbkey, Session("SearchData" & "Similarity" & dbkey & formgroup)
			Session("SearchData" & "Similarity" & dbkey & formgroup)=""
			
			ClearStructuralData dbkey, Session("SearchData" & "Identity" & dbkey & formgroup)
			Session("SearchData" & "Identity" & dbkey & formgroup)=""
			
			ClearStructuralData dbkey, Session("SearchData" & "Formula" & dbkey & formgroup)
			Session("SearchData" & "Formula" & dbkey & formgroup)=""
			
			ClearStructuralData dbkey, Session("SearchData" & "MolWeight" & dbkey & formgroup)
			Session("SearchData" & "MolWeight" & dbkey & formgroup)=""
			
			Session("SearchData" & "FULL_SQL" & dbkey & formgroup)=""
			
			ClearAllSearchData dbkey, formgroup
			
		Case "search_no_gui"
			Session("errors_found" & dbkey & formgroup) = ""
			Session("no_gui" & dbkey & formgroup) = True
			Session("strGetFields" & dbkey & formgroup)= ""
			Session("Base_RSRecordCount" & dbkey & formgroup)=0
			formgroupflag = GetFormGroupVal(dbkey, formgroup, kFormGroupFlag)
			Session("error" & dbkey & formgroup)= False
			Session("CurrentLocation" & dbkey & formgroup)= ""
			Session("fEmptyRecordset" & dbkey & formgroup) = False
			Session("Message" & dbkey & formgroup) = ""
			Session("MoreMolids" & dbkey & formgroup) = ""
			Session("LastID" & dbkey & formgroup) = ""
			Session("LastID" & dbkey & formgroup) = ""
			Session("GetNextCount" & dbkey & formgroup) = 1
			Session("strWhereSubforms" & dbkey & formgroup)= ""
			Session("TableAliasTracker" & dbkey & formgroup)=""
			Session("SearchData" & "RelPortion" & dbkey & formgroup)=""
			Session("SearchData" & "SearchName" & dbkey & formgroup)=""
			Session("Message" & dbkey & formgroup) = ""
			Session("RecordsFound" & dbkey & formgroup) = ""
			Session("StatusComment" & dbkey & formgroup) = ""
			Session("BaseCurrentIndex" & dbkey & formgroup) = 1
			Session("FilterReturnedWhere" & dbkey & formgroup)= ""
			Session("RegTrackingStr" & dbkey & formgroup) = "0"
			Session("records_found" & dbkey & formgroup) = ""
			Session("SearchData" & "FULL_SQL" & dbkey & formgroup)=""
			Session("Refine" & dbkey & formgroup)=""
			Session("reload_basers" & dbkey & formgroup)=""
			Session("sort_direction" & dbkey & formgroup) = ""
			Session("order_by" & dbkey & formgroup)=""
		Case "register"
			Session("errors_found" & dbkey & formgroup) = ""
			Session("no_gui" & dbkey & formgroup) = False
			Session("strGetFields" & dbkey & formgroup)= ""
			Session("Base_RSRecordCount" & dbkey & formgroup)=0
			formgroupflag = GetFormGroupVal(dbkey, formgroup, kFormGroupFlag)
			Session("error" & dbkey & formgroup)= False
			Session("CurrentLocation" & dbkey & formgroup)= ""
			Session("fEmptyRecordset" & dbkey & formgroup) = False
			Session("Message" & dbkey & formgroup) = ""
			
			Session("LastID" & dbkey & formgroup) = ""
			Session("LastID" & dbkey & formgroup)
			Session("GetNextCount" & dbkey & formgroup) = 1
			Session("strWhereSubforms" & dbkey & formgroup)= ""
			Session("TableAliasTracker" & dbkey & formgroup)=""
			Session("SearchData" & "RelPortion" & dbkey & formgroup)=""
			Session("Message" & dbkey & formgroup) = ""
			Session("RecordsFound" & dbkey & formgroup) = ""
			Session("StatusComment" & dbkey & formgroup) = ""
			Session("BaseCurrentIndex" & dbkey & formgroup) = 1
			Session("FilterReturnedWhere" & dbkey & formgroup)= ""
			Session("records_found" & dbkey & formgroup) = ""
			Session("reload_basers" & dbkey & formgroup)=""
			Session("sort_direction" & dbkey & formgroup) = ""
			Session("order_by" & dbkey & formgroup)=""
		Case "register_all"
			Session("errors_found" & dbkey & formgroup) = ""
			Session("no_gui" & dbkey & formgroup) = False
			Session("strGetFields" & dbkey & formgroup)= ""
			Session("Base_RSRecordCount" & dbkey & formgroup)=0
			formgroupflag = GetFormGroupVal(dbkey, formgroup, kFormGroupFlag)
			Session("error" & dbkey & formgroup)= False
			Session("CurrentLocation" & dbkey & formgroup)= ""
			Session("fEmptyRecordset" & dbkey & formgroup) = False
			Session("Message" & dbkey & formgroup) = ""
			Session("MoreMolids" & dbkey & formgroup) = ""
			Session("LastID" & dbkey & formgroup) = ""
			Session("LastID" & dbkey & formgroup)
			Session("GetNextCount" & dbkey & formgroup) = 1
			Session("strWhereSubforms" & dbkey & formgroup)= ""
			Session("TableAliasTracker" & dbkey & formgroup)=""
			Session("SearchData" & "RelPortion" & dbkey & formgroup)=""
			Session("Message" & dbkey & formgroup) = ""
			Session("RecordsFound" & dbkey & formgroup) = ""
			Session("StatusComment" & dbkey & formgroup) = ""
			Session("BaseCurrentIndex" & dbkey & formgroup) = 1
			Session("FilterReturnedWhere" & dbkey & formgroup)= ""
			Session("records_found" & dbkey & formgroup) = ""
			Session("reload_basers" & dbkey & formgroup)=""
			Session("sort_direction" & dbkey & formgroup) = ""
			Session("order_by" & dbkey & formgroup)=""
		Case "add_record"
			Session("errors_found" & dbkey & formgroup) = ""
			Session("no_gui" & dbkey & formgroup) = False
			Session("strGetFields" & dbkey & formgroup)= ""
			Session("Base_RSRecordCount" & dbkey & formgroup)=0
			formgroupflag = GetFormGroupVal(dbkey, formgroup, kFormGroupFlag)
			Session("error" & dbkey & formgroup)= False
			Session("CurrentLocation" & dbkey & formgroup)= ""
			Session("fEmptyRecordset" & dbkey & formgroup) = False
			Session("Message" & dbkey & formgroup) = ""
			Session("MoreMolids" & dbkey & formgroup) = ""
			Session("LastID" & dbkey & formgroup) = ""
			Session("LastID" & dbkey & formgroup)
			Session("GetNextCount" & dbkey & formgroup) = 1
			Session("strWhereSubforms" & dbkey & formgroup)= ""
			Session("TableAliasTracker" & dbkey & formgroup)=""
			Session("SearchData" & "RelPortion" & dbkey & formgroup)=""
			Session("SearchData" & "SearchName" & dbkey & formgroup)=""
			Session("Message" & dbkey & formgroup) = ""
			Session("RecordsFound" & dbkey & formgroup) = ""
			Session("StatusComment" & dbkey & formgroup) = ""
			Session("BaseCurrentIndex" & dbkey & formgroup) = 1
			Session("FilterReturnedWhere" & dbkey & formgroup)= ""
			Session("RegTrackingStr" & dbkey & formgroup) = "0"
			Session("records_found" & dbkey & formgroup) = ""
			Session("reload_basers" & dbkey & formgroup)=""
			Session("sort_direction" & dbkey & formgroup) = ""
			Session("order_by" & dbkey & formgroup)=""
		Case "update_record"
			Session("errors_found" & dbkey & formgroup) = ""
			Session("no_gui" & dbkey & formgroup) = False
			Session("strGetFields" & dbkey & formgroup)= ""
			Session("Base_RSRecordCount" & dbkey & formgroup)=0
			formgroupflag = GetFormGroupVal(dbkey, formgroup, kFormGroupFlag)
			Session("error" & dbkey & formgroup)= False
			Session("CurrentLocation" & dbkey & formgroup)= ""
			Session("fEmptyRecordset" & dbkey & formgroup) = False
			Session("Message" & dbkey & formgroup) = ""
			Session("MoreMolids" & dbkey & formgroup) = ""
			Session("LastID" & dbkey & formgroup) = ""
			Session("LastID" & dbkey & formgroup)
			Session("GetNextCount" & dbkey & formgroup) = 1
			Session("strWhereSubforms" & dbkey & formgroup)= ""
			Session("TableAliasTracker" & dbkey & formgroup)=""
			Session("SearchData" & "RelPortion" & dbkey & formgroup)=""
			Session("SearchData" & "SearchName" & dbkey & formgroup)=""
			Session("Message" & dbkey & formgroup) = ""
			Session("RecordsFound" & dbkey & formgroup) = ""
			Session("StatusComment" & dbkey & formgroup) = ""
			Session("BaseCurrentIndex" & dbkey & formgroup) = 1
			Session("FilterReturnedWhere" & dbkey & formgroup)= ""
			Session("RegTrackingStr" & dbkey & formgroup) = "0"
			Session("records_found" & dbkey & formgroup) = ""
			Session("reload_basers" & dbkey & formgroup)=""
			Session("sort_direction" & dbkey & formgroup) = ""
			Session("order_by" & dbkey & formgroup)=""
		Case "get_next"
			Session("no_gui" & dbkey & formgroup) = False
			Session("MoreMolids" & dbkey & formgroup) = ""
			Session("fEmptyRecordset" & dbkey & formgroup) = False
			Session("Message" & dbkey & formgroup) = ""
			Session("BaseCurrentIndex" & dbkey & formgroup) = Request.QueryString("currentindex")
			Session("GetNextCount" & dbkey & formgroup) = CLng(Session("GetNextCount" & dbkey & formgroup)) + 1
			Session("RecordsFound" & dbkey & formgroup) = ""
			Session("StatusComment" & dbkey & formgroup) = ""
			Session("reload_basers" & dbkey & formgroup)=""
		Case "edit_query","new_search","db","restore_query","delete_query"
			if(stype = "new_search") then
				Session("SearchData" & "inv_compounds.SDF" & dbkey & formgroup)=""	
			end if
			Session("fEmptyRecordset" & dbkey & formgroup) = False
			Session("no_gui" & dbkey & formgroup) = False
			Session("Base_RSRecordCount" & dbkey & formgroup)=0
			if lcase(dbkey) = "biosar_browser" then
				Response.Cookies("PagingMove" & dbkey) = ""
			else
				Response.Cookies("PagingMove" & dbkey & formgroup) = ""
			end if
			Session("error" & dbkey & formgroup)= False
			Session("fEmptyRecordset" & dbkey & formgroup) = False
			Session("Base_RS" & dbkey & formgroup) = ""
			Session("MolIDString" & dbkey & formgroup) = ""
			Session("MoreMolids" & dbkey & formgroup) = ""
			Session("LastID" & dbkey & formgroup) = ""
			Session("LastID" & dbkey & formgroup)
			Session("GetNextCount" & dbkey & formgroup) =1
			Session("CurrentLocation" & dbkey & formgroup)= ""
			Session("AppletArray") =""
			Session("SearchFilterFlag" & dbkey & formgroup) = "search"
			Session("Refine" & dbkey & formgroup)=""
			Session("strWhereSubforms" & dbkey & formgroup)= ""
			Session("TableAliasTracker" & dbkey & formgroup)=""
			Session("Message" & dbkey & formgroup) = ""
			Session("RecordsFound" & dbkey & formgroup) = ""
			Session("StatusComment" & dbkey & formgroup) = ""
			Session("GetNextArray" & dbkey & formgroup)= ""
			Session("FilterReturnedWhere" & dbkey & formgroup)= ""
			Session("SearchData" & "FULL_SQL" & dbkey & formgroup)=""			
			Session("reload_basers" & dbkey & formgroup)=""
			'Session("sort_direction" & dbkey & formgroup) = ""
			'Session("order_by" & dbkey & formgroup)=""
		Case "refine"
			Session("no_gui" & dbkey & formgroup) = False
			formgroupflag = GetFormGroupVal(dbkey, formgroup, kFormGroupFlag)
			if lcase(dbkey) = "biosar_browser" then
				Response.Cookies("PagingMove" & dbkey & formgroup) = ""
			else
				Response.Cookies("PagingMove" & dbkey & formgroup) = ""
			end if
			Session("fEmptyRecordset" & dbkey & formgroup) = False
			Session("error" & dbkey & formgroup)= False
			Session("CurrentLocation" & dbkey & formgroup)= ""
			Session("AppletArray") =""
			Session("strWhereSubforms" & dbkey & formgroup)= ""
			Session("SearchData" & "RelPortion"& dbkey & formgroup)=""
			Session("Message" & dbkey & formgroup) = ""
			Session("RecordsFound" & dbkey & formgroup) = ""
			Session("StatusComment" & dbkey & formgroup) = ""
			Session("FilterReturnedWhere" & dbkey & formgroup)= ""
			Session("reload_basers" & dbkey & formgroup)=""
			Session("in_refine_mode" & dbkey & formgroup) = true
			Session("sort_direction" & dbkey & formgroup) = ""
			Session("order_by" & dbkey & formgroup)=""
		Case "apply"
			Session("reload_basers" & dbkey & formgroup)=""
			Session("no_gui" & dbkey & formgroup) = False
			formgroupflag = GetFormGroupVal(dbkey, formgroup, kFormGroupFlag)
			'Response.Cookies("PagingMove" & dbkey & formgroup)  = ""
			Session("Base_RSRecordCount" & dbkey & formgroup)=0
			Session("error" & dbkey & formgroup)= False
			Session("CurrentLocation" & dbkey & formgroup)= ""
			Session("fEmptyRecordset" & dbkey & formgroup) = False
			Session("Message" & dbkey & formgroup) = ""
			Session("MoreMolids" & dbkey & formgroup) = ""
			Session("LastID" & dbkey & formgroup) = ""
			Session("GetNextCount" & dbkey & formgroup) = 1
			Session("strWhereSubforms" & dbkey & formgroup)= ""
			Session("TableAliasTracker" & dbkey & formgroup)=""
			Session("Message" & dbkey & formgroup) = ""
			Session("RecordsFound" & dbkey & formgroup) = ""
			Session("StatusComment" & dbkey & formgroup) = ""
			Session("FilterReturnedWhere" & dbkey & formgroup)= "refine"
			Session("SearchFilterFlag" & dbkey & formgroup) = "refine"
			Session("BaseCurrentIndex" & dbkey & formgroup)= 1
			
		
		Case "undo_refine"
			Session("reload_basers" & dbkey & formgroup)=""
			Session("no_gui" & dbkey & formgroup) = False
			if lcase(dbkey) = "biosar_browser" then
				Response.Cookies("PagingMove" & dbkey) = ""
			else
				Response.Cookies("PagingMove" & dbkey & formgroup) = ""
			end if
			Session("FilterReturnedWhere" & dbkey & formgroup)= ""
			Session("error" & dbkey & formgroup)= False
			Session("CurrentLocation" & dbkey & formgroup)= ""
			Session("fEmptyRecordset" & dbkey & formgroup) = False
			Session("BaseCurrentIndex" & dbkey & formgroup)= 1
			Session("in_refine_mode" & dbkey & formgroup) = false
			

	End Select
End Sub

'-------------------------------------------------------------------------------
' Name: ClearStructuralData(dbkey, inputstr)
' Type:  Sub
' Purpose: clear all session variables contianing chemical data
' Inputs: dbkey as string, fieldnames as comma delimited list
' Returns: none
'-------------------------------------------------------------------------------
Sub ClearStructuralData(dbkey, inputStr)
	input_array = split(inputStr, ",", -1)
	for i = 0 to UBound(input_array)
		Session("SearchData" & input_array(i) & dbkey & formgroup)= ""
	next
End sub

'-------------------------------------------------------------------------------
' Name: ClearAllSearchData(dbkey, formgroup)
' Type:  Sub
' Purpose: clear all session variables containing search data based on information in formgroup
' Inputs: dbkey as string, formgroup name as string
' Returns: none
'-------------------------------------------------------------------------------
Sub ClearAllSearchData(dbkey,formgroup)
	ClearData "ChemFields", "", getFormGroupVal(dbkey, formgroup, kStructureFields)
	ClearData "ChemFields", "", getFormGroupVal(dbkey, formgroup, kMWFields)
	ClearData "ChemFields", "", getFormGroupVal(dbkey, formgroup, kFormulaFields)
	ClearData "RelFields", "", getFormGroupVal(dbkey, formgroup, kRelFields)	
End sub


'-------------------------------------------------------------------------------
' Name: UpdateArray(dbkey, formgroup,getnextcount)
' Type:  Sub
' Purpose: add ids to session array for storing get next hits
' Inputs: dbkey as string, formgroup name as string, count for next set of hits as INT
' Returns: none
'-------------------------------------------------------------------------------
Sub UpdateArray(ByVal dbkey, ByVal formgroup, ByVal getnextcount)
	getnextcount = CLng(getnextcount + 1)
	Session("GetNextMaxHits" & dbkey & formgroup) = CLng(getnextcount * Application("MaxHits" & dbkey))
	'Session("GetNextArray" & dbkey & formgroup) = GetIDFromRS(dbkey, formgroup, "Base_RS")
End sub



'-------------------------------------------------------------------------------
' Name: GetFromArray(dbkey, formgroup,getnextcount)
' Type:  function
' Purpose: get count of hits in get next Session("GetNextArray" & dbkey & formgroup)
' Inputs: dbkey as string, formgroup name as string, count for next set of hits as INT
' Returns: current number of hits in Session("GetNextArray" & dbkey & formgroup) as INT
'-------------------------------------------------------------------------------
Function GetFromArray(ByVal dbkey, ByVal formgroup, ByVal getnextcount)
	on error resume next
	storedarray = Split(Session("GetNextArray" & dbkey & formgroup), ";", -1)
	GetFromArray = storedarray(getnextcount)
End Function



'-------------------------------------------------------------------------------
' Name: SetDBkey(dbkey, formgroup)
' Type:  function
' Purpose: set the first data view for returning results for global search
' Inputs: dbkey as string, formgroup name as string
' Returns: data view as string
'-------------------------------------------------------------------------------
Function SetDBkey(ByVal dbkey, ByVal formgroup)
	formgroupflag = GetFormGroupVal(dbkey, formgroup, kFormGroupFlag)
	If formgroupflag="GLOBAL_SEARCH" then
		dbkey =Application("GlobalBaseDB")	
	End If
	SetDBkey = dbkey
End Function



'-------------------------------------------------------------------------------
' Name: ReturnInputForm(dbkey, formgroup,stype)
' Type:  Sub
' Purpose: set input form path
' Inputs: dbkey as string, formgroup name as string, search type as enum
'	search type enum values
'		refine
'		edit_query
'		restore_query
'		search
'		add_record
'		add_compound
' Returns: nothing
' Comments: Sets Session("CurrentLocation" & dbkey & formgroup) with path to input form and appropriate formmode
'-------------------------------------------------------------------------------
Sub ReturnInputForm(ByVal dbkey, ByVal formgroup, ByVal stype)
	
    formgroupflag = GetFormGroupVal(dbkey, formgroup, kFormGroupFlag)
	If formgroupflag = "INDEX_SEARCH" then
		indexdb = Application(formgroup & dbkey & "IndexDB")
		dbkey = indexdb
	End if
	If formgroupflag = "GLOBAL_SEARCH" then
		globalbasedb = Application("GlobalBaseDB")
	End If

	Select case stype
		Case "refine"
			if Session("RestoreQueryOnRefine") OR Application("RestoreQueryOnRefine") then special = "&special=edit_query"
			special = special & "&refinetype=" & Request.Form("RefineType")
			formmode = "refine"
			Session("RestoreQueryOnRefine") = false
		Case "edit_query"
			
			special = "&special=edit_query"
			if formgroupflag = "REG_TEMP" then
				formmode = "add_compounds" 
			else
				formmode = "search"
			end if
		Case "restore_query"
			
			queryname = Request.QueryString("queryname")
			special = "&special=restore_query&queryname="& queryname
			if formgroupflag = "REG_TEMP" then
				formmode = "add_compounds" 
			else
				formmode = "search"
			end if
		Case "search"
			special = ""
			formmode = GetFormGroupVal(dbkey, formgroup,kInputFormMode)
		Case "new_search"
			special = ""
			formmode = GetFormGroupVal(dbkey, formgroup,kInputFormMode)
			special = "&special=clear_previous_query"
		Case "add_record"
			special = ""
			formmode = GetFormGroupVal(dbkey, formgroup,kInputFormMode)
		Case "add_compounds"
			special = ""
			formmode = GetFormGroupVal(dbkey, formgroup,kInputFormMode)
	
	End Select
	If formgroupflag = "GLOBAL_SEARCH" then
		theformpath=GetFormGroupVal(globalbasedb, formgroup, kInputFormPath)
	else
		theformpath=GetFormGroupVal(dbkey, formgroup, kInputFormPath)
	end if 
	if Left(theformpath, 1) = "/" then
		test_array = split(theformpath, "/", -1)
		if Not (UCase(test_array(1)) = UCase(Application("appkey"))) then
			theformpath = "/" & Application("appkey")& theformpath
		end if
	end if
	'theformpath
	'theformpath = GetFormGroupVal(dbkey, formgroup, kInputFormPath)
	If not special <> "" then
		if Not Left(theformpath, 1) = "/" then
			Session("CurrentLocation" & dbkey & formgroup)=Application("AppPathHTTP") & "/" & dbkey & "/" & theformpath & "?formgroup=" & formgroup & "&formmode=" & formmode & "&dbname=" & dbkey 
		else
			Session("CurrentLocation" & dbkey & formgroup)=theformpath & "?formgroup=" & formgroup & "&formmode=" & formmode & "&dbname=" & dbkey 
		end if
	Else
	
		if Not (UCase(stype) = "EDIT_QUERY" OR UCase(stype) = "REFINE" OR UCase(stype) = "RESTORE_LAST") then
			if Not request("return_location") <> "" then
				if Not Left(theformpath, 1) = "/" then
					Session("CurrentLocation" & dbkey & formgroup)=Application("AppPathHTTP")  & "/" & dbkey & "/" & theformpath & "?formgroup=" & formgroup & "&formmode=" & formmode & "&dbname=" & dbkey  & special
				else
					Session("CurrentLocation" & dbkey & formgroup)=theformpath & "?formgroup=" & formgroup & "&formmode=" & formmode & "&dbname=" & dbkey & special
				end if
			else
				Session("CurrentLocation" & dbkey & formgroup) = request("return_location") & special
			end if
		else
			if Not Left(theformpath, 1) = "/" then
				if formgroupflag = "GLOBAL_SEARCH" then 
			    	Session("CurrentLocation" & dbkey & formgroup)=Application("AppPathHTTP") & "/" & globalbasedb & "/" & theformpath & "?formgroup=" & formgroup & "&formmode=" & formmode & "&dbname=" & dbkey & special
				else
				    Session("CurrentLocation" & dbkey & formgroup)=Application("AppPathHTTP") & "/" & dbkey & "/" & theformpath & "?formgroup=" & formgroup & "&formmode=" & formmode & "&dbname=" & dbkey & special
				end if 
			else
				Session("CurrentLocation" & dbkey & formgroup)=theformpath & "?formgroup=" & formgroup & "&formmode=" & formmode & "&dbname=" & dbkey & special
			end if
		
		end if
	End If
	
	redirectpath = Session("CurrentLocation" & dbkey & formgroup) 
	redirectpath=MakeQueryStringBeDifferent(redirectpath)
	append_to_string = getPreserveQueryItems()		
	redirectpath = redirectpath & append_to_string
	DoRedirect dbkey, redirectpath
End sub

'-------------------------------------------------------------------------------
' Name: getPreserveQueryItems()
' Type:  Function
' Purpose: determine what items in querystring should be preserved in new querystring
' Inputs: none
' Request Inputs: preserver_items
' Returns: url formatted string containing preserved items as string
'-------------------------------------------------------------------------------
Function getPreserveQueryItems()
	if request("preserve_items") <> "" then
		preserve_items_array = split(request("preserve_items"), ",", -1)
		for i = 0 to UBound(preserve_items_array)
			if preserve_string <> "" then
				preserve_string = preserve_string & "&" & preserve_items_array(i) & "=" & request(preserve_items_array(i))
			else
				preserve_string = "&" & preserve_items_array(i) & "=" & request(preserve_items_array(i))
			end if
		next
	else
		preserve_string = ""
	end if
	getPreserveQueryItems = preserve_string
End Function

'-------------------------------------------------------------------------------
' Name: ReturnEditResultsMaster(dbkey, formgroup, action, dbsearchnames)
' Type:  Function
' Purpose: set edit record return path
' Inputs: data view as string, formgroup name as string, record action enum  as string, dataview comma delimited list as string
'	action enum values
'		UPDATE_RECORD
'		DELETE_RECORD
'		ADD_RECORD
' Request Inputs: CurrentLocation, Return_Location, Stored_Location
' Returns: return path
'-------------------------------------------------------------------------------
Function ReturnEditResultsMaster(ByVal dbkey, ByVal formgroup, ByVal action,  ByVal dbsearchnames)
	return_location=Request("CurrentLocation") 
	return_Location_override = Request("Return_Location") 
	stored_location = Request("Stored_Location")
		
	if return_Location_override <> "" then
		return_Location = return_Location_override
	End if 
		
	if not return_Location_override <> "" AND Not stored_location <> "" then 
	
		if instr(return_location, "form_change=true")> 0 then
			formmode = "list"
			temp_result = GetFormGroupVal(dbkey, formgroup, kResultFormPath)
			if instr(temp_result, ";")>0 then
				result_forms = split(temp_result, ";", -1)
				result_list_view = result_forms(0)
				result_form_view = result_forms(1)
				return_location = Replace(return_location, result_form_view, result_list_view)
				SetStartRecordset dbkey, formgroup
			else
				result_list_view = temp_result
				result_form_view = replace(return_location, "_result_list.asp", "_form.asp")
			end if
				
		else
			if UCase(action) = "ADD_RECORD" then
				formmode =request("formmode")
			else
				formmode = "edit"
			end if
		end if
		Select Case UCase(action)
			Case "UPDATE_RECORD"
				redirectpath = Replace(return_location, "formmode=edit_record", "formmode=" & formmode)
				if Request("ExactSearchFields")<> "" then
					redirectpath= redirectpath & "&edit_structure=true"
				end if
			Case "DELETE_RECORD"
				redirectpath = Replace(return_location, "formmode=edit_record", "formmode=" & formmode)
					
			Case "ADD_RECORD"
				redirectpath = Replace(return_location, "formmode=add_record", "formmode=" & formmode)

			End Select
			
	else 'if not return_Location_override <> "" AND Not stored_location <> "" then 

		Select Case UCase(action)
			Case "UPDATE_RECORD"
				if return_location <> "" then
					redirectpath = (return_location)
				else
					redirectpath = (stored_location)
				end if	
			
			Case "DELETE_RECORD"
				if return_location <> "" then
					redirectpath = (return_location)
				else
					redirectpath = (stored_location)
				end if
			Case "ADD_RECORD"
				if return_location <> "" then
					redirectpath = (return_location)
				else
					redirectpath = (stored_location)
				end if
		End Select
	end if 'if not return_Location_override <> "" AND Not stored_location <> "" then 
	
	Session("CurrentLocation" & dbkey & formgroup)=redirectpath & "&time=" & Timer()
	Session("reload_list") = true
	Session("reload_form") = true
	
	session("formmode_loaded") = formmode
	redirectpath=MakeQueryStringBeDifferent(redirectpath)
	append_to_string = getPreserveQueryItems()		
	redirectpath = redirectpath & append_to_string
	ReturnEditResultsMaster=redirectpath
End Function


'-------------------------------------------------------------------------------
' Name: ReturnEditResults(dbkey, formgroup, action, dbsearchnames)
' Type:  Sub
' Purpose: master routine to set form path after edit record function
' Inputs: data view as string, formgroup name as string, record action enum  as string, dataview comma delimited list as string
'	action enum values
'		UPDATE_RECORD
'		DELETE_RECORD
'		ADD_RECORD
' Request Inputs: CurrentLocation, Return_Location, Stored_Location
' Returns: none
' Comments: redirects to path returned by ReturnEditResultsMaster
'-------------------------------------------------------------------------------
Sub	ReturnEditResults(ByVal dbkey, ByVal formgroup, ByVal action,  ByVal dbsearchnames)
	
	redirectpath=ReturnEditResultsMaster(dbkey, formgroup, action, dbsearchnames)
	
	DoRedirect dbkey, redirectpath

End Sub

'-------------------------------------------------------------------------------
' Name: ReturnResultsMaster(dbkey, formgroup, action, dbsearchnames)
' Type:  Function
' Purpose: set detail view form  path
' Inputs: data view as string, formgroup name as string, record action enum  as string, dataview comma delimited list as string
'	action enum values
'		SEARCH
' Request Inputs: Return_Location, formmode_override
' Returns: return path for detail form
'-------------------------------------------------------------------------------


function ReturnResultsMaster(ByVal dbkey, ByVal formgroup, ByVal action,  ByVal dbsearchnames)

	if Session("no_gui" & dbkey & formgroup) = False then
		Return_Location = Request("Return_Location") 
		Return_formmode = Request("formmode_override")
		if not return_location <> "" then 
			if action = "register" then
				formmode = "list"
			end if
			if Return_formmode <> "" then
				if (Instr(UCase(Return_formmode), "EDIT_")>0 or Instr(UCase(Return_formmode),"ADD_") > 0) then
					formmode = "edit" 'used to get the right page - but overridden before the redirect
					formmode_override = Return_formmode
				else
					formmode = Return_formmode
				end if
			end if
			formgroupflag = GetFormGroupVal(dbkey, formgroup, kFormGroupFlag)
			If Not Session("fEmptyRecordset" & dbkey & formgroup)= True then
				If action = "search" then
					StoreSearchData dbkey, formgroup
				End If
			End If
			temp_result = GetFormGroupVal(dbkey, formgroup, kResultFormPath)
		
			if instr(temp_result, ";")>0 then
				result_forms = split(temp_result, ";", -1)
				result_list_view = result_forms(0)
				if Left(result_list_view, 1) = "/" then
				test_array = split(result_list_view, "/", -1)
					if Not (UCase(test_array(1)) = UCase(Application("appkey"))) then
						result_list_view = "/" & Application("appkey")&  result_list_view
					end if
				end if
				result_form_view = result_forms(1)
				if Left(result_form_view, 1) = "/" then
					test_array = split(result_form_view, "/", -1)
					if Not (UCase(test_array(1)) = UCase(Application("appkey"))) then
						result_form_view = "/" & Application("appkey")&  result_form_view
					end if
				end if
			else
				if Left(temp_result, 1) = "/" then
					test_array = split(temp_result, "/", -1)
					if Not (UCase(test_array(1)) = UCase(Application("appkey"))) then
						temp_result = "/" & Application("appkey")&  temp_result
					end if
				end if
				result_list_view = temp_result
				result_form_view = replace(result_list_view, "_result_list.asp", "_form.asp")
			end if
			
			if Not formmode <> "" then
				formmode = GetFormGroupVal(dbkey, formgroup, kResultFormMode)
				if instr(Application("prefs_formgroups"), formgroup)> 0 OR Application("prefs_formgroups")= "" then
					temp = Session("UserResultsPrefs" & dbkey)
				else
					temp = ""
				end if
			else
				temp = formmode
			end if
			if temp <> "" then
					if UCase(temp) = "LIST" then
						resultform =result_list_view
						formmode = "list"
					else if UCase(temp) = "EDIT"  then
						resultform = result_form_view
						formmode = "edit"
						else 
							if UCase(formmode) = "EDIT" then
									resultform =result_form_view 
							else
								resultform =result_list_view
							formmode = "list"
							end if
						end if
					end if
			else
				
				if UCase(formmode) = "EDIT" then
					resultform =result_form_view 
				else
					resultform =result_list_view
					formmode = "list"
				end if
			end if
			if not resultform <> "" then
				if formmode = "list" then
					resultform = request("dbname") & "_result_list.asp"
				else
					resultform = request("dbname") & "_form.asp"
				end if
			end if
			if action = "get_sql_string" then
				if Not Left(resultform,1) = "/" then
					Session("CurrentLocation" & dbkey & formgroup)=Application("AppPathHTTP")  & "/" & dbkey & "/" &  resultform & "?formgroup=" & formgroup & "&formmode=" & formmode & "&dbname=" & dbkey & "&BaseCurrentIndex=" & Session("BaseCurrentIndex" & dbkey & formgroup) & "&BaseRecordCount=" & 	Session("Base_RSRecordCount" & dbkey & formgroup) &"&dbsearchnames=" &  DBSearchNames & "&table_name=" & request("base_table_name")
				else
					Session("CurrentLocation" & dbkey & formgroup)=  resultform & "?formgroup=" & formgroup & "&formmode=" & formmode & "&dbname=" & dbkey & "&BaseCurrentIndex=" & Session("BaseCurrentIndex" & dbkey & formgroup) & "&BaseRecordCount=" & 	Session("Base_RSRecordCount" & dbkey & formgroup) &"&dbsearchnames=" &  DBSearchNames & "&table_name=" & request("base_table_name")
				end if
				SetStartRecordset dbkey, formgroup
			else
				if Not Left(resultform,1) = "/" then
					Session("CurrentLocation" & dbkey & formgroup)=Application("AppPathHTTP")  & "/" & dbkey & "/" &  resultform & "?formgroup=" & formgroup & "&formmode=" & formmode & "&dbname=" & dbkey & "&BaseCurrentIndex=" & Session("BaseCurrentIndex" & dbkey & formgroup) & "&BaseRecordCount=" & 	Session("Base_RSRecordCount" & dbkey & formgroup) &"&dbsearchnames=" &  DBSearchNames 
				else
					Session("CurrentLocation" & dbkey & formgroup)= resultform & "?formgroup=" & formgroup & "&formmode=" & formmode & "&dbname=" & dbkey & "&BaseCurrentIndex=" & Session("BaseCurrentIndex" & dbkey & formgroup) & "&BaseRecordCount=" & 	Session("Base_RSRecordCount" & dbkey & formgroup) &"&dbsearchnames=" &  DBSearchNames 
				end if
			end if
			redirectpath =  Session("CurrentLocation" & dbkey & formgroup)
			if not inStr(redirectpath, "&time=")>0 then
				redirectpath = redirectpath & "&time=" & Timer()
			end if
			if request.querystring("limit_access") <> "" then
				redirectpath = redirectpath & "&limit_access=" & request.querystring("limit_access")
			end if
			if formmode_override <> "" then
				redirectpath = replace(redirectpath, "&formmode=" & formmode, "&formmode=" & formmode_override)
			end if
		else
			redirectpath = return_location
		end if
		Session("reload_list") = true
		Session("reload_form") = true
		
		session("formmode_loaded") = formmode
		redirectpath=MakeQueryStringBeDifferent(redirectpath)
		
	else
		session("formmode_loaded") = formmode
		Session("errors_found" & dbkey & formgroup)= "no_records_found"
		Response.end
	end if
	append_to_string = getPreserveQueryItems()		
	redirectpath = redirectpath & append_to_string
	ReturnResultsMaster=redirectpath
end function

'-------------------------------------------------------------------------------
' Name: ReturnResults(dbkey, formgroup, action, dbsearchnames)
' Type:  Function
' Purpose: set detail view form  path by calling ReturnResultsMaster
' Inputs: see ReturnResultsMaster for detials on inputs
' Returns: redirects to formpath from ReturnResultsMaster
'-------------------------------------------------------------------------------
Sub	ReturnResults(ByVal dbkey, ByVal formgroup, ByVal action,  ByVal dbsearchnames)
	redirectpath = ReturnResultsMaster(dbkey, formgroup, action, dbsearchnames)
	DoRedirect dbkey, redirectpath
End Sub


'-------------------------------------------------------------------------------
' Name: GetBaseTable(dbkey, formgroup, tabletype)
' Type:  Function
' Purpose: get chemical or relational base table for formgroup depening on formgroup flag
' Inputs: data view as string, formgroup as string, table type as string 
'		table types: basetable
'					moltable
'						
' Returns: returns table name as string
'-------------------------------------------------------------------------------
Function GetBaseTable(ByVal dbkey, ByVal formgroup, ByVal tabletype)
	formmode = UCase(request("formmode"))
	formgroupflag = GetFormGroupVal(dbkey, formgroup, kFormGroupFlag)
	tabletype = UCase(tabletype)
	Select Case tabletype
		Case "BASETABLE"
			Select Case formgroupflag
				Case "REG_COMMIT"
					Select Case formmode 
						Case "REGISTER"
							thetable = Application(formgroup & dbkey & "RegCommitBaseTable")
						Case "SEARCH" 
							thetable = Application(formgroup & dbkey & "RegTempBaseTable")
						Case "EDIT"
							thetable = Application(formgroup & dbkey & "RegCommitBaseTable")
						Case "LIST"
							thetable = Application(formgroup & dbkey & "RegCommitBaseTable")
						Case else
							thetable = Application(formgroup & dbkey & "RegTempBaseTable")
					End select
				Case "REG_TEMP"
					thetable = Application(formgroup & dbkey & "RegTempBaseTable")
				Case "GLOBAL_SEARCH", "SINGLE_SEARCH"
					thetable= GetTableGroupVal(dbkey, formgroup, kBaseTable)
				Case Else
					thetable= GetTableGroupVal(dbkey, formgroup, kBaseTable)
				End Select
		Case "MOLTABLE"
			Select Case formgroupflag
				Case "REG_COMMIT"
					Select Case formmode 
						Case "REGISTER"
							thetable = Application(formgroup & dbkey & "RegCommitMolTable")
						Case "SEARCH" 
							thetable = Application(formgroup & dbkey & "RegTempMolTable")
						Case "EDIT"
							thetable = Application(formgroup & dbkey & "RegCommitMolTable")
						Case "LIST"
							thetable = Application(formgroup & dbkey & "RegCommitMolTable")
						Case else
							thetable = Application(formgroup & dbkey & "RegTempMolTable")
					End select
				Case "REG_TEMP"
					thetable = Application(formgroup & dbkey & "RegTempMolTable")
				Case "GLOBAL_SEARCH", "SINGLE_SEARCH"
					thetable= GetTableGroupVal(dbkey, formgroup, kMolTable)
				Case Else
					thetable= GetTableGroupVal(dbkey, formgroup, kMolTable)

			End Select
	End Select
	GetBaseTable = thetable
End Function


'-------------------------------------------------------------------------------
' Name: GetBaseTable2(dbkey, formgroup, tabletype)
' Type:  Function
' Purpose: get chemical or relational base table for formgroup. Does not care
'		   about formmode or formgroup flag.
'		   It is used by hitlist handling code instead of the original function
'          which had reg specific formmode and formgroup flag logic
' Inputs: data view as string, formgroup as string, table type as string 
'		table types: basetable
'					moltable
'						
' Returns: returns table name as string
'-------------------------------------------------------------------------------
Function GetBaseTable2(ByVal dbkey, ByVal formgroup, ByVal tabletype)
	GetBaseTable2 = GetTableGroupVal(dbkey, formgroup, kBaseTable)
End Function

'-------------------------------------------------------------------------------
' Name: DoAddRecord(dbkey, formgroup, table_names, field_names, addtype)
' Type:  Function
' Purpose: Add record to database
' Inputs: data view as string, formgroup as string, table names list  as string , field names list as sting, add type as string
'	addtypes:  CASCADE|Empty String
' Request Inputs:  Add_Record_Action
' Session Variable Inputs: 	Session("SearchData" & "Exact" & dbkey & formgroup)				
' Returns: boolean true if record addtion is successful
' Session Variable Returns:  Session("duplicates_found" & dbkey & formgroup), Session("Add_Record_New_ID" & dbkey & formgroup)
'-------------------------------------------------------------------------------
Function DoAddRecord(dbkey, formgroup, table_names, field_names, addType)
	Session("duplicates_found" & dbkey & formgroup)=""
	Session("Add_Record_New_ID" & dbkey & formgroup) = ""
	
	
	
	'loop through data from form groups ado searchable fields and commit each fields data to temp table
	temp_tables_array = split(table_names, ",", -1)
	for i = 0 to UBound(temp_tables_array)
		tablename_temp = temp_tables_array(i)
		strucDataPassed = inStr(UCase(Session("SearchData" & "Exact" & dbkey & formgroup)), UCase(tablename_temp))> 0
		if strucDataPassed then
			primkey = GetTableVal(dbkey, tablename_temp, kPrimaryKey)
			'Relax the restriction on mol_id as primary key
			molIDTag = 0 'Used to identify a row when mol_id is the primary key
			if UCase(primkey) = "MOL_ID" then
				'Session("errors_found" & dbkey & formgroup) = "MOL_ID cannot be the primary key. An alternate primary key must be added to " &  tablename_temp & ". The " & dbkey & ".ini file must be modified to reflect his change."
				'Cleanup any problems from a previous structure commit
				Set midConn = GetConnection(dbkey, formgroup, tablename_temp)
				sql = "Update " & tablename_temp & " set mol_id = null where mol_id =" & molIDTag
				midConn.execute sql
				midConn.close				
			end if
		end if
		Add_Record_Action = request("Add_Record_Action")
		
		Select Case UCase(Add_Record_Action)
			Case "DUPLICATE_SEARCH_NO_ADD"
				StoreBasearray = Session("Base_RS" & dbkey & formgroup)
				if inStr(UCase(Session("SearchData" & "Exact" & dbkey & formgroup)), UCase(tablename_temp))> 0 then			
					if UseCartridge(dbkey, formgroup) then
						dups_found = doDuplicatesSearch(dbkey, formgroup, Session("SearchData" & "Exact" & dbkey & formgroup))
					else
						dups_found = doDuplicatesSearch(dbkey, formgroup, tablename_temp)
					end if
					if dups_found <> "" then
						Session("errors_found" & dbkey & formgroup) = "Duplicate Compound(s) Found: mol_id=" & dups_found & " . No record(s) were added."
						Session("duplicates_found" & dbkey & formgroup)=dups_found
						Session("Base_RS" & dbkey & formgroup) = StoreBasearray
						DoAddRecord = false
						exit function
					end if
				end if
			
			Case "DUPLICATE_SEARCH_ADD"
				StoreBasearray = Session("BaseRS" & dbkey & formgroup)
				if inStr(UCase(Session("SearchData" & "Exact" & dbkey & formgroup)), UCase(tablename_temp))> 0 then			
					if UseCartridge(dbkey, formgroup) then
						dups_found = doDuplicatesSearch(dbkey, formgroup, Session("SearchData" & "Exact" & dbkey & formgroup))
					else
						dups_found = doDuplicatesSearch(dbkey, formgroup, tablename_temp)
					end if
					if dups_found <> "" then
						Session("duplicates_found" & dbkey & formgroup)=dups_found
						Session("Base_RS" & dbkey & formgroup) = StoreBasearray
					end if
				end if

			Case Else
		End Select

		
		Set DataConn = GetConnection(dbkey, formgroup, tablename_temp)
	
		if DataConn.State=0 then ' assume user has been logged out
			DoLoggedOutMsg "search_funcs", "DoAddRecord", "bad connection:forgroup=" & formgroup & " dbkey=" & dbkey & " table name=" & tablename_temp
		end if
		
		Set CommitRS = Server.CreateObject("ADODB.Recordset")
		if bCoreOracleTrace = true then
			sql = "ALTER SESSION SET SQL_TRACE=TRUE"
			DataConn.Execute(sql)
		end if
		primkey = GetTableVal(dbkey, tablename_temp, kPrimaryKey) 
		'LJB 11/17 need to convert from alias to real table name 
		real_table_name =GetTableVal(dbkey, tablename_temp, kTableRealName)
		CommitRS.Open real_table_name, DataConn, adOpenKeyset,  adLockOptimistic, adCmdTable 'get the right record with mol_id
		CommitRS.AddNew	
		
		' Sets a temporary mol_id value to be able to handle the newly added row
		if i=0 AND UCase(primkey) = "MOL_ID" AND strucDataPassed then
			CommitRS(primkey).value = molIDTag 
		End if
		
		' This block sets the foreingkey field in the base table
		' Runs only on child tables
		if UCase(addType) = "CASCADE" then
			if i > 0 then
				'get link val string for current table
				linkString_temp = GetTableVal(dbkey,tablename_temp,kSelectJoin)
				if inStr(linkString, "|")> 0 then
					linkstring_array = split(linkstring_temp, "|", -1)
					linkString = linstring_array(0)
				else
					linkString=linkString_temp
				end if
				
				'split link val of format : this_table_name.this_table_link=from_table_name.from_table_link 
				linkStringArray = Split(linkString , "=", -1)
				this_table_link_array = Split(linkStringArray(0), ".", -1)
				from_table_link_array= Split(linkStringArray(1), ".", -1)
				'get info about the the current table last table
				if UBound(this_table_link_array) = 2 then
					this_table_name =this_table_link_array(0) & "." & this_table_link_array(1)
					this_table_fkey =this_table_link_array(2)
				else
					this_table_name =this_table_link_array(0) 
					this_table_fkey =this_table_link_array(1)
				end if
				'get info about the table from which the newid key is being passed to this table last table
				if UBound(this_table_link_array) = 2 then
					from_table_name=from_table_link_array(0) & "." & from_table_link_array(1)
					from_table_Fkey=from_table_link_array(2)
				else
					from_table_name=from_table_link_array(0)
					from_table_Fkey=from_table_link_array(1)
				end if
				'check if the from_table_fkey is the same as the primary key of the from table			
				from_table_PKey = GetTableVal(dbkey,from_table_name,kPrimaryKey)
				
				'if keys are not the same then go back ot the fron table and get the value needed by this table for the new record
				if Not UCase(from_table_PKey) = UCase(from_table_fkey) then
						Do Until Len(new_newid)> 0
							Set CommitRS2 = Server.CreateObject("ADODB.Recordset")
							sql = "SELECT " & from_table_Fkey & "  FROM " & from_table_name & " WHERE  " & from_table_PKey & " =" &  newid
							CommitRS2.Open sql, DataConn
							new_newid = CommitRS2(from_table_Fkey)
						loop
						CloseRS(CommitRS2)
						newid = new_newid
					'commit proper value to this table
				end if
				CommitRS(this_table_fkey) = newid
			end if 'i>0
				Fkey = this_table_fkey
		end if

		' Here the fields get populated
		field_array = Split(field_names, ",", -1)

		for j = 0 to UBound(field_array)
			fullfieldnamearray =split(field_array(j), ";", -1)
			fullfieldname =fullfieldnamearray(0)
			fieldnamearray = split(fullfieldname, ".", -1)
			if UBound(fieldnamearray) = 2 then
				fieldname = fieldnamearray(2)
				table_name = fieldnamearray(0) & "." & fieldnamearray(1)
			else
				fieldname = fieldnamearray(1)
				table_name = fieldnamearray(0)
			end if
			
				if UCase(table_name) =  UCase(tablename_temp) then
					on error resume next
					theValue = Session("SearchData" & fullfieldname & dbkey & formgroup)
					if Application("FIELD_SPLIT_CHARACTER") <> "" then
						field_split_char = Application("FIELD_SPLIT_CHARACTER")
					else
						field_split_char = ";"
					end if
				
					
					if inStr(theValue, field_split_char)> 0 then
						theValuearray = split(theValue, field_split_char, -1)
						for k = 0 to UBound(theValuearray)
							if k = 0 then
								CommitRS.Fields(fieldname).Value = theValuearray(0)
								CommitRS.Update
							else
								CommitRS.AddNew
								CommitRS(FKey) = newid
								CommitRS.Fields(fieldname).Value = theValuearray(k)
							end if
						next
					else
						if Not isEmpty(theValue)then 
							'CommitRS.Fields(fieldname).Value= Session("SearchData" & fullfieldname & dbkey & formgroup)
							'SYAN changed on 12/16/2003 to fix CSBR-35466
							if (CommitRS.Fields(fieldname).Type) = adDBTimeStamp or (CommitRS.Fields(fieldname).Type) = adDate then
								dateVal = Session("SearchData" & fullfieldname & dbkey & formgroup)
								CommitRS.Fields(fieldname).Value = ConvertStrToDate(Application("DATE_FORMAT"), dateVal)
							'SYAN changed on 9/23/2004 to fix CSBR-46729
							elseif (CommitRS.Fields(fieldname).Type) = adVarNumeric or (CommitRS.Fields(fieldname).Type) = adDouble then
								CommitRS.Fields(fieldname).Value= CDbl(Session("SearchData" & fullfieldname & dbkey & formgroup))
							else
								CommitRS.Fields(fieldname).Value= Session("SearchData" & fullfieldname & dbkey & formgroup)
							end if

						end if
					end if
					
					CheckForADOErrors dbkey, DataConn, "DoAddRecord Field error: " & fieldname & Session("SearchData" & fullfieldname & dbkey & formgroup), "log"
				end if
			
		Next 'j

		CommitRS.Update
		CheckForADOErrors dbkey, DataConn, "DoAddRecord Update error: " & err.number & err.description, "log"
		'DGB commented out the following block to fix CSBR-50398
		'because the newid is alredy set above.  Movelast does gurantee returning the newly 
		'entered row!
		
		'Fetch the primary key handle used to commit the structure
		'if UCase(GetTableVal(dbkey, table_name,kSQLSyntax)) = "ACCESS" then
		'	CloseRS(CommitRS)
		'	Set CommitRS = Server.CreateObject("ADODB.Recordset")
		'	CommitRS.Open tablename_temp, DataConn, adOpenKeyset,  adLockOptimistic 'get the right record with mol_id
		'	CommitRS.MoveLast
		'end if
		newid = CommitRS(primkey)
		
		'Commit the structure
		if newid <> ""  AND strucDataPassed then
			if  UseCartridge(dbkey, formgroup) and Not bStructureDone = true then
				success = DoCartridgeAddStructure(dbkey, formgroup, Session("SearchData" & "Exact" & dbkey & formgroup), newid,"",DataConn,CommitRS)
				CloseRS(CommitRS)
			else
				CloseRS(CommitRS)
				isOK= DoAddStructure(dbkey, formgroup, Session("SearchData" & "Exact" & dbkey & formgroup),newid,DataConn) 
			end if
		end if
		
		'if mol_id is the PK, get its new value generated by the structure commit
		
		

		if i=0 AND UCase(primkey) = "MOL_ID" AND strucDataPassed then
			Set midRS = Server.CreateObject("ADODB.Recordset")
			'Pool for the MOL_ID inserted by CSDO for a maximum of 20 seconds
			t=timer()
			Do while (newid = 0 AND timer()-t < 20)
				'sql = "SELECT Max(MOL_ID) from " & tablename_temp
				'midRS.Open sql, DataConn				
				midRS.Open tablename_temp, DataConn, adOpenDynamic,  adLockReadOnly
				'newid=  midRS(0).value
				midRS.MoveLast
				newid=midRS("MOL_ID").Value
				midRS.Close
			loop
		End if
		
		Session("Add_Record_New_ID" & dbkey & formgroup) = newid
		'add to BaseRS
		if i = 0 then
			thearray= Session("Base_RS" & dbkey & formgroup)
			if isArray(thearray) = false then
				Dim thearray
				ReDim thearray(0,0)
				thearray(0,0)=newid
				Session("Base_RS" & dbkey & formgroup) = thearray
				Session("fEmptyRecordset" & dbkey & formgroup)= false
			else
				currentcount =UBound(thearray,2)
				newcount = CLng(currentcount) + 1
				ReDim Preserve thearray(0,newcount)
				thearray(0,newcount) = newid
				Session("Base_RS" & dbkey & formgroup) = thearray
			end if
		end if
		
		UpdateTableRecordCount dbkey, formgroup,  tablename_temp, DataConn
			
		CloseConn(DataConn)
	Next 'i

	if err.number <> 0 OR Session("errors_found" & dbkey & formgroup)<> "" then
		success = false
	else
		success = true
	end if
	DoAddRecord=success
End Function



'-------------------------------------------------------------------------------
' Name: DoUpdateRecord(dbkey, formgroup, StrucFields, thefields, tablename,uniqueid)
' Type:  Function
' Purpose: update record to database including structure record
' Inputs: data view as string, formgroup as string, Structure field list as list  as string ,relational field list as string, tablename  as string, base id for table  as CInt
' Returns: boolean true if record updaate is successful
'-------------------------------------------------------------------------------
Function DoUpdateRecord(ByVal dbkey, ByVal formgroup, ByVal StrucFields, ByVal thefields, ByVal tablename, ByVal uniqueid)
	'get basetable and moltable values from ini file for formgroup
	'create data connection and recordset object for adding data to temporary table
	'loop through data from form groups ado searchable fields and commit each fields data to temp table	
	sqlSyntax = GetTableVal(dbkey, tablename, kSQLSyntax)
	fields_array = Split(thefields, ",", -1)
	Set DataConn = GetConnection(dbkey, formgroup, tablename)
	if DataConn.State=0 then ' assume user has been logged out
		DoLoggedOutMsg "search_funcs", "DoUpdateRecord", "bad connection:forgroup=" & formgroup & " dbkey=" & dbkey & " table name=" & tablename
	end if
	Set CommitRS = Server.CreateObject("ADODB.Recordset")
	for j = 0 to UBound(fields_array)
		on error resume next
		fullfieldname = fields_array(j)
		if fullfieldname <> ""  then
			if InStr(fullfieldname, "UID")> 0 then
				test ="UID." & uniqueid & ":" &  UCase(tablename)& "."
				temp_name = split(fullfieldname, ".", -1)
				if UBound(temp_name) = 3 then
					fieldname = temp_name(3)
				else
					fieldname = temp_name(2)'format is UID.unqi:tablename.fieldname
				end if
			else
				test = UCase(tablename)& "."
				temp = split(fullfieldname, ":", -1)
				temp_new = split(temp(1), ".", -1)
				if UBound(temp_new) = 2 then
					fieldname = temp_new(2)
				else
					fieldname = temp_new(1)
				end if
			end if
			strucFieldArray = split(StrucFields, ",", -1)
			bStrucField = false

			for i = 0 to UBound(strucFieldArray)
				strucFieldTest = replace(strucFieldArray(i), fieldname & uniqueid, fieldname)
				if UCase(strucFieldTest) = UCase(fullfieldname) then
					bStrucField = true
				end if
			next

			if InStr(Ucase(fullfieldname), UCase(test))> 0 and Not bStrucField = true then
				Dim newVal, currentVal, sql
				table_unique_id = GetTableVal(dbkey, tablename, kPrimaryKey)
				'datatype =getDataType(dbkey,  formgroup,  tablename & "." & table_unique_id)
				datatype = 1
				delimiter = GetFieldDelimiter(datatype)
				on error resume next
				'see if data has changed for each submitted field, then update
				
				''SYAN modified on 1/27/2005 to parameterize the statement
				'Original
				if UCase(sqlSyntax) = "ORACLE" then
					if delimiter = "#" then
						Select case datatype
							Case "8" 
								sql = "Select " & fieldname & " From " & tablename  &   " where " & table_unique_id & "= TO_DATE('" & uniqueid & "'," & "'MM,DD,YYYY')"' this is passed in as a parameter
							Case "9"
								sql = "Select " & fieldname & " From " & tablename  &   " where " & table_unique_id & "=TO_DATE('" & uniqueid & "'," & "'DD,MM,YYYY')"' this is passed in as a parameter
						end select
					else
						sql = "Select " & fieldname & " From " & tablename  &   " where " & table_unique_id & "=" & delimiter & uniqueid & delimiter
					end if
				else
					sql = "Select " & fieldname & " From " & tablename  &   " where " & table_unique_id & "=" & delimiter & uniqueid & delimiter
				end if 'UCase(sqlSyntax) = "Oracle"
				CommitRS.Open sql, DataConn, adOpenKeyset,  adLockOptimistic
				
				'Changed to
				'if UCase(sqlSyntax) = "ORACLE" then
				'	if delimiter = "#" then
				'		Select case datatype
				'			Case "8" 
				'				sql = "Select " & fieldname & " From " & tablename  &   " where " & table_unique_id & "= TO_DATE('" & uniqueid & "'," & "'MM,DD,YYYY')"' this is passed in as a parameter
				'			Case "9"
				'				sql = "Select " & fieldname & " From " & tablename  &   " where " & table_unique_id & "=TO_DATE('" & uniqueid & "'," & "'DD,MM,YYYY')"' this is passed in as a parameter
				'		end select
				'		CommitRS.Open sql, DataConn, adOpenKeyset,  adLockOptimistic
				'	else
				'		'sql = "Select " & fieldname & " From " & tablename  &   " where " & table_unique_id & "=" & delimiter & uniqueid & delimiter
				'		sql = "Select " & fieldname & " From " & tablename  &   " where " & table_unique_id & "=?"
				'		Set Cmd = Server.CreateObject("ADODB.COMMAND")
				'		Cmd.CommandText = sql
				'		Cmd.Parameters.Append Cmd.CreateParameter("uID", adVarChar, adParamInput, len(delimiter & uniqueid & delimiter),  delimiter & uniqueid & delimiter)
				'		Cmd.ActiveConnection = DataConn
				'		Cmd.CommandType = adCmdText
				'		CommitRS.Open cmd							
				'	end if
				'else
				'	sql = "Select " & fieldname & " From " & tablename  &   " where " & table_unique_id & "=" & delimiter & uniqueid & delimiter
				'	CommitRS.Open sql, DataConn, adOpenKeyset,  adLockOptimistic
				'end if 'UCase(sqlSyntax) = "Oracle"
				'End of SYAN modification	
							
				if not (CommitRS.BOF AND CommitRS.EOF) then
					currentValue=""
					CommitRS.MoveFirst
					currentValue =CommitRS(fieldname).Value
					if Not isNull(currentValue) then
						currentValue = CStr(currentValue)
					else
						currentValue = ""
					end if
					'showmessagedialog("2" & err.number & err.description + fullfieldname)
					CheckForADOErrors dbkey, DataConn, "Update Record Error"& "\n\n" & "Table Name: " & tablename & "\n\n" &  "Field Name: " & fieldname &  "\n\n" &"Update Value: " & Request.Form(fullfieldname) & "\n\n" & "Provider Error", "log"
					newVal = Request.Form(fullfieldname)
					bUpdate = false
					if isNull(currentValue) OR currentValue = "" then
						bUpdate = true
					else
						if Not (currentValue = newVal) then
							bUpdate = true
						end if
					end if
					if inStr(fullfieldname, ".structure")>0 then
						bUpdate = false
					end if
					if bUpdate = true then
						if isEmpty(newVal) then newVal = Null
						'SYAN modified 12/19/2003 to fix CSBR-35466
						'CommitRS(fieldname).Value = newVal
						if (CommitRS.Fields(fieldname).Type) = adDBTimeStamp or (CommitRS.Fields(fieldname).Type) = adDate then
							newVal = ConvertStrToDate(Application("DATE_FORMAT"), newVal)
						'SYAN changed on 9/23/2004 to fix CSBR-46729
						elseif (CommitRS.Fields(fieldname).Type = 5 or CommitRS.Fields(fieldname).Type = 139) then 'adDouble or adVarNumeric
							newVal = CDbl(newVal)
						end if
						CommitRS(fieldname).Value = newVal
						'End of SYAN modification
						
						CommitRS.Update
						CommitRS.Close
						CheckForADOErrors dbkey, DataConn, "DoUpdateRecord Update Field error" & fieldname & newVal & tablename, "log"
					end if
					CommitRS.Close
				end if
			end if
						
		end if 'if fullfieldname <> ""
				
	Next 'j (field)
	

	'update structures
	if StrucFields <> "" then
		if UseCartridge(dbkey, formgroup) and Not bStructureDone = true then
			success = DoCartridgeUpdateStructure(dbkey, formgroup,  StrucFields,tablename, uniqueid, DataConn, "") 
		else
			isOK = DoUpdateStructure(dbkey, formgroup, StrucFields,tablename, uniqueid) 
		end if
	end if
		
	if err.number > 0 OR  Session("errors_found" & dbkey & formgroup)<> "" then
		success = false
	else
		success = true
	end if
	CloseConn(DataConn)
	DoUpdateRecord = success
End Function




'-------------------------------------------------------------------------------
' Name: DoDeleteRecord(dbkey, formgroup, uniqueid,tablename,input_strWhere)
' Type:  Function
' Purpose: delete record from database including structure record
' Inputs: data view as string, formgroup as string, base id for table  as CInt, tablename  as string, where clause as string
' Returns: boolean true if record updaate is successful
'-------------------------------------------------------------------------------
Function DoDeleteRecord(ByVal dbkey, ByVal formgroup,  ByVal uniqueid, ByVal tablename, ByVal input_strWhere)
	'loop through data tables
	sqlSyntax = GetTableVal(dbkey, tablename, kSQLSyntax)
	on error resume next
	if Not input_strWhere <> "" then
		table_unique_id = GetTableVal(dbkey, tablename, kPrimaryKey)
			
		datatype =getDataType(dbkey,  formgroup,  tablename & "." & table_unique_id)
		delimiter = GetFieldDelimiter(datatype)
		if UCase(sqlSyntax) = "ORACLE" then
			if delimiter = "#" then
				Select case datatype
					Case "8" 
						sql =  tablename & "" & "." & "" & table_unique_id & "= TO_DATE('" & uniqueid & "'," & "'MM,DD,YYYY')"' this is passed in as a parameter
					Case "9"
						sql =  tablename & "" & "." & "" & table_unique_id & "=TO_DATE('" & uniqueid & "'," & "'DD,MM,YYYY')"' this is passed in as a parameter
				end select
			else
				strWhere= tablename & "" & "." & "" & table_unique_id & "" & "=" & delimiter & uniqueid & delimiter
			end if
		else
			strWhere= tablename & "" & "." & "" & table_unique_id & "" & "=" & delimiter & uniqueid & delimiter
		end if
	else
		strWhere = input_strWhere
	end if
			
	sql = "Delete FROM " & "" & tablename & "" & " WHERE " & strWhere
		
	'on error resume next
	Set DataConn = GetConnection(dbkey, formgroup, tablename)
	if DataConn.State=0 then ' assume user has been logged out
		DoLoggedOutMsg "search_funcs", "DoDeleteRecord", "bad connection:forgroup=" & formgroup & " dbkey=" & dbkey & " table name=" & tablename 
	end if

	DataConn.Execute sql
	CheckForADOErrors dbkey, DataConn, "Delete Record Error" & "\n\n" & "SQL: " & sql & "\n\n", "log"
	UpdateTableRecordCount dbkey, formgroup,  tablename, DataConn
	CloseConn(DataConn)

	on error goto 0
	if err.number > 0 OR  Session("errors_found" & dbkey & formgroup)<> "" then
		if inStr(Session("errors_found" & dbkey & formgroup), "child")> 0 then
			Session("errors_found" & dbkey & formgroup)="Deletion Failed. Record is referenced by other tables."
		end if
		success = false
	else
		success = true
	end if
	DoDeleteRecord = success
End Function


'-------------------------------------------------------------------------------
' Name: DoCascadeDelete(dbkey, formgroup, uniqueid,tablename,input_strWhere)
' Type:  Function
' Purpose: delete record from database including structure record
' Inputs: data view as string, formgroup as string, base id for table  as CInt, tablename  as string, where clause as string
' Returns: boolean true if record update is successful
'-------------------------------------------------------------------------------
Function DoCascadeDelete(ByRef DataConn, ByVal dbkey, ByVal formgroup,  ByVal uniqueid, ByVal tablename, ByVal input_strWhere)
	'loop through data tables
	sqlSyntax = GetTableVal(dbkey, tablename, kSQLSyntax)
	on error resume next
	if Not input_strWhere <> "" then
		table_unique_id = GetTableVal(dbkey, tablename, kPrimaryKey)
		datatype =getDataType(dbkey,  formgroup,  tablename & "." & table_unique_id)
		delimiter = GetFieldDelimiter(datatype)
		if UCase(sqlSyntax) = "ORACLE" then
			if delimiter = "#" then
				Select case datatype
					Case "8" 
						sql =  tablename & "" & "." & "" & table_unique_id & "= TO_DATE('" & uniqueid & "'," & "'MM,DD,YYYY')"' this is passed in as a parameter
					Case "9"
						sql =  tablename & "" & "." & "" & table_unique_id & "=TO_DATE('" & uniqueid & "'," & "'DD,MM,YYYY')"' this is passed in as a parameter
				end select
			else
				strWhere= tablename & "" & "." & "" & table_unique_id & "" & "=" & delimiter & uniqueid & delimiter
			end if
		else
			strWhere= tablename & "" & "." & "" & table_unique_id & "" & "=" & delimiter & uniqueid & delimiter
		end if
	else
		strWhere = input_strWhere
	end if
		
	sql = "Delete FROM " & "" & tablename & "" & " WHERE " & strWhere
	DataConn.Execute sql
	if UCase(sqlSyntax) = "ORACLE" then
		DataConn.Execute "commit"
	end if
	CheckForADOErrors dbkey, DataConn, "Delete Record Error" & "\n\n" & "SQL: " & sql & "\n\n", "log"
	UpdateTableRecordCount dbkey, formgroup,  tablename, DataConn

	if err.number > 0 OR  Session("errors_found" & dbkey & formgroup)<> "" then
		success = false
	else
		success = true
	end if
	DoCascadeDelete = success
End Function



'-------------------------------------------------------------------------------
' Name: DoAddStructure(dbkey, formgroup, fieldnames,uniqueid,DataConn)
' Type:  Function
' Purpose: delete structure from database 
' Inputs: data view as string, formgroup as string,  field name list  as string, base id for table  as CInt, connection object as reference 
' Returns: boolean true if record add structure is successful
' Comments: calls DoCartridgeAddStructure if Cartridge is used
'-------------------------------------------------------------------------------
Function DoAddStructure( ByVal dbkey,  ByVal formgroup,  ByVal fieldnames, ByVal uniqueid, ByRef DataConn)
	
	fieldnames_array = split(fieldnames, ",", -1)
	for i = 0 to UBound(fieldnames_array)
		if  UseCartridge(dbkey, formgroup) then
			success = DoCartridgeAddStructure(dbkey, formgroup, fullfieldname, uniqueid,DataConn,RS)
		else
			fullfieldname=fieldnames_array(i)
			temp = split(fullfieldname, ".", -1)
			if UBound(temp) = 2 then
				compound_moltable= temp(0) & "." & temp(1)
				fieldname= temp(2)
			else
				compound_moltable= temp(0)
				fieldname= temp(1)
			end if
			compound_strucIDField = GetTableVal(dbkey, compound_moltable, kStrucFieldID)
			compound_moltable_baseid = GetTableVal(dbkey, compound_moltable, kPrimaryKey)
			base64string = Session("SearchData" & fullfieldname  & dbkey & formgroup)
			Session("BASE64_CDX" & uniqueid & dbkey & formgroup) = base64string
			myPath = Application("TempFileDirectory" & dbkey) & fullfieldname & "_" & uniqueid & ".cdx"
			DecodeBase64 base64string, myPath 'put the decoded structure into cfwtemp\RegTemp.cdx
			' actually just updating a structure, not adding one from 
			' scratch
			sql = "UPDATE " & compound_moltable & " SET " & _
				  "STRUCTURE = STRUCT('" & myPath & "') WHERE " & _
				  compound_moltable_baseid & " = " & uniqueid
			existingConnection = ""
			
			
			'Pool for the unique id before sending to CSDO for a maximum of 20 seconds
			t=timer()
			tid = -1 
			Do while (tid <> uniqueid  AND timer()-t < 20)
				tsql = "SELECT " & compound_moltable_baseid & " FROM " & compound_moltable & " WHERE " & compound_moltable_baseid & "= " & uniqueid 
				Set tRS = DataConn.execute(tsql)				
				tid = tRS(0).value
				tRS.close
			loop
			Set tRS = Nothing
			
			Set rs = CSDODoCommand(sql, dbkey, formgroup, "0",existingConnection)
			
			Set rs= Nothing
			rs = ""

			if Application("TABLES_WITH_BASE64_CDX")<> "" and Not UseCartridge(dbkey, formgroup) then
				if Not (UCase( Application("TABLES_WITH_BASE64_CDX"))= UCase(compound_moltable)) then
					sql = "SELECT * FROM " & compound_moltable & " WHERE " & compound_moltable_baseid & " = " & uniqueid
					Set CommitRS = Server.CreateObject("ADODB.Recordset")
					theMOLID = 0
					Do While Not theMOLID > 0
						Set CommitRS = DataConn.Execute(sql)
						if not (CommitRS.BOF and CommitRS.EOF)then
							thetestMOLID = CommitRS("MOL_ID")
							if Len(thetestMOLID)> 0 then
								theMOLID = CLng(thetestMOLID)
							else
								theMOLID = 0
							end if
						end if
					loop
					CommitRS.Close
					thetable = Application("TABLES_WITH_BASE64_CDX")
					CommitRS.Open thetable, DataConn, adOpenKeyset,  adLockOptimistic,adCmdTable  'get the right record with mol_id
					CommitRS.AddNew
					CommitRS("MOL_ID") = theMOLID
					CommitRS("BASE64_CDX")=base64string
					CommitRS.Update
					CommitRS.Close
				else
					sql = "UPDATE " & compound_moltable & " SET BASE64_CDX = ? WHERE " & compound_moltable_baseid & " = " & uniqueid
					Set Cmd = Server.CreateObject("ADODB.COMMAND")
					Cmd.CommandText = sql
					Cmd.Parameters.Append Cmd.CreateParameter("BASE64_CDX", adLongVarChar, adParamInput, len(base64string), base64string)
					Cmd.ActiveConnection = DataConn
					Cmd.CommandType = adCmdText
					Cmd.Execute	
					'sql = "UPDATE " & compound_moltable & " SET BASE64_CDX = '" & base64string & "' WHERE " & compound_moltable_baseid & " = " & uniqueid
					'DataConn.Execute(sql)	
				end if
			end if
		end if
		next
		DoAddStructure = true
end function


'-------------------------------------------------------------------------------
' Name: DoUpdateStructure(dbkey, formgroup, strucFields,tablename,uniqueid)
' Type:  Function
' Purpose: update structure from database 
' Inputs: data view as string, formgroup as string, structure fields list as string, table name   as string, base id for table  as CInt
' Returns: boolean true if update is successful
' Comments: calls DoCartridgeUpdateStructure if Cartridge is used
'-------------------------------------------------------------------------------
Function DoUpdateStructure(ByVal dbkey, ByVal formgroup, ByVal strucFields, ByVal tablename, ByVal uniqueid)
	if UseCartridge(dbkey, formgroup) then
	
		success = DoCartridgeUpdateStructure(dbkey, formgroup,  StrucFields,tablename, uniqueid, "","" ) 
	else
			strucFields_array = split(strucFields, ",", -1)
			SQLSyntax = GetTableVal(dbkey, tablename,kSQLSyntax)
			bUpdateTables = False
			for i=0 to UBound(strucFields_array)
				fullfieldname = strucFields_array(i)
				if InStr(fullfieldname, "UID")> 0 then
					test ="UID." & uniqueid & ":" &  UCase(tablename)& "."
					temp_name = split(fullfieldname, ".", -1)
					if UBound(temp_name) = 3 then
						fieldname = temp_name(3)'format is UID.unqi:tablename.fieldname
					else
						fieldname = temp_name(2)'format is UID.unqi:tablename.fieldname
					end if
				else
					test = UCase(tablename)& "."
					temp = split(fullfieldname, ":", -1)
					temp_new = split(temp(1), ".", -1)
					if Ubound(temp_new) = 2 then
						fieldname = temp_new(2)
					else
						fieldname = temp_new(1)
					end if
				end if
				
				if inStr(UCase(fullfieldname),UCase(test))> 0 then
					base64string = Trim(Request.form(fullfieldname))
					
				
					'4/23/2002 the unique id that is passed in is the primary key for the table so the table_strucid must be
					' the primary key.
					table_strucid =	GetTableVal(dbkey, tablename, kPrimaryKey)
					
					Session("BASE64_CDX" & uniqueid & dbkey & formgroup) = base64string
					if NOT UCase(base64string) = "NO_STRUCTURE" or Len(base64string)= 0 then
						origfieldname = fieldname
						fieldname = replace(fieldname, uniqueid, "")
						cdx_name = tablename & fieldname & "_" & uniqueid & ".cdx"
						myPath = Application("TempFileDirectory" & dbkey)   & cdx_name
						gif_name = tablename & fieldname & "_" & uniqueid & ".gif"
						myGifPath = Application("TempFileDirectory" & dbkey)   & gif_name
						DecodeBase64 base64string, myPath 'put the decoded structure into cfwtemp\RegTemp.cdx
							
						if instr(fieldname, "BASE64")> 0 then 'output the normal tablename.structure.cdx and gif as well
							cdx_name = tablename & "Structure" &  "_" & uniqueid & ".cdx"
							myPath = Application("TempFileDirectory" & dbkey)   & cdx_name
							gif_name = tablename & "Structure" & "_" & uniqueid & ".gif"
							myGifPath = Application("TempFileDirectory" & dbkey)   & gif_name
							DecodeBase64 base64string, myPath 'put the decoded structure into cfwtemp\RegTemp.cdx
							
						end if
							on error resume next
							'update the structure
						
							sql = "UPDATE " & tablename & " SET " & _
							  "STRUCTURE = STRUCT('" & myPath & "') WHERE " & _
							  table_strucid & " = " & uniqueid
							existingConnection= ""	  
								
							Set rs = CSDODoCommand(sql, dbkey, formgroup, "0",existingConnection)
							'if UCase(SQLSyntax) = "ORACLE" then
								'sql = "commit"
								'Set rs = CSDODoCommand(sql, dbkey, formgroup, "0", existingConnection)
							'end if
						
							Set rs = Nothing
							rs = ""
								
							'update mw and formula fields	
								'Set StrucObj = CreateObject("ChemFinder.Molecule")
								'StrucObj.Read myPath	
								Session("MW"& dbkey & formgroup & tablename & "MolWeight" & uniqueid)=""
								Session("Formula"& dbkey & formgroup & tablename &  "Formula" & uniqueid)=""
								'Set StrucObj = Nothing
								'StrucObj = ""
								basetable = getBasetable(dbkey, formgroup,"moltable")
									
								'output an updated cdx file
								querystring = "SELECT STRUCTFILE(STRUCTURE, '" & myPath & "') FROM " & tablename & " WHERE " &  table_strucid & " = " & uniqueid					
								Set rs = CSDODoCommand(querystring, dbkey, formgroup, "0", existingConnection)
								Set rs = Nothing
								rs = ""
									
								'output an updated gif file
								querystring = "SELECT STRUCTFILE(STRUCTURE, '" & myGifPath & "') FROM " & tablename & " WHERE " &  table_strucid & " = " & uniqueid					
								Set rs = CSDODoCommand(querystring, dbkey, formgroup, "0", existingConnection)
								Set rs = Nothing
								rs = ""
									
								Session("reload_list") = true
								Session("reload_form") = true
								
								if Application("TABLES_WITH_MOLIDS") <> "" and instr(UCase(Application("TABLES_WITH_MOLIDS")),UCase(tablename))>0 then
									tablearray=Split(Application("TABLES_WITH_MOLIDS"), ",", -1)
									'4/22/2002: further explanation
									'get the new mol_id from the update. You are still looking at the table that came in as a parameter so the
									'table_strucid is the primary key of the a table
									sql = "SELECT MOL_ID FROM " & tablename & _
									" WHERE " & table_strucid & " = " & uniqueid
									Set rs = CSDODoCommand(sql, dbkey, formgroup, "0", existingConnection)
									if not rs.eof then
										theMOLID = rs.fields("MOL_ID")
									end if
									Set rs = Nothing
									rs = ""

									if (Len(theMOLID) > 0 and theMOLID > 0) then
										for j = 0 to UBound(tablearray)
											if not UCase(tablearray(j)) = UCase(tablename) then 
												'in this case you are looking at a differnt table so the table_strucid must link
												'to the base structure tables primary key - thus it must be the structure id for the table
												'Futher explanation: 4/22/2002 here the table_strucid must be the actually stucture ID of the linking table AND
												'there is an assumption that it's name is the same as the primary key of the table that originally 
												'came is as a paramter. this is only used in chem_reg.
												table_strucid = GetTableVal(dbkey,  tablearray(j), kStrucFieldID)	
												sql = "UPDATE " & tablearray(j) & " SET " & _
												 "MOL_ID = " & theMOLID & " WHERE " & _
												 table_strucid & " = " & uniqueid
												Set rs = CSDODoCommand(sql, dbkey, formgroup, "0", existingConnection)
												Set rs = Nothing
												rs = ""
											end if
										next
									end if
								end if 'Application("TablesWithMOLIDS") <> ""

							if UCase(Application("App_Type")) = "REGISTRATION" then
							
								if Application("TABLES_WITH_BASE64_CDX") <> "" and instr(UCase(Application("TABLES_WITH_BASE64_CDX")),UCase(tablename))>0 then
									sql = "SELECT MOL_ID FROM " & tablename & _
									" WHERE " & table_strucid & " = " & uniqueid
									Set rs = CSDODoCommand(sql, dbkey, formgroup, "0", existingConnection)
								
									if not rs.eof then
										theMOLID = rs.fields("MOL_ID")
									end if
									Set rs = Nothing
									rs = ""
									
									if (Len(theMOLID)> 0 and theMOLID > 0) then
										Set DataConn = GetConnection(dbkey, formgroup, tablename)
										if DataConn.State=0 then ' assume user has been logged out
											DoLoggedOutMsg "search_funcs", "DoUpdateStructure", "bad connection:forgroup=" & formgroup & " dbkey=" & dbkey & " table name=" & tablename 
										end if
										Set CommitRS = Server.CreateObject("ADODB.Recordset")
										tablearray=Split(Application("TABLES_WITH_BASE64_CDX"), ",", -1)
										for j = 0 to UBound(tablearray)
											if UCase(tablearray(j)) = UCase(tablename) then 
												table_strucid = GetTableVal(dbkey,  tablearray(j), kStrucFieldID)	
												if UCase(base64string) = "NO_STRUCTURE"  then base64string = ""
												
												sql = "SELECT BASE64_CDX FROM " & tablearray(j) & " WHERE  MOL_ID= " & theMOLID										
												CommitRS.Open sql, DataConn, adOpenKeyset,  adLockOptimistic
												
												if not (CommitRS.BOF and CommitRS.EOF)then
													CommitRS.MoveFirst
													CommitRS("BASE64_CDX")=""
													CommitRS.Update
													CommitRS("BASE64_CDX")=base64string
													CommitRS.Update
													CommitRS.Close
												
													CheckForADOErrors dbkey, DataConn, "DoUpdateStructure Update error" & fieldname & newVal & tablename, "log"
												
												end if
											end if
										next
										CloseRS(CommitRS)
										CloseConn(DataConn)
										
									end if
								end if'if Application("TABLES_WITH_BASE64_CDX") <> "" and instr(UCase(Application("TABLES_WITH_BASE64_CDX")),UCase(tablename))>0 then
							
							else 'if UCase(Application("App_Type")) = "REGISTRATION" then
								if Application("TABLES_WITH_BASE64_CDX") <> ""  then
									sql = "SELECT MOL_ID FROM " & tablename & _
									" WHERE " & table_strucid & " = " & uniqueid
									Set rs = CSDODoCommand(sql, dbkey, formgroup, "0", existingConnection)
									if not rs.eof then
										theMOLID = rs.fields("MOL_ID")
									end if
									Set rs = Nothing
									rs = ""
									if (Len(theMOLID)> 0 and theMOLID > 0) then
										Set DataConn = GetConnection(dbkey, formgroup, tablename)
										if DataConn.State=0 then ' assume user has been logged out
											DoLoggedOutMsg "search_funcs", "DoUpdateStructure", "bad connection:forgroup=" & formgroup & " dbkey=" & dbkey & " table name=" & tablename 
										end if
										thetable = Application("TABLES_WITH_BASE64_CDX")
										sql = "select BASE64_CDX from " & thetable  & " where MOL_ID =" & theMOLID
										Set CommitRS = Server.CreateObject("ADODB.Recordset")
										CommitRS.Open sql, DataConn, adOpenKeyset,  adLockOptimistic 'get the right record with mol_id
										if not (CommitRS.BOF and CommitRS.EOF)then
											CommitRS.MoveFirst
											CommitRS("BASE64_CDX")=""
											CommitRS.Update
											CommitRS("BASE64_CDX")=base64string
											CommitRS.Update
											CommitRS.Close
										end if
										CloseRS(CommitRS)
										CloseConn(DataConn)
									end if
								end if 'if Application("TABLES_WITH_BASE64_CDX") <> ""  then
						end if 'NOT UCase(Application("App_Type")) = "REGISTRATION" then
						
				end if
				
				if err.number > 0 then 
							HandleError dbkey, formgroup, "", err.Source, err.number, err.description
				end if
			end if
				
			next 'strucfield	
			Session("reload_form") = true
			Session("reload_list") = true
			if err.number > 0 Or  Session("errors_found" & dbkey & formgroup)<> ""then
				Session("errors_found" & dbkey & formgroup)= Session("errors_found" & dbkey & formgroup) & err.description & err.source
				success = false
			else
				success = true
			end if
	end if
	DoUpdateStructure = success ' return last error
	
End Function


'-------------------------------------------------------------------------------
' Purpose:
' Inputs:
' Returns:
'-------------------------------------------------------------------------------
Sub DoRedirect(dbkey, redirectpath)
%>
	<script language = "javascript">
	
	MainWindow = <%=Application("mainwindow")%>
	MainWindow.location.href = "<%=redirectpath%>"
	</script>
<%

end sub

Sub DoRedirectNewWindow(dbkey, redirectpath)
%>
	<script language = "javascript">
		MainWindow = <%=Application("mainwindow")%>
		var w = window.open("<%=redirectpath%>")
	</script>
<%

end sub

'-------------------------------------------------------------------------------
' Purpose:
' Inputs:
' Returns:
'-------------------------------------------------------------------------------
Sub ShowMessageDialog(message)
%>
	<script language = "javascript">
		alert("<%=message%>")
	</script>
<%
end sub

'-------------------------------------------------------------------------------
' Purpose:
' Inputs:
' Returns:
'-------------------------------------------------------------------------------
Sub CheckForADOErrors(ByVal dbkey, ByRef DataConn, ByVal description, ByVal output)
	on error resume next

	if  DataConn.Errors.Count > 0 then
		If instr(output, "log")> 0 then
			for j = 0 to DataConn.Errors.Count
				LogAction(description & "-" & DataConn.Errors.Item(j).Description)
				if Session("errors_found" & dbkey & formgroup) <> "" then
					Session("errors_found" & dbkey & formgroup) = Session("errors_found" & dbkey & formgroup) & ":" & description & "-" & DataConn.Errors.Item(j).Description
				else
					Session("errors_found" & dbkey & formgroup) =description & "-" & DataConn.Errors.Item(j).Description
				end if
			Next
		else
			Response.write "the following error occured for " & description 
			for j = 0 to DataConn.Errors.Count
				Response.Write DataConn.Errors.Item(j).Description
				if Session("errors_found" & dbkey & formgroup) <> "" then
					Session("errors_found" & dbkey & formgroup) = Session("errors_found" & dbkey & formgroup) & ":" & description & "-" & DataConn.Errors.Item(j).Description
				else
					Session("errors_found" & dbkey & formgroup) =description & "-" & DataConn.Errors.Item(j).Description
				end if
			Next
		end if
	end if
	
	on error goto 0
End Sub

Sub DoLoggedOutMsg(page, sfunction, msg)
	Response.Write "<html><head></head><title></title><body onload='top.frames[""navbar""].location.replace(""/" & Application("AppKey") & "/blank.html"")'"
	Response.Write "<br><p>"
	Response.Write "An error has occurred."
	Response.Write "Page: " & page & "<BR>"
	Response.Write "Function: " & sfunction & "<BR>"
	Response.Write "Message: " & msg & "<BR>"
	Response.Write "Err Source:" & Err.Source & "<BR>"
	Response.Write "Err Description:" & Err.Description & "<BR>"
	Response.Write "<P>"
	Response.Write "<a href=""javascript:location.replace('/" & Application("AppKey")& "/login.asp')"">Continue</a>"
	Response.Write "</P>"
	Response.Write ""
	response.write "</body>"
	Response.Write "</html>"
	Response.end
End Sub


Sub UpdateBaseTableRecordCount(ByVal dbkey, ByVal formgroup, ByRef DataConn)
	on error resume next
	basetable = GetBaseTable(dbkey, formgroup, "basetable")
	sql = "Select Count(*) From "  & basetable
	if Not isObject(DataConn) then
		Set DataConn = GetConnection(dbkey, formgroup, basetable)
	end if
	Set RS = DataConn.Execute(sql)
	If Not (RS.BOF AND RS.EOF)then
		theCount = RS.Fields(0)
		if CBool(Application("Use_Session_Record_Counts")) = true then
			Session(basetable & "RecordCount" & dbkey) = theCount
		else
			Application.Lock
				Application(basetable & "RecordCount" & dbkey) = theCount
			Application.UnLock
		end if
		RS.Close
	End if
End Sub

Sub UpdateTableRecordCount(ByVal dbkey, ByVal formgroup, ByVal tablename, ByRef DataConn)
	sql = "Select Count(*) From "  & tablename
	if Not isObject(DataConn) then
		Set DataConn = GetConnection(dbkey, formgroup, tablename)
	end if
	Set RS = DataConn.Execute(sql)
	If Not (RS.BOF AND RS.EOF)then
		theCount = RS.Fields(0)
		if CBool(Application("Use_Session_Record_Counts")) = true then
			Session(tablename & "RecordCount" & dbkey) = theCount
		else
			Application.Lock
				Application(tablename & "RecordCount" & dbkey) = theCount
			Application.UnLock
		end if 
		RS.Close
	End if
end sub

function GetDBSearchNames()
	temp_names_array = Split(Application("DBNames"), ",", -1)
	for i = 0 to UBound(temp_names_array)
		theValue = request(temp_names_array(i))
		if Not (theValue = "" or theValue= "undefined"  or theValue = "null" ) then
			if TempDBNames <> "" then
				TempDBNames= TempDBNames & "," & theValue
			else
				TempDBNames = theValue
			end if
		end if
	Next
	GetDBSearchNames= TempDBNames
end function



Function DoDuplicatesSearch(dbkey, formgroup, tablename)
	Dim ADOmolstr,compound_moltable,compound_basetable,compound_table_baseid,Base64Str
	Base64Str = Request.Form(tablename & ".Structure")
	if UseCartridge(dbkey, formgroup) then
		ADOmolstr = DoCartridgeDuplicateSearch(dbkey, formgroup, tablename,Base64Str, "", "")
	else
		compound_moltable = tablename		
		'get the base64str for this records
		
		if Base64Str <> "" then
			on error resume next
			mypath = Application("TempFileDirectory" & dbkey) & "SessionDir\" & Session.SessionID & "\" & tablename & "Structure" & ".cdx"
			'decode base64 str
			DecodeBase64 Base64Str, mypath
			AtomsExist = CheckChemicalContent(myPath)
			if AtomsExist = true then
				Session("GetDupSearchAppPrefs") = "TRUE"
				sql = "SELECT MOL_ID FROM "  &_
					  compound_moltable & " WHERE " & _
					  "EXACTSTRUCT(STRUCTURE, " & _
					  "STRUCT('" & mypath & "')) > 0"
				set rs = CSDODoCommand(sql, dbkey, formgroup, "0", Conn)
				Session("OverrideDefaultPrefs") = ""
				Session("GetDupSearchAppPrefs") = ""
				if inStr(UCase(err.source), "MOLSERVER")>0 then
					ADOmolstr = "PARSING_ERROR"
				else
					err.clear()
					if not (rs.BOF and rs.EOF) then
						do while not rs.EOF
							If ADOMolStr = "" then
								ADOMolStr = rs.Fields("MOL_ID")
							else	
								ADOMolStr = ADOMolStr & "," & rs.Fields("MOL_ID")
							end if
							rs.MoveNext
						loop
						CloseRS(rs)
					else
						ADOmolstr = ""
					end if
				end if
			else
				ADOmolstr = ""
			end if
		else
			ADOmolstr = ""
		end if	
	end if 'UseCartridge 
	DoDuplicatesSearch = ADOmolstr
End function


'#####
' Making sure that a query string is different from the last time or so it was used.
'#####

Function MakeQueryStringBeDifferent  ( sLocation )
	Dim  sNewLocation
	Dim  sNewDifferent
	Dim  sOldDifferent
	Dim  iDifferent

	' We want a uniform length for the parameter we use to make the query string different
	' because that will make it easier to replace the parameter if it is already in the
	' query string.  For now, make it five digits.
	iDifferent = Int( Timer() )
	while ( iDifferent < 10000 )
		iDifferent = iDifferent * 10
	wend
	sNewDifferent = "QSDiff=" & Left( CStr( iDifferent ), 5 )

	iDiffString = inStr( sLocation, "QSDiff" )
	if iDiffString <= 0 then
		' There is no "difference" string in the query string.
		if inStr( sLocation, "?" ) <= 0 then
			' There is no query string yet.  Start with the difference string.
			sNewLocation = sLocation & "?" & sNewDifferent
		else
			' There is already a query string.  Tack the difference string on.
			sNewLocation = sLocation & "&" & sNewDifferent
		end if
	else
		' There is a "difference" string in the query string.  Get the old one.
		sOldDifferent = Mid( sLocation, iDiffString, 12 )  ' QSDiff=*****

		' Replace the old difference string with the new one.
		sNewLocation = Replace( sLocation, sOldDifferent, sNewDifferent )
	end if

	MakeQueryStringBeDifferent = sNewLocation
end Function


Function DoAddRecordMaster(dbkey, formgroup, table_names, field_names, AddOrder)
		
		if AddOrder <> "" then
			 table_names = AddOrder
			 AddType = "CASCADE"
		else
			AddType = ""
		end if
		isOK= DoAddRecord(dbkey, formgroup, table_names, field_names, AddType)
		if isOK = false then
			showErrors = True
		end if
		
		DoAddRecordMaster=ShowErrors		
End Function


Function DoUpdateRecordMaster(dbkey, formgroup, RelFields, StrucFields, table_names)
			SetSessionVars dbkey, formgroup, "update_record"
			showErrors = False
			table_name_array = split(table_names, ",", -1)
			thecounteri=0
			Session("counti")= UBound(table_name_array)
			for thecounteri = 0 to CLng(Session("counti"))
				table_name = table_name_array(thecounteri)	
				tables_row_ids = request(table_name & "_ROW_IDS")
					
				tables_row_ids_array = split(tables_row_ids, ",", -1)
				thecounterj=0
				Session("countj")= UBound(tables_row_ids_array)
				for thecounterj = 0 to CLng(Session("countj"))
					row_id = tables_row_ids_array(thecounterj)
					'get all submitted data fields for this table and row_id
							
					isOK = DoUpdateRecord(dbkey, formgroup, StrucFields,RelFields, table_name, row_id)
					if UCase(formgroupflag) = "REG_COMMIT" then
						DoUpdateTempModInfo dbkey, formgroup, row_id
					end if
					if isOK = False then
						showErrors = True
					end if
				next 'row_id thecounter for table i
			next 'table i
	
		
		DoUpdateRecordMaster= showErrors
End Function


Function DoDeleteRecordMaster (dbkey, formgroup, table_names, delete_order)
		formgroupflag= GetFormGroupVal(dbkey, formgroup, kFormGroupFlag)
		if UCase(formgroupflag) = "REG_SEARCH" then
			isOK = DoDeleteReg()
			if isOK = false then
				showErrors = True
			end if
		else
			if delete_order <> "" then
				delete_order_array = Split(delete_order, ",", -1)
				table_name_array = split(table_names, ",", -1)
				Session("delete_count")= UBound(delete_order_array) 'like register all, the count needs to be store in a session variable or else the count never increments and an infinite loop is created.
				Set DataConn = GetConnection(dbkey, formgroup, delete_order_array(Session("delete_count")))
				thecounter = 0
				for thecounter = 0 to CLng(Session("delete_count"))
					current_table = delete_order_array(thecounter)			
					for j = 0 to UBound(table_name_array)
						table_name = table_name_array(j)
						if UCase(table_name) = UCase(current_table) then
							tables_row_ids = request(table_name & "_ROW_IDS")	
							tables_row_ids_array = split(tables_row_ids, ",", -1)
							for k = 0 to UBound(tables_row_ids_array)							
								strWhere = ""
								row_id = tables_row_ids_array(k)						
								isOK = DoCascadeDelete(DataConn, dbkey, formgroup, row_id,table_name, strWhere)		
								if isOK = false then
									showErrors = true
								end if
							next 'row_id k for table j
						end if 'if UCase(table_name) = UCase(current_table) then
					next 'table j
				next 'delete order i
				CloseConn(DataConn)
			else	
				table_name_array = split(table_names, ",", -1)
				for j = 0 to UBound(table_name_array)
					table_name = table_name_array(j)	
					tables_row_ids = request(table_name & "_ROW_IDS")
					tables_row_ids_array = split(tables_row_ids, ",", -1)
						for k = 0 to UBound(tables_row_ids_array)
							strWhere= ""
							row_id = tables_row_ids_array(k)
							isOK = DoDeleteRecord(dbkey, formgroup, row_id,table_name, strWhere)		
							if isOK = false then
								showErrors = true
							end if
							next 'row_id k for table j
				next 'table j
			end if
		end if
		Session("delete_count")=""
		DoDeleteRecordMaster=ShowErrors
	End Function
	
	Function isEmpty(theVar)
		if isNull(theVar) then
			theReturn = True
		else
			if not theVar <> "" then
				theReturn = True
			else
				theReturn = False
			end if
		end if
		isEmpty = theReturn
	End Function

Function isZero(theVar)
	if not isEmpty(theVar) and not isNull(theVar) then
		if CDbl(theVar)> 0 then
			theReturn = false
		else
			theReturn = true
		end if
	else
		theReturn = true
	end if
	isZero = theReturn
End Function


Sub SetStartRecordset(dbkey, formgroup)
	Session("CurrentRecord" & dbkey & formgroup)=1
	Session("LastStartingIndex" & dbkey & formgroup)=1
End sub


Sub FlushMessageToClient(strText)
	if Not request("return_data") <> "" then
		on error resume next
		Response.Buffer = True
		Response.Flush
		Response.Write String(255," ")
		if  CBool(Application("USE_ANIMATED_GIF")) = true then
			Response.Write "<TABLE Width=""600""  border=""0""><tr><td valign=top align=center>" & strText & "</td></tr></TABLE>"
		else
			Response.Write strText
		end if
		Response.Flush
	end if
End Sub

Sub FlushImageToClient(strImageName)
	if Not request("return_data") <> "" then	
		on error resume next
		Response.Buffer = True
		if detectNS6 = true then
			response.Write "."
		end if	
		Response.Flush
		Response.Write String(255," ")
		'!DGB! 10/17/01
		'Path of gif should point to /source/graphics not to application navbuttons path.
		'Unless there is an explicit override from the ini file
		Response.Write "<BR><BR><BR><TABLE Width=""600""  border=""0""><tr><td valign=middle align=center><IMG SRC=""" & strImageName & """></td></tr></TABLE>"
		Response.Flush
	end if
End Sub



function prepHillFormula(ByVal dbkey, ByVal formgroup, ByVal strFldType,  ByVal strFieldname, ByVal strValue, ByVal inputStrWhere)

		if Left(strCriteria, 1) = "*" then
			strCriteria = "*" & hillOrderFormula(Right(strCriteria, len(strCriteria)-1))
		elseif Right(strCriteria, 1) = "*" then
			strCriteria = hillOrderFormula(Left(strCriteria, len(strCriteria)-1)) & "*"
		else
			strCriteria = hillOrderFormula(strCriteria)
		end if
			thearray= split(strFieldname, ".", -1)
			if UBound(thearray) = 2 then
				tablename = thearray(0) & "." & thearray(1)
				fieldname = thearray(2)
			else
				tablename = thearray(0)
				fieldname = thearray(1)
			end if 
		if Instr(strCriteria, "*") then
			prepHillFormula = "[" & tablename & "].[" & fieldname & " ] LIKE " & Chr(39) & strCriteria & Chr(39)
		else
			prepHillFormula = "[" & tablename & "].[" & fieldname & " ]" & " = " & Chr(39) & strCriteria & Chr(39)
		end if
end function

'=====================================================================
'input:		a random formula string, may have non-number and non-letter
'			characters
'
'output:	a clean Hill Ordered formula string
'
'=====================================================================
function hillOrderFormula(formula)
	dim orderer
	set orderer = Server.CreateObject("HillOrder.Orderer")
	hillOrderFormula = orderer.Reorder(formula)
	set orderer = nothing
end function


Sub StoreRequestObj(dbkey, formgroup,inputval)
	'!DGB! Changed "True" to uppercase!
	if UCase(inputval) = "TRUE" then
		'build dictionary object
		Set myObject = CreateObject("Scripting.Dictionary")
		
		for i = 1 to Request.Form.Count
			myObject.Add Request.Form.Key(i), Request.Form.Item(i)
		next
		Set Session("Request_FormObject" & dbkey & formgroup) = myObject
		'build dictionary object
		Set myObject2 = CreateObject("Scripting.Dictionary")
		for j = 1 to Request.QueryString.Count
			myObject2.Add Request.QueryString.Key(j), Request.QueryString.Item(j)
		next
		Set Session("Request_QueryStringObject" & dbkey & formgroup) = myObject2
	end if
End Sub

	

Sub ReturnData (dbkey, formgroup, strDataAction, DBSearchNames, return_data, return_location,return_fields)
	select case UCase(return_data)
			case "" 'default
				if return_location = "" then
					
					ReturnResults dbkey, formgroup, strDataAction, DBSearchNames
				else
					doredirect dbkey, return_location
				end if
			case "REDIRECT" 
				if return_location = "" then
					redirectpath = ReturnResultsMaster(dbkey, formgroup, strDataAction, DBSearchNames)
					Response.redirect redirectpath
				else
					Response.redirect return_location
				end if
			case "NO_REDIRECT" 
					
					redirectpath = ReturnResultsMaster(dbkey, formgroup, strDataAction, DBSearchNames)
					Response.Write redirectpath
					Response.end
					response.write redirectpath
			
			case "TRANSFER"
				if return_location = "" then
					redirectpath = ReturnResultsMaster(dbkey, formgroup, strDataAction, DBSearchNames)
					Server.transfer redirectpath
				else
					Server.transfer return_location
				end if
			case "CSV" 'same as default
				if inStr(return_field, ".")> 0 then
					temp = split(return_field, ".", -1)
					if UBound(temp) = 2 then
						return_field = temp(2)
					else
						return_field = temp(1)
					end if
				end if
				if Not return_field <> "" then
					basetable = GetBaseTable(dbkey, formgroup, "basetable")
					baseid = GetTableVal(dbkey, basetable, kPrimaryKey)
					return_field= baseid
				end if
						if  Session("Base_RSRecordCount" & dbkey & formgroup)> 0 then
							basearray = Session("Base_RS" & dbkey & formgroup)
							for i = 0 to UBound(basearray,2)
								BaseID = basearray(0,i)
								if myCVS <> "" then
									myCVS = myCVS & "," & BaseID
								else
									myCVS = BaseID
								end if
							next
							
							return_str= myCVS
						else
							return_str = "no_records_found"
							
						end if
						
						Response.Write return_str	
						response.end
					
			case "HITLISTID"
				'blank out the hitlistids, so when the session is killed the hit list isn't deleted
				if Request("KillSession")=1 then
					Session("BaseRShitlistID" & dbkey & formgroup)=0
					Session("RefineHitlistID" & dbkey & formgroup)=0
				end if
				Response.Write Session("hitlistID" & dbkey & formgroup)
				response.end
		end select
		
End Sub

Sub SetGetDataMethod (dbkey, formgroup, metadata_directive)

		Select case UCase(metadata_directive)
			case "","PREPARED" 'default looks at request("relfields") to determin fields for populating search variables
				GetSearchData dbkey, formgroup
			case "BYPASS_INI" 'depends totally on values from form for populating search variables
				Session("bypass_ini" & dbkey & formgroup) = true
				GetSearchData_bypass dbkey, formgroup
			case "BLIND" 'looks thought ini table to determine possible values for populating search variables
				Session("no_gui" & dbkey & formgroup) = true
				GetSearchData_blind dbkey, formgroup
			case "BLIND_GUI" 
				Session("no_gui" & dbkey & formgroup) = false
				GetSearchData_blind dbkey, formgroup
		end select
		
End Sub

Sub DoReloadBaseRS(dbkey, formgoup)
	Dim schema_name
		basetable = GetBaseTable2(dbkey, formgroup, "basetable")
		
		SQLSyntax=GetTableVal(dbkey,basetable,kSQLSyntax)
		
		' Decide which value of maxhits to use				
		appMaxhits = Application("MaxHits" & dbkey)
		'LJB 4/15/04. account for maxhits = "" and 0
		if appMaxhits = "" or appMaxhits = 0 then
			maxhits = 0
		else
			sessionMaxhits = Session("GetNextMaxHits" & dbkey & formgroup)
		if sessionMaxhits > appMaxhits then
			maxhits = sessionMaxhits +1
		Else
			maxhits = appMaxhits + 1
		End if	 
		end if	 
		Select Case UCase(SQLSyntax)
			Case "ACCESS"
				sql= "Select Top " & maxhits & " CSDOHITLIST.ID from CSDOHITLIST WHERE hitlistID=" & Session("hitlistID" & dbkey & formgroup)
			Case  "ORACLE"
				if UCase(dbkey) = "REG" then
					schema_name= Application("REG_USERNAME")
				else
					schema_name= Application(dbkey & "_USERNAME")
				end if
				baseTablePK = GetTableVal(dbkey, basetable, kPrimaryKey)
				
				if UseCartridge(dbkey, formgroup) then 
					sql= "SELECT b." & baseTablePK & " FROM " & baseTable & " b, " & schema_name & ".CSDOHITLIST c WHERE b.rowid = c.id AND c.hitlistID=" & Session("hitlistID" & dbkey & formgroup)
				
					if Request.QueryString("jumptoindex") <> "" then
						sortOrderString = prepareSortOrder(dbkey, formgroup,SQLSyntax)
						if sortOrderString <> "" then
							sql = sql & " " & Replace(sortOrderString,baseTable,"b")
						end if
					end if
				
				else
					sql= "SELECT CSDOHITLIST.ID  FROM " & schema_name & ".CSDOHITLIST WHERE hitlistID=" & Session("hitlistID" & dbkey & formgroup)
				end if
			Case "SQLSERVER"
				sql= "Select CSDOHITLIST.ID from CSDOHITLIST WHERE hitlistID=" & Session("hitlistID" & dbkey & formgroup)

		End Select
		rsname = "Look_Ahead"
		Session("ContentsField" & dbkey & formgroup) = "" 'ensures that hitlist is not saved for reload baseRS
		Session("Base_RS" & dbkey & formgroup) = CreateRecordset(rsname, dbkey, formgroup, sql, maxhits, adOpenForwardOnly, adLockReadOnly)
		'DGB Rewind so the first record is displayed during restore
		Session("CurrentRecord" & dbkey & formgroup)=1
		Session("LastStartingIndex" & dbkey & formgroup)=1
End Sub

Function DropTempTable(dbkey, fromgroup, tablename)

	Set conn = GetNewConnection (dbkey, formgroup, "base_connection")
	Set cmd = Server.CreateObject("ADODB.Command")
	
        Set cmd.ActiveConnection = conn
        cmd.CommandType = adCmdText
        ' complains if table doesn't already exist
        On Error Resume Next
        cmd.CommandText = "drop table " & tablename
     
    Set Cmd = Nothing
    CloseConn(conn)
    if not err.number <> 0 then
	  Session("MSIS_TempTableName")=""
    end if
end function

Sub buildRS(dbkey, formgroup, the_ids)
		the_ids_array = split(the_ids, ",", -1)
		theCount = Ubound(the_ids_array)
		Dim theRSArray()
		ReDim theRSArray(0,theCount)
		for i = 0 to thecount
			theRSArray(0,i) = the_ids_array(i)
		next
		Session("fEmptyRecordset" & dbkey & formgroup) = "False"
		Session("Base_RS" & dbkey & formgroup) = theRSArray
End Sub

function buildAltFormGroupActionStr(dbkey,dest_formgroup,criteria,formmode_override,button_override_txt,last_location_input,last_location_text,do_redirect)
	dim formmode
	dim return_location 
	dim action
	dim dbname
	dim formgroup
	dim full_criteria
	
	action= "?dataaction=search&metadata_directive=blind_gui"
	dbname = "&dbname=" & dbkey
	formgroup = "&formgroup=" & dest_formgroup
	full_criteria = Server.HTMLEncode("&" & criteria)
	if formmode_override <> "" then
		formmode = "&formmode_override=" & formmode_override
	end if
	if UCase(do_redirect) = "FALSE" then
		return_data  = "&return_data=" & "no_redirect"
	else
		return_data = ""
	end if
	if button_override_txt <> "" then
		button_override = "&button_override=" & button_override_txt 
	else
		button_override =""
	end if
	if Not detectNS4 = true then
		if last_location_input <> "" then
			last_location = "&get_last_location=" & "true"
			cookie_name = "lastlocation" & dbkey & dest_formgroup
			%>
			<script language = "javascript">
					setCookie("<%=cookie_name%>", "<%=last_location_input%>",1)
			</script>
			<%
			if last_location <> "" then
				last_location_text = Server.HTMLEncode(last_location_text)
				last_location = last_location & "&last_location_text=" & last_location_text
			else
				last_location_text = Server.HTMLEncode("return to last location")
				last_location = last_location & "&last_location_text=" & last_location_text
			end if
		else
			last_location = ""
		end if	
		else
		last_location = ""
	end if
	fullaction = "/" & Application("AppKey") & "/" & dbkey & "/" & dbkey & "_action.asp" & action & dbname & formgroup  & formmode  & full_criteria & button_override_txt & last_location  & "&preserve_items=button_override,get_last_location,last_location_text" & return_data
	buildAltFormGroupActionStr = fullaction
end function

function buildNoRSAltFormGroupActionStr(dbkey,dest_formgroup,criteria,formmode_override,button_override_txt,last_location_input,last_location_text,do_redirect)
	dim formmode
	dim return_location 
	dim action
	dim dbname
	dim formgroup
	dim full_criteria
	
	action= "?dataaction=build_rs"
	dbname = "&dbname=" & dbkey
	formgroup = "&formgroup=" & dest_formgroup
	full_criteria = "&id_list=" & criteria
	if formmode_override <> "" then
		formmode = "&formmode_override=" & formmode_override
	end if
	if UCase(do_redirect) = "FALSE" then
		return_data  = "&return_data=" & "no_redirect"
	else
		return_data = ""
	end if
		
	if button_override_txt <> "" then
		button_override_txt = "&button_override=refine,get_more," & button_override_txt
	else
		button_override_txt = "&button_override="  & "refine,get_more"
	end if
	if last_location_input <> "" then
		last_location = "&get_last_location=" & "true"
		cookie_name = "lastlocation" & dbkey & dest_formgroup%>
		<script language = "javascript">
				setCookie("<%=cookie_name%>", "<%=last_location_input%>",1)
		</script>
		<%
		if last_location <> "" then
			last_location = last_location & "&last_location_text=" & last_location_text
		else
			last_location = last_location & "&last_location_text=" & "return to last location"
		end if
	end if	
	fullaction = "/" & Application("AppKey") & "/" & dbkey & "/" & dbkey & "_action.asp" & action & dbname & formgroup  & formmode  & full_criteria & button_override_txt & last_location  & "&preserve_items=button_override,get_last_location,last_location_text" & return_data
	buildNoRSAltFormGroupActionStr = fullaction
end function

Sub Progressbar(currRow, totalRows, flushRate)
		PercentDone = Int((currRow/totalRows* 100)/5)
		if NOT Response.IsClientConnected then Response.end 
		
		if ((currRow MOD flushRate)=0) OR (currRow = totalRows)then 
				on error resume next
				Response.Buffer = True
				rowsRemaining = totalRows - currRow
				If Session("LastPercent") <> PercentDone then
					Block = "Block" & PercentDone
					response.write "<SCRIPT>"
					for i = PercentDone to 1 step -1
						response.write "document.Block" & i & ".src = '/cfserverasp/source/graphics/blue.gif';"
					next
					response.write "</SCRIPT>"
				End if	
				TimeElapsed = Timer - Session("StartTime") 	
				RowsCompleted = totalRows - rowsremaining 
				Rate = Round(RowsCompleted/TimeElapsed, 2)
				response.write "<SCRIPT>document.form1.rowsRemaining.value='" & rowsRemaining & "';document.form1.timeElapsed.value='" & SecondsToTimer(TimeElapsed) & "';document.form1.rate.value='" & Rate & "';document.form1.totalRows.value='" & totalRows & "';document.form1.rowsCompleted.value='" & RowsCompleted & "';</SCRIPT>"
				response.flush
				Session("LastPercent") = PercentDone					
		End if
End sub

Function SecondsToTimer(seconds)
	Hours = Int(seconds/3600)
	seconds = seconds - hours * 3600
	If hours < 10 then hours = "0" & hours 
	Minutes = Int(seconds/60)
	If Minutes < 10 then Minutes = "0" & Minutes
	seconds = Int(seconds - minutes * 60)
	If seconds < 10 then seconds = "0" & seconds
	SecondsToTimer = Hours & ":" & Minutes & ":" & seconds
End function

Sub InitializeProgressBar(bCloseWindow,strUrl)
	Session("LastPercent")=""
	Session("StartTime")=""
	Session("StartTime") = Timer
	response.write "<HTML><HEAD><STYLE TYPE=""text/css"">"
	response.write "#ctext {position:relative; background-color:#FFFFFF; layer-background-color:#FFFFFF;font-family:verdana; font-size:12}"
	response.write "#caption {position:relative; background-color:#FFFFFF; layer-background-color:#FFFFFF;font-family:verdana; font-size:12}"
	response.write "</STYLE></HEAD><BODY><center><form name=form1>"
	response.write "<div id=""caption""></div>"
	response.write "<TABLE WIDTH=""100"" CELLPADDING=0 CELLSPACING=0 BORDER=0>"
	response.write "<TR><TD align=right nowrap><div id=""ctext""> Total records :&nbsp;</div></TD><TD colspan=20><input size=""8"" disabled onfocus=""blur()"" type=""text"" name=""totalRows""></TD></TR>"
	response.write "<TR><TD align=right nowrap><div id=""ctext"">Records remaining:&nbsp;</div></TD><TD colspan=20><input size=""8"" disabled onfocus=""blur()"" type=""text"" name=""rowsRemaining""></TD></TR>"
	response.write "<TR><TD align=right nowrap><div id=""ctext"">Records completed:&nbsp;</div></TD><TD colspan=20><input  size=""8"" disabled onfocus=""blur()"" type=""text"" name=""rowsCompleted""></TD></TR>"
	response.write "<TR><TD align=right><div id=""ctext"">Progress:&nbsp;</div></TD>"
	For X = 1 to 20
	response.write "<TD><IMG SRC=""/cfserverasp/source/graphics/grey.gif"" NAME=""Block" & X & """ WIDTH=10 HEIGHT=15 ALT=""Progress Bar""><IMG SRC=""/cfserverasp/source/graphics/White.gif"" WIDTH=""2"" height=""15""></TD>"
	Next
	response.write "</TR>"
	response.write "<tr><TD align=right nowrap><div id=""ctext"">Time elapsed:&nbsp;</div></TD><TD colspan=20><input  size=""8"" disabled onfocus=""blur()"" type=""text"" name=""timeElapsed""></TD></tr>"
	response.write "<tr><TD align=right nowrap><div id=""ctext"">Rate (records/sec):&nbsp;</div></TD><TD colspan=20><input  size=""8"" disabled onfocus=""blur()""  type=""text"" name=""rate""></TD></tr>"
	if bCloseWindow = True then
		response.write "<tr><TD align=center colspan=21><BR><a href=# onclick=""window.close()"" ><IMG border=0 src=""" & Application("NavButtonGifPath") & "cancel_dialog_btn.gif" & """></a></TD></tr>"
	else
		if Not isEmpty(strUrl) then
			if detectNS4() = true or detectIE5() = true then
				response.write "<tr><TD align=center colspan=21><BR><a href=""javascript:location.replace(&quot;" & strUrl & "&quot;)"" ><IMG border=0 src=""" & Application("NavButtonGifPath") & "cancel_dialog_btn.gif" & """></a></TD></tr>"
			else
				response.write "<tr><TD align=center colspan=21><BR><a href=# onclick=""location.href('" & strUrl & "')"" ><IMG border=0 src=""" & Application("NavButtonGifPath") & "cancel_dialog_btn.gif" & """></a></TD></tr>"
			end if
		else
			if detectNS4() = true or detectIE5() = true then
				response.write "<tr><TD align=center colspan=21><BR><a href=""javascript:location.replace(true)""><IMG border=0 src=""" & Application("NavButtonGifPath") & "cancel_dialog_btn.gif" & """></a></TD></tr>"
			else
				response.write "<tr><TD align=center colspan=21><BR><a href=# onclick=""location.reload(true)"" ><IMG border=0 src=""" & Application("NavButtonGifPath") & "cancel_dialog_btn.gif" & """></a></TD></tr>"
			end if
		end if
	end if
	
	response.write "</TABLE></form></center></BODY></HTML>"
End Sub


Function getLabelNameFromDict(dbkey, formgroup,formmode, theKeyName_str)
	Dim myVar
	if  Session("bypass_ini" & dbkey & formgroup)  = true then
	Dim i
		if formmode = "EDIT" then 
			display_view = "DETAIL" 
		else
			display_view = formmode
		end if
		if Application("FIELD_LABELS" & formgroup &  display_view)<> "" then
			on error resume next
			temp = split(Application("FIELD_LABELS" & formgroup &  display_view), ",", -1)
			for i = 0 to UBound(temp)
				temp2=split(temp(i), ":", -1)
				if Trim(UCase(temp2(0))) = Trim(UCase(theKeyName_str)) then
					'LJB 12/2004. Fully quality field name so that fields with the same name will be recongnized by ChemDraw for Excel. Only do this for calls from export_hits.asp
					'We don't want the fully qualified names in the export hits dialog.
					' DGB  commented, because we do actually want the fully qualified names in the dialog
					'if inStr(Request.ServerVariables("HTTP_REFERER"), "export_hits.asp") > 0 then
						table_name_temp = split(temp2(0), ".", -1)
						tablename_val = getTableNameFromDict(dbkey, formgroup,formmode, table_name_temp(0) & "." & table_name_temp(1))
						myVar = tablename_val  & "." &  temp2(1)
					'else
					'	myVar =  temp2(1)
					'end if
				end if
			next
		end if
	else
		if isObject(custom_fields_dict) then
				if inStr(theKeyName_str, ".")> 0 then
					theKeyNameTemp = split(theKeyName_str, ".", -1)
					theKeyName =theKeyNameTemp(UBound(theKeyNameTemp))
				else
					theKeyName=theKeyName_str
				end if
				if custom_fields_dict.Exists(theKeyName) then
					myVar = custom_fields_dict.ITEM(theKeyName)
				Else
					myVar = theKeyName
				End if
		else 
				
					if isObject(Session("FIELD_LABELS")) then
						if inStr(theKeyName_str, ".")> 0 then
							theKeyNameTemp = split(theKeyName_str, ".", -1)
							theKeyName = UCase(theKeyNameTemp(UBound(theKeyNameTemp)))
						else
							theKeyName=theKeyName_str
						end if
							myVar = Session("FIELD_LABELS").ITEM(UCase(theKeyName))
					else
						myVar = theKeyName_str
					end if	
					
				
		end if
	end if
	getLabelNameFromDict=myVar
End Function

Function getTableNameFromDict(dbkey, formgroup,formmode, theKeyName_str)
	Dim myVar
	 if Session("bypass_ini" & dbkey & formgroup) = true then
		if formmode = "EDIT" then 
			display_view = "DETAIL" 
		else
			display_view = formmode
		end if
		if Application("TABLE_LABELS" & formgroup &  display_view)<> "" then
			on error resume next
			temp = split(Application("TABLE_LABELS" & formgroup &  display_view), ",", -1)
			for i = 0 to UBound(temp)
				temp2=split(temp(i), ":", -1)
				if Trim(UCase(temp2(0))) = Trim(UCase(theKeyName_str)) then
					myvar = temp2(1)
					exit for
				end if
			next
		end if
	else
		if isObject(custom_table_dict) then
				myVar = custom_table_dict.ITEM(theKeyName_str)
		else 
			if isObject(Session("TABLE_LABELS")) then
					myVar = Session("TABLE_LABELS").ITEM(theKeyName_str)
			else
				myVar = theKeyName_str
			end if	
		end if
	end if
	getTableNameFromDict = myVar
End Function

Function CheckOrigRequest(fullfieldname,fieldstoexport)
	itemfound = false
	myArray = split(fieldstoexport, ",", -1)
		for i = 0 to UBound(myArray)
			if UCase(myArray(i)) = UCase(fullfieldname) then
				 itemFound = true
				 exit For
			end if
		next
	CheckOrigRequest = itemFound
End Function


Function getChunkArray(inputStr)
	dim n, pos, i, segmentLength
	n = Len(inputStr) 'number of characters
	pos = 1 'starting position
	i = 0 'starting index
	segmentLength = 4000 'thelength of the segment
	Dim myChunkStr
	while pos < n 
		si = Mid(inputStr, pos, segmentLength)
		if myChunkStr <> "" then
			myChunkStr = myChunkStr & "," & si
		else
			myChunkStr = si
		end if
		pos = pos + segmentLength 
		i = i + 1
	wend
	theReturn = split(myChunkStr, ",", -1)
	getChunkArray = theReturn
end function

Function getChunkString(inputStr)
	dim n, pos, i, segmentLength
	n = Len(inputStr) 'number of characters
	pos = 1 'starting position
	i = 0 'starting index
	segmentLength = 4000 'thelength of the segment
	Dim myChunkStr
	while pos < n 
		si = Mid(inputStr, pos, segmentLength)
		if myChunkStr <> "" then
			myChunkStr = myChunkStr & "," & si 
		else
			myChunkStr = si 
		end if
		pos = pos + segmentLength 
		i = i + 1
	wend
	
	getChunkString = myChunkStr
end function

function AddChildTableCriteria(dbkey, formgroup, tablename_in, sql)
	dim theReturn
	
	temp = Split(Session("SearchData" & "Relational" & dbkey & formgroup), ",", -1)
	for i = 0 to UBound(temp)
		temp2 = split(temp(i), ".", -1)
		if UBound(temp2) = 2 then
			tablename = temp2(0) & "." & temp2(1)
		else
			tablename = temp2(0) 
		end if
		if UCase(tablename_in) = UCase(tablename) then
			if field_list <> "" then
				field_list = field_list & "," & temp(i)
			else
				field_list = temp(i)
			end if
		end if
	next
	if field_list <> "" then
		strWhere = GetTableSpecificRelFields(dbkey, formgroup, field_list)
		if strWhere <> "" then
			final_sql = sql & " AND " & strWhere
		else
			final_sql = sql
		end if
	else
		strWhere = ""
		final_sql  = sql
	end if
	final_sql = Replace(final_sql, "*", "%")
	AddChildTableCriteria  = final_sql

End function

Function GetTableSpecificRelFields(ByVal dbkey, ByVal formgroup, ByVal inputstr)
	fieldArray = split(inputstr, ",", -1)
	count = UBound(fieldArray)
	for i = 0 to  count
		if Not inStr(fieldArray(i), ";") >0 then
			new_field_name= appendDataType(dbkey, formgroup, fieldArray(i))
			if Not new_field_name <> "" then
				HandleError dbkey, formgroup, "field_type_missing", "no field type specified in query or ini file for:" & fieldArray(i), "", ""
			else
				fieldArray(i) = new_field_name
			end if
		end if
		temp = split(fieldArray(i), ";", -1)
		fieldtype = temp(1)
		fieldname = temp(0)
		fieldvalue = Session("SearchData" & temp(0) & dbkey & formgroup)
		

		if Not fieldvalue <> "" then exit function
		formgroupflag = GetFormGroupVal(dbkey, formgroup, kFormGroupFlag)
		If formgroupflag = "GLOBAL_SEARCH" then
			returnedfieldname = GetFieldCorr(dbkey, formgroup, "OtherField", fieldArray(i))
			
			if inStr(1, returnedfieldname, ";") > 0 then 
				temp = split(returnedfieldname, ";", -1)
				fieldtype = temp(1)
				fieldname = temp(0)
			Else
				breturnBlank = True
			End if
			
		End If
		strWhere = GetRelStrWhere(dbkey,formgroup, fieldtype, fieldname, fieldvalue, strWhere)
	Next 'i
	GetTableSpecificRelFields = strWhere

End Function

'-------------------------------------------------------------------------------'
'-------------------------------------------------------------------------------'
'-------------------------------------------------------------------------------'
'--------------------------Legacy code - No longer used ---------------------------'
'-------------------------------------------------------------------------------'
'-------------------------------------------------------------------------------'
'-------------------------------------------------------------------------------'



'get the molstr from the CF search that will be passed to ADO as a string
Function GetMolStr(ByVal dbkey, ByVal formgroup, ByVal path, ByVal maxhits)
	on error resume next
	'open hitlist file, read in StrucUniqueIDs and create a comma delimited string
	Set fs = Server.CreateObject("Scripting.FileSystemObject")
	Set a = fs.OpenTextFile(path)
	'read each line and add it to a string
	counter = 0
	if maxhits <> "" then 'get only maxhits
		Do While a.AtEndOfStream <> True
			temp = a.ReadLine
			if (counter>0 and counter<(maxhits + 1)) then
				If temp <> ""  then
					If molstr <> "" then
						molstr = molstr & "," & temp
					Else 
						molstr =  temp
					End If 
				Else
					Exit Do
				end if
			end if
			counter=counter+1
		loop
	else 'get all in file
		Do While a.AtEndOfStream <> True
			temp = a.ReadLine
			if (counter>0) then	
				If temp <> ""  then
					If molstr <> "" then
						molstr = molstr & "," & temp
					Else 
						molstr =  temp
					End If 
				Else
					Exit Do
				End If
			end if
			counter=counter+1
		loop
	end if
	'End reading lines
	a.Close
	'End reading hitlist
	if err.number > 0 then
		HandleError dbkey, formgroup, "cfw_molstr_no_hits", "cfw empty molstr", err.number, err.description
	end if
	if molstr <> "" then
		GetMolStr = molstr
	Else
		HandleError dbkey, formgroup, "cfw_molstr_no_hits", "cfw empty molstr", err.number, err.description
	End if		
End Function


Sub SetListSearchType(ByRef CFWDoc, ByVal firstsearch)
	If firstsearch = true then
		CFWDoc.ExecuteCalCommand("SET SEARCHING SRCH_OVER_CURR_LIST 0")
	Else
		CFWDoc.ExecuteCalCommand("SET SEARCHING SRCH_OVER_CURR_LIST 1")
	End If
End Sub

'create a recordset object only is not already created
Function GetNewRSObject(ByVal dbkey)
	if Not isObject(Session("rs" & dbkey & formgroup)) then
		Set Session("rs" & dbkey & formgroup) = Server.CreateObject("ADODB.Recordset")
	End if
End Function

Sub CloseConnection(dbkey, conn_name)
	DataConn.Close
	Set DataConn = Nothing
	DataConn = ""
End Sub

Function GetScratchConn()
	'check If object already exists
	on error resume next
	Set DataConn=Server.CreateObject("ADODB.Connection")
	ConnString = "C:\Inetpub\ccr_scratch.mdb;Driver={Microsoft Access Driver (*.mdb)};DriverId=25;FIL=MS Access;"
	DataConn.ConnectionString = ConnString
	DataConn.ConnectionTimeout = 15
	DataConn.CommandTimeout = 15
	DataConn.Password = ""
	DataConn.UserName = ""
	'DataConn.Provider = "Microsoft.Jet.OLEDB.3.51"
	
	DataConn.Open 
	if err.number > 0 then
		DataConn.Close
		Set DataConn = Nothing
		DataConn = ""
		HandleError dbkey, formgroup, "conn_string", "GetNewConnection", ErrorsMade,""
	Else
	Set GetScratchConn = DataConn
	End if
	
End Function

Sub CleanUpRecordsets(ByVal dbkey, ByVal formgroup, ByVal inputstr)
		Session("Base_RS" & dbkey & formgroup) = ""
End sub


Sub GetCurrentPrefs(ByVal dbkey, ByVal formgroup)

	Session("PrefsS1" & dbkey ) = Request.Cookies("S1" & dbkey )
	If Session("PrefsS1" & dbkey ) = "false" then Session("PrefsS1" & dbkey ) = "0"
	If Session("PrefsS1" & dbkey )= "true" then Session("PrefsS1" & dbkey ) = "1"
	If Session("PrefsS1" & dbkey )= "" then Session("PrefsS1" & dbkey ) = "1"

	Session("PrefsS2" & dbkey ) = Request.Cookies("S2" & dbkey )
	If Session("PrefsS2" & dbkey ) = "false" then Session("PrefsS2" & dbkey ) = "0"
	If Session("PrefsS2" & dbkey )= "true" then Session("PrefsS2" & dbkey ) = "1"
	If Session("PrefsS2" & dbkey )= "" then Session("PrefsS2" & dbkey ) = "1"


	Session("PrefsS3" & dbkey ) = Request.Cookies("S3" & dbkey )
	If Session("PrefsS3" & dbkey ) = "false" then Session("PrefsS3" & dbkey ) = "0"
	If Session("PrefsS3" & dbkey )= "true" then Session("PrefsS3" & dbkey ) = "1"
	If Session("PrefsS3" & dbkey )= "" then Session("PrefsS3" & dbkey ) = "1"

	Session("PrefsS4" & dbkey ) = Request.Cookies("S4" & dbkey )
	If Session("PrefsS4" & dbkey ) = "false" then Session("PrefsS4" & dbkey ) = "0"
	If Session("PrefsS4" & dbkey )= "true" then Session("PrefsS4" & dbkey ) = "1"
	If Session("PrefsS4" & dbkey )= "" then Session("PrefsS4" & dbkey ) = "1"

	Session("PrefsS5" & dbkey ) = Request.Cookies("S5" & dbkey )
	If Session("PrefsS5" & dbkey ) = "false" then Session("PrefsS5" & dbkey ) = "0"
	If Session("PrefsS5" & dbkey )= "true" then Session("PrefsS5" & dbkey ) = "1"
	If Session("PrefsS5" & dbkey )= "" then Session("PrefsS5" & dbkey ) = "1"

	Session("PrefsS6" & dbkey ) = Request.Cookies("S6" & dbkey )
	If Session("PrefsS6" & dbkey ) = "" then Session("PrefsS6" & dbkey ) = "90"
	
	Session("PrefsS7" & dbkey ) = Request.Cookies("S7" & dbkey )
	If Session("PrefsS7" & dbkey ) = "false" then Session("PrefsS7" & dbkey ) = "0"
	If Session("PrefsS7" & dbkey )= "true" then Session("PrefsS7" & dbkey ) = "1"
	If Session("PrefsS7" & dbkey )= "" then Session("PrefsS7" & dbkey ) = "0"

End Sub

Function SetOpts(sstype, refine)
	kCFSubStructure=0
	kCFFullStructure=1
	kCFSimilar=2
	kCFTetrahedralStereo=4
	kCFDoubleBondStereo=8
	kCFHitAnyChargeHetero=16
	kCFHitAnyChargeCarbon=32
	kCFFragmentsOverlap=64
	kCFUseReactionCenter=128
	kCFPermitExtraneousFragments=256
	kCFSearchOverCurrentlist=512
	
	Dim nOpts
	nOpts = 0

	'search flags
	If sstype = 0 then
		nOpts = nOpts + kCFSubStructure
	End If

	If sstype = 1 then
		nOpts = nOpts + kCFFullStructure
	End If

	If sstype = 3 then
		nOpts = nOpts + kCFFullStructure + kCFSimilar 
	End If

	'search over list flag
	If refine = True then
		nOpts = nOpts + kCFSearchOverCurrentlist
	End If 

	'set option flags
	If Not Session("PrefsS1" & dbkey & formgroup) = "OFF" then
		nOpts = nOpts + kCFTetrahedralStereo
	End If

	If Not Session("PrefsS2" & dbkey & formgroup) = "OFF" then
		nOpts = nOpts + kCFDoubleBondStereo
	End If

	If Not Session("PrefsS3" & dbkey & formgroup) = "OFF" then
		nOpts = nOpts + kCFHitAnyChargeHetero
	End If

	If Not Session("PrefsS4" & dbkey & formgroup) = "OFF" then
		nOpts = nOpts + kCFHitAnyChargeCarbon
	End If

	If Not Session("PrefsS5" & dbkey & formgroup) = "OFF" then
		nOpts = nOpts + kCFUseReactionCenter
	End If
	
	SetOpts = nOpts
End Function

Sub StoreCookieData(ByVal fieldtype, ByVal fldinputstr, ByVal queryname)
	fieldarray =  Split(fldinputstr, ",", -1)
	for j = 0 to UBound(fieldarray)
		If fieldtype = "RelFields" then
			relname = split(fieldarray(j), ";", -1)
			Response.Cookies(queryname & dbkey & formgroup)(relname(0))=Session("SearchData" & relname(0) & dbkey & formgroup)
			Response.Cookies(queryname & dbkey & formgroup).Expires  = Date + 365
		Else
			Response.Cookies(queryname & dbkey & formgroup)(fieldarray(j))=Session("SearchData" & fieldarray(j) & dbkey & formgroup)
		End If
	Next
End Sub


Sub StoreCookieSearchData(ByVal dbkey,ByVal formgroup, ByVal queryname)
	'store individual values
	StoreCookieData "ChemFields", Session("SearchData" & "SubStructure" & dbkey & formgroup), queryname
	StoreCookieData "RelFields", Session("SearchData" & "Relational" & dbkey & formgroup), queryname
End Sub

Sub RemoveMarkedHit(ByVal dbkey,ByVal formgroup, ByVal marked_hit)
	current_hits = ""
	current_hits = Request.Cookies("MarkedHits" & dbkey & formgroup)
	temparray = Split(current_hits, ",", -1)
	for i = 0 to UBound(temparray)
		If Not marked_hit = temparray(i) then
			If new_hits <> "" then
				new_hits = new_hits & "," & temparray(i)
			Else
				new_hits = temparray(i)
			End If
		End If
	next
	Response.Cookies("MarkedHits" & dbkey & formgroup).Expires = Date + 365
	Response.Cookies("MarkedHits" & dbkey & formgroup) = new_hits
End Sub


Sub DeleteCookieSearchData(ByVal dbkey, ByVal formgroup, ByVal queryname)
	Response.Cookies(queryname & dbkey & formgroup)=""
End Sub


Sub ClearMarkedHitsData(ByVal dbkey, ByVal formgroup)
	Response.Cookies("MarkedHits" & dbkey & formgroup) = ""
End Sub


Function GetChemRelStrWhere(ByVal RelPortion, ByVal ChemPortion)
	If Session("fEmptyRecordset" & dbkey & formgroup) = False then
		If RelPortion <> "" then 
			RelPortion = RelPortion & " AND "
		End If
		GetChemRelStrWhere = Relportion & ChemPortion
	Else
		GetChemRelStrWhere = ""
	end if
	Session("SearchData" & "FullStrWhere" & dbkey & formgroup)= GetChemRelStrWhere

End Function


Function GetChemPortion(ByVal dbkey, ByVal formgroup, ByVal outmolstr)
	If outmolstr <> "" then 
		basetable = GetBaseTable(dbkey, formgroup, "basetable")
		strucid = GetTableVal(dbkey, basetable, kStrucFieldID)
		If Session("CFWRecords" & dbkey & formgroup)> 1 then
			GetChemPortion = "[" & Trim(basetable) & "]" & "." & "[" & Trim(strucid) & "]" & " IN " & "(" &  outmolstr & ")"
		Else 
			If Session("CFWRecords" & dbkey & formgroup)= "1" then
				GetChemPortion =  "[" & Trim(basetable) & "]" & "." & "[" & Trim(strucid) & "]"  & " = " & outmolstr
			End If
		End If
	Else
		GetChemPortion = ""
		Session("fEmptyRecordset" & dbkey & formgroup) = True
	End If

	Session("SearchData" & "ChemPortion" & dbkey & formgroup) = GetChemPortion
End Function


Function GetBaseIDPortion(ByVal dbkey, ByVal formgroup, ByVal ids)
	' logaction "GBIP dbkey, fg = " & dbkey & " " & formgroup
	
	If ids <> "" then '
		basetable = GetBaseTable(dbkey, formgroup, "basetable")
		baseid = GetTableVal(dbkey, basetable, kPrimaryKey)
		GetBaseIDPortion = basetable & "." & baseid & " IN " & "(" &  ids & ")"		
	Else
		GetBaseIDPortion = ""
		Session("fEmptyRecordset" & dbkey & formgroup) = True
	End If

	Session("SearchData" & "BaseIDPortion" & dbkey & formgroup) = GetBaseIDPortion
End Function


Sub DisplayProcessingCount(WindowType, CurrentCount)
	Select Case UCase(WindowType)
		Case "OPENWINDOW" 
		%>
			<SCRIPT language="JavaScript">
				
					function OpenStatusWindow(leftPos,topPos,recnumber){
					var attribs = "toolbar=0,location=0,directories=0,status=0,menubar=0,scrollbars,resizable,width=300,height=200,screenX=" + leftPos + ",screenY=" + topPos + ",left=" + leftPos + ",top=" + topPos
					CSStatusWindow = window.open("","Status", attribs);
					if(recnumber !=0){
						CSStatusWindow.document.write ('Processing Record #' + recnumber + '<br>');
					}
					CSStatusWindow.window.scroll(0,1000000);
					}
					OpenStatusWindow(100,200,<%=CurrentCount%>);
			</SCRIPT>
		<%	
	Case "CLOSEWINDOW" 
		%>
			<SCRIPT language="JavaScript">
					function CloseStatusWindow(leftPos,topPos,recnumber){
					var attribs = "toolbar=0,location=0,directories=0,status=0,menubar=0,scrollbars,resizable,width=300,height=200,screenX=" + leftPos + ",screenY=" + topPos + ",left=" + leftPos + ",top=" + topPos
					CSStatusWindow = window.open("","Status",attribs);
					CSStatusWindow.document.write ('Processing complete');
					CSStatusWindow.window.scroll(0,1000000);
					CSStatusWindow.close()
					}
					CloseStatusWindow(100,200,'','');

			</SCRIPT>
		<%
	Case "UPDATEWINDOW" 
		%>
			<SCRIPT language="JavaScript">
					CSStatusWindow.document.write ('Processing Record #' + "<%=CurrentCount%>" + '<br>');
					CSStatusWindow.window.scroll(0,1000000);
			</SCRIPT>
		<%
	
	end Select


end sub
'-------------------------------------------------------------------------------
' Purpose:	Writes hits from an ADO search to a file in the session directory
' Assumes:	rs.fields(0) is the primary key (mol_id)
' Args:		An ADO Recordset
'-------------------------------------------------------------------------------
sub WriteHitsFromADOSearch (byval rs, byval iNumRecords, byval uniqueid)
	'LogAction ("in WriteHitsFromADOSearch")
	AdoHitlistPath = Application("TempFileDirectory" & dbkey) & "Sessiondir\" & Session.sessionid & "\" &   "adohits.txt"

	Set fs = Server.CreateObject("Scripting.FileSystemObject")
	Set outfile = fs.OpenTextFile(AdoHitListPath, 2, True)  
	outfile.WriteLine UCase(uniqueid)
	Do While not rs.EOF
	'for ic = 1 to iNumRecords
		outfile.WriteLine rs.fields(0)
		rs.movenext
	loop
	outfile.close
end sub


'-------------------------------------------------------------------------------
' Purpose:	Restores an ADO Recordset to ChemFinder
' Assumes:	A file called "adohits.txt" in the session directory
' Args:		A ChemFinder document object to which hits are restored
' Returns:	true if there were hits; false if adohits.txt is absent of empty
'-------------------------------------------------------------------------------
function RestoreAdoHits (byref CFWDoc)
	icount = 0
	bSuccess = False
	AdoHitlistPath = Application("TempFileDirectory" & dbkey) & "Sessiondir\" & Session.sessionid & "\" &   "adohits.txt"
	'Check to see that the file has records. If not, leave bSuccess=False
	Set fs = Server.CreateObject ("Scripting.FileSystemObject")
	Set infile = fs.OpenTextFile (AdoHitListPath)
	Do While infile.AtEndOfStream <> True
		temp = infile.ReadLine
		icount = icount + 1
		if icount > 1 then
			bSuccess = True
			Exit Do
		end if
	loop
	infile.close
	set fs = nothing
	'End reading hitlist

	'restore list to ChemFinder
	if bSuccess = True then
		on error resume next
		CFWDoc.ExecuteCalCommand "Search Restore List " & AdoHitlistPath
		on error goto 0
	end if
	RestoreAdoHits = bSuccess
end function



'-------------------------------------------------------------------------------
' Purpose:
' Assumes:
' Inputs:
'-------------------------------------------------------------------------------
Function AddToQueryCookieStr(ByVal dbkey, ByVal formgroup, ByVal query_name)
	formgroupflag = GetFormGroupVal(dbkey, formgroup, kFormGroupFlag)
	
	add_name = true
	current_names = ""
	If formgroupflag = "GLOBAL_SEARCH" then
		dbkey = Application("GlobalBaseDB")
		current_names = Request.Cookies("StoredQueriesGlobal" & dbkey & formgroup)
	else
		current_names = Request.Cookies("StoredQueries" & dbkey & formgroup)
	end if
	if current_names <> "" then
		temparray = Split(current_names, ",", -1)
		for i = 0 to UBound(temparray)
			If query_name = temparray(i) then
				add_name = false
			End If
		next
	else
		add_name = true
	end if
	If add_name = true then
		If current_names <> "" then
			new_names = current_names & "," & query_name
		Else
			new_names = query_name
		End If
		
		If formgroupflag = "GLOBAL_SEARCH" then
			dbkey = Application("GlobalBaseDB")
			Response.Cookies("StoredQueriesGlobal" & dbkey & formgroup).Expires = Date + 365
			Response.Cookies("StoredQueriesGlobal" & dbkey & formgroup) = new_names
		else
			Response.Cookies("StoredQueries" & dbkey & formgroup).Expires = Date + 365
			Response.Cookies("StoredQueries" & dbkey & formgroup) = new_names
		end if
	End If
	AddToQueryCookieStr = new_names
End Function

Sub SetupForRefine()
	if formgroupflag = "GLOBAL_SEARCH" then
			DBSearchNames = Session("SearchData" & "SearchDBNames")
		else
			DBSearchNames = dbkey
		end if
		DBSearchNamesArray = split(DBSearchNames, ",", -1)
		thedbkey = 0
		Session("count") = UBound(DBSearchNamesArray)
		dbkeyset = false
		
		For thedbkey = 0 to CLng(Session("count"))
			dbkey = DBSearchNamesArray(thedbkey)
			Session("LastSearchData" & "FULL_SQL" & dbkey & formgroup)=Session("SearchData" & "FULL_SQL" & dbkey & formgroup)
			StoreSearchData dbkey, formgroup
			StoreChemSearchData dbkey, formgroup
			Session("LastSearchData" & "SearchDBNames")= Session("SearchData" & "SearchDBNames")
			SetSessionVars dbkey, formgroup,"refine"
			Session("LastMoreMolids" & dbkey & formgroup) =Session("MoreMolids" & dbkey & formgroup)
			Session("LastLastID" & dbkey & formgroup) = Session("LastID" & dbkey & formgroup)
			if Session("hitlistrecordcount" & dbkey & formgroup) > 0 and dbkeyset = false then 
				dbreturn = dbkey
				dbkeyset  = true
			end if
		next
		'need to populate dbreturn. dbreturn will be empty if no hits are returned.
		if not dbreturn <> "" then
			dbreturn = dbkey
			dbkeyset = true
		end if
End Sub

'SYAN added 12/16/2003 to fix CSBR-35466
Function ConvertStrToDate(date_format, dateStr)
	sections = split(dateStr, "/")
	
	Select case CStr(date_format)
		case "8"
			dateObj = DateSerial(CInt(sections(2)), CInt(sections(0)), CInt(sections(1)))
		case "9"
			dateObj = DateSerial(CInt(sections(2)), CInt(sections(1)), CInt(sections(0)))
		case "10"
			dateObj = DateSerial(CInt(sections(0)), CInt(sections(1)), CInt(sections(2)))
	End Select
	ConvertStrToDate = dateObj
End Function

'SYAN added 12/16/2003 to fix CSBR-35466
Function ConvertDateToStr(date_format, dateObj)
	if IsNull(dateObj) = false then
		Select case CStr(date_format)
			case "8"
				dateStr = Month(dateObj) & "/" & Day(dateObj) & "/" & Year(dateObj)
			case "9"
				dateStr = Day(dateObj) & "/" & Month(dateObj) & "/" & Year(dateObj)
			case "10"
				dateStr = Year(dateObj) & "/" & Month(dateObj) & "/" & Day(dateObj)
		End Select
	else
		dateStr = "" 
	end if
	ConvertDateToStr = dateStr
End Function


sub setOrderBySessVariable(dbkey, formgroup, sql)
	'LJB 2/27/04 for sql that comes in via get_sql_string, if there is an order by clause it will be ignored by the cartridge code unless it
	'is store in the session("order_by" & dbkey & formgroup) variable.
	temp_sql = replace(sql, " order by ", " ORDER BY ")
	temp_sql= replace(temp_sql, " Order By ", " ORDER BY ")
	temp_sql= replace(temp_sql, " ORDER By ", " ORDER BY ")
	temp_sql_array = split(temp_sql, " ORDER BY ", -1)
	temp_order_by = temp_sql_array(1)
	if inStr(UCase(temp_order_by), " DESC")>0 then
		Session("sort_direction" & dbkey & formgroup) = "DESC"
	else
		Session("sort_direction" & dbkey & formgroup) = "ASC"
	end if
	temp_order_by = replace(temp_order_by, " DESC", "")
	temp_order_by = replace(temp_order_by, " ASC", "")
	temp_order_by = replace(temp_order_by, " ", "")
	Session("order_by" & dbkey & formgroup) = temp_order_by
	
End sub


'SYAN added 5/21/2004
'-------------------------------------------------------------------------------
' Purpose: Build IN clause with cardinality hint based on number of values
' Inputs: Comma delimited value list, number of values
' Output: IN clause with bind variable 
'-------------------------------------------------------------------------------
Function BuildInClause(ByVal valueList, ByVal numOfValues)
	Dim retVal
	Dim magnitude
	
	if numOfValues < 10 then
		magnitude = 1
	elseif numOfValues < 100 then
		magnitude = 10
	elseif numOfValues < 1000 then
		magnitude = 100
	elseif numOfValues < 1000 then
		magnitude = 100
	elseif numOfValues < 10000 then
		magnitude = 1000
	elseif numOfValues < 100000 then
		magnitude = 10000
	else
		magnitude = "NONE"
	end if
	
	if magnitude = "NONE" then
		retVal = "select * from " & GetFullTableNAME(dbkey, formgroup, "TEMP_IDS") '"select * from REGDB.TEMP_IDS"
	else
		retVal = "select /*+ cardinality(t " & magnitude & ") */ * from " & GetFullTableNAME(dbkey, formgroup, "TEMP_IDS") '"select /*+ cardinality(t " & magnitude & ") */ * from REGDB.TEMP_IDS"
	end if
	
	BuildInClause = retVal
End Function

sub pageGenerationTime()
	'Response.Clear
	Dim bShowPgT
	bShowPgT = (Application("PageTimer")= "on" OR Session("PageTimer")= "on") 
	'bShowPgt = "1"
	if bShowPgt then
		Response.Write "</tr></td></table></center><BR>"
		if Session("hitlistWriteTime") <> "" then 
			Response.Write "<BR><font size=1><span title=""This is the approximate time to generate the hitlist from the query criteria."">Search time: " & Session("hitlistWriteTime") & " s</font></span>"
			Session("hitlistWriteTime")=""
		end if
		Response.Write "<span title=""This is the time taken by the server to compose the html response to be sent to browser.""><BR><font size=1>Page generation time: " & timer - ppt & " s</font></span>"
		Response.Write "<BR><span title=""This is the approximate time taken by browser to parse and load the html returned by the server.""><font size=1>Page load time: <span id=pageLoadTime></span></span>"
	end if
	Trace "Out:Page:BioSAR_Browser_Input_form.asp",25
end sub
%>
