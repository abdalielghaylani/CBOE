using System;
using System.Collections.Generic;
using System.Text;

using CambridgeSoft.COE.DataLoader.Core.Contracts;

/* NOTE:
 * Each time a data-point is added to the list of field values, the field type should be
 * given he opportunity to re-evaluate itself using that particular value.
 * 
 * Therefore, it is highly desirable to tie these mechanisms together.
 */

namespace CambridgeSoft.COE.DataLoader.Core
{
    /// <summary>
    /// During the reading/parsing of a data file, the names and types of each logical field
    /// that discovered are stored here. In some cases (such as SDFile or potentially XML),
    /// individual records may lack fields for which there is no data, so a 'master' field list
    /// must be maintained.
    /// <para>
    /// For different file types, the names and types of fields are derived differently,
    /// as described here:
    /// </para>
    /// <list type="bullet">
    /// <item>
    /// CSV, MSExcel worksheet: Field names are derived from either a header record, or when absent, autogenerated.
    /// Field types are derived by a type-guessing algorithm which takes into account each data-point
    /// assigned to that field value.
    /// </item>
    /// <item>
    /// SDFile: Field names are explicitly extracted from each SD record. The Molecule field always exists.
    /// Field types are determined algorithmically in teh same manner as for CSVs and MS Excel worksheets.
    /// </item>
    /// <item>
    /// MS Access table or view: Field names and types are explicitly retrieved from the schema.
    /// Alternatively, field types can be derived algorithmically as described above.
    /// </item>
    /// </list>
    /// </summary>
    public static class SourceFieldTypes
    {
        private static Dictionary<string, Type> _typeDefinitions = new Dictionary<string,Type>();
        /// <summary>
        /// Stores field names and data-types for the current 
        /// </summary>
        public static Dictionary<string, Type> TypeDefinitions
        {
            get { return _typeDefinitions; }
        }

        /// <summary>
        /// Adds or overwrites a dictionary entry.
        /// </summary>
        /// <param name="key">the name of the source field</param>
        /// <param name="rawValue">the value from the source</param>
        /// <param name="target">the ISourceRecord to push the raw value into</param>
        public static void SetValue(string key, object rawValue, ISourceRecord target)
        {
            if (!target.FieldSet.ContainsKey(key))
            {
                //Add the key and value pair
                target.FieldSet.Add(key, rawValue);
                SourceFieldTypes.SetKeyDefinition(key, null);
            }
            else
            {
                //Overwrite a key's existing value
                target.FieldSet[key] = rawValue;
            }

            //Re-evaluate the data-type if the data-point has a 'non-empty' value
            if (rawValue != null && rawValue != DBNull.Value)
            {
                string rawString = rawValue.ToString();
                if (!string.IsNullOrEmpty(rawString.Trim()))
                    SourceFieldTypes.SetKeyDefinition(key, DataTypingUtility.EvaluateType(rawString));
            }
        }

        /// <summary>
        /// Used internally to accumulate field names and their types.
        /// </summary>
        /// <param name="key"></param>
        /// <param name="objectType"></param>
        private static void SetKeyDefinition(string key, Type objectType)
        {
            //re-evaluate key's TYPE
            if (!_typeDefinitions.ContainsKey(key))
                _typeDefinitions.Add(key, objectType);
            else
            {
                //the existing entry's Type
                bool performTypeReplacement = false;
                Type globalType = _typeDefinitions[key];

                //replace the entry's Type as necessary
                if (objectType != null && (globalType != objectType))
                {
                    if (globalType == null)
                        performTypeReplacement = true;
                    else
                    {
                        //string trumps everything
                        if (objectType == typeof(string))
                            performTypeReplacement = true;

                        //int can be converted to double
                        if (globalType == typeof(int) && objectType == typeof(double))
                            performTypeReplacement = true;

                        //incompatible combinations automatically become string
                        if (
                            globalType == typeof(DateTime) && (objectType == typeof(int) || objectType == typeof(double))
                            || objectType == typeof(DateTime) && (globalType == typeof(int) || globalType == typeof(double))
                        )
                        {
                            _typeDefinitions[key] = typeof(string);
                            return;
                        }
                    }
                }

                // finally, replace the existing type if warranted
                if (performTypeReplacement)
                    _typeDefinitions[key] = objectType;
            }
        }

        /// <summary>
        /// Eliminates a shared field definition.
        /// </summary>
        /// <param name="key"></param>
        private static void DropKeyDefinition(string key)
        {
            if (_typeDefinitions.ContainsKey(key))
                _typeDefinitions.Remove(key);
        }

    }
}
