<?xml version="1.0" encoding="utf-8"?>
<topic id="fdcbfcd5-51ac-4856-b1ba-a4af71e18be7" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <!--
    <summary>
      <para>Optional summary abstract</para>
    </summary>
    -->
    <introduction>
      <!-- Uncomment this to generate an outline of the section and sub-section
           titles.  Specify a numeric value as the inner text to limit it to
           a specific number of sub-topics when creating the outline.  Specify
           zero (0) to limit it to top-level sections only.  -->
           
      <!-- <autoOutline /> -->
      <para>
      		This document is intended to explain the basics for implementing a custom select clause that can be used in ChemBioViz Gateway (Search Runtime) or in Search Service.
			Implementing select clauses comes to play when you have your own database functions that you want to call for showing that information in your application, whether you want to use it at application level (ChemBioViz) or Search Service level.
			The way we will try to explain this is based on providing you a solution for implementing a Cast select clause, which will be responsible of performing casts to some underlying field.
		</para>
    </introduction>
    <!-- Add one or more top-level section elements.  These are collapsible.
         If using <autoOutline />, add an address attribute to identify it
         and specify a title so that it can be jumped to with a hyperlink. -->
    <section address="Section1">
      <title>Defining a result criteria xml</title>
      <content>
        <!-- Uncomment this to create a sub-section outline
        <autoOutline /> -->
        <para>The first thing a developer has to decide is how will be the xml snippet for using the criteria.</para>
		<para>A simplified Result Criteria use to be in the way:</para>
		<code language="xml" source=".\Topics\CustomResultCriteriaFiles\simpleexample.xml" />
      
      	<para>The cast snippet is an example of the xml snippet we have defined for the cast select clause. It has a fieldId, which is defined on dataview, and in this case is the DEPTNO of the table SCOTT.DEPT, the datatype to cast the field to and an alias.</para>
		<para>So we are going generate a sql portion that would be like: CAST(DEPTNO as varchar2(4)) "ID AS VARCHAR"</para>
		<para>More complex functions will likely need several more attributes.</para>

		<para>In this example we will be using the following Dataview xml:</para>
		<code language="xml" source=".\Topics\CustomResultCriteriaFiles\sampledataview.xml" />
 
      
      </content>
    </section>
    
    
	<section address="Section2">
	  <title>Implementing base class and interfaces</title>
	  <content>
	    <para>A custom select clause must inherit from the class SelectClauseItem and should ISelectClauseParser.</para>
		<para>In order to do so, your project should reference the framework dll and have in it a new class, which should include the following namespace:</para>
		<code>using CambridgeSoft.COE.Framework.Common.SqlGenerator.Queries.SelectItems;</code>
		
		<para>Then your class must inherit and implement the proper class and interface:</para>
		<code>public class CastSelectClause : SelectClauseItem, ISelectClauseParser</code>
		
		<para>By inheriting the abstract class SelectClauseItem you will be forced to implement GetDependantString method and Name property:</para>
		<code language="c#" source=".\Topics\CustomResultCriteriaFiles\GetDependant.txt" />
 
		

		<para>GetDependantString is responsible of generating its string portion to be rendered inside the select clause list in the resulting query. </para>
		<para>The dataBaseType is passed to this function so you may create different sql for different databases. For instance the SelectClauseCASE uses this paratemer to render a DECODE statement if it is an Oracle DB and a CASE if it’s a MSSQL DB.</para>
		<para>Usually the Name is just the Alias.</para>
		
		<para>Then you must implement the select clause parser interface:</para>
		<code language="c#" source=".\Topics\CustomResultCriteriaFiles\ClauseParser.txt" />
 
		
		<para>CreateInstance method is in charge of creating a new instance of the clause, based on its xml snippet that we have previously defined.</para>
		<para>In this method you receive the xmlNode snippet and also an INamesLookup, which is a helper to lookup fields and tables (names and values) from the DataView that is being used.</para>
	  </content>
	</section>

    
	<section address="section4">
	  <title>Making your assembly strongly named</title>
	  <content>
	     <para>Once we have done the previous steps we may say that no more Code is needed, but we still have a few configuration tasks. The best way to succeed is to have you assembly where the clause was implemented Strongly Named.</para>
	  	  <link xlink:href="88a93b49-413f-440a-910f-9488ed22825e">See Making your assembly strongly named</link>
	  </content>
	</section>

    <section address="section5">
	  <title>Registering the criteria through Configuration</title>
	  <content>
	    <para>The main configuration source for ChemOfficeEnterprise is COEFrameworkConfig.xml, which is located at the special folder C:\Documents and Settings\All Users\Application Data\Cambridgesoft\ChemOfficeEnterprise11.x.x.x.</para>
		<para>That file has a particular section defined as follows:</para>
		<code language="xml" source=".\Topics\FrameworkConfigFiles\mappingsSection.xml" />
			
		<para>In that section there are several pre-built select clauses that should be kept as they are:</para>		
		<code language="xml" source=".\Topics\FrameworkConfigFiles\mappingsSectionInnerXML.xml" />
		
		<para>Inside this section we must register our new criteria by adding </para>	
		<code language="xml" source=".\Topics\CustomSearchCriteriaFiles\WhereClauseFWNode.xml" />
		
		<para>The name of the select clause is the name of the xml snippet to be used, but lower cased (always). The parserClassName must be fully qualified, including its namespace. And the assembly name is what’s called Full Assembly Name, which is made in the form:</para>	
		<quote>AssemblyName, Version=AssemblyVersion, Culture=Culture, PublicKeyToken=PublicToken</quote>
		<para>The assembly version and culture are specified in the AssemblyInfo class of your project. The public token key is the one we have previously generated (sn –t …).</para>
	  </content>
	</section>
    
    <section address="section6">
	  <title>Making your assembly available of use by COEFramework</title>
	  <content>
	  	  <para>For the COE Framework to use your assembly, it will need to be configured so it can be found.</para>
	  	  <link xlink:href="5a3be626-1e5a-4ee6-80df-c501762cec63">See Making your dll available for COE Framework</link>
	  </content>
	</section>	
    
    
    <relatedTopics>
      <!-- One or more of the following:
           - A local link
           - An external link
           - A code entity reference

      <link xlink:href="Other Topic's ID"/>
      <link xlink:href="Other Topic's ID">Link inner text</link>

      <externalLink>
          <linkText>Link text</linkText>
          <linkAlternateText>Optional alternate link text</linkAlternateText>
          <linkUri>URI</linkUri>
      </externalLink>

      <codeEntityReference>API member ID</codeEntityReference>

      Examples:

      <link xlink:href="00e97994-e9e6-46e0-b420-5be86b2f8270" />
      <link xlink:href="00e97994-e9e6-46e0-b420-5be86b2f8278">Some other topic</link>

      <externalLink>
          <linkText>SHFB on CodePlex</linkText>
          <linkAlternateText>Go to CodePlex</linkAlternateText>
          <linkUri>http://shfb.codeplex.com</linkUri>
      </externalLink>

      <codeEntityReference>T:TestDoc.TestClass</codeEntityReference>
      <codeEntityReference>P:TestDoc.TestClass.SomeProperty</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.#ctor</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.#ctor(System.String,System.Int32)</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.ToString</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.FirstMethod</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.SecondMethod(System.Int32,System.String)</codeEntityReference>
      -->
    </relatedTopics>
  </developerConceptualDocument>
</topic>